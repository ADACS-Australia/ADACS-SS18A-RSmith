#!/usr/bin/env python

import sys
import os
from optparse import OptionParser
from numpy import argsort
from pylal.dq import dqFrameUtils

from glue import git_version
__author__ = "Duncan Macleod <duncan.macleod@ligo.org>"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date

"""
Script to query frames for channels
"""

# =============================================================================
# Execute shell cmd and get output
# =============================================================================

def make_external_call(cmd,shell=False):

  """
    Execute shell command and capture standard output and errors. Does not
    support complex commands with pipes, e.g. `echo ${VAR} | grep insp` will
    fail. Returns tuple "(stdout,stderr)".
  """

  args = shlex.split(str(cmd))
  p = subprocess.Popen(args,shell=shell,\
                       stdout=subprocess.PIPE,stderr=subprocess.PIPE)
  p_out, p_err = p.communicate()
  if p.returncode != 0:
    raise ValueError, "Command %s failed. Stderr Output: \n%s" %( cmd, p_err)

  return p_out, p_err

# =============================================================================
# Parse command line
# =============================================================================

def parse_command_line():

  """
    Parser function dedicated
  """

  usage = """usage: %prog [options]

This script will return all frame types associated with given channel. All or part of a channel name to search for must be given. Including all or part of a data type will greatly speed up the search.

Accepted ifos:

H,L,V,H0,H1,H2,L0,L1,G0,G1,V0,V1
"""

  parser = OptionParser(usage=usage)

  parser.add_option("--verbose", action="store_true", default=False,\
                    help="verbose output")

  parser.add_option("-c", "--channels", action="store", type="string",\
                    default="",
                    help="relevant channel (or part therein), or comma"+\
                         "separated list of channels (or parts therein) "+\
                         "for search")

  parser.add_option("-e", "--exclude-channels", action="store", type="string",\
                    default="",
                    help="exclude these channels (or parts therein),"+\
                         "comma separated")
  
  parser.add_option("-t", "--types", action="store", type="string",\
                    default="",
                    help="specfic data type (or part therein), "+\
                         "or comma separated list of data types "+\
                         "(or parts therein) to search")
 
  parser.add_option("-i", "--ifos", action="store", type="string",\
                    default="",
                    help="specific ifo, or comma separated list of ifos, "+\
                         "to search")

  parser.add_option("-s", "--gps-time", action="store", type="string",\
                    help="gps time around which channels must be active")

  parser.add_option("--full", action="store_true", default=False,\
                    help="include ALL data types in search, default: %default")

  parser.add_option("--short", action="store_true", default=False,\
                    help="include only the most common data types in search "+\
                         "(recommended for most users), default: %default")

  parser.add_option("--match", action="store_true", default=False,\
                    help="return only full matches to --channels option, "+\
                         "default: %default")

  (options, args) = parser.parse_args()

  return options,args

# =============================================================================
# Main program starts here
# =============================================================================

def main():

  
  # parse input options
  options,args = parse_command_line()

  channels    = [ch for ch in options.channels.split(',') if ch]
  ex_channels = [ch for ch in options.exclude_channels.split(',') if ch]
  types       = [type for type in options.types.split(',') if type]
  ifos        = [ifo for ifo in options.ifos.split(',') if ifo]
  full        = options.full
  short       = options.short
  match       = options.match
  time        = options.gps_time
  verbose     = options.verbose

  # set up ignore list
  ignore_list=[]
  if not types and not full:
    ignore_list=['M','T']

  # set up search type
  if short and full:
    parser.error('Please choose only one of --short, --full.')
  if options.short:  search='short'
  elif options.full:  search='full'
  else:  search='standard'

  # find types and ifos
  types = dqFrameUtils.find_types(types,search=search)
  if not ifos:
    ifos = sorted(['H0','H1','H2',\
                   'L0','L1',\
                   'G0','G1',\
                   'V0','V1'])
  # find channels
  found = dqFrameUtils.find_channels(channels,types,ifos,ignore=ignore_list,\
                                     match=match,time=time,verbose=verbose)

  # print summary
  if verbose:
    print >>sys.stdout, str(len(found))+" channels found:"

  # sort channels by name and print
  found = sorted(found, key=lambda ch: ch.name)
  for ch in found:
    print >>sys.stdout, ':'.join([ch.ifo,ch.name]),ch.type,ch.sampling

  if verbose:
    print >>sys.stdout

if __name__ == '__main__':
  main()
