#!/usr/bin/env python

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

from optparse import OptionParser
try:
    import sqlite3
except ImportError:
    # pre 2.5.x
    from pysqlite2 import dbapi2 as sqlite3
try:
    any
    all
except NameError:
    # Python < 2.5
    from glue.iterutils import any, all
import sys
import os

from glue import segments
from glue import segmentsUtils
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import dbtables
from glue.ligolw import utils
from glue.ligolw.utils import process

from pylal import db_thinca_rings


usage = """
Computes durations for every row in the experiment_summary table in a
database and stores them.
"""

__author__ = "Collin Capano <cdcapano@physics.syr.edu>"
__date__ = "$Date$"
__version__ = "$Revision$"


# =============================================================================
#
#                                   Set Options
#
# =============================================================================


def parse_command_line():
    """
    Parse the command line, return options and check for consistency among the
    options.
    """
    parser = OptionParser( version = "", usage = usage )

    parser.add_option( "-d", "--database", action = "store", type = "string", default = None,
        help = 
            "Input database to read. Can only input one at a time."
        )
    parser.add_option( "-t", "--tmp-space", action = "store", type = "string", default = None,
        metavar = "PATH",
        help = 
            "Location of local disk on which to do work. This is optional; " +
            "it is only used to enhance performance in a networked " +
            "environment. "
        )
    parser.add_option( "-v", "--verbose", action = "store_true", default = False,
        help =
            "Be verbose."
        )

    (options, args) = parser.parse_args()

    # check for required options and for self-consistency
    if not options.database:
        raise ValueError, "No database specified."

    return options, sys.argv[1:]

# =============================================================================
#
#                              Function Definitions
#
# =============================================================================


def get_playground_sets_from_all_data(all_data_ring_sets):
    """
    Calculates playground segment sets using all_data ring_sets.
    Returns a dictionary of segments (which is of form {instrument_set:segmentlist})
    with just playground segments in them.
    
    @all_data_ring_sets: all_data ring sets
    """
    playground_sets = {}
    playground = segmentsUtils.S2playground(all_data_ring_sets.extent_all())
    for instruments, seglist in all_data_ring_sets.items():
        playground_sets[instruments] = seglist.coalesce() & playground 

    return playground_sets


class Durations:
    """
    Class to store and retrieve durations.
    self.durations has the structure:
    self.durations[(on_instruments, veto_def_name,datatype, time_slide_id)]
    """
    def __init__( self ):
        self.durations = {}

    def map_slides_to_durations( self, veto_def_name, datatype, time_slide_dict, livetime_dict ):
        for instruments in livetime_dict:
            for slide_id, duration in zip(time_slide_dict.keys(), livetime_dict[instruments]):
                self.durations[(instruments, veto_def_name, datatype, slide_id)] = duration

    def retrieve_duration( self, on_instruments, veto_def_name, datatype, time_slide_id ):
        on_instruments = frozenset(lsctables.instrument_set_from_ifos(on_instruments))
        if not (datatype == "playground" or datatype == "exclude_play"):
            datatype = "full_data"
        if (on_instruments, veto_def_name, datatype, time_slide_id) in self.durations:
            return self.durations[( on_instruments, veto_def_name, datatype, time_slide_id )]


# =============================================================================
#
#                                     Main
#
# =============================================================================

#
#       Generic Initilization
#

options, args = parse_command_line()

# get input database filename
filename = options.database
if not os.path.isfile( filename ):
    raise ValueError, "The input database, %s, cannot be found." % filename

# Setup working databases and connections
if options.verbose: 
    print >> sys.stdout, "Opening database..."

working_filename = dbtables.get_connection_filename( 
    filename, tmp_path = options.tmp_space, verbose = options.verbose )
connection = sqlite3.connect( working_filename )
dbtables.DBTable_set_connection( connection )
xmldoc = dbtables.get_xml(connection)

# Add program to process and process params table

# FIXME: remove the following two lines once boolean type
# has been properly handled
from glue.ligolw import types as ligolwtypes
ligolwtypes.FromPyType[type(True)] = ligolwtypes.FromPyType[type(8)]

proc_id = process.register_to_xmldoc(xmldoc, 'compute_durations', options.__dict__)

#
#       Compute Durations
#

# find the tables we'll need
time_slide_table = table.get_table(xmldoc, lsctables.TimeSlideTable.tableName)
expr_table = table.get_table(xmldoc, lsctables.ExperimentTable.tableName)
expr_summ_table = table.get_table(xmldoc, lsctables.ExperimentSummaryTable.tableName)

# turn the time slide table into a dictionary
time_slide_dict = time_slide_table.as_dict()

# initialize duration bank
dur_bank = Durations()

# get the ring_sets
ring_sets = db_thinca_rings.get_thinca_rings_by_available_instruments(connection, program_name = "thinca")

# find out if there is playground or exclude_play in the database
sqlquery = """
    SELECT DISTINCT
        datatype
    FROM
        experiment_summary
   """
datatypes = [datatype[0] for datatype in connection.cursor().execute(sqlquery)]
if "playground" in datatypes or "exclude_play" in datatypes:
    playground_segs = get_playground_sets_from_all_data(ring_sets)
    exclude_play_segs = ring_sets - playground_segs
    zero_lag_offsets = dict([[slide_id, offset_vector] for slide_id, offset_vector in time_slide_dict.items() if not any(time_slide_dict[slide_id].values())])

if options.verbose:
    print >> sys.stderr, "Getting all veto categories in the experiment_summary table..."

# get veto_segments
sqlquery = """
    SELECT DISTINCT
        veto_def_name
    FROM
        experiment_summary
    """
for veto_def_name in connection.cursor().execute(sqlquery).fetchall():
    veto_def_name = veto_def_name[0]
    if options.verbose:
        print >>sys.stderr, "Retrieving veto segments for %s..." % veto_def_name
    try:
        veto_segments = db_thinca_rings.get_veto_segments(connection, veto_def_name)
    except AttributeError:
        # will get an AttributeError if using newer format veto segment file because
        # the new format does not include _ns; if so, remove the _ns columns from the
        # segment table and reset the definitions of lsctables.Segment.get and lsctables.Segment.set
        from glue.lal import LIGOTimeGPS

        del lsctables.SegmentTable.validcolumns['start_time_ns']
        del lsctables.SegmentTable.validcolumns['end_time_ns']

        def get_segment(self):
            """
            Return the segment described by this row.
            """
            return segments.segment(LIGOTimeGPS(self.start_time, 0), LIGOTimeGPS(self.end_time, 0))

        def set_segment(self, segment):
            """
            Set the segment described by this row.
            """
            self.start_time = segment[0].seconds
            self.end_time = segment[1].seconds

        lsctables.Segment.get = get_segment
        lsctables.Segment.set = set_segment

        veto_segments = db_thinca_rings.get_veto_segments(connection, veto_def_name)

    # compute the durations (or livetimes) for every possible instrument combo for every
    # slide in the time-slide table; the resulting durations dictionary has the following form:
    # durations[(on_instruments, veto_def_name, datatype, time_slide_id)] = livetime (in seconds)
    if options.verbose:
       print >> sys.stderr, "\tcalculating durations for:"

    livetime_dict = db_thinca_rings.get_thinca_livetimes(ring_sets, veto_segments, time_slide_dict.values(), verbose = options.verbose)
    dur_bank.map_slides_to_durations(veto_def_name, "full_data", time_slide_dict, livetime_dict)

    if "playground" in datatypes:
        if options.verbose:
            print >> sys.stderr, "\n\tcalculating playground durations for:"

        livetime_dict = db_thinca_rings.get_thinca_livetimes(playground_segs, veto_segments, zero_lag_offsets.values(), verbose = options.verbose)
        dur_bank.map_slides_to_durations(veto_def_name, "playground", zero_lag_offsets, livetime_dict)

    if "exclude_play" in datatypes:
        if options.verbose:
            print >> sys.stderr, "\n\tcalculating exclude_play durations for:"

        livetime_dict = db_thinca_rings.get_thinca_livetimes(exclude_play_segs, veto_segments, zero_lag_offsets.values(), verbose = options.verbose)
        dur_bank.map_slides_to_durations(veto_def_name, "exclude_play", zero_lag_offsets, livetime_dict)

#
# finished getting all durations, now populate the experiment_summary table
# with them
#
if options.verbose:
    print >> sys.stderr, "\nPopulating the experiment_summary table with results..."

connection.create_function("retrieve_duration", 4, dur_bank.retrieve_duration)

# populate the experiment_summary table with the appropiate duration
sqlquery = """
    UPDATE experiment_summary
    SET duration = (
        SELECT retrieve_duration(
            experiment.instruments,
            experiment_summary.veto_def_name,
            experiment_summary.datatype,
            experiment_summary.time_slide_id
            )
        FROM
            experiment
        WHERE
            experiment.experiment_id == experiment_summary.experiment_id
        )"""
connection.cursor().execute( sqlquery )

#
#       Close database and exit
#

connection.commit()
connection.cursor().close()
dbtables.put_connection_filename(filename, working_filename, verbose = options.verbose)

if options.verbose:
    print >> sys.stderr, "Finished!"

# set process end time
process.set_process_end_time(proc_id)
sys.exit(0)


