#!/usr/bin/python

# $Id$
__author__ = "Drew Keppel <drew.keppel@ligo.org>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


import sys, os, re, exceptions, glob, optparse, itertools
from types import *

from glue.ligolw import lsctables

from pylal import SimInspiralUtils
from pylal import SnglInspiralUtils
from pylal import CoincInspiralUtils

##############################################################################
usage = """usage: %prog [options]

Program to calculate the mass region in template space needed to make an
upper limit on a mass region in injection space.

"""
parser = optparse.OptionParser( usage=usage, version="%prog CVS $Id$")

parser.add_option("-g","--glob",action="store",type="string",\
  default=[], metavar=" GLOB",help="GLOB of found injections files to read" )
parser.add_option("-I", "--input", help="read thinca filenames from input file")

parser.add_option("-t","--mass-cut",action="store",type="string",
    default=None,metavar=" TYPE",
    help="type of mass region to use (mtotal|mchirp|mcomp)")
parser.add_option("-m","--mass-range-low",action="store",type="float",
    default=False,metavar=" MASS",
    help="the lower bound on the mass for injections" )
parser.add_option("-M","--mass-range-high",action="store",type="float",
    default=False,metavar=" MASS",
    help="the upper bound on the mass for injections" )
parser.add_option("-q","--mass2-range-low",action="store",type="float",
    default=1.0,metavar=" MASS",
    help="the lower bound on the mass2 for injections" )
parser.add_option("-Q","--mass2-range-high",action="store",type="float",
    default=False,metavar=" MASS",
    help="the upper bound on the mass2 for injections" )

parser.add_option("-p","--mass-mass",action="store_true",default=False,
    help="make the recovered mass vs. injected mass plot" )
parser.add_option("-P","--hist-mass-error",action="store_true",default=False,
    help="make a histogram of the mass error" )
parser.add_option("-n","--num-bins",action="store",type='int',\
  default=20, metavar=" NUM",\
  help="number of bins used in histogram" )
parser.add_option("-f","--figure-name",action="store",type="string",
    default=None,metavar=" FNAME",
    help="generate png figures with name FNAME-fig.png")
parser.add_option("-s","--show-plot",action="store_true",default=False,
    help="display the figures on the terminal" )

(opts,args) = parser.parse_args()

###############################
# check for necessary arguments
if not opts.glob and not opts.input:
  print >>sys.stderr, "Must specify a --glob of files or --input file to read"
  print >>sys.stderr, "Enter 'plotthinca --help' for usage"
  sys.exit(1)

if not opts.mass_cut == 'mchirp' and not opts.mass_cut == 'mtotal' \
    and not opts.mass_cut == 'mcomp':
  print >>sys.stderr, "Must specify --mass-cut as either mtotal, mchirp,"
  print >>sys.stderr, " or mcomp"
  sys.exit(1)

###########################################
# read files in from the glob or input file
fList = []
if opts.glob is not None:
    fList += glob.glob(opts.glob)
if opts.input is not None:
    fList += [lal.CacheEntry(line).path() for line in open(opts.input)]
if len(fList) < 1:
  print >>sys.stderr, "The glob for " + opts.glob + " returned no files"
  sys.exit(1)

#####################################################################
# Do the pylab import in such a way that doesn't require an X display
# if show() won't be invoked.
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from pylal import viz
if not opts.show_plot:
  rc('text', usetex=True)

#######################################################################
# Calculate the minimum and maximum values of Mchirp and eta to be kept
if opts.mass_cut == 'mtotal':
  McMin = (opts.mass2_range_low*(opts.mass_range_low-opts.mass2_range_low)/\
           (opts.mass_range_low**2.0))**(0.6)*opts.mass_range_low
  McMax = 0.25**(0.6)*opts.mass_range_high
elif opts.mass_cut == 'mcomp':
  McMin = (opts.mass_range_low*opts.mass2_range_low)**(0.6)*\
          (opts.mass_range_low+opts.mass2_range_low)**(-0.2)
  McMax = (opts.mass_range_high*opts.mass2_range_high)**(0.6)*\
          (opts.mass_range_high+opts.mass2_range_high)**(-0.2)
  etaMin = (opts.mass_range_high*opts.mass2_range_low)/\
            ((opts.mass_range_high+opts.mass2_range_low)**2.0)
  etaMax = (opts.mass_range_low*opts.mass2_range_high)/\
            ((opts.mass_range_low+opts.mass2_range_high)**2.0)
elif opts.mass_cut == 'mchirp':
  McMin = opts.mass_range_low
  McMax = opts.mass_range_high

##################################################
# import CoincInspiral table and SimInspiral table
statistic = CoincInspiralUtils.coincStatistic( "snr" )
injDict = []
for file,idx in zip(fList,range(len(fList))):
  injDict.append({})
  injDict[idx]["sngl_inspiral"] = \
      SnglInspiralUtils.ReadSnglInspiralFromFiles([file])
  injDict[idx]["coincs"] = \
      CoincInspiralUtils.coincInspiralTable(injDict[idx]["sngl_inspiral"],
                                            statistic)
  injDict[idx]["sim_inspiral"] = \
      SimInspiralUtils.ReadSimInspiralFromFiles([file])

##############################################################################
# only keep CoincInspiral and SimInspiral entries within injection mass region
injSet = {}
injSet["rec_mchirp"] = []
injSet["inj_mchirp"] = []
injSet["rec_eta"] = []
injSet["inj_eta"] = []
injSet["rec_mass1"] = []
injSet["inj_mass1"] = []
injSet["rec_mass2"] = []
injSet["inj_mass2"] = []
if opts.mass_cut == 'mtotal':
  for jdx in range(len(fList)):
    for idx in range(len(injDict[jdx]["sim_inspiral"])):
      if opts.mass_range_low <= \
          injDict[jdx]["sim_inspiral"].get_column("total_mass")[idx] \
          and injDict[jdx]["sim_inspiral"].get_column("total_mass")[idx] < \
          opts.mass_range_high:
        injSet["inj_mchirp"].append(float(injDict[jdx]["sim_inspiral"].\
            get_column("mchirp")[idx]))
        injSet["inj_mass1"].append(max(float(injDict[jdx]["sim_inspiral"].\
            get_column("mass1")[idx]),
            float(injDict[jdx]["sim_inspiral"].\
            get_column("mass2")[idx])))
        injSet["inj_mass2"].append(min(float(injDict[jdx]["sim_inspiral"].\
            get_column("mass1")[idx]),
            float(injDict[jdx]["sim_inspiral"].\
            get_column("mass2")[idx])))
        combo,ifos = injDict[jdx]["coincs"][idx].get_ifos()
        mchirpRecovered = 0.0
        mass1Recovered = 0.0
        mass2Recovered = 0.0
        for ifo in ifos:
          mchirpRecovered += getattr(injDict[jdx]["coincs"][idx],ifo).mchirp
          mass1Recovered += getattr(injDict[jdx]["coincs"][idx],ifo).mass1
          mass2Recovered += getattr(injDict[jdx]["coincs"][idx],ifo).mass2
        mchirpRecovered /= len(ifos)
        mass1Recovered /= len(ifos)
        mass2Recovered /= len(ifos)
        injSet["rec_mchirp"].append(mchirpRecovered)
        injSet["rec_mass1"].append(mass1Recovered)
        injSet["rec_mass2"].append(mass2Recovered)
elif opts.mass_cut == 'mchirp':
  for jdx in range(len(fList)):
    for idx in range(len(injDict[jdx]["sim_inspiral"])):
      if opts.mass_range_low <= \
          injDict[jdx]["sim_inspiral"].get_column("mchirp")[idx] \
          and injDict[jdx]["sim_inspiral"].get_column("mchirp")[idx] < \
          opts.mass_range_high:
        injSet["inj_mchirp"].append(float(injDict[jdx]["sim_inspiral"].\
            get_column("mchirp")[idx]))
        combo,ifos = injDict[jdx]["coincs"][idx].get_ifos()
        mchirpRecovered = 0.0
        for ifo in ifos:
          mchirpRecovered += getattr(injDict[jdx]["coincs"][idx],ifo).mchirp
        mchirpRecovered /= len(ifos)
        injSet["rec_mchirp"].append(mchirpRecovered)
elif opts.mass_cut == 'mcomp':
  for jdx in range(len(fList)):
    for idx in range(len(injDict[jdx]["sim_inspiral"])):
      if (opts.mass_range_low <= \
          injDict[jdx]["sim_inspiral"].get_column("mass1")[idx] \
          < opts.mass_range_high \
          and opts.mass2_range_low <= \
          injDict[jdx]["sim_inspiral"].get_column("mass2")[idx] \
          < opts.mass2_range_high ) \
          or (opts.mass2_range_low <= \
          injDict[jdx]["sim_inspiral"].get_column("mass1")[idx] \
          < opts.mass2_range_high \
          and opts.mass_range_low <= \
           injDict[jdx]["sim_inspiral"].get_column("mass2")[idx] \
           < opts.mass_range_high ):
        injSet["inj_mchirp"].append(float(injDict[jdx]["sim_inspiral"].\
            get_column("mchirp")[idx]))
        injSet["inj_eta"].append(float(injDict[jdx]["sim_inspiral"].\
            get_column("eta")[idx]))
        injSet["inj_mass1"].append(max(float(injDict[jdx]["sim_inspiral"].\
            get_column("mass1")[idx]),
            float(injDict[jdx]["sim_inspiral"].\
            get_column("mass2")[idx])))
        injSet["inj_mass2"].append(min(float(injDict[jdx]["sim_inspiral"].\
            get_column("mass1")[idx]),
            float(injDict[jdx]["sim_inspiral"].\
            get_column("mass2")[idx])))
        combo,ifos = injDict[jdx]["coincs"][idx].get_ifos()
        mchirpRecovered = 0.0
        etaRecovered = 0.0
        mass1Recovered = 0.0
        mass2Recovered = 0.0
        for ifo in ifos:
          mchirpRecovered += getattr(injDict[jdx]["coincs"][idx],ifo).mchirp
          etaRecovered += getattr(injDict[jdx]["coincs"][idx],ifo).eta
          mass1Recovered += getattr(injDict[jdx]["coincs"][idx],ifo).mass1
          mass2Recovered += getattr(injDict[jdx]["coincs"][idx],ifo).mass2
        mchirpRecovered /= len(ifos)
        etaRecovered /= len(ifos)
        mass1Recovered /= len(ifos)
        mass2Recovered /= len(ifos)
        injSet["rec_mchirp"].append(mchirpRecovered)
        injSet["rec_eta"].append(etaRecovered)
        injSet["rec_mass1"].append(mass1Recovered)
        injSet["rec_mass2"].append(mass2Recovered)

###################################
# calculate the fraction mass error
mchirpError = (array(injSet["rec_mchirp"]) - array(injSet["inj_mchirp"])) / \
              array(injSet["inj_mchirp"])
sigmaMchirpError = std(mchirpError)
meanMchirpError = mean(mchirpError)
if opts.mass_cut == 'mcomp':
  etaError = (array(injSet["rec_eta"]) - array(injSet["inj_eta"])) / \
             array(injSet["inj_eta"])
  sigmaEtaError = std(etaError)
  meanEtaError = mean(etaError)

##########################################################################
# recalculate after getting rid of outliers greater than 5 sigma from mean
# do this until sigma changes by less than 10%
newSigmaMchirpError = sigmaMchirpError
newMeanMchirpError = meanMchirpError
oldSigmaMchirpError = newSigmaMchirpError
oldMeanMchirpError = newMeanMchirpError
while True:
  tmpMchirpError = []
  for idx in range(len(mchirpError)):
    if abs(mchirpError[idx] - newMeanMchirpError) < newMeanMchirpError + \
        5.0*newSigmaMchirpError:
      tmpMchirpError.append(mchirpError[idx])
  oldSigmaMchirpError = newSigmaMchirpError
  oldMeanMchirpError = newMeanMchirpError
  newSigmaMchirpError = std(tmpMchirpError)
  newMeanMchirpError = mean(tmpMchirpError)
  if (oldSigmaMchirpError - newSigmaMchirpError)/oldSigmaMchirpError < 0.1:
    break

sigmaMchirpError = oldSigmaMchirpError
meanMchirpError = oldMeanMchirpError

if opts.mass_cut == 'mcomp':
  newSigmaEtaError = sigmaEtaError
  newMeanEtaError = meanEtaError
  oldSigmaEtaError = newSigmaEtaError
  oldMeanEtaError = newMeanEtaError
  while True:
    tmpEtaError = []
    for idx in range(len(etaError)):
      if abs(etaError[idx] - newMeanEtaError) < newMeanEtaError + \
          5.0*newSigmaEtaError:
        tmpEtaError.append(etaError[idx])
    oldSigmaEtaError = newSigmaEtaError
    oldMeanEtaError = newMeanEtaError
    newSigmaEtaError = std(tmpEtaError)
    newMeanEtaError = mean(tmpEtaError)
    if (oldSigmaEtaError - newSigmaEtaError)/oldSigmaEtaError < 0.1:
      break

  sigmaEtaError = oldSigmaEtaError
  meanEtaError = oldMeanEtaError

###############################################################
# convert this into a minimum and maximum mass in trigger space
minMchirp = max(0.0,McMin*\
                    (1 - 4.0*sigmaMchirpError + min(0.0,meanMchirpError)))
maxMchirp = McMax*(1 + 4.0*sigmaMchirpError + max(0.0,meanMchirpError))

if opts.mass_cut == 'mcomp':
  minEta = max(0.0,etaMin*(1 - 4.0*sigmaEtaError + min(0.0,meanEtaError)))
  maxEta = etaMax*(1 + 4.0*sigmaEtaError + max(0.0,meanEtaError))
else:
  minEta = 0.01
  maxEta = 0.25

print "[coireMassCut]"
print "mass-cut = mchirp"
if opts.mass_cut == 'mcomp':
  print ";inj-mass1-range-low = %f" % (opts.mass_range_low)
  print ";inj-mass1-range-high = %f" % (opts.mass_range_high)
  print ";inj-mass2-range-low = %f" % (opts.mass2_range_low)
  print ";inj-mass2-range-high = %f" % (opts.mass2_range_high)
else:
  print ";inj-mass-range-low = %f" % (opts.mass_range_low)
  print ";inj-mass-range-high = %f" % (opts.mass_range_high)
print "mass-range-low = %f" % (minMchirp)
print "mass-range-high = %f" % (maxMchirp)
if opts.mass_cut == 'mcomp':
  print "mass2-range-low = %f" % (minEta)
  print "mass2-range-high = %f" % (maxEta)

##############################################
# infinite sequence of integers, starting at 1
plot_num = itertools.count(1)

#############################################
# plot recovered and injected mass2 vs. mass1
if opts.mass_mass and (opts.mass_cut == 'mcomp' or opts.mass_cut == 'mtotal'):
  figure(plot_num.next())
  if opts.mass_cut == 'mcomp':
    xInjBox = [opts.mass_range_low, opts.mass_range_high,
               opts.mass_range_high, opts.mass_range_low, opts.mass_range_low]
    yInjBox = [opts.mass2_range_low, opts.mass2_range_low,
               opts.mass2_range_high, opts.mass2_range_high,
               opts.mass2_range_low]
  elif opts.mass_cut == 'mtotal':
    xInjBox = [opts.mass_range_low-1., opts.mass_range_high-1.,
               opts.mass_range_high/2., opts.mass_range_low/2.,
               opts.mass_range_low-1.]
    yInjBox = [1, 1, opts.mass_range_high/2., opts.mass_range_low/2., 1]
  xRecBox = []
  yRecBox = []
  dMchirp = (maxMchirp - minMchirp)/100.
  dEta = (maxEta - minEta)/100.
  for idx in range(101):
    mchirp = minMchirp + float(idx)*dMchirp
    eta = max(minEta,0.02)
    m1 = mchirp/2.*(eta**(-0.6) + (eta**(-1.2) - 4.*eta**(-0.2))**(0.5))
    m2 = mchirp/2.*(eta**(-0.6) - (eta**(-1.2) - 4.*eta**(-0.2))**(0.5))
    xRecBox.append(m1)
    yRecBox.append(m2)
  for idx in range(101):
    mchirp = maxMchirp
    eta = max(min(minEta + float(idx)*dEta,0.25),0.02)
    m1 = mchirp/2.*(eta**(-0.6) + (eta**(-1.2) - 4.*eta**(-0.2))**(0.5))
    m2 = mchirp/2.*(eta**(-0.6) - (eta**(-1.2) - 4.*eta**(-0.2))**(0.5))
    xRecBox.append(m1)
    yRecBox.append(m2)
  for idx in range(101):
    mchirp = maxMchirp - float(idx)*dMchirp
    eta = max(min(maxEta,0.25),0.02)
    m1 = mchirp/2.*(eta**(-0.6) + (eta**(-1.2) - 4.*eta**(-0.2))**(0.5))
    m2 = mchirp/2.*(eta**(-0.6) - (eta**(-1.2) - 4.*eta**(-0.2))**(0.5))
    xRecBox.append(m1)
    yRecBox.append(m2)
  for idx in range(101):
    mchirp = minMchirp
    eta = max(min(maxEta - float(idx)*dEta,0.25),0.02)
    m1 = mchirp/2.*(eta**(-0.6)+(eta**(-1.2)-4.*eta**(-0.2))**(0.5))
    m2 = mchirp/2.*(eta**(-0.6)-(eta**(-1.2)-4.*eta**(-0.2))**(0.5))
    xRecBox.append(m1)
    yRecBox.append(m2)

  xBank = [1, 34, 17.5, 1]
  yBank = [1, 1, 17.5, 1]
  plot(xInjBox, yInjBox, 'r', xRecBox, yRecBox, 'b', xBank, yBank, 'k',
       linewidth=2)
  hold(True)
  plot(injSet["inj_mass1"], injSet["inj_mass2"], 'rx',
       injSet["rec_mass1"], injSet["rec_mass2"], 'b+')
  min_mass1 = min(min(injSet["inj_mass1"]),min(injSet["rec_mass1"]))
  max_mass1 = max(max(injSet["inj_mass1"]),max(injSet["rec_mass1"]))
  min_mass2 = min(min(injSet["inj_mass2"]),min(injSet["rec_mass2"]))
  max_mass2 = max(max(injSet["inj_mass2"]),max(injSet["rec_mass2"]))
  xlim(xmin=int(min(min(xRecBox),min_mass1))-1.0,
       xmax=int(max(max(xRecBox),max_mass1))+1.0)
  ylim(ymin=int(min(min(yRecBox),min_mass2))-1.0,
       ymax=int(max(max(max(yRecBox),max(yBank)),max_mass2))+1.0)
  xlabel('$m_{1}$ $(M_{\odot})$', size='x-large')
  ylabel('$m_{2}$ $(M_{\odot})$', size='x-large')
  legend(('injected', 'recovered'), loc='upper right')
  if opts.figure_name:
    savefig(opts.figure_name + '_m2_vs_m1.png')

##################################
# plot recovered vs. injected mass
if opts.mass_mass:
  figure(plot_num.next())
  plot(injSet["inj_mchirp"], injSet["rec_mchirp"],'rx')
  hold(True)
  axvline(x=McMin, linewidth=2, color='b')
  axvline(x=McMax, linewidth=2, color='b')
  axhline(y=minMchirp, linewidth=2, color='r')
  axhline(y=maxMchirp, linewidth=2, color='r')
  xlim(xmin=int(McMin)-1.0,xmax=int(McMax)+1.0)
  ylim(ymin=int(minMchirp)-1.0,
       ymax=max(int(maxMchirp)+1.0,int(max(injSet["rec_mchirp"]))+1.0))
  ylabel('Recovered $M_{chirp}$ $(M_{\odot})$',size='x-large')
  xlabel('Injected $M_{chirp}$ $(M_{\odot})$',size='x-large')
  if opts.figure_name:
    savefig(opts.figure_name + '_inj_vs_rec_mchirp.png')

if opts.mass_cut == 'mcomp' and opts.mass_mass:
  figure(plot_num.next())
  plot(injSet["inj_eta"], injSet["rec_eta"],'rx')
  hold(True)
  axvline(x=etaMin, linewidth=2, color='b')
  axvline(x=etaMax, linewidth=2, color='b')
  axhline(y=minEta, linewidth=2, color='r')
  axhline(y=maxEta, linewidth=2, color='r')
  xlim(xmin=int(etaMin)-0.1,xmax=int(etaMax)+0.1)
  ylim(ymin=int(minEta)-0.1,ymax=int(max(maxEta,max(injSet["rec_eta"])))+0.1)
  ylabel('Recovered $\eta$',size='x-large')
  xlabel('Injected $\eta$',size='x-large')
  if opts.figure_name:
    savefig(opts.figure_name + '_inj_vs_rec_eta.png')

####################################
# histogram of fractional mass error
if opts.hist_mass_error:
  figure(plot_num.next())
  mchirpErrorMax = max(mchirpError)
  mchirpErrorMin = min(mchirpError)
  y,x,patches = hist(mchirpError,bins=opts.num_bins)
  bar(x,y,width=(mchirpErrorMax - mchirpErrorMin)/opts.num_bins)
  hold(True)
  normalization = ((mchirpErrorMax - mchirpErrorMin)/opts.num_bins)* \
                  len(mchirpError)/(2.0*pi*sigmaMchirpError**2.0)**(0.5)
  x_gauss = array(range(501))*(mchirpErrorMax - mchirpErrorMin)/500.0 + \
            mchirpErrorMin
  y_gauss = normalization*exp(-(x_gauss - meanMchirpError)**2.0/ \
                               (2.0*sigmaMchirpError**2.0))
  plot(x_gauss,y_gauss,'k',linewidth=2)
  axvline(x=5.0*sigmaMchirpError + meanMchirpError, linewidth=2, color='r')
  axvline(x=-5.0*sigmaMchirpError + meanMchirpError, linewidth=2, color='r')
  ylabel('$\#$',size='x-large')
  xlabel('Fractional $M_{chirp}$ Error',size='x-large') 
  if opts.figure_name:
    savefig(opts.figure_name + '_frac_mchirp_error_hist.png')

if opts.mass_cut == 'mcomp' and opts.hist_mass_error:
  figure(plot_num.next())
  etaErrorMax = max(etaError)
  etaErrorMin = min(etaError)
  y,x,patches = hist(etaError,bins=opts.num_bins)
  bar(x,y,width=(etaErrorMax - etaErrorMin)/opts.num_bins)
  hold(True)
  normalization = ((etaErrorMax - etaErrorMin)/opts.num_bins)* \
                  len(etaError)/(2.0*pi*sigmaEtaError**2.0)**(0.5)
  x_gauss = array(range(501))*(etaErrorMax - etaErrorMin)/500.0 + \
                  etaErrorMin
  y_gauss = normalization*exp(-(x_gauss - meanEtaError)**2.0/ \
                               (2.0*sigmaEtaError**2.0))
  plot(x_gauss,y_gauss,'k',linewidth=2)
  axvline(x=5.0*sigmaEtaError + meanEtaError, linewidth=2, color='r')
  axvline(x=-5.0*sigmaEtaError + meanEtaError, linewidth=2, color='r')
  ylabel('$\#$',size='x-large')
  xlabel('Fractional $\eta$ Error',size='x-large')
  if opts.figure_name:
    savefig(opts.figure_name + '_frac_eta_error_hist.png')

if opts.show_plot:
  show()
