#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]

from optparse import OptionParser
import pylab
import sys
import time
import urllib
from xml import sax

from glue import lal
from glue import segments
from glue.ligolw import ligolw
from glue.ligolw import metaio
from glue.ligolw import lsctables
from glue.ligolw import docutils
from pylal import rate
from pylal.xlal.date import XLALGPSToUTC, XLALUTCToGPS

#
# =============================================================================
#
#                                 Command line
#
# =============================================================================
#

usage = """
usage: %prog [options] cache_files...

Generate long time scale trigger rate plot, getting trigger file names from LAL
cache files.

"""
parser = OptionParser(usage)
parser = OptionParser(version="%prog CVS $Id$")
parser.add_option("-s", "--gps-start-time", metavar="SECONDS", default=None, help="start time of plot in GPS seconds")
parser.add_option("-e", "--gps-end-time", metavar="SECONDS", default=None, help="end time of plot in GPS seconds")
parser.add_option("-w", "--window", metavar="SECONDS", default=3600.0, help="width of averaging window in seconds")
parser.add_option("-i", "--instrument", metavar="INSTRUMENT", help="instrument name")
parser.add_option("-o", "--output-base", metavar="BASE", help="output file name base (no extension)")
options, cache = parser.parse_args()
del parser

# check for output
if not options.output_base:
	print >>sys.stderr, "error: no output file base specified!"
	sys.exit(1)

# check for instrument
if not options.instrument:
	print >>sys.stderr, "error: no instrument specified!"
	sys.exit(1)

# parse window
options.window = float(options.window)

# parse trigger cache files
if not len(cache):
	print >>sys.stderr, "error: no trigger cache files specified!"
	sys.exit(1)
cache = reduce(list.__add__, [map(lal.CacheEntry, file(name)) for name in cache], [])

# set segment
try:
	options.gps_start_time = lal.LIGOTimeGPS(options.gps_start_time)
	options.gps_end_time = lal.LIGOTimeGPS(options.gps_end_time)
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)
options.segment = segments.segment(options.gps_start_time, options.gps_end_time)
options.read_segment = options.segment.protract(5.0 * options.window)

# filter cache entries and sort
cache = filter(lambda c: options.read_segment.intersects(c.segment), cache)
cache.sort()


#
# =============================================================================
#
#   Custom SnglBurstTable append() method to put triggers directly into bins
#
# =============================================================================
#

rate = rate.Rate(options.read_segment, options.window)
num_triggers = 0

def append(table, trigger):
	global num_triggers, rate
	num_triggers += 1
	if options.read_segment[0] <= trigger.get_peak() < options.read_segment[1]:
		rate[trigger.get_peak()] = 1.0
	if not (num_triggers % 500):
		print >>sys.stderr, "triggers: %d\r" % num_triggers,

lsctables.SnglBurstTable.append = append


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

def SnglBurstAndSearchSummOnlyHandler(doc):
	"""
	Construct a document handler that reads only sngl_burst and search
	summary tables.
	"""
	return docutils.PartialLIGOLWContentHandler(doc, lambda name, attrs: (name == ligolw.Table.tagName) and (metaio.StripTableName(attrs["Name"]) in map(metaio.StripTableName, [lsctables.SnglBurstTable.tableName, lsctables.SearchSummaryTable.tableName])))


def ReadFiles(cache):
	doc = ligolw.Document()
	handler = SnglBurstAndSearchSummOnlyHandler(doc)
	for n, c in enumerate(cache):
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(cache), c.url)
		ligolw.make_parser(handler).parse(urllib.urlopen(c.url))
		print >>sys.stderr, "triggers: %d" % num_triggers
		docutils.MergeCompatibleTables(doc)
	return doc


searchsumm_tables = lsctables.getTablesByType(ReadFiles(cache), lsctables.SearchSummaryTable)

if len(searchsumm_tables) == 0:
	seglist = segments.segmentlist([])
elif len(searchsumm_tables) == 1:
	seglist = searchsumm_tables[0].get_inlist().coalesce()
else:
	print >>sys.stderr, "error: files contain incompatible search summary tables"
	sys.exit(1)


#
# =============================================================================
#
#                        How to generate X axis labels
#
# =============================================================================
#

def utc_midnight(gps):
	"""
	Truncate a GPS seconds to UTC midnight.
	"""
	# convert to UTC (as list so we can edit it)
	tm = list(XLALGPSToUTC(gps))

	# truncate to midnight
	tm[3] = 0	# hours
	tm[4] = 0	# minutes
	tm[5] = 0	# seconds

	# convert back to GPS
	return XLALUTCToGPS(tuple(tm))


def next_midnight(midnight):
	"""
	Given a UTC midnight in GPS seconds, return the GPS seconds of the next
	midnight.
	"""
	# add 86401 and truncate to midnight (accounts for possible leap
	# second).
	return utc_midnight(midnight + 86401)


def make_xticks(segment):
	# find the first UTC midnight on the X axis
	gps = utc_midnight(int(segment[0]))
	if gps < int(segment[0]):
		gps = next_midnight(gps)

	# find the last UTC midnight on the X axis
	last_gps = utc_midnight(int(segment[1]))

	# generate tick locations and labels
	locs, labels = [], []
	while gps <= last_gps:
		tm = time.struct_time(XLALGPSToUTC(gps))
		locs.append(gps)
		if tm.tm_wday == 1:	# tuesday
			labels.append(time.strftime("%H h, %a %b %d, %Y", tm))
		else:
			labels.append("")
		gps = next_midnight(gps)
	return locs, labels


#
# =============================================================================
#
#                                    Figure
#
# =============================================================================
#

# build a figure whose axes are 3" wide per week, and whose height is the width
# of a US letter page (minus some typical printer margins)
def newfig(segment):
	weeks = float(segment.duration())/86400.0/7.0	# FIXME: leep seconds?
	border = [0.5, 0.75, 0.125, 0.625]	# inches
	width = weeks * 3.0 + border[0] + border[2]	# inches
	height = 8.0	# inches
	fig = pylab.figure()
	fig.set_figsize_inches(width, height)
	pylab.setp(pylab.gca(), position = [border[0] / width, border[1] / height, (width - border[0] - border[2]) / width, (height - border[1] - border[3]) / height])
	return fig

fig = newfig(options.segment)
axes = pylab.gca()

rate.convolve()
pylab.plot(rate.xvals, rate.yvals)

pylab.setp(axes, xlim = list(options.segment))
pylab.grid(True)

for seg in ~seglist & segments.segmentlist([options.segment]):
	pylab.axvspan(seg[0], seg[1], facecolor = "k", alpha = 0.2)

pylab.title("%s Excess Power Trigger Rate vs. Time\n(%d Triggers, %g s Average)" % (options.instrument, num_triggers, options.window))

ticks = make_xticks(options.segment)
pylab.xticks(ticks[0], ticks[1], horizontalalignment="right", fontsize=10, rotation=10)
pylab.xlabel("UTC")
pylab.yticks(fontsize=10)
pylab.ylabel("Trigger Rate (Hz)")

pylab.savefig(options.output_base + ".eps")
pylab.savefig(options.output_base + ".png")
pylab.savefig(options.output_base + ".svg")
