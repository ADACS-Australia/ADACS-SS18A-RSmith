#!/usr/bin/python

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__date__ = "$Date$"
__version__ = "$Id$"

from optparse import OptionParser
import pylab
import sys
import time
import urllib
from xml import sax

from glue import lal
from glue import segments
from glue.ligolw import ligolw
from glue.ligolw import metaio
from glue.ligolw import lsctables
from glue.ligolw import docutils
from pylal import rate
from pylal.support import XLALGPSToUTC, XLALUTCToGPS

#
# =============================================================================
#
#                                 Command line
#
# =============================================================================
#

usage = """
usage: %prog [options] cache_files...

Generate long time-scale trigger rate plot, getting trigger file names from LAL
cache files.

"""
parser = OptionParser(usage)
parser = OptionParser(version="%prog CVS $Id$")
parser.add_option("-s", "--gps-start-time", metavar="SECONDS", default=None, help="start time of plot in GPS seconds")
parser.add_option("-e", "--gps-end-time", metavar="SECONDS", default=None, help="end time of plot in GPS seconds")
parser.add_option("-w", "--window", metavar="SECONDS", default=3600.0, help="width of averaging window in seconds")
parser.add_option("-o","--output-base", metavar="BASE", help="output file name base (no extension)")
options, cache = parser.parse_args()
del parser

# check for output
if not options.output_base:
	print >>sys.stderr, "error: no output file base specified!"
	sys.exit(1)

# parse window
options.window = float(options.window)

# parse trigger cache files
if not len(cache):
	print >>sys.stderr, "error: no trigger cache files specified!"
	sys.exit(1)
cache = reduce(list.__add__, [map(lal.CacheEntry, file(name)) for name in cache], [])

# set segment
try:
	options.gps_start_time = lal.LIGOTimeGPS(options.gps_start_time)
	options.gps_end_time = lal.LIGOTimeGPS(options.gps_end_time)
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)
options.segment = segments.segment(options.gps_start_time, options.gps_end_time)
options.read_segment = options.segment.protract(5.0 * options.window)

# filter cache entries and sort
cache = filter(lambda c: options.read_segment.intersects(c.segment), cache)
cache.sort()


#
# =============================================================================
#
#   Custom SnglBurstTable append() method to put triggers directly into bins
#
# =============================================================================
#

rate = rate.Rate(options.read_segment, options.window)
num_triggers = 0

def append(table, trigger):
	global num_triggers, rate
	num_triggers += 1
	if options.read_segment[0] <= trigger.get_peak() < options.read_segment[1]:
		rate[trigger.get_peak()] = 1.0
	if not (num_triggers % 500):
		print >>sys.stderr, "triggers: %d\r" % num_triggers,

lsctables.SnglBurstTable.append = append


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

def SnglBurstAndSearchSummOnlyHandler(doc):
	"""
	Construct a document handler that reads only sngl_burst and search
	summary tables.
	"""
	return docutils.PartialLIGOLWContentHandler(doc, lambda name, attrs: (name == ligolw.Table.tagName) and (metaio.StripTableName(attrs["Name"]) in map(metaio.StripTableName, [lsctables.SnglBurstTable.tableName, lsctables.SearchSummaryTable.tableName])))


def ReadFiles(cache):
	doc = ligolw.Document()
	handler = SnglBurstAndSearchSummOnlyHandler(doc)
	for n, c in enumerate(cache):
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(cache), c.url)
		ligolw.make_parser(handler).parse(urllib.urlopen(c.url))
		print >>sys.stderr, "\n",
	return docutils.MergeCompatibleTables(doc)


searchsumm_tables = lsctables.getTablesByType(ReadFiles(cache), lsctables.SearchSummaryTable)

if len(searchsumm_tables) == 0:
	seglist = segments.segmentlist([])
elif len(searchsumm_tables) == 1:
	seglist = searchsumm_tables[0].get_inlist().coalesce()
else:
	print >>sys.stderr, "error: files contain incompatible search summary tables"
	sys.exit(1)


#
# =============================================================================
#
#                        How to generate X axis labels
#
# =============================================================================
#

def utc_midnight(gps):
	"""
	Round down a GPS seconds to UTC midnight.
	"""
	# convert to UTC (as list so we can edit it)
	tm = list(XLALGPSToUTC(gps))

	# round down to midnight
	tm[3] = 0	# hours
	tm[4] = 0	# minutes
	tm[5] = 0	# seconds

	# convert back to GPS
	return XLALUTCToGPS(tuple(tm))


def next_midnight(midnight):
	"""
	Given a UTC midnight in GPS seconds, return the GPS seconds of the next
	midnight.
	"""
	# add 86401 and round down to midnight (accounts for possible leap
	# second).
	return utc_midnight(midnight + 86401)


def make_xticks(segment):
	# find the first UTC midnight on the X axis
	gps = utc_midnight(int(segment[0]))
	if gps < int(segment[0]):
		gps = next_midnight(gps)

	# find the last UTC midnight on the X axis
	last_gps = utc_midnight(int(segment[1]))

	# generate tick locations and labels
	locs, labels = [], []
	while gps <= last_gps:
		tm = time.struct_time(XLALGPSToUTC(gps))
		locs.append(gps)
		if tm.tm_wday == 1:	# tuesday
			labels.append(time.strftime("%H h, %a %b %d, %Y", tm))
		else:
			labels.append("")
		gps = next_midnight(gps)
	return locs, labels


#
# =============================================================================
#
#                                    Figure
#
# =============================================================================
#

rate.convolve()

# figure is 3" wide per week
fig = pylab.figure(1)
fig.set_figsize_inches(float(options.segment.duration())/86400/7 * 3,8)
axes = pylab.gca()

pylab.plot(rate.xvals, rate.yvals)

pylab.setp(axes, xlim = list(options.segment))
pylab.grid(True)

for seg in ~seglist & segments.segmentlist([options.segment]):
	pylab.axvspan(seg[0], seg[1], facecolor = "k", alpha = 0.2)

pylab.title("Excess Power Trigger Rate vs. Time\n(%d Triggers, %g s Average)" % (num_triggers, options.window))

ticks = make_xticks(options.segment)
pylab.xticks(ticks[0], ticks[1], horizontalalignment="right", fontsize=10, rotation=15)
pylab.xlabel("UTC")
pylab.yticks(fontsize=10)
pylab.ylabel("Trigger Rate (Hz)")

pylab.savefig(options.output_base + ".eps")
pylab.savefig(options.output_base + ".png")
