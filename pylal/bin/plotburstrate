#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]

from optparse import OptionParser
import matplotlib
matplotlib.use("Agg")
from matplotlib import figure
from matplotlib.backends.backend_agg import FigureCanvasAgg
import sys
import time
import urllib

from glue.lal import CacheEntry
from glue import segments
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw.utils import ligolw_add
from pylal import rate
from pylal.date import LIGOTimeGPS, XLALGPSToUTC, UTCMidnights

#
# =============================================================================
#
#                                 Command line
#
# =============================================================================
#

usage = """
usage: %prog [options] cache_files...

Generate long time scale trigger rate plot, getting trigger file names from LAL
cache files.

"""
parser = OptionParser(usage)
parser = OptionParser(version="%prog CVS $Id$")
parser.add_option("-s", "--gps-start-time", metavar="SECONDS", default=None, help="start time of plot in GPS seconds")
parser.add_option("-e", "--gps-end-time", metavar="SECONDS", default=None, help="end time of plot in GPS seconds")
parser.add_option("-w", "--window", metavar="SECONDS", default=3600.0, help="width of averaging window in seconds")
parser.add_option("-i", "--instrument", metavar="INSTRUMENT", help="instrument name")
parser.add_option("-o", "--output-base", metavar="BASE", help="output file name base (no extension)")
options, cache = parser.parse_args()
del parser

# check for output
if not options.output_base:
	print >>sys.stderr, "error: no output file base specified!"
	sys.exit(1)

# check for instrument
if not options.instrument:
	print >>sys.stderr, "error: no instrument specified!"
	sys.exit(1)

# parse window
options.window = float(options.window)

# parse trigger cache files
if not len(cache):
	print >>sys.stderr, "error: no trigger cache files specified!"
	sys.exit(1)
cache = reduce(list.__add__, [map(CacheEntry, file(name)) for name in cache], [])

# set segment
try:
	options.gps_start_time = LIGOTimeGPS(options.gps_start_time)
	options.gps_end_time = LIGOTimeGPS(options.gps_end_time)
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)
options.segment = segments.segment(options.gps_start_time, options.gps_end_time)
options.read_segment = options.segment.protract(5.0 * options.window)

# filter cache entries and sort
cache = filter(lambda c: options.read_segment.intersects(c.segment), cache)
cache.sort()


#
# =============================================================================
#
#   Custom SnglBurstTable append() method to put triggers directly into bins
#
# =============================================================================
#

rate = rate.Rate(options.read_segment, options.window)
num_triggers = 0

def snglburst_append(table_elem, trigger):
	global num_triggers, rate
	num_triggers += 1
	if options.read_segment[0] <= trigger.get_peak() < options.read_segment[1]:
		rate[trigger.get_peak(),] += 1.0
	if not (num_triggers % 500):
		print >>sys.stderr, "triggers: %d\r" % num_triggers,

lsctables.SnglBurstTable.append = snglburst_append


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

def element_filter(name, attrs):
	return (name == ligolw.Table.tagName) and (table.StripTableName(attrs["Name"]) in map(table.StripTableName, [lsctables.SnglBurstTable.tableName, lsctables.SearchSummaryTable.tableName]))

class ContentHandler(ligolw.PartialLIGOLWContentHandler):
	"""
	A content handler that reads only sngl_burst and search summary
	tables.
	"""
	def __init__(self, doc):
		ligolw.PartialLIGOLWContentHandler.__init__(self, doc, element_filter)

ligolw_add.ContentHandler = ContentHandler

searchsumm_tables = lsctables.getTablesByType(ligolw_add.ligolw_add(ligolw.Document(), [c.url for c in cache], verbose = True), lsctables.SearchSummaryTable)


if len(searchsumm_tables) == 0:
	seglist = segments.segmentlist([])
elif len(searchsumm_tables) == 1:
	seglist = searchsumm_tables[0].get_inlist().coalesce()
else:
	print >>sys.stderr, "error: files contain incompatible search summary tables"
	sys.exit(1)


#
# =============================================================================
#
#                        How to generate X axis labels
#
# =============================================================================
#

def make_xticks(segment):
	# generate tick locations and labels
	locs = list(UTCMidnights(*segment))
	labels = []
	for tm in map(lambda t: time.struct_time(XLALGPSToUTC(t)), locs):
		if tm.tm_wday == 1:	# tuesday
			labels.append(time.strftime("%H h, %a %b %d, %Y", tm))
		else:
			labels.append("")
	return map(float, locs), labels


#
# =============================================================================
#
#                                    Figure
#
# =============================================================================
#

# build a figure whose axes are 3" wide per week, and whose height is the width
# of a US letter page (minus some typical printer margins)
def newfig(segment):
	weeks = float(abs(segment))/86400.0/7.0	# FIXME: leep seconds?
	border = [0.5, 0.75, 0.125, 0.625]	# inches
	width = weeks * 3.0 + border[0] + border[2]	# inches
	height = 8.0	# inches
	fig = figure.Figure()
	canvas = FigureCanvasAgg(fig)
	fig.set_figsize_inches(width, height)
	fig.gca().set_position([border[0] / width, border[1] / height, (width - border[0] - border[2]) / width, (height - border[1] - border[3]) / height])
	return fig

fig = newfig(options.segment)
axes = fig.gca()

axes.plot(rate.centres()[0], rate.filter())

axes.set_xlim(list(options.segment))
axes.grid(True)

for seg in ~seglist & segments.segmentlist([options.segment]):
	axes.axvspan(seg[0], seg[1], facecolor = "k", alpha = 0.2)

axes.set_title("%s Excess Power Trigger Rate vs. Time\n(%d Triggers, %g s Average)" % (options.instrument, num_triggers, options.window))

ticks = make_xticks(options.segment)
axes.set_xticks(ticks[0])
axes.set_xticklabels(ticks[1], horizontalalignment="right", fontsize=10, rotation=10)
axes.set_xlabel("UTC")
#axes.yticks(fontsize=10)
axes.set_ylabel("Trigger Rate (Hz)")

fig.savefig(options.output_base + ".eps")
fig.savefig(options.output_base + ".png")
fig.savefig(options.output_base + ".svg")
