#!/usr/bin/env python
#
#       coincToLALInference.py
#
#       Copyright 2012
#       Vivien Raymond <vivien.raymond@ligo.org>
#
#
#       This program is free software; you can redistribute it and/or modify
#       it under the terms of the GNU General Public License as published by
#       the Free Software Foundation; either version 2 of the License, or
#       (at your option) any later version.
#
#       This program is distributed in the hope that it will be useful,
#       but WITHOUT ANY WARRANTY; without even the implied warranty of
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#       GNU General Public License for more details.
#
#       You should have received a copy of the GNU General Public License
#       along with this program; if not, write to the Free Software
#       Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#       MA 02110-1301, USA.

#===============================================================================
# Python script to create all necessary files to run lalinference_mcmc in the 
# working directory. Takes as first argument the coinc table as generated by 
# gracedb, and an optional second argument specifying the approximant name to be
# used (default TaylorF2):
# 
#        cd <submit_directory>
#        ./coincToLALInference.py coinc.xml SpinTaylorFrameless
#
# It will use ligo_data_find to generate cache files, and print an error message
# if not enought contiguous data is available.
#
# Tested only on the CIT cluster.
#
#===============================================================================


import sys
import math
import commands

from glue.ligolw import utils
from glue.ligolw import lsctables

types = {'H': 'H1H2_DMT_ERHOFT', 'L': 'L1_DMT_ERHOFT', 'V': 'ER1_hoft'}
psdsegments = 32

xmldoc = utils.load_filename( sys.argv[1] )
sngltable = lsctables.getTablesByType( xmldoc, lsctables.SnglInspiralTable )[0]
template_duration = [event.template_duration for event in sngltable]
ifo = [event.ifo for event in sngltable]
channel = [event.channel for event in sngltable]
f_final = [event.f_final for event in sngltable]

insptable = lsctables.getTablesByType( xmldoc, lsctables.CoincInspiralTable )[0]
end_time = [event.end_time for event in insptable]
end_time_ns = [event.end_time_ns for event in insptable]
snr = [event.snr for event in insptable]
# ifos = [event.ifos for event in insptable]

ifostr='['
cachestr='['
freqstr='['
channelstr='['
for n, i in enumerate(ifo):
  ifostr+=str(i)
  cachestr+=str(end_time[0]) + '-' + str(i) + '.cache'
  freqstr+='10'
  channelstr+=str(i) + ':' + str(channel[n])
  ligo_data_find_seg = 'ligo_data_find -o ' + str(i)[0] + ' -t ' + types[str(i)[0]] + ' -s ' + str(math.floor(end_time[0]-max(template_duration)*1.2*(psdsegments+1))) + ' -e ' + str(end_time[0]+3) + ' --show-times'
  status, output = commands.getstatusoutput(ligo_data_find_seg)
  if output.count('\n') > 0:
    exit_str='Data for ' + str(i) + ' is not contiguous. Aborting.\n'
    exit_str+=output
    sys.exit(exit_str)
  ligo_data_find_str = 'ligo_data_find -o ' + str(i)[0] + ' -t ' + types[str(i)[0]] + ' -s ' + str(math.floor(end_time[0]-max(template_duration)*1.2*(psdsegments+1))) + ' -e ' + str(end_time[0]+3) + ' -l | grep localhost/data/node'
  status, output = commands.getstatusoutput(ligo_data_find_str)
  cache_file = open('./' + str(end_time[0]) + '-' + str(i) + '.cache','w')
  cache_file.write(output)
  if len(ifo)>n+1:
    ifostr+=','
    cachestr+=','
    freqstr+=','
    channelstr+=','
ifostr+=']'
cachestr+=']'
freqstr+=']'
channelstr+=']'

srate = [2**x for x in range(15)]
freq=16384
for f in reversed(srate):
  if f > max(f_final):
    freq = f

command = '--trigtime ' + str(end_time[0]) + '.' + str(end_time_ns[0])
command += ' --trigSNR ' + str(snr[0])
command += ' --seglen ' + str(math.floor(max(template_duration)*1.2))
command += ' --psdlength ' + str(math.floor(max(template_duration)*1.2)*psdsegments)
command += ' --psdstart ' + str(math.floor(end_time[0]-max(template_duration)*1.2*(psdsegments+1)))
command += ' --ifo ' + ifostr
command += ' --cache ' + cachestr
command += ' --channel ' + channelstr
command += ' --flow ' + freqstr
command += ' --srate ' + str(freq)
if len(sys.argv) > 2:
  command += ' --approximant ' + str(sys.argv[2])
# command += ' --order threePointFivePN' 
command += ' --Dmax 1000'
#command += ' --Niter 5000000'

#print command

submit_file = open('./lalinference_mcmc.sub','w')
submit_str =  'universe = parallel\n'
submit_str += 'environment=CONDOR_MPI_PATH=/usr/lib64/openmpi\n'
submit_str += 'getenv = True\n'
submit_str += 'executable = /archive/home/vivien/condor_mpirun\n'
submit_str += 'arguments = --verbose --stdout cluster$(CLUSTER).proc$(PROCESS).mpiout --stderr cluster$(CLUSTER).proc$(PROCESS).mpierr /archive/home/vivien/master/bin/lalinference_mcmc -- ' + command + ' \n'
submit_str += 'machine_count = 8\n'
submit_str += 'log = cluster$(CLUSTER).proc$(PROCESS).log\n'
submit_str += 'output = cluster$(CLUSTER).proc$(PROCESS).subproc$(NODE).out\n'
submit_str += 'error = cluster$(CLUSTER).proc$(PROCESS).subproc$(NODE).err\n'
submit_str += 'notification = Always\n'
submit_str += 'on_exit_remove = (ExitBySignal == True) || (ExitCode != 143)\n'
submit_str += 'rank = (40 - (2.0 * TotalCondorLoadAvg))\n'
submit_str += 'queue\n'
submit_file.write(submit_str)




