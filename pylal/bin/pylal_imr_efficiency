#!/usr/bin/python
import scipy
from scipy import interpolate
import numpy
try:
	import sqlite3
except ImportError:
	# pre 2.5.x
	from pysqlite2 import dbapi2 as sqlite3

sqlite3.enable_callback_tracebacks(True)

import sys
import glob
import copy
from optparse import OptionParser
import traceback

from glue import segments
from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import dbtables
from glue.ligolw import utils
from glue.ligolw import table
from glue import segmentsUtils
from glue.ligolw.utils import process
from glue.ligolw.utils import segments as ligolw_segments

from pylal import db_thinca_rings
from pylal import llwapp
from pylal import rate
from pylal import SimInspiralUtils
from pylal.xlal.datatypes.ligotimegps import LIGOTimeGPS
from pylal import imr_utils
import matplotlib
matplotlib.use('Agg')

from matplotlib import pyplot

from pylal import git_version
__author__ = "Chad Hanna <channa@ligo.caltech.edu>, Satya Mohapatra <satya@physics.umass.edu>"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date


def parse_command_line():
	parser = OptionParser(version = git_version.verbose_msg, usage = "%prog [options] [file ...]", description = "%prog computes mass/mass upperlimit")
	parser.add_option("--output-tag", default = "", metavar = "name", help = "Set the file output name file")
	parser.add_option("--far", default = float("inf"), type = "float", metavar = "Hz", help = "FAR to use for injection finding - default infinity")
	parser.add_option("--live-time-program", default = "gstlal_inspiral", help = "Set the name of the live time program to use to get segments from the search summary table")
	parser.add_option("--veto-segments-name", default = "vetoes", help = "Set the name of the veto segments to use from the XML document.")
	parser.add_option("-t", "--tmp-space", metavar = "path", help = "Path to a directory suitable for use as a work area while manipulating the database file.  The database file will be worked on in this directory, and then moved to the final location when complete.  This option is intended to improve performance when running in a networked environment, where there might be a local disk with higher bandwidth than is available to the filesystem on which the final output will reside.")
	parser.add_option("--l-horizon", default = 30, type = "float", metavar = "Mpc", help = "L horizon, default 30")
	parser.add_option("--h-horizon", default = 30, type = "float", metavar = "Mpc", help = "H horizon, default 30")
	parser.add_option("--l-snr", default = 8, type = "float", metavar = "snr", help = "L horizon, default 8")
	parser.add_option("--h-snr", default = 8, type = "float", metavar = "snr", help = "H horizon, default 8")
	parser.add_option("--verbose", action = "store_true", help = "Be verbose.")

	opts, filenames = parser.parse_args()

	if not filenames:
		raise ValueError("must provide at least one database")

	return opts, filenames


options, filenames = parse_command_line()

IMR = imr_utils.DataBaseSummary(filenames, tmp_path = options.tmp_space, veto_segments_name = options.veto_segments_name, live_time_program = options.live_time_program, verbose = options.verbose)

for instruments, total_injections in IMR.total_injections_by_instrument_set.items():
	found_below_far = imr_utils.found_injections_below_far(IMR.found_injections_by_instrument_set[instruments], far_thresh = options.far)
	
	found_below_horizon = [sim for sim in total_injections if sim.get_chirp_dist('h') < options.h_horizon * (8. / options.h_snr) and sim.get_chirp_dist('l') < options.l_horizon * (8. / options.l_snr)]
	
	if options.verbose:
		print >> sys.stderr, "Found %d injections in %s below FAR %e" % (len(found_below_far), "".join(instruments), options.far)


	dist_bins = imr_utils.guess_nd_bins(total_injections, {"distance": (15, rate.LinearBins)})

	eff, x = imr_utils.compute_search_efficiency_in_bins(found_below_far, total_injections, dist_bins)
	eff_horizon, x = imr_utils.compute_search_efficiency_in_bins(found_below_horizon, total_injections, dist_bins)

	eff = eff.array
	eff_horizon = eff_horizon.array

	pyplot.figure()
	pyplot.plot(dist_bins.centres()[0], eff, label = "actual efficiency @ %.1e FAR" % options.far)
	pyplot.plot(dist_bins.centres()[0], eff_horizon, label = "efficiency assuming \n H1 SNR %.1f @ %.0f Mpc \n L1 SNR %.1f @ %.0f Mpc" % (options.h_snr, options.h_horizon, options.l_snr, options.l_horizon))
	pyplot.grid()
	pyplot.legend()
	pyplot.xlabel('Distance (Mpc)')
	pyplot.ylabel('Efficiency')
	pyplot.savefig("%s-%s.png" % ("".join(instruments), options.output_tag))

