#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import bisect
from optparse import OptionParser
import sys

from glue.ligolw import lsctables
from pylal import llwapp
from pylal import SnglBurstUtils

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version = "%prog CVS $Id$")
	parser.add_option("-f", "--force", action = "store_true", help = "process even if file has already been processed")
	parser.add_option("--comment", metavar = "text", default = "", help = "set comment string in process table")
	parser.add_option("-c", "--compare", metavar = "[bytime|bytimeandfreq]", default = "bytimeandfreq", help = "set comparison test")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	# set comparison function
	if options.compare == "bytime":
		options.comparefunc = SnglBurstUtils.CompareSimBurstAndSnglBurstByTime
	elif options.compare == "bytimeandfreq":
		options.comparefunc = SnglBurstUtils.CompareSimBurstAndSnglBurstByTimeandFreq
	else:
		raise ValueError, "unrecognized compare test \"%s\"" % options.compare

	return options, (filenames or [None])


#
# =============================================================================
#
#                              Document Interface
#
# =============================================================================
#

class DocContents(object):
	"""
	A wrapper interface to the XML document.
	"""
	def __init__(self, xmldoc):
		# locate tables
		self.snglbursttable = llwapp.get_table(xmldoc, lsctables.SnglBurstTable.tableName)
		self.simbursttable = llwapp.get_table(xmldoc, lsctables.SimBurstTable.tableName)
		self.tisitable = llwapp.get_table(xmldoc, lsctables.TimeSlideTable.tableName)

		# get coinc_def_id for sim_burst <--> sngl_burst coincs
		self.sb_coinc_def_id = llwapp.get_coinc_def_id(doc, [lsctables.SnglBurstTable.tableName, lsctables.SimBurstTable.tableName])

		# get coinc_def_id's for sngl_burst <--> sngl_burst, and
		# sim_burst <--> coinc coins.
		try:
			self.bb_coinc_def_id = llwapp.get_coinc_def_id(doc, [lsctables.SnglBurstTable.tableName], create_new = False)
			self.sc_coinc_def_id = llwapp.get_coinc_def_id(doc, [lsctables.CoincTable.tableName, lsctables.SimBurstTable.tableName])
		except KeyError:
			self.bb_coinc_def_id = None
			self.sc_coinc_def_id = None

		# get coinc table, create one if needed
		try:
			self.coinctable = llwapp.get_table(xmldoc, lsctables.CoincTable.tableName)
		except ValueError:
			self.coinctable = lsctables.New(lsctables.CoincTable)
			xmldoc.childNodes[0].appendChild(self.coinctable)
		self.coincids = lsctables.NewILWDs(self.coinctable, "coinc_event_id")

		# get coinc_map table, create one if needed
		try:
			self.coincmaptable = llwapp.get_table(xmldoc, lsctables.CoincMapTable.tableName)
		except ValueError:
			self.coincmaptable = lsctables.New(lsctables.CoincMapTable)
			xmldoc.childNodes[0].appendChild(self.coincmaptable)

		# build an index of zero-lag sngl_burst <--> sngl_burst
		# coincs
		self.coinc_event = {}
		for coinc in self.coinctable:
			if (coinc.coinc_def_id != self.bb_coinc_def_id) or not llwapp.time_slide_is_null(self.tisitable, coinc.time_slide_id):
				continue
			self.coinc_event[coinc] = []
			for coincmap in self.coincmaptable:
				if coincmap.coinc_event_id != coinc.coinc_event_id:
					continue
				for burst in self.snglbursttable:
					if burst.event_id == coincmap.event_id:
						self.coinc_event[coinc].append(burst)
						break


		# construct the zero-lag time slide needed to cover the
		# instruments listed in all the triggers, then determine
		# its ID (or create it if needed)
		time_slide = {}
		for instrument in self.snglbursttable.getColumnByName("ifo"):
			time_slide[instrument] = 0.0
		self.tisi_id = llwapp.get_time_slide_id(xmldoc, time_slide)

		# sort triggers by start time
		self.snglbursttable.rows.sort(lambda a, b: cmp(a.get_start(), b.get_start()))
		self.starttimes = self.snglbursttable.getColumnByName("start_time")

	def triggers_near_starttime(self, t, dt = 2.0):
		"""
		Return a list of the triggers with start times within dt of
		t.
		"""
		return self.snglbursttable.rows[bisect.bisect_left(self.starttimes, t - dt):bisect.bisect_right(self.starttimes, t + dt)]

	def sort_triggers_by_id(self):
		"""
		Sort the sngl_burst table's rows by ID (tidy-up document
		for output).
		"""
		self.snglbursttable.rows.sort(lambda a, b: cmp(lsctables.ILWDID(a.event_id), lsctables.ILWDID(b.event_id)))


#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#

def append_process(xmldoc, **kwargs):
	process = llwapp.append_process(xmldoc, program = "ligolw_binjfind", version = __version__, cvs_repository = "lscsoft", cvs_entry_time = __date__, comment = kwargs["comment"])

	params = [("--compare", "lstring", kwargs["compare"])]
	llwapp.append_process_params(xmldoc, process, params)

	return process


#
# =============================================================================
#
#                 Build sim_burst <--> sngl_burst Coincidences
#
# =============================================================================
#

def new_coinc(contents, process, coinc_def_id):
	"""
	Construct a new coinc_event row attached to the given process, and
	belonging to the set of coincidences defined by the given
	coinc_def_id.
	"""
	coinc = lsctables.Coinc()
	coinc.process_id = process.process_id
	coinc.coinc_def_id = coinc_def_id
	coinc.coinc_event_id = contents.coincids.next()
	coinc.time_slide_id = contents.tisi_id
	coinc.nevents = 0
	contents.coinctable.append(coinc)
	return coinc


def find_sngl_burst_matches(contents, sim, comparefunc):
	"""
	Scan the burst table for matching triggers coincident with sim.
	"""
	matches = []
	for row in contents.triggers_near_starttime(sim.geocent_peak_time):
		if comparefunc(sim, row):
			matches.append(row)
	return matches


def add_sim_burst_sngl_burst_coinc(contents, process, sim, bursts):
	"""
	Create a coinc_event in the coinc table, and add arcs in the
	coinc_event_map table linking the sim_burst row and the list of
	sngl_burst rows to the new coinc_event row.
	"""
	coinc = new_coinc(contents, process, contents.sb_coinc_def_id)
	coinc.nevents += len(bursts)

	coincmap = lsctables.CoincMap()
	coincmap.coinc_event_id = coinc.coinc_event_id
	coincmap.event_id = sim.simulation_id
	contents.coincmaptable.append(coincmap)

	for event in bursts:
		coincmap = lsctables.CoincMap()
		coincmap.coinc_event_id = coinc.coinc_event_id
		coincmap.event_id = event.event_id
		contents.coincmaptable.append(coincmap)


#
# =============================================================================
#
#                   Build sim_burst <--> coinc Coincidences
#
# =============================================================================
#

def find_coinc_matches(contents, sim, comparefunc):
	"""
	Scan the coinc_event table for matching burst coincs coincident
	with sim.
	"""
	matches = []
	for coinc_event, bursts in contents.coinc_event.iteritems():
		for burst in bursts:
			if not comparefunc(sim, burst):
				break
		else:
			matches.append(coinc_event)
	return matches


def add_sim_burst_coinc_coinc(contents, process, sim, coincs):
	"""
	Create a coinc_event in the coinc table, and add arcs in the
	coinc_event_map table linking the sim_burst row and the list of
	coinc_event rows to the new coinc_event row.
	"""
	coinc = new_coinc(contents, process, contents.sc_coinc_def_id)
	coinc.nevents += len(coincs)

	coincmap = lsctables.CoincMap()
	coincmap.coinc_event_id = coinc.coinc_event_id
	coincmap.event_id = sim.simulation_id
	contents.coincmaptable.append(coincmap)

	for event in coincs:
		coincmap = lsctables.CoincMap()
		coincmap.coinc_event_id = coinc.coinc_event_id
		coincmap.event_id = event.coinc_event_id
		contents.coincmaptable.append(coincmap)


#
# =============================================================================
#
#                                 Library API
#
# =============================================================================
#

def ligolw_binjfind(xmldoc, **kwargs):
	process = append_process(xmldoc, **kwargs)
	if kwargs["verbose"]:
		print >>sys.stderr, "indexing..."
	contents = DocContents(xmldoc)
	if kwargs["verbose"]:
		print >>sys.stderr, "constructing injection-burst coincidences..."
	for sim in contents.simbursttable.rows:
		matches = find_sngl_burst_matches(contents, sim, kwargs["comparefunc"])
		if matches:
			add_sim_burst_sngl_burst_coinc(contents, process, sim, matches)
	if contents.sc_coinc_def_id:
		if kwargs["verbose"]:
			print >>sys.stderr, "constructing injection-coinc coincidences..."
		for sim in contents.simbursttable.rows:
			matches = find_coinc_matches(contents, sim, kwargs["comparefunc"])
			if matches:
				add_sim_burst_coinc_coinc(contents, process, sim, matches)
	contents.sort_triggers_by_id()
	llwapp.set_process_end_time(process)
	return xmldoc


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

try:
	options, filenames = parse_command_line()
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)

for n, filename in enumerate(filenames):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	doc = llwapp.load_filename(filename, options.verbose)
	if llwapp.doc_includes_process(doc, "liglw_binjfind"):
		if options.verbose:
			print >>sys.stderr, "warning: %s already processed," % (filename or "stdin"),
		if options.force:
			if options.verbose:
				print >>sys.stderr, "continuing"
		else:
			if options.verbose:
				print >>sys.stderr, "skipping"
			continue
	ligolw_binjfind(doc, **options.__dict__)
	llwapp.write_filename(doc, filename, options.verbose)
	doc.unlink()
