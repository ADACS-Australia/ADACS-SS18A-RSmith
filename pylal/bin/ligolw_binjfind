#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

from optparse import OptionParser
import os
import socket
import sys
import time

from glue.ligolw import ligolw
from glue.ligolw import metaio
from glue.ligolw import lsctables
from glue.ligolw import docutils
from pylal import SnglBurstUtils
from pylal.support import XLALUTCToGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                          Trigger Selection Methods
#
# =============================================================================
#

def PickBestPeakTime(sim, burst1, burst2):
	if sim.coordinates == "ZENITH":
		tsim = sim.get_geocent_peak()
	elif burst1.ifo == "H1":
		tsim = sim.get_h_peak()
	elif burst1.ifo == "H2":
		tsim = sim.get_h_peak()
	elif burst1.ifo == "L1":
		tsim = sim.get_l_peak()
	else:
		raise Exception, "unrecognized sngl_burst IFO \"%s\"" % burst1.ifo
	if abs(tsim - burst1.get_peak()) < abs(tsim - burst2.get_peak()):
		return burst1
	return burst2


def PickBestConfidence(sim, burst1, burst2):
	if burst1.confidence < burst2.confidence:
		return burst1
	return burst2


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

parser = OptionParser(version = "%prog CVS $Id$")
parser.add_option("--comment", metavar = "text", default = "", help = "set comment string in process table")
parser.add_option("-c", "--compare", metavar = "[bytime|bytimeandfreq]", default = "bytimeandfreq", help = "set comparison test")
parser.add_option("-i", "--input", metavar = "filename", help = "read from filename (default = stdin)")
parser.add_option("-o", "--output", metavar = "filename", help = "write to filename (default = stdout)")
parser.add_option("-s", "--select", metavar = "[bestpeaktime|bestconfidence]", default = "bestconfidence", help = "set selection method when more than one trigger matches")
parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
options, args = parser.parse_args()
del parser, args

# set comparison function
if options.compare == "bytime":
	comparefunc = SnglBurstUtils.CompareSimBurstAndSnglBurstByTime
elif options.compare == "bytimeandfreq":
	comparefunc = SnglBurstUtils.CompareSimBurstAndSnglBurstByTimeandFreq
else:
	print >>sys.stderr, "error: unrecognized compare test \"%s\"" % options.compare
	sys.exit(1)

# set selection method
if options.select == "bestpeaktime":
	selectfunc = PickBestPeakTime
elif options.select == "bestconfidence":
	selectfunc = PickBestConfidence
else:
	print >>sys.stderr, "error: unrecognized selection method \"%s\"" % options.select
	sys.exit(1)


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

doc = ligolw.Document()
if options.input:
	ligolw.make_parser(lsctables.LIGOLWContentHandler(doc)).parse(file(options.input))
else:
	ligolw.make_parser(lsctables.LIGOLWContentHandler(doc)).parse(sys.stdin)


#
# =============================================================================
#
#                                 Preparation
#
# =============================================================================
#

proctable = metaio.getTablesByName(doc, lsctables.ProcessTable.tableName)
if len(proctable) != 1:
	print >>sys.stderr, "error: input must contain exactly 1 process table"
	sys.exit(1)
proctable = proctable[0]

procparamtable = metaio.getTablesByName(doc, lsctables.ProcessParamsTable.tableName)
if len(procparamtable) != 1:
	print >>sys.stderr, "error: input must contain exactly 1 process params table"
	sys.exit(1)
procparamtable = procparamtable[0]

snglbursttables = metaio.getTablesByName(doc, lsctables.SnglBurstTable.tableName)
simbursttables = metaio.getTablesByName(doc, lsctables.SimBurstTable.tableName)

tisitable = metaio.getTablesByName(doc, lsctables.TimeSlideTable.tableName)
if len(tisitable) != 1:
	print >>sys.stderr, "error: input must contain exactly 1 time slide table"
	sys.exit(1)
tisitable = tisitable[0]

try:
	coinctable = metaio.getTablesByName(doc, lsctables.CoincTable.tableName)[0]
except IndexError:
	coinctable = lsctables.New(lsctables.CoincTable)
	doc.childNodes[0].appendChild(coinctable)
coincids = docutils.NewILWDs(coinctable, "coinc_event_id")

try:
	coincmaptable = metaio.getTablesByName(doc, lsctables.CoincMapTable.tableName)[0]
except IndexError:
	coincmaptable = lsctables.New(lsctables.CoincMapTable, columns = ["coinc_event_id", "event_id"])
	doc.childNodes[0].appendChild(coincmaptable)


#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#

process = lsctables.Process()
process.program = "ligolw_binjfind"
process.version = __version__
process.cvs_repository = "lscsoft"
process.cvs_entry_time = XLALUTCToGPS(time.strptime(__date__, "%Y/%m/%d %H:%M:%S"))
process.comment = options.comment
process.is_online = 0
process.node = socket.gethostbyaddr(socket.gethostname())[0]
process.username = os.environ["LOGNAME"]
process.unix_procid = os.getpid()
process.start_time = XLALUTCToGPS(time.gmtime())
process.end_time = 0
process.jobid = 0
process.domain = ""
process.ifos = ""
process.process_id = docutils.NewILWDs(proctable, "process_id").next()

proctable.append(process)

def add_param(name, type, value):
	param = lsctables.ProcessParams()
	param.program = process.program
	param.process_id = process.process_id
	param.param = str(name)
	param.type = str(type)
	param.value = str(value)
	procparamtable.append(param)

add_param("--compare", "lstring", options.compare)
if options.input != None:
	add_param("--input", "lstring", options.input)
if options.output != None:
	add_param("--output", "lstring", options.output)
add_param("--select", "lstring", options.select)


#
# =============================================================================
#
#                         Find The Zero-Lag Time Slide
#
# =============================================================================
#

def find_zero_lag_tisi(table):
	for id, tisi in table.dict.iteritems():
		for row in tisi:
			if row.offset != 0.0:
				break
		else:
			return id, [row.instrument for row in tisi]

try:
	tisi_id, tisi_instruments = find_zero_lag_tisi(tisitable)
except Exception, e:
	print >>sys.stderr, "error:  input does not contain a zero-lag time slide %s" % str(e)
	sys.exit(1)

#
# =============================================================================
#
#                  Build Injection <--> Trigger Coincidences
#
# =============================================================================
#

def add_found_injection(sim, burst):
	if burst.ifo not in tisi_instruments:
		print >>sys.stderr, "error: zero-lag time slide does not list instrument %s" % burst.ifo
		sys.exit(1)

	coinc = lsctables.Coinc()
	coinc.process_id = process.process_id
	coinc.coinc_event_id = coincids.next()
	coinc.time_slide_id = tisi_id
	coinctable.append(coinc)

	coincmap = lsctables.CoincMap()
	coincmap.coinc_event_id = coinc.coinc_event_id
	coincmap.event_id = sim.simulation_id
	coincmaptable.append(coincmap)

	coincmap = lsctables.CoincMap()
	coincmap.coinc_event_id = coinc.coinc_event_id
	coincmap.event_id = burst.event_id
	coincmaptable.append(coincmap)


def find_best_match(sim, snglbursttables):
	bestmatch = None
	for bursttable in snglbursttables:
		for burst in bursttable.rows:
			if comparefunc(sim, burst):
				if not bestmatch:
					bestmatch = burst
				else:
					bestmatch = selectfunc(sim, bestmatch, burst)
	return bestmatch


for simtable in simbursttables:
	for sim in simtable.rows:
		bestmatch = find_best_match(sim, snglbursttables)
		if bestmatch:
			add_found_injection(sim, bestmatch)


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

process.end_time = XLALUTCToGPS(time.gmtime())

if options.output:
	doc.write(file(options.output, "w"))
else:
	doc.write(sys.stdout)
