#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import bisect
from optparse import OptionParser
import sys

from glue.ligolw import lsctables
from pylal import llwapp
from pylal import SnglBurstUtils

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version = "%prog CVS $Id$")
	parser.add_option("-f", "--force", action = "store_true", help = "process even if file has already been processed")
	parser.add_option("--comment", metavar = "text", default = "", help = "set comment string in process table")
	parser.add_option("-c", "--compare", metavar = "[bytime|bytimeandfreq]", default = "bytimeandfreq", help = "set comparison test")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	# set comparison function
	if options.compare == "bytime":
		options.comparefunc = SnglBurstUtils.CompareSimBurstAndSnglBurstByTime
	elif options.compare == "bytimeandfreq":
		options.comparefunc = SnglBurstUtils.CompareSimBurstAndSnglBurstByTimeandFreq
	else:
		raise ValueError, "unrecognized compare test \"%s\"" % options.compare

	return options, (filenames or [None])


#
# =============================================================================
#
#                         Find The Zero-Lag Time Slide
#
# =============================================================================
#

def find_zero_lag_tisi(table):
	for id, tisi in table.dict.iteritems():
		for row in tisi:
			if row.offset != 0.0:
				break
		else:
			return id, [row.instrument for row in tisi]
	raise ValueError, "%s does not contain a zero-lag time slide" % table.tableName


#
# =============================================================================
#
#                              Document Interface
#
# =============================================================================
#

class DocContents(object):
	"""
	A wrapper interface to the XML document.
	"""
	def __init__(self, xmldoc):
		#
		# Locate tables
		#

		self.snglbursttable = llwapp.get_table(xmldoc, lsctables.SnglBurstTable.tableName)
		self.simbursttable = llwapp.get_table(xmldoc, lsctables.SimBurstTable.tableName)
		self.tisitable = llwapp.get_table(xmldoc, lsctables.TimeSlideTable.tableName)

		try:
			self.coinctable = llwapp.get_table(xmldoc, lsctables.CoincTable.tableName)
		except ValueError:
			# FIXME: add support for coinc_definer
			self.coinctable = lsctables.New(lsctables.CoincTable, columns = ["process_id", "coinc_event_id", "time_slide_id", "nevents"])
			xmldoc.childNodes[0].appendChild(self.coinctable)
		self.coincids = lsctables.NewILWDs(self.coinctable, "coinc_event_id")

		try:
			self.coincmaptable = llwapp.get_table(xmldoc, lsctables.CoincMapTable.tableName)
		except ValueError:
			self.coincmaptable = lsctables.New(lsctables.CoincMapTable, columns = ["coinc_event_id", "event_id"])
			xmldoc.childNodes[0].appendChild(self.coincmaptable)

		#
		# Identify the zero-lag time slide
		#

		self.tisi_id, self.tisi_instruments = find_zero_lag_tisi(self.tisitable)

		#
		# Sort triggers by start time
		#

		self.snglbursttable.rows.sort(lambda a, b: cmp(a.get_start(), b.get_start()))
		self.starttimes = self.snglbursttable.getColumnByName("start_time")

	def triggers_near_starttime(self, t, dt = 2.0):
		"""
		Return a list of the triggers with start times withing dt
		of t.
		"""
		return self.snglbursttable.rows[bisect.bisect_left(self.starttimes, t - dt):bisect.bisect_right(self.starttimes, t + dt)]

	def sort_triggers_by_id(self):
		"""
		Sort the sngl_burst table's rows by ID (tidy-up document for
		output).
		"""
		self.snglbursttable.rows.sort(lambda a, b: cmp(lsctables.ILWDID(a.event_id), lsctables.ILWDID(b.event_id)))


#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#

def append_process(xmldoc, **kwargs):
	process = llwapp.append_process(xmldoc, program = "ligolw_binjfind", version = __version__, cvs_repository = "lscsoft", cvs_entry_time = __date__, comment = kwargs["comment"])

	params = [("--compare", "lstring", kwargs["compare"])]
	llwapp.append_process_params(xmldoc, process, params)

	return process


#
# =============================================================================
#
#                  Build Injection <--> Trigger Coincidences
#
# =============================================================================
#

def new_coinc(contents, process):
	"""
	Construct a new coinc_event row attached to the given process.
	"""
	coinc = lsctables.Coinc()
	coinc.process_id = process.process_id
	coinc.coinc_event_id = contents.coincids.next()
	coinc.time_slide_id = contents.tisi_id
	coinc.nevents = 0
	contents.coinctable.append(coinc)
	return coinc


def add_found_injection(contents, coinc, sim, bursts):
	"""
	Add arcs in the coinc_event_map linking the sim_burst row and the list
	of sngl_burst rows to the given coinc_event row.
	"""
	coincmap = lsctables.CoincMap()
	coincmap.coinc_event_id = coinc.coinc_event_id
	coincmap.event_id = sim.simulation_id
	contents.coincmaptable.append(coincmap)

	coinc.nevents += len(bursts)

	for burst in bursts:
		if burst.ifo not in contents.tisi_instruments:
			print >>sys.stderr, "error: zero-lag time slide does not list instrument %s needed by event %s" % (burst.ifo, burst.event_id)
			sys.exit(1)
		coincmap = lsctables.CoincMap()
		coincmap.coinc_event_id = coinc.coinc_event_id
		coincmap.event_id = burst.event_id
		contents.coincmaptable.append(coincmap)


def find_matches(contents, sim, comparefunc):
	"""
	Scan the burst table for matching triggers coincident with sim.
	"""
	matches = []
	for row in contents.triggers_near_starttime(sim.geocent_peak_time):
		if comparefunc(sim, row):
			matches.append(row)
	return matches


#
# =============================================================================
#
#                                 Library API
#
# =============================================================================
#

def ligolw_binjfind(xmldoc, **kwargs):
	process = append_process(xmldoc, **kwargs)
	if kwargs["verbose"]:
		print >>sys.stderr, "indexing..."
	contents = DocContents(xmldoc)
	if kwargs["verbose"]:
		print >>sys.stderr, "constructing injection-burst coincidences..."
	for sim in contents.simbursttable.rows:
		matches = find_matches(contents, sim, kwargs["comparefunc"])
		if matches:
			add_found_injection(contents, new_coinc(contents, process), sim, matches)
	contents.sort_triggers_by_id()
	llwapp.set_process_end_time(process)
	return xmldoc


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

try:
	options, filenames = parse_command_line()
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)

try:
	for n, filename in enumerate(filenames):
		if options.verbose:
			print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
		doc = llwapp.load_filename(filename, options.verbose)
		if llwapp.doc_includes_process(doc, "liglw_binjfind"):
			if options.verbose:
				print >>sys.stderr, "warning: %s already processed," % (filename or "stdin"),
			if options.force:
				if options.verbose:
					print >>sys.stderr, "continuing"
			else:
				if options.verbose:
					print >>sys.stderr, "skipping"
				continue
		ligolw_binjfind(doc, **options.__dict__)
		llwapp.write_filename(doc, filename, options.verbose)
		doc.unlink()
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)
