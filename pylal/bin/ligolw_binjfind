#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import bisect
from optparse import OptionParser
import sys

from glue.ligolw import lsctables
from glue.ligolw import docutils
from pylal import llwapp
from pylal import SnglBurstUtils

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

parser = OptionParser(version = "%prog CVS $Id$")
parser.add_option("--comment", metavar = "text", default = "", help = "set comment string in process table")
parser.add_option("-c", "--compare", metavar = "[bytime|bytimeandfreq]", default = "bytimeandfreq", help = "set comparison test")
parser.add_option("-i", "--input", metavar = "filename", help = "read from filename (default = stdin)")
parser.add_option("-o", "--output", metavar = "filename", help = "write to filename (default = stdout)")
parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
options, args = parser.parse_args()
del parser, args

# set comparison function
if options.compare == "bytime":
	comparefunc = SnglBurstUtils.CompareSimBurstAndSnglBurstByTime
elif options.compare == "bytimeandfreq":
	comparefunc = SnglBurstUtils.CompareSimBurstAndSnglBurstByTimeandFreq
else:
	print >>sys.stderr, "error: unrecognized compare test \"%s\"" % options.compare
	sys.exit(1)


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

doc = llwapp.load_filename(options.input, options.verbose)


#
# =============================================================================
#
#                                 Preparation
#
# =============================================================================
#

try:
	snglbursttable = llwapp.get_table(doc, lsctables.SnglBurstTable.tableName)
	simbursttable = llwapp.get_table(doc, lsctables.SimBurstTable.tableName)
	tisitable = llwapp.get_table(doc, lsctables.TimeSlideTable.tableName)
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)

try:
	coinctable = llwapp.get_table(doc, lsctables.CoincTable.tableName)
except ValueError:
	coinctable = lsctables.New(lsctables.CoincTable)
	doc.childNodes[0].appendChild(coinctable)
coincids = docutils.NewILWDs(coinctable, "coinc_event_id")

try:
	coincmaptable = llwapp.get_table(doc, lsctables.CoincMapTable.tableName)
except ValueError:
	coincmaptable = lsctables.New(lsctables.CoincMapTable, columns = ["coinc_event_id", "event_id"])
	doc.childNodes[0].appendChild(coincmaptable)


#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#

process = llwapp.append_process(doc, program = "ligolw_binjfind", version = __version__, cvs_repository = "lscsoft", cvs_entry_time = __date__, comment = options.comment)

params = [("--compare", "lstring", options.compare)]
if options.input != None:
	params += [("--input", "lstring", options.input)]
if options.output != None:
	params += [("--output", "lstring", options.output)]
llwapp.append_process_params(doc, process, params)


#
# =============================================================================
#
#                         Find The Zero-Lag Time Slide
#
# =============================================================================
#

def find_zero_lag_tisi(table):
	for id, tisi in table.dict.iteritems():
		for row in tisi:
			if row.offset != 0.0:
				break
		else:
			return id, [row.instrument for row in tisi]

try:
	tisi_id, tisi_instruments = find_zero_lag_tisi(tisitable)
except Exception, e:
	print >>sys.stderr, "error:  input does not contain a zero-lag time slide %s" % str(e)
	sys.exit(1)


#
# =============================================================================
#
#                         Sort Triggers By Start Time
#
# =============================================================================
#

snglbursttable.rows.sort(lambda a, b: cmp(a.get_start(), b.get_start()))

starttimes = snglbursttable.getColumnByName("start_time")


#
# =============================================================================
#
#                  Build Injection <--> Trigger Coincidences
#
# =============================================================================
#

def new_coinc():
	coinc = lsctables.Coinc()
	coinc.process_id = process.process_id
	coinc.coinc_event_id = coincids.next()
	coinc.time_slide_id = tisi_id
	coinc.nevents = 0
	coinctable.append(coinc)
	return coinc


def add_found_injection(coinc, sim, burst):
	if burst.ifo not in tisi_instruments:
		print >>sys.stderr, "error: zero-lag time slide does not list instrument %s needed by event %s" % (burst.ifo, burst.event_id)
		sys.exit(1)

	coinc.nevents += 1

	coincmap = lsctables.CoincMap()
	coincmap.coinc_event_id = coinc.coinc_event_id
	coincmap.event_id = sim.simulation_id
	coincmaptable.append(coincmap)

	coincmap = lsctables.CoincMap()
	coincmap.coinc_event_id = coinc.coinc_event_id
	coincmap.event_id = burst.event_id
	coincmaptable.append(coincmap)


def find_matches(sim, bursttable):
	"""
	Scan the burst table for matching triggers within +/- 2 seconds of
	the injection's geocentric peak time.
	"""
	matches = []
	for row in bursttable.rows[bisect.bisect_left(starttimes, sim.geocent_peak_time - 2):bisect.bisect_right(starttimes, sim.geocent_peak_time + 2)]:
		if comparefunc(sim, row):
			matches.append(row)
	return matches


for sim in simbursttable.rows:
	matches = find_matches(sim, snglbursttable)
	if matches:
		coinc = new_coinc()
		for match in matches:
			add_found_injection(coinc, sim, match)


#
# =============================================================================
#
#                             Sort Triggers By ID
#
# =============================================================================
#

snglbursttable.rows.sort(lambda a, b: cmp(lsctables.ILWDID(a.event_id), lsctables.ILWDID(b.event_id)))


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

llwapp.set_process_end_time(process)

llwapp.write_filename(doc, options.output, options.verbose)
