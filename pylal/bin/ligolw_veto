#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2007  Kipp Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


from optparse import OptionParser
from pysqlite2 import dbapi2 as sqlite3
import sys


from glue import segments
from glue.ligolw import dbtables
from glue.ligolw import utils
from pylal import SnglBurstUtils
from pylal import llwapp
from pylal.date import LIGOTimeGPS


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog [options] --veto-segments-db=filename files ...",
		description = "%prog probably does something..."
	)
	parser.add_option("--veto-segments-db", metavar = "filename", help = "Load veto segments from this SQLite DB file (required).")
	parser.add_option("--veto-segments-name", metavar = "name", default = "sngl_burst_veto", help = "Use the segment lists named this to define the veto times (default = \"sngl_burst_veto\").")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	if options.veto_segments_db is None:
		raise ValueError, "missing required --veto-segments-db option"

	return options, (filenames or [None])


#
# =============================================================================
#
#                                Load Segments
#
# =============================================================================
#


def load_segments(filename, name, verbose = False):
	if verbose:
		print >>sys.stderr, "loading \"%s\" segments ... " % name,
	connection = sqlite3.connect(filename)
	dbtables.DBTable_set_connection(connection)
	segs = llwapp.segmenttable_get_by_name(dbtables.DBTable_get_xml(), name)
	connection.close()
	if verbose:
		print >>sys.stderr, "done."
		for ifo in segs:
			print >>sys.stderr, "loaded %d veto segment(s) for %s totalling %g s" % (len(segs[ifo]), ifo, float(abs(segs[ifo])))
	return segs


#
# =============================================================================
#
#                              Excess Power Veto
#
# =============================================================================
#


def apply_excess_power_veto(contents, veto_segs, verbose = False):
	def sngl_burst_is_vetoed(ifo, start, start_ns, duration, veto_segs = veto_segs):
		start = LIGOTimeGPS(start, start_ns)
		return ifo in veto_segs and veto_segs[ifo].intersects_segment(segments.segment(start, start + duration))
	contents.connection.create_function("sngl_burst_is_vetoed", 4, sngl_burst_is_vetoed)
	cursor = contents.connection.cursor()

	#
	# Delete burst <--> burst coincs containing vetoed bursts
	#

	if verbose:
		print >>sys.stderr, "removing vetoed burst <--> burst coincs ..."
	cursor.execute("""
DELETE FROM
	coinc_event
WHERE
	coinc_def_id == ?
	AND coinc_event_id IN (
		SELECT
			coinc_event_id
		FROM
			coinc_event_map
			JOIN sngl_burst ON (
				coinc_event_map.table_name == 'sngl_burst'
				AND coinc_event_map.event_id == sngl_burst.event_id
			)
		WHERE
			sngl_burst_is_vetoed(sngl_burst.ifo, sngl_burst.start_time, sngl_burst.start_time_ns, sngl_burst.duration)
	)
	""", (contents.bb_definer_id,))

	#
	# Delete sim <--> coinc coincs pointing to deleted coincs
	#

	if contents.sc_definer_id is not None:
		if verbose:
			print >>sys.stderr, "removing vetoed sim <--> coinc coincs ..."
		cursor.execute("""
DELETE FROM
	coinc_event
WHERE
	coinc_def_id == ?
	AND coinc_event_id IN (
		SELECT
			coinc_event_id
		FROM
			coinc_event_map
		WHERE
			table_name == 'coinc_event'
			AND event_id NOT IN (
				SELECT
					coinc_event_id
				FROM 
					coinc_event
			)
	)
		""", (contents.sc_definer_id,))

	#
	# Now that we no longer need to form links through the
	# coinc_def_map table, delete vetoed burst rows from it
	#

	if verbose:
		print >>sys.stderr, "removing vetoed bursts from coinc_def_map table ..."
	cursor.execute("""
DELETE FROM
	coinc_event_map
WHERE
	coinc_event_map.table_name == 'sngl_burst'
	AND coinc_event_map.event_id IN (
		SELECT
			event_id
		FROM
			sngl_burst
		WHERE
			sngl_burst_is_vetoed(ifo, start_time, start_time_ns, duration)
	)
	""")

	#
	# The coinc_def_map table no longer contains any rows pointing to
	# vetoed bursts, update the event counts in sim <--> burst coincs
	# and delete any for which this is now 0
	#

	if contents.sb_definer_id is not None:
		if verbose:
			print >>sys.stderr, "updating sim <--> burst event counts ..."
		cursor.execute("""
UPDATE
	coinc_event
SET
	nevents = (SELECT COUNT(*) FROM coinc_event_map WHERE coinc_event_map.coinc_event_id == coinc_event.coinc_event_id AND coinc_event_map.table_name == 'sngl_burst')
WHERE
	coinc_event.coinc_def_id == ?
		""", (contents.sb_definer_id,))
		if verbose:
			print >>sys.stderr, "removing empty sim <--> burst coincs ..."
		cursor.execute("""
DELETE FROM
	coinc_event
WHERE
	coinc_def_id == ?
	AND nevents == 0
		""", (contents.sb_definer_id,))

	#
	# We have removed all the rows from the coinc_event table that will
	# be removed, so now remove multi_burst and coinc_event_map rows
	# that point to non-existent coinc_events
	#

	if verbose:
		print >>sys.stderr, "trimming coinc_event_map table ..."
	cursor.execute("""
DELETE FROM
	coinc_event_map
WHERE
	coinc_event_map.coinc_event_id NOT IN (
		SELECT
			coinc_event_id
		FROM 
			coinc_event
	)
	""")

	if verbose:
		print >>sys.stderr, "trimming multi_burst table ..."
	cursor.execute("""
DELETE FROM
	multi_burst
WHERE
	multi_burst.coinc_event_id NOT IN (
		SELECT
			coinc_event_id
		FROM 
			coinc_event
	)
	""")

	#
	# Tables are now consistent, and contain no coincs involving a
	# vetoed burst
	#

	if verbose:
		print >>sys.stderr, "done."
	contents.connection.commit()


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# Command line.
#


options, filenames = parse_command_line()


#
# Load veto segments.
#


veto_segs = load_segments(options.veto_segments_db, options.veto_segments_name, verbose = options.verbose)


#
# Iterate over files
#


for n, filename in enumerate(filenames):
	#
	# Open the database file.
	#

	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename),

	connection = sqlite3.connect(filename)
	dbtables.DBTable_set_connection(connection)

	#
	# Summarize the database.
	#

	database = SnglBurstUtils.CoincDatabase().summarize(dbtables.DBTable_get_xml(), "lalapps_power", options.verbose)

	#
	# Apply vetoes
	#

	apply_excess_power_veto(database, veto_segs, verbose = options.verbose)

	#
	# Clean up
	#

	connection.commit()
	connection.close()
	del database, connection


#
# Done
#


if options.verbose:
	print >>sys.stderr, "done."
