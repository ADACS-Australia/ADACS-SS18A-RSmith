#!/usr/bin/env python
"""
Tomoki Isogai (isogait@carleton.edu)

This program makes an (inner) dag file for qscans.
Also, if --qscan_config is specified as 'selected', it creates config files that 
include only DARM_ERR and the channel of interest.
Post script can be appended for each qscan - default script is to erase some 
plots to save some space (leaves only thumbnails of whitened spectrogram 
(default display), autoscaled eventogram (contains info from all Q planes), and 
raw time series (useful to see things like saturations, data corruption, etc)) 
you can provide your own post script as necessary

$Id$
"""
import optparse
import sys, os, glob
from glue import pipeline

__author__ = "Tomoki Isogai <isogait@carleton.edu>"
__date__ = "$Date$"[7:-2]
__version__ = "$Revision$"[11:-2]

def parse_commandline():
    """
    Parse the options given on the command-line.
    """
    parser = optparse.OptionParser(usage=__doc__,\
                               version="$Id: qscanSetup,v 1.00 2008/7/12")
    parser.add_option("-n","--name_tag", help="name tag used")
    parser.add_option("-d","--dagdir", default="dags",\
                      help="directory for dag/submission file")
    parser.add_option("-o", "--outdir", default="",\
                      help="output directory for qscan")
    parser.add_option("-t", "--time_glob",\
                                   help="glob for files of times to be qscaned")
    parser.add_option("-q", "--qscan_executable",\
                      default='/archive/home/qonline/q/bin/qscan.sh',\
                      help="qscan executable, either qscan.sh ro qscanlite.sh")
    parser.add_option("-c", "--qscan_config", default='selected',\
                      help="config for qscan. see above for detail")
    parser.add_option("-f", "--qscan_framecache", help="framecache for qscan")
    parser.add_option("-p", "--post_qscan", help='post qscan script')
    parser.add_option("-l", "--condor_log_dir", help="log directory for condor")
    parser.add_option("-v", "--verbose", action="store_true",\
                      default=False, help="run verbosely")
    
    opts, args = parser.parse_args()
    
    # check if necessary input exists
    for o in ("name_tag","time_glob","qscan_executable","qscan_framecache",\
                                                              "condor_log_dir"):
        if getattr(opts,o) is None:
            print >>sys.stderr, "Error: --%s is a required parameter"%o
            sys.exit(1)
            
            
    # create necessary directories if not exist yet
    if not os.path.exists(opts.dagdir):
        os.makedirs(opts.dagdir)
    if not os.path.exists(opts.outdir):
        os.makedirs(opts.outdir)
    if not os.path.exists("qscan_configs"): 
        os.mkdir("qscan_configs")
            
    # show parameters
    if opts.verbose:
        print "running qscan_setup..."
        print 
        print "********************  QSCAN PARAMETERS *************************"
        print 'name tag:'; print opts.name_tag;
        print 'dag directory:'; print opts.dagdir;
        print 'output directory:'; print opts.outdir;
        print 'glob for time files:'; print opts.time_glob
        print 'qscan executable:'; print opts.qscan_executable;
        print 'qscan config:'; print opts.qscan_config;
        print 'qscan framecache'; print opts.qscan_framecache
        print 'post qscan script'; print opts.post_qscan
        print 'condor log directory:'; print opts.condor_log_dir
        print
            
    return opts

##############################################################################
# Define Jobs.  A Job corresponds to a program.  Each Job can have multiple 
# Nodes (instances).
##############################################################################

class qscanJob(pipeline.CondorDAGJob):
    """
    This class represents the qscan program.  
    """
    def __init__(self,qscan_executable):
        self.__executable = qscan_executable
        self.__universe = "vanilla"
        pipeline.CondorDAGJob.__init__(self,self.__universe, self.__executable)

        self.set_stdout_file('logs/$(logname)-$(cluster).out')
        self.set_stderr_file('logs/$(logname)-$(cluster).err')
        self.add_condor_cmd('getenv','True')

##############################################################################
# Define Nodes.  A Node corresponds to a single instance of a program to be
# run.  They each attach to a Job, which contains the information common to
# all Nodes of a single type.
##############################################################################

class qscanNode(pipeline.CondorDAGNode):
    def __init__(self, job, name, retry,time, config, framecache,\
                                                           outdir, post_script):
        """
        A qscanNode runs an instance of qscan in a Condor DAG.
        """
        pipeline.CondorDAGNode.__init__(self, job)

        self.set_name(name)
        self.set_retry(retry)
        self.add_var_arg(time)
        self.add_var_arg(config)
        self.add_var_arg(framecache)
        self.add_var_arg(outdir)
        if post_script!="" and post_script!=None:
            self.set_post_script(post_script)
            # $RETURN is a return value from qscanNode
            self.add_post_script_arg("$RETURN "+outdir+"/"+time)
        self.add_macro("logname",name)

################################################################################
# Utility function
################################################################################

def rename(src):
    """
    rename existing directory/files, so that new run won't overwrite
    """
    index = 0; dst = src
    while os.path.exists(dst):
        index += 1
        dst = src+str(index)
    os.renames(src,dst)

################################################################################
# Qscan Config file generation function
################################################################################
    
def selected_config(ifo, chan):
    """
    create config file for abbreviated qscan (qscan of only gravitational wave
    channel and the channel of interest)
    return the file name
    """
    # read in the original config file
    # change this to www later
    default_config = 'inputfiles/qscan_config.txt'
    if not os.path.isfile(default_config):
        print >>sys.stderr, "Error: default config file not found at %s"%default_config
        sys.exit(1)
    lines = open(default_config).readlines()
    # loop over each line and get only the necessary lines
    content=[]; lineInd=0
    for line in lines:
        # include all the section header, which starts with [
        if line[0]=='[':
            content.append(line); content.append("\n")
        # get gravitational wave channel
        # 17 lines around channel name is the necessary part
        if line[32:34] == ifo and\
                      (line[35:-3]=="LSC-DARM_ERR" or line[35:-3]=="Pr_B1_ACp"):
            content+=lines[lineInd-1:lineInd+15]
        # get the channel of the interest
        # var chan is not a formal channel name 
        # (ex. h1_darmerr for H1:LSC-DARM_ERR)
        # some of them are not even channel names (like h1_michctrlhifreq)
        # these informal names can cause trouble (for example, there are two bsy
        # etc.)
        # include all possibilities - extra channel is better than none
        # deal with those name difference with find and replace
        if line[32:34]==chan[:2].upper() and\
        chan[3:].upper().replace("_","").find(line[39:-3].replace("_",""))!=-1:
            content+=lines[lineInd-1:lineInd+15]
        lineInd += 1
    # save in a file
    fileName=os.path.join('qscan_configs','selected_'+ifo+"_"+chan+'_config.txt')
    open(fileName,'w').write(''.join(content))
    return fileName

def main(opts):
    """
    create a dag file
    """
    tag = opts.name_tag 
    
    # make a list of time files for qscan
    # "if" part is to check if the glob is really qscan time files meant for 
    file_list = [f for f in glob.glob(opts.time_glob)\
                                if f.find(tag)!=-1 and f.find('qscanTimes')!=-1]
    
    # qscan time files are only created for veto candidate channels
    # if no file is found, issue a warning message, but exit successfully
    if file_list==[]:
        print>>sys.stderr, """
        Warning: no time file found, %s"""%opts.time_glob
        sys.exit(0)
        
    # set up dag
    dag=pipeline.CondorDAG(os.path.join(opts.condor_log_dir,"%s_qscan.log"%tag))
    dag.set_dag_file(os.path.join(opts.dagdir,"%s_qscan"%tag))
    qscan_job = qscanJob(opts.qscan_executable)
    qscan_job.set_sub_file(os.path.join(opts.dagdir,"%s_qscan.sub"%tag))
    
        
    # loop over each file and get times
    for c in file_list:
        # find out channel name from file name
        name_parts = os.path.splitext(c)[0].split("-")
        channel = name_parts[-3]
        ifo = name_parts[-4].upper()
        if opts.verbose: print "processing %s..."%channel
        
        # make config file for abbreviated qscan if specified as 'selected'
        if opts.qscan_config.lower()=="selected":
            config=selected_config(ifo,channel)
        else: # otherwise just pass on as specified
            config=opts.qscan_config
            
        # set output directory for qscan
        outdir=os.path.join(opts.outdir,"%s-%s-%s"%(opts.name_tag,ifo,channel))
        if os.path.exists(outdir): rename(outdir)
        
        if opts.verbose: 
            print "qscan options: config: %s framecache: %s outdir: %s"\
                                          %(config,opts.qscan_framecache,outdir) 
        # read in GPS times for qscan from file
        time_file=open(c)
        for line in time_file:
            info=line.strip().split() # info[0]: GPS time, info[1]: snr 
            if info[0][0]!="#" and info[0][0]!="%": # skip comment lines
                time=info[0]
                # quick check if the code really grabed the time
                if float(time)<800000000: 
                    print >> sys.stderr, """
                Error: time is possibly wrong.
                       file: %s
                       time: %f
                    """%(c,float(time))
                    sys.exit(1)
                dagNodeName = "qscan-"+ifo+"-"+channel+"-"+time
                retry = 3
                qs = qscanNode(qscan_job,dagNodeName,retry,time,config,\
                                   opts.qscan_framecache,outdir,opts.post_qscan)
                dag.add_node(qs)
        # there must be at least one time
        if dag.get_nodes==[]:
            print >> sys.stderr, "Error: no time found"
    # write dag file and submission file 
    dag.write_sub_files()
    dag.write_dag()
    
    ## doesn't work anymore with the newer version of DAGMan
    ## need to be fixed
    ## make condor submission file with appropriate maxjobs
    #if ifo == "V1": maxjobs=5 # only available at European clusters
    #elif opts.qscan_config.lower()=='selected': maxjobs=50 
    #elif opts.qscan_config=='@full': maxjobs=3 # R frame, taped
    #else: maxjobs=30
    #if opts.verbose: 
    #    print "submitting %s_%s_qscan.dag to condor with maxjobs %d"\
    #                                                      %(tag,channel,maxjobs)
    #log=os.path.join(opts.condor_log_dir,"%s.log"%tag)
    ## make a submission file for the dag
    ## append appropriate log file so that outer dag can recognize
    #dag_loc = os.path.join(opts.dagdir,"%s_qscan.dag"%tag)
    #exitNum=os.system('condor_submit_dag -f -append "log = %s" -maxjobs %d -no_submit %s'\
    #                                                     %(log,maxjobs,dag_loc))
    #if exitNum != 0:
    #    print >> sys.stderr,\
    #                     "Error: failed to write a qscan condor submission file"
    #    sys.exit(1)
                
if __name__=="__main__":
    # parse commandline
    opts = parse_commandline()
    # do the work                               
    main(opts)
