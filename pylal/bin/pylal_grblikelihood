#!/usr/bin/env python
#
# Copyright (C) 2007  Patrick Brady, Nickolas Fotopoulos
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
"""
This code computes the probabilities that go into the distance upper limits
for the CBC external trigger search.

There is a lot of advanced indexing technique here.  Reference:
http://scipy.org/Cookbook/Indexing
"""

from __future__ import division

__author__ = "Nickolas Fotopoulos <nvf@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"
__Id__ = "$Id$"
__prog__ = "pylal_grblikelihood"
__title__ = "GRB interpretation"

import optparse
import cPickle as pickle
import sys

import numpy
numpy.seterr(all="raise")  # throw an exception on any funny business

import matplotlib
matplotlib.use("Agg")
import pylab
pylab.rc("text", usetex=True)

from pylal import InspiralUtils
from pylal import plotutils
from pylal import viz

################################################################################
# utility functions

def compute_pc0_by_mc(offsource_loudest_by_trial_mc, onsource_loudest_by_mc):
    """
    Compute p(c \in neighborhood(c_0) | 0) for each possible on-source
    loudest event, c_0.  What m_2 this corresponds to will be chosen later.
    """
    num_trials = offsource_loudest_by_trial_mc.shape[0]

    # minimum resolvable pc0 is approximately this
    pc0_eps = 0.5 / num_trials

    # for each mc, count how many trials have c \in neighborhood(c_0)
    num_louder_by_mc = \
        (offsource_loudest_by_trial_mc > onsource_loudest_by_mc[None, :])\
        .sum(axis=0, dtype=float)

    # for each mchirp bin, determine p(c|0) by summing across trials
    pc0_by_mc = num_louder_by_mc / num_trials

    # if 0, then set to minimum resolvable
    pc0_by_mc[pc0_by_mc < pc0_eps] = pc0_eps
    return pc0_by_mc

def compute_pch_by_mc_m2(inj_loudest_by_inj_mc_m2, num_sims_by_m2,
    onsource_loudest_by_mc):
    """
    Compute p(c \in neighborhood(c_0) | h(m2, D)) for each possible on-source
    loudest event, c_0.  What m_2 this corresponds to will be chosen later.
    """
    # for each mc, m2, count how many trials have c \in neighborhood(c_0)
    num_louder_by_mc_m2 = \
        (inj_loudest_by_inj_mc_m2 > onsource_loudest_by_mc[None, :, None])\
        .sum(axis=0)

    # minimum resolvable is ~0.5 / num_sims; pathological if num_sims == 0, but
    # we will be careful to apply it only if num_sims != 0.
    pch_eps_by_mc_m2 = 0.5 / \
        (num_sims_by_m2[None, :].repeat(len(mc_bins), axis=0) + 1e-10)

    # compute p(c|h) vs (mc, m2) for finding the loudest event in each m2 bin
    pch_by_mc_m2 = num_louder_by_mc_m2 / (num_sims_by_m2[None, :] + 1e-10)
    zero_ind = (num_louder_by_mc_m2 == 0) & (num_sims_by_m2[None, :] != 0)
    pch_by_mc_m2[zero_ind] = pch_eps_by_mc_m2[zero_ind]

    return pch_by_mc_m2

def get_level_crossings(xy_array, level, y_bins):
    """
    Return the linearly interpolated y values where the xy_array dips first
    dips below level, iterating upwards.
    """
    # sanity checks
    if xy_array.ndim != 2:
        raise ValueError, "require a two-dimensional xy_array"
    if xy_array.shape[1] != len(y_bins):
        raise ValueError, "xy_array y-dimension does not match y_bin length"

    def _first_below_val(column, target):
        """
        Return the index of the first entry that is less than target.
        If no entry is less than the target, return the length of the column.
        """
        for i, val in enumerate(column):
            if val < target:
                return i
        return len(column)

    def _interp_column(column, level, y_vals, min_y=0, max_y=None):
        """
        Return the linearly interpolated value of y where the column first
        dips below level.
        """
        if max_y is None:
            max_y = y_vals[-1]
        ind = _first_below_val(column, level)
        if ind == 0:
            return min_y
        elif ind == len(column):
            return max_y
        else:
            # interpolate between ind-1 and ind
            slope = (y_vals[ind] - y_vals[ind-1]) / \
                    (column[ind] - column[ind-1])
            return y_vals[ind-1] + (level - column[ind-1]) * slope

    y_vals = y_bins.centres()
    return numpy.array([_interp_column(col, level, y_vals, min_y=0,
                                       max_y=y_bins.max) \
                        for col in xy_array])

def parse_args():
    parser = optparse.OptionParser(version="%prog CVS $Id$ ")

    # cache input
    parser.add_option("--relic-onsource", help="output of pylal_relic "\
        "containing the onsource loudest coincs.")
    parser.add_option("--relic-offsource", help="output of pylal_relic "\
        "containing the offsource loudest coincs.")
    parser.add_option("--relic-injections", help="output of pylal_relic "\
        "containing the loudest injection coincs.")

    # calibration uncertainty
    parser.add_option("--calibration-uncertainty", type="float", metavar="CAL",
        help="calibration uncertainty (D -> (1+/-CAL)*D)")

    # InspiralUtils compatibility
    parser.add_option("--gps-start-time", type="int",
        help="GPS start time of data analyzed")
    parser.add_option("--gps-end-time", type="int",
        help="GPS end time of data analyzed")
    parser.add_option("--ifo-tag", help="IFO coincidence time analyzed")
    parser.add_option("--user-tag", help="a tag to label your plots")
    parser.add_option("--output-path", help="root of the HTML output")
    parser.add_option("--enable-output", action="store_true",
        default=False, help="enable plots and HTML output")
    parser.add_option("--html-for-cbcweb", action="store_true",
        default=False, help="enable HTML output with the appropriate headers "
        "for the CBC website")
    parser.add_option("--show-plot", action="store_true", default=False,
        help="display the plots to screen if an X11 display is available")

    # odds and ends
    parser.add_option("--verbose", action="store_true", default=False,
        help="print extra information to the console")

    options, arguments = parser.parse_args()

    # check that mandatory switches are present
    for opt in ("relic_onsource", "relic_offsource", "relic_injections"):
        if getattr(options, opt) is None:
            raise ValueError, "%s is required" % opt.replace("_", "-")

    if options.calibration_uncertainty is not None:
        raise NotImplemented

    return options, arguments

################################################################################
# parse arguments
opts, args = parse_args()

##############################################################################
# read in bin definitions and loudest stats
# All vetoes have been taken into account

if opts.verbose:
    print "Reading in bin definitions and loudest statistics..."
statistic, mc_bins, m2_bins, D_bins, onsource_loudest_by_mc \
    = pickle.load(open(opts.relic_onsource))
statistic, mc_bins, m2_bins, D_bins, offsource_loudest_by_trial_mc \
    = pickle.load(open(opts.relic_offsource))
statistic, mc_bins, m2_bins, D_bins, num_sims_by_inj_m2_D, \
    inj_loudest_by_inj_mc_m2_D = pickle.load(open(opts.relic_injections))

num_sims_by_m2_D = num_sims_by_inj_m2_D.sum(axis=0)
num_sims_by_m2 = num_sims_by_m2_D.sum(axis=1)

# print summary
print "on-source loudest combined " + statistic + " by mchirp category:"
for low, hi, stat in zip(mc_bins.lower(), mc_bins.upper(),
                         onsource_loudest_by_mc):
    print "  [%f, %f): %f" % (low, hi, stat)
print "Number of injections read:", len(inj_loudest_by_inj_mc_m2_D)

##############################################################################
# generic initialization
InspiralUtils.initialise(opts, __prog__, __version__)

################################################################################
# identify the loudest (by likelihood) on-source coincidences by m2

pc0_by_mc = compute_pc0_by_mc(offsource_loudest_by_trial_mc,
                              onsource_loudest_by_mc)

print "p(c(mchirp) | 0):"
for low, hi, pc0 in zip(mc_bins.lower(), mc_bins.upper(), pc0_by_mc):
    print "  [%f, %f): %f" % (low, hi, pc0)

inj_loudest_by_inj_mc_m2 = inj_loudest_by_inj_mc_m2_D.max(axis=3)
pch_by_mc_m2 = compute_pch_by_mc_m2(inj_loudest_by_inj_mc_m2,
    num_sims_by_m2, onsource_loudest_by_mc)

print "p(c(mchirp) | h(m2)):"
for low, hi, pch_by_m2 in zip(mc_bins.lower(), mc_bins.upper(), pch_by_mc_m2):
    print "  [%f, %f): %s" % (low, hi, str(pch_by_m2))

L_by_mc_m2 = pch_by_mc_m2 / pc0_by_mc[:, None]

print "Lambda(c(mchirp) | h(m2)):"
for low, hi, pch_by_m2 in zip(mc_bins.lower(), mc_bins.upper(), L_by_mc_m2):
    print "  [%f, %f): %s" % (low, hi, str(pch_by_m2))

# for each m2 bin, find the max L=p(c|h)/p(c|0)
mc_ind_by_m2 = L_by_mc_m2.argmax(axis=0)
mc_m2_map = (mc_ind_by_m2, range(len(m2_bins)))
max_L_by_m2 = L_by_mc_m2[mc_m2_map]

################################################################################
# compute P(Lambda > Lambda_0(m2) | h(m2, D))
# FIXME: Some of this section is convoluted because of the 4-D representation
# of inj_loudest_by_inj_mc_m2_D.
# FIXME: This can be done in O(N_{inj}) time because L is monotonic with SNR
# within an mc bin, so a threshold in L can be converted to a threshold in SNR
# for each mc bin.

inj_pc0_by_m2_D = numpy.zeros((len(m2_bins), len(D_bins)), dtype=float) + 1e-10
inj_pch_by_m2_D = numpy.zeros((len(m2_bins), len(D_bins)), dtype=float) + 1e-10
inj_louder_count_by_m2_D = numpy.zeros((len(m2_bins), len(D_bins)), dtype=int)
for inj_trial_loudest_by_mc_m2_D in inj_loudest_by_inj_mc_m2_D:

    # find D bin
    m2_D_mask = (inj_trial_loudest_by_mc_m2_D != 0).sum(axis=0, dtype=bool)
    if m2_D_mask.sum() == 0:
        continue
    # sanity check: one m2, D pair contains something other than zero
    assert m2_D_mask.sum() == 1, "only one (m2, D) bin should be nonzero"
    m2_ind = m2_D_mask.sum(axis=1, dtype=bool).nonzero()[0]
    D_ind = m2_D_mask.sum(axis=0, dtype=bool).nonzero()[0]

    # compute likelihood of this (inj + noise) instance arising from m2'
    inj_trial_loudest_by_mc_m2 = inj_trial_loudest_by_mc_m2_D.max(axis=2)
    inj_trial_loudest_by_mc = inj_trial_loudest_by_mc_m2.max(axis=1)

    inj_trial_pc0_by_mc = compute_pc0_by_mc(offsource_loudest_by_trial_mc,
        inj_trial_loudest_by_mc)

    # this inner loop makes the algorithm O(n^2)
    inj_trial_pch_by_mc_m2 = compute_pch_by_mc_m2(inj_loudest_by_inj_mc_m2,
        num_sims_by_m2, inj_trial_loudest_by_mc)

    inj_trial_L_by_mc_m2 = inj_trial_pch_by_mc_m2 / inj_trial_pc0_by_mc[:, None]
    inj_trial_L = inj_trial_L_by_mc_m2[:, m2_ind].max()

    # record if anything is louder than the loudest on-source coinc for this m2
    if inj_trial_L > max_L_by_m2[m2_ind]:
        inj_louder_count_by_m2_D[m2_D_mask] += 1

    # record diagnostics
    mc_ind = inj_trial_L_by_mc_m2[:, m2_ind].argmax()
    inj_pc0_by_m2_D[m2_D_mask] += numpy.log10(inj_trial_pc0_by_mc[mc_ind])
    inj_pch_by_m2_D[m2_D_mask] += numpy.log10(inj_trial_pch_by_mc_m2[mc_ind, m2_ind])
nonzero_ind = num_sims_by_m2_D.nonzero()
inj_pc0_by_m2_D[nonzero_ind] /= num_sims_by_m2_D[nonzero_ind]
inj_pch_by_m2_D[nonzero_ind] /= num_sims_by_m2_D[nonzero_ind]

pLh_by_m2_D = inj_louder_count_by_m2_D / (num_sims_by_m2_D + 1e-10)

################################################################################
# plots
fnameList = []
tagList = []

c_in_E = r"c \in \mathcal{E}(c_0)"
c_in_E_m2 = r"c \in \mathcal{E}(c_0(m_2))"
mc_latex = r"\langle \hat{M}_\mathrm{chirp} \rangle"
mc_ranges = zip(mc_bins.lower(), mc_bins.upper())

## mchirp vs loudest stat horizontal bar graph
text = "mchirp vs loudest statistic"

plot = plotutils.NumberVsBinBarPlot(statistic.replace("_", r"\_"),
    "$" + mc_latex + "$", "Loudest statistics by mchirp")
plot.add_content(mc_bins, onsource_loudest_by_mc)
plot.finalize(orientation="horizontal")

# add p(c|0) on top as text
for mc, pc0 in zip(mc_bins.centres(), pc0_by_mc):
    plot.ax.text(0.5, mc, r"$p(" + c_in_E + r"|0) = $" + str(pc0))

if plot.ax.get_xlim()[1] < 20:
    plot.ax.set_xlim(xmax=20)

# add mchirp dividers
for divider in mc_bins.boundaries:
    plot.ax.hlines(divider, 0, plot.ax.get_xlim()[1], linestyle="dashed")

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "loudest_stats_by_mchirp")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

## injection count vs (m2, D) image
text = "Injection count"

plot = plotutils.ImagePlot("$m_2\ (M_\odot)$", "$D\ \mathrm{(Mpc)}$",
    r"Injections made")
plot.add_content(num_sims_by_m2_D.T, m2_bins, D_bins)
plot.finalize()

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "injection_count_by_m2_D")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

## for L(c|h) vs (m2, mc) image
# TODO: before and after MC and calibration systematics
text = "L(c(mc)|h(m2))"

plot = plotutils.ImagePlot(\
    r"$m_2\ (M_\odot)$",
    r"$" + mc_latex + r"(M_\odot;\textrm{ not to scale)}$",
    r"$\Lambda(c(" + mc_latex + r") \in \mathcal{E}(c_0(m2))\,|\,h(m_2))$")
plot.add_content(L_by_mc_m2, m2_bins, mc_bins)
plot.finalize()

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "oldL_by_mc_m2")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()


## for L(c|h) vs m2
# TODO: before and after MC and calibration systematics
text = "ln L(c(mc)|h(m2))"

plot = plotutils.SimplePlot(\
    r"$m_2\ (M_\odot)$",
    r"$\log \Lambda(c \in \mathcal{E}(c_0(m2))\,|\,h(m_2))$",
    r"$\log \Lambda(c \in \mathcal{E}(c_0(m2))\,|\,h(m_2))$")
for mc_range, L_by_m2 in zip(mc_ranges, L_by_mc_m2):
    L_by_m2[L_by_m2 < 1e-10] = 1e-10
    plot.add_content(m2_bins.centres(), numpy.log10(L_by_m2),
                     label=r"$" + mc_latex + r"\in [%4.2f, %4.2f)$" % mc_range)
plot.finalize()
plot.ax.set_ylim(ymin=-0.5)

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "L_by_mc_m2")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

## p(c|h) from max L mchirp bins vs (m2, D) image
# TODO: before and after MC and calibration systematics
text = "p(L(m_2) > L_0(m_2)|h(m2, D))"

plot = plotutils.ImagePlot(r"$m_2\ (M_\odot)$", r"$D\ \mathrm{(Mpc)}$",
    r"$P(\Lambda(m_2) > \Lambda_0(m_2)\,|\,h(m_2, D))$")
plot.add_content(pLh_by_m2_D.T, m2_bins, D_bins)
plot.finalize()

image = [c for c in plot.ax.get_children() \
         if isinstance(c, matplotlib.image.AxesImage)][0]
image.set_clim((0, 1))

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "pLh_by_m2_D")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

## p(c|h) and p(c|0) vs D for an m2 slice
#m2_ind = len(m2_bins) // 2
m2_ind = 8
m2_val = m2_bins.centres()[m2_ind]
text = "p(c|h) and p(c|0) vs D for m2=%4.2f" % m2_val

plot = plotutils.SimplePlot(\
    r"$D\textrm{ (Mpc)}$", "",
    r"$\textrm{Probabilities calculated with }m_2=%4.2f$" % m2_val)
plot.add_content(D_bins.centres(), inj_pc0_by_m2_D[m2_ind, :],
    label=r"$\left\langle \log p(c \in \mathcal{E}(c_0(m_2, D)) \,|\, 0) "\
        r"\right\rangle$")
plot.add_content(D_bins.centres(), inj_pch_by_m2_D[m2_ind, :],
    label=r"$\left\langle \log p(c \in \mathcal{E}(c_0(m_2, D)) \,|\, "\
        r"h(m_2, D)\right\rangle$")
plot.add_content(D_bins.centres(), inj_pch_by_m2_D[m2_ind, :] \
    - inj_pc0_by_m2_D[m2_ind, :], label=r"ratio")
plot.finalize()

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "probabilities_by_D")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()


## upper limit contours (m2, D) image
text = "(m2, D) exclusion plot"

plot = plotutils.FillPlot(r"$m_2\ (M_\odot)$", r"$D\ \mathrm{(Mpc)}$",
    "Exclusion regions")

exclusion_x = m2_bins.lower()
zero = numpy.zeros(len(m2_bins), dtype=float)

exclusion_y = get_level_crossings(pLh_by_m2_D, 0.25, D_bins)
tmpx, tmpy = viz.makesteps(exclusion_x, zero, exclusion_y)
plot.add_content(tmpx, tmpy, label=r"25\% exclusion")

exclusion_y = get_level_crossings(pLh_by_m2_D, 0.5, D_bins)
tmpx, tmpy = viz.makesteps(exclusion_x, zero, exclusion_y)
plot.add_content(tmpx, tmpy, label=r"50\% exclusion")

exclusion_y = get_level_crossings(pLh_by_m2_D, 0.75, D_bins)
tmpx, tmpy = viz.makesteps(exclusion_x, zero, exclusion_y)
plot.add_content(tmpx, tmpy, label=r"75\% exclusion")

exclusion_y = get_level_crossings(pLh_by_m2_D, 0.9, D_bins)
tmpx, tmpy = viz.makesteps(exclusion_x, zero, exclusion_y)
plot.add_content(tmpx, tmpy, label=r"90\% exclusion")

plot.finalize()

plot.ax.set_ylim((0, D_bins.max))

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "exclusion_by_m2_D")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()


#############################################################################
# Generate HTML and cache file
if opts.enable_output:
    html_filename = InspiralUtils.write_html_output(opts, sys.argv[1:],
        fnameList, tagList)
    InspiralUtils.write_cache_output(opts, html_filename, fnameList)

    if opts.html_for_cbcweb:
        html_filename_publish = InspiralUtils.write_html_output(opts,
            sys.argv[1:], fnameList, tagList, cbcweb=True)

if opts.show_plot:
    pylab.show()
