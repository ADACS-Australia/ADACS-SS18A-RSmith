#!/usr/bin/python
#
# Copyright (C) 2007  Patrick Brady
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#

from __future__ import division  # float division for integers

import sys
import os
import optparse
import glob

import numpy
numpy.seterr('raise')  # throw an exception on floating point errors

from glue import segments
from glue import segmentsUtils
import pylal.itertools
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils
from pylal import SimInspiralUtils

__author__ = "Patrick Brady <patrick@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]

##############################################################################
# Define a Square Array
##############################################################################
def square(xedges, yedges, coincTriggers, simtypeflag):
  """
  Histogram coincTriggers in the mass1-distance plane.

  @param xdata:  array of data for parameter x
  @param xedges: bin boundaries for parameter x
  @param ydata:  array of data for parameter y
  @param yedges: bin boundaries for parameter y
  @param coincTriggers: data to histogram
  @param simtypeflag: "missed" or "found"
  """
  ng_x_y = zeros(shape=(len(yedges), len(xedges)), dtype=int)
  xstep = xedges[1] - xedges[0]
  ystep = yedges[1] - yedges[0]

  for coinc in coincTriggers:
    if ((simtypeflag == "found" and coinc.stat >= 0) or\
        (simtypeflag == "missed" and coinc.stat < 0)):
      xdata = coinc.sim.mass1
      ydata = coinc.sim.distance
      k = int((xdata-xedges[0]) / xstep)
      l = int((ydata-yedges[0]) / ystep)

      if (k >= 0 and k < len(xedges)) and (l >= 0 and l < len(yedges)):
        ng_x_y[l][k] += 1

  return ng_x_y

#############################################################################
# make steps so that fill will work properly
"""
Function to create an array of steps suitable for filling between.
"""
def makesteps(x,y1,y2):
  xnew=[]
  y1new=[y1[0]]
  y2new=[y2[0]]
  for i in arange(x.size-1):
    xnew.append(x[i])
    xnew.append(x[i+1])
    y1new.append(y1[i])
    y1new.append(y1[i+1])
    y2new.append(y2[i])
    y2new.append(y2[i+1])
  xnew.append(x[-1])

  tmpx=asarray(xnew)
  tmpy1=asarray(y1new)
  tmpy2=asarray(y2new)
  xnew=concatenate((tmpx,tmpx[::-1]))
  ynew=concatenate((tmpy1,tmpy2[::-1]))

  return xnew,ynew

#######################################################################
# make a smooth contour at the specified confidence
def get_smooth_contour(xedges,yedges,pcsignalsq,confidence,width=3.0): 	 #
  clevel=zeros(len(xedges))
  dy = yedges[1]-yedges[0] 
  for i in arange(len(xedges)):
    found = 0
    for j in arange(len(yedges)):
      if pcsignalsq[j,i]>confidence and not found: 
        slope=(yedges[j]-yedges[j-1])/(pcsignalsq[j,i]-pcsignalsq[j-1,i])
        clevel[i]=dy+yedges[j-1] + (confidence-pcsignalsq[j-1,i])*slope
        found = 1 
      if pcsignalsq[j,i]<confidence and found: 
        found = 0 	 

  gauss = exp( - 0.5 * ( ( xedges - mean( xedges ) ) / width )**2  )\
    / sqrt( 2.0 * pi ) / width
  yarray= convolve(asarray(clevel),gauss,mode=1) 	 
  yarray = clevel[0] * yarray / yarray[0] 	 
  tmpx,tmpy = makesteps(xedges,zeros(len(xedges)),yarray) 	 
 	 
  return tmpx,tmpy,yarray


##############################################################################
usage = """%prog [options]

GRB Likelihood calculation

We attempt to compute the posterior distribution

p[ h(lambda) | c ]

where c is the event candidate and h(lambda) is a signal with
parameters lambda.
"""

parser = optparse.OptionParser(usage=usage, version="%prog CVS $Id$ ")
parser.add_option("-g", "--on-source-glob",
  help="GLOB on-source thinca files to read")
parser.add_option("-m", "--missed-glob",
  help="GLOB missed injection files to read")
parser.add_option("-u", "--found-glob",
  help="GLOB found injection files to read")
parser.add_option("-e", "--epsilon", type="float", default=0.,
  help="if metric distance squared > EPSILON, discard")
parser.add_option("-n", "--ntrials", type="int", default=0,
  help="number off source segments")
parser.add_option("-l", "--loudest-event-cut", action="store_true",
  default=False, help="evaluate probabilities with a loudest-event cut")
parser.add_option("-c", "--min-loudest-event-stat", type="float",
  help="if there are no candidates, use this as the loudest event statistic")
parser.add_option("-P", "--figure-type", default="ps",
  help="generate figures with this extension (e.g. ps or png")
parser.add_option("-x", "--min-snr", type="float",
  help="minimum value of snr on plot")
parser.add_option("-X", "--max-snr", type="float",
  help="maximum value of snr on plot")
parser.add_option("-o", "--open-box", action="store_true", default=False,
  help="run with the open box")
parser.add_option("-s", "--show-plot", action="store_true", default=False,
  help="display the figures on the terminal")
parser.add_option("-v", "--verbose", action="store_true", default=False,
  help="verbose debugging output")
parser.add_option("-B", "--h1-triggers",action="store_true", default=False,\
  help="input files contain triggers from H1")
parser.add_option("-C", "--h2-triggers",action="store_true", default=False,\
  help="input files contain triggers from H2")
parser.add_option("-D", "--l1-triggers",action="store_true", default=False,\
  help="input files contain triggers from L1")
parser.add_option("-E", "--g1-triggers",action="store_true", default=False,\
  help="input files contain triggers from G1")
parser.add_option("-S", "--statistic", default='snr',
  help="choice of statistic used in making plots, valid arguments are: "
       "snr (DEFAULT), snr_over_chi, s3_snr_chi_stat, effective_snr, "
       "bitten_l, bitten_lsq")
parser.add_option("-V","--veto-file",
  help="read in segments from FNAME (assumed segwizard format)")
parser.add_option("-F","--full-segs",
  help="read in segments from FNAME (assumed segwizard format)")
parser.add_option("-O","--on-source-segs",
  help="read in segments from FNAME (assumed segwizard format)")
parser.add_option("-N", "--nbins", type="float", default=20,\
  help="number of bins")
parser.add_option("-a", "--min-mass", type="float", default=0.5,\
  help="minimum value for the mass range")
parser.add_option("-b", "--max-mass", type="float", default=20.0,\
  help="maximum value for the mass range")
parser.add_option("-d", "--bins-mass", type="float", default=8.0,\
  help="number of bins for the mass range")
parser.add_option("-f", "--min-distance", type="float", default=1.0,\
  help="minimum value for the distance range")
parser.add_option("-i", "--max-distance", type="float", default=20.0,\
  help="maximum value for the distance range")
parser.add_option("-j", "--bins-distance", type="float",default=13.0,\
  help="number of bins for the distance range")

(opts,args) = parser.parse_args()

if opts.on_source_glob is None:
  print >>sys.stderr, "Must specify a GLOB of on-source files to read"
  print >>sys.stderr, "Enter 'plotthinca --help' for usage"
  sys.exit(2)

if (opts.full_segs is None) or (opts.on_source_segs is None):
  print >>sys.stderr, "There must be full-segs and on-source-segs"
  sys.exit(2)

# check that statistic is OK:
if opts.statistic not in ('snr', 'snr_over_chi', 's3_snr_chi_stat',
    'effective_snr', 'bitten_l', 'bitten_lsq'):
  print >>sys.stderr, "--statistic must be one of"
  print >>sys.stderr, "(snr|snr_over_chi|s3_snr_chi_stat|effective_snr|bitten_l|bitten_lsq)"
  sys.exit(2)

# check plot type; strip leading periods
opts.figure_type = opts.figure_type.strip(".")
assert opts.figure_type in ("png", "ps", "eps", "svg")

# Change to Agg back-end if show() will not be called
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
rc('axes', titlesize='x-large', labelsize='x-large')
rc('text', usetex=True)

#####################################################################
# initialize some basic information

statistic = CoincInspiralUtils.coincStatistic(opts.statistic)

ifo_list = [ifo for ifo in ("G1", "H1", "H2", "L1") \
            if getattr(opts, "%s_triggers" % ifo.lower())]

ifo_combos = CoincInspiralUtils.get_ifo_combos(ifo_list)

#####################################################################
# Read in all the segment lists
fullseglist = segmentsUtils.fromsegwizard(open(opts.full_segs))
onsourceseglist = segmentsUtils.fromsegwizard(open(opts.on_source_segs))

# take padding into account
fullseglist &= segments.segmentlist([fullseglist.extent().contract(72)])

# take veto into account
if opts.veto_file:
  vetolist = segmentsUtils.fromsegwizard(open(opts.veto_file))
  fullseglist -= vetolist

# define off-source segments
offsourceseglist = fullseglist - onsourceseglist

# make a list of 180s off source segments
seglist = segments.segmentlist()
for seg in offsourceseglist:
  seglist.extend(segmentsUtils.segmentlist_range(seg[0], seg[1], 180))

if opts.verbose:
  print "The number of trial segments is %i" % len(seglist)
numtrials = len(seglist)

#####################################################################
# read in on-source triggers
coincfiles = glob.glob(opts.on_source_glob)
inspTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(coincfiles)

# perform the veto
if inspTriggers and opts.veto_file:
  inspTriggers = inspTriggers.veto(vetolist)

# construct the off source listing
offsourceTriggers = CoincInspiralUtils.coincInspiralTable(\
    inspTriggers.veto(onsourceseglist), statistic)

# construct the coincs
if opts.open_box:
  coincTriggers = CoincInspiralUtils.coincInspiralTable(\
      inspTriggers.veto(offsourceseglist),statistic)
else:
  coincTriggers = CoincInspiralUtils.coincInspiralTable()
  coincTriggers.append(offsourceTriggers[0])

if opts.max_snr is None:
  if len(inspTriggers) > 0:
    xhigh = max(inspTriggers.get_column(opts.statistic))
  else:
    xhigh = 50.0
else:
  xhigh = opts.max_snr + 1

if opts.min_snr is None:
  if len(inspTriggers) > 0:
    xlow = min(inspTriggers.get_column(opts.statistic))
  else:
    xlow = 1.0
else:
  xlow = opts.min_snr

#####################################################################
# make the plot background and foreground
delta=xhigh-xlow
ds=0.5*delta/opts.nbins
bins = arange( xlow, xhigh, delta/opts.nbins)

# build the histogram. The return values are
#   the count per bin
#   the bin (lower) edges
#   the patches
# Note: the matplotlib hist function assumes that these are the lower
# edges of the bins. I have not looked into the code yet to confirm
# how it handles that last bin. Since all other bins are equally
# spaced, this doesn't really matter for us.
[zero_dist,bin,info] = hist(coincTriggers.getstat(),bins)

# add a zero to the beginning of the array containing count; this
# method is so that the cumulative distribution is plotted correctly
# as we'll see...
zero_dist = concatenate( (zeros(1),zero_dist) )

# construct the cumulative distribution. Here's what is done:
#   * sum up the total count - unaffected by the zeros(1) added above
#   * subtract from that the cumulative sum of the modified array
#   * the first element of the new array is the total number of events
#   above threshold
#   * note that the cumsum only creates an array with the same length as
#   bins
cum_dist_zero = numpy.sum(zero_dist)-cumsum(zero_dist[0:bin.size])
cum_dist_offsource = []
for seg in seglist:
  offsourcetrial = offsourceTriggers.getTriggersInSegment(seg) 
  [num_offsource,bin,info] = hist(offsourcetrial.getstat(),bins)
  num_offsource = concatenate( (zeros(1),num_offsource) )
  cum_offsource = sum(num_offsource)-cumsum(num_offsource[0:bin.size])
  # adds a row to the cum_dist_offsource
  cum_dist_offsource.append(cum_offsource)
#cum_dist_offsource = reshape(array(cum_dist_offsource), \
      #(len(seglist),opts.nbins))

# takes the mean over rows for each column
offsource_mean = mean(cum_dist_offsource)
# takes the std over rows for each column
offsource_std = std(cum_dist_offsource)
clf()
figure()
hold(True)
semilogy((bins+ds)**2,cum_dist_zero+0.0001,'r^',markerfacecolor="b",markersize=12)
semilogy((bins+ds)**2,offsource_mean, 'r+', markersize=12)

# The following loop is needed to make the plot nice when making
# logarithmic filled regions.
offsource_min = []
for i in range( len(offsource_mean) ):
  offsource_min.append( max(offsource_mean[i] - offsource_std[i], 0.0001) )
  offsource_mean[i] = max(offsource_mean[i], 0.0001)
tmpx,tmpy = makesteps(bins,offsource_min,offsource_mean+offsource_std)
p=fill(tmpx**2,tmpy, facecolor='y')
setp(p, alpha=0.3)
grid(True)
axis([ xlow*xlow, (xhigh-2*ds)*(xhigh-2*ds), 0.001, 10.0])
xlabel(r"$\rho_{\mathrm{eff}}^2$")
ylabel(r"Expected number of events")
savefig("snr_dist.%s" % opts.figure_type)


#####################################################################
# read in the missed and found files
injTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(\
    glob.glob(opts.found_glob) )

coincInjTriggers = CoincInspiralUtils.coincInspiralTable(\
    injTriggers,statistic)
coincInjTriggers.add_sim_inspirals( \
    SimInspiralUtils.ReadSimInspiralFromFiles(glob.glob(opts.found_glob)) )
coincInjTriggers.add_missed_sims( \
    SimInspiralUtils.ReadSimInspiralFromFiles(glob.glob(opts.missed_glob)) )

#####################################################################
# do loudest event cut
if opts.loudest_event_cut:
  # determine loudest event statistic
  if len(coincTriggers) > 0:
    loudest_stat = coincTriggers.getstat().max()
  else:
    loudest_stat = opts.min_loudest_event_stat

  # trim off-source candidate list
  lt, eq, gt = offsourceTriggers.partition_by_stat(loudest_stat)
  offsourceTriggers = gt
  offsourceTriggers.extend(eq.rows)

  # mark found injections with smaller stat as missed
  for coinc in coincInjTriggers:
    if coinc.stat < loudest_stat:
      coinc.stat = -1

#####################################################################
# histogram triggers in mass1-distance space
dx=(opts.max_mass-opts.min_mass)/opts.bins_mass
xedges = arange( opts.min_mass, opts.max_mass, dx )
dy=(opts.max_distance-opts.min_distance)/opts.bins_distance
yedges = arange( opts.min_distance, opts.max_distance, dy )
foundsq = square(xedges, yedges, coincInjTriggers, "found")
missedsq = square(xedges, yedges, coincInjTriggers, "missed")

#####################################################################
# if there are coincident triggers on source
if coincTriggers and not opts.loudest_event_cut:
  # loop over each candidate
  for candidate in coincTriggers:
    tmparray = zeros(len(seglist), dtype=int)

    # cut out those triggers near to the candidate, and
    # evaulate the p(c|0) based on that
    triggers_within_epsilon = \
        offsourceTriggers.getTriggersWithinEpsilon(candidate, opts.epsilon)

    for coinc in triggers_within_epsilon:
      # index by end time of alphabetically first IFO in coinc
      end_time = getattr(coinc, coinc.get_ifos()[1][0]).end_time
      if end_time in seglist:
        tmparray[seglist.find(end_time)] = 1

    if opts.verbose: print tmparray
    pczero = tmparray.sum() / len(seglist)

    print "p(c|0) = %f" % pczero

    # cut out those injection triggers near to the candidate, and
    # evaulate the p(c|signal with lambda) based on that
    injTriggers_within_epsilon = \
        coincInjTriggers.getTriggersWithinEpsilon(candidate, opts.epsilon)

    print "Number of injections within epsilon: %f" % \
        len(injTriggers_within_epsilon)

    foundwithinepsilonsq = \
        square(xedges, yedges, injTriggers_within_epsilon, "found")

    pcsignalsq = foundwithinepsilonsq / (missedsq + foundsq + 1.0e-10)
else:
  # p(no triggers | no signal )
  #
  # number of segments without a trigger / total number of segments
  # this is also the correct branch to take for the loudest-event analysis
  tmparray = zeros(len(seglist), dtype=int)

  for coinc in offsourceTriggers:
    # index by end time of alphabetically first IFO in coinc
    end_time = getattr(coinc, coinc.get_ifos()[1][0]).end_time
    if end_time in seglist:
      tmparray[seglist.find(end_time)] = 1

  if opts.verbose: print tmparray
  pczero = 1.0 - tmparray.sum() / len(seglist)

  print "p(c|0) = %f" % pczero

  # p(no triggers | signal with parameters lambda)
  #
  # number of missed injections with parameters lambda / total number
  # of injections with parameter lambda
  pcsignalsq = missedsq / (missedsq + foundsq + 1.0e-10)

  pcsignal = missedsq.sum() / (missedsq.sum() + foundsq.sum() + 1.0e-10)
  print "p(c|h) = %f" % pcsignal

#####################################################################
# generate plots

im_extent = [min(xedges), max(xedges), min(yedges), max(yedges)]

#figure()
##imshow(pcsignalsq, origin='lower')
#hold(True)
#IC = contourf(xedges, yedges, pcsignalsq)
#xlabel(r"$m_2 (M_\odot)$")
#ylabel(r"$D (\mathrm{Mpc})$")
#colorbar(IC)

figure()
palette = cm
IM = imshow(pcsignalsq, origin='lower', extent=im_extent,
  interpolation='nearest')
hold(True)
contour(pcsignalsq, extent=im_extent)
colorbar(IM)
axis('tight')
#axvline(candmass)
title(r'$p[\mathrm{candidate}|h(m_2,D)]$')
xlabel(r"$m_2 (M_\odot)$")
ylabel(r"$D (\mathrm{Mpc})$")
savefig("pcsignal.%s" % opts.figure_type)

figure()
palette = cm
IM = imshow(foundsq + missedsq, origin='lower', extent=im_extent,
  interpolation='nearest')
hold(True)
contour(foundsq + missedsq, extent=im_extent)
colorbar(IM)
axis('tight')
#axvline(candmass)
title('Number of injections made')
xlabel(r"$m_2 (M_\odot)$")
ylabel(r"$D (\mathrm{Mpc})$")
savefig("made-injections.%s"  % opts.figure_type)

figure()
palette = cm
IM = imshow(foundsq / (foundsq + missedsq + 1.0e-10), origin='lower',
  extent=im_extent, interpolation='nearest')
hold(True)
contour(foundsq / (foundsq + missedsq + 1.0e-10), extent=im_extent)
colorbar(IM)
axis('tight')
#axvline(candmass)
title('Fraction of injections found')
xlabel(r"$m_2 (M_\odot)$")
ylabel(r"$D (\mathrm{Mpc})$")
savefig("found-fraction.%s" % opts.figure_type)

figure()
tmpx,tmpy,yarray = get_smooth_contour(xedges,yedges,pcsignalsq,0.1)
p1=fill(tmpx,tmpy, facecolor='y')
setp(p1, alpha=0.5)
tmpx,tmpy,yarray = get_smooth_contour(xedges,yedges,pcsignalsq,0.15)
p2=fill(tmpx,tmpy, facecolor='k')
setp(p2, alpha=0.3)
tmpx,tmpy,yarray = get_smooth_contour(xedges,yedges,pcsignalsq,0.20)
p3=fill(tmpx,tmpy, facecolor='k')
setp(p3, alpha=0.1)
hold(True)
axis([opts.min_mass, max(xedges), 0.0, max(yedges)])
xlabel(r"$m_2 (M_\odot)$")
ylabel(r"$D (\mathrm{Mpc})$")
legend((p3, p2, p1), ('80\% exclusion area','85\% exclusion area','90\% exclusion area'), loc="lower right")
savefig("pcsignal-slice.%s" % opts.figure_type)

if opts.show_plot:
  show()
