#!/usr/bin/env python
#
# Copyright (C) 2007  Patrick Brady
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#

from __future__ import division  # float division for integers

import sys
import os
import optparse
import glob

import numpy
numpy.seterr('raise')  # throw an exception on floating point errors

from glue import segments
from glue import segmentsUtils
import pylal.itertools
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils
from pylal import SimInspiralUtils

__author__ = "Patrick Brady <patrick@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]

##############################################################################
# Define a Square Array
##############################################################################
def square(xedges, yedges, coincTriggers, simtypeflag):
  """
  Histogram coincTriggers in the mass1-distance plane.

  @param xdata:  array of data for parameter x
  @param xedges: bin boundaries for parameter x
  @param ydata:  array of data for parameter y
  @param yedges: bin boundaries for parameter y
  @param coincTriggers: data to histogram
  @param simtypeflag: "missed" or "found"
  """
  ng_x_y = zeros(shape=(len(yedges), len(xedges)), dtype=int)
  xstep = xedges[1] - xedges[0]
  ystep = yedges[1] - yedges[0]

  for coinc in coincTriggers:
    if ((simtypeflag == "found" and coinc.stat >= 0) or\
        (simtypeflag == "missed" and coinc.stat < 0)):
      xdata = coinc.sim.mass1
      ydata = coinc.sim.distance
      k = int((xdata-xedges[0]) / xstep)
      l = int((ydata-yedges[0]) / ystep)

      if (k >= 0 and k < len(xedges)) and (l >= 0 and l < len(yedges)):
        ng_x_y[l][k] += 1

  return ng_x_y

##############################################################################
usage = """%prog [options]

GRB Likelihood calculation

We attempt to compute the posterior distribution

p[ h(lambda) | c ]

where c is the event candidate and h(lambda) is a signal with
parameters lambda.
"""

parser = optparse.OptionParser(usage=usage, version="%prog CVS $Id$ ")
parser.add_option("-g", "--on-source-glob",
  help="GLOB on-source thinca files to read")
parser.add_option("-m", "--missed-glob",
  help="GLOB missed injection files to read")
parser.add_option("-u", "--found-glob",
  help="GLOB found injection files to read")
parser.add_option("-e", "--epsilon", type="float", default=0.,
  help="if metric distance squared > EPSILON, discard")
parser.add_option("-n", "--ntrials", type="int", default=0,
  help="number off source segments")
parser.add_option("-l", "--loudest-event-cut", action="store_true",
  default=False, help="evaluate probabilities with a loudest-event cut")
parser.add_option("-c", "--min-loudest-event-stat", type="float",
  help="if there are no candidates, use this as the loudest event statistic")
parser.add_option("-P", "--figure-type", default="ps",
  help="generate figures with this extension (e.g. ps or png")
parser.add_option("-x", "--min-snr", type="float",
  help="minimum value of snr on plot")
parser.add_option("-X", "--max-snr", type="float",
  help="maximum value of snr on plot")
parser.add_option("-o", "--open-box", action="store_true", default=False,
  help="run with the open box")
parser.add_option("-s", "--show-plot", action="store_true", default=False,
  help="display the figures on the terminal")
parser.add_option("-v", "--verbose", action="store_true", default=False,
  help="verbose debugging output")
parser.add_option("-B", "--h1-triggers",action="store_true", default=False,\
  help="input files contain triggers from H1")
parser.add_option("-C", "--h2-triggers",action="store_true", default=False,\
  help="input files contain triggers from H2")
parser.add_option("-D", "--l1-triggers",action="store_true", default=False,\
  help="input files contain triggers from L1")
parser.add_option("-E", "--g1-triggers",action="store_true", default=False,\
  help="input files contain triggers from G1")
parser.add_option("-S", "--statistic", default='snr',
  help="choice of statistic used in making plots, valid arguments are: "
       "snr (DEFAULT), snr_over_chi, s3_snr_chi_stat, effective_snr, "
       "bitten_l, bitten_lsq")
parser.add_option("-V","--veto-file",
  help="read in segments from FNAME (assumed segwizard format)")
parser.add_option("-F","--full-segs",
  help="read in segments from FNAME (assumed segwizard format)")
parser.add_option("-O","--on-source-segs",
  help="read in segments from FNAME (assumed segwizard format)")

(opts,args) = parser.parse_args()

if opts.on_source_glob is None:
  print >>sys.stderr, "Must specify a GLOB of on-source files to read"
  print >>sys.stderr, "Enter 'plotthinca --help' for usage"
  sys.exit(2)

if (opts.full_segs is None) or (opts.on_source_segs is None):
  print >>sys.stderr, "There must be full-segs and on-source-segs"
  sys.exit(2)

# check that statistic is OK:
if opts.statistic not in ('snr', 'snr_over_chi', 's3_snr_chi_stat',
    'effective_snr', 'bitten_l', 'bitten_lsq'):
  print >>sys.stderr, "--statistic must be one of"
  print >>sys.stderr, "(snr|snr_over_chi|s3_snr_chi_stat|effective_snr|bitten_l|bitten_lsq)"
  sys.exit(2)

# check plot type; strip leading periods
opts.figure_type = opts.figure_type.strip(".")
assert opts.figure_type in ("png", "ps", "eps", "svg")

# Change to Agg back-end if show() will not be called
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
rc('axes', titlesize='x-large', labelsize='x-large')
rc('text', usetex=True)

#####################################################################
# initialize some basic information

statistic = CoincInspiralUtils.coincStatistic(opts.statistic)

ifo_list = [ifo for ifo in ("G1", "H1", "H2", "L1") \
            if getattr(opts, "%s_triggers" % ifo.lower())]

ifo_combos = CoincInspiralUtils.get_ifo_combos(ifo_list)

#####################################################################
# Read in all the segment lists
fullseglist = segmentsUtils.fromsegwizard(open(opts.full_segs))
onsourceseglist = segmentsUtils.fromsegwizard(open(opts.on_source_segs))

# take padding into account
fullseglist &= segments.segmentlist([fullseglist.extent().contract(72)])

# take veto into account
if opts.veto_file:
  vetolist = segmentsUtils.fromsegwizard(open(opts.veto_file))
  fullseglist -= vetolist

# define off-source segments
offsourceseglist = fullseglist - onsourceseglist

# make a list of 180s off source segments
seglist = segments.segmentlist()
for seg in offsourceseglist:
  seglist.extend(segmentsUtils.segmentlist_range(seg[0], seg[1], 180))

if opts.verbose:
  print "The number of trial segments is %i" % len(seglist)

#####################################################################
# read in on-source triggers
coincfiles = glob.glob(opts.on_source_glob)
inspTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(coincfiles)

# perform the veto
if opts.veto_file:
  inspTriggers = inspTriggers.veto(vetolist)

# construct the off source listing
offsourceTriggers = CoincInspiralUtils.coincInspiralTable(\
    inspTriggers.veto(onsourceseglist), statistic)

# construct the coincs
if opts.open_box:
  coincTriggers = CoincInspiralUtils.coincInspiralTable(\
      inspTriggers.veto(offsourceseglist),statistic)
else:
  coincTriggers = CoincInspiralUtils.coincInspiralTable()
  coincTriggers.append(offsourceTriggers[0])

if opts.max_snr is None:
  if len(inspTriggers) > 0:
    xhigh = max(inspTriggers.get_column(opts.statistic))
  else:
    xhigh = 50.0
else:
  xhigh = opts.max_snr + 1

if opts.min_snr is None:
  if len(inspTriggers) > 0:
    xlow = min(inspTriggers.get_column(opts.statistic))
  else:
    xlow = 1.0
else:
  xlow = opts.min_snr

#####################################################################
# make the plot background and foreground
figure()
bins = arange(20.0, 120.0, 5)
[zero_dist,bin,info] = hist(offsourceTriggers.getstat(),bins)
xlabel(r"Effective SNR")
ylabel(r"Expected number of events")
savefig("snr_dist.%s" % opts.figure_type)


  

#####################################################################
# read in the missed and found files
injTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(\
    glob.glob(opts.found_glob) )

coincInjTriggers = CoincInspiralUtils.coincInspiralTable(\
    injTriggers,statistic)
coincInjTriggers.add_sim_inspirals( \
    SimInspiralUtils.ReadSimInspiralFromFiles(glob.glob(opts.found_glob)) )
coincInjTriggers.add_missed_sims( \
    SimInspiralUtils.ReadSimInspiralFromFiles(glob.glob(opts.missed_glob)) )

#####################################################################
# do loudest event cut
if opts.loudest_event_cut:
  # determine loudest event statistic
  if len(coincTriggers) > 0:
    loudest_stat = coincTriggers.getstat().max()
  else:
    loudest_stat = opts.min_loudest_event_stat

  # trim off-source candidate list
  lt, eq, gt = offsourceTriggers.partition_by_stat(loudest_stat)
  offsourceTriggers = gt
  offsourceTriggers.extend(eq.rows)

  # mark found injections with smaller stat as missed
  for coinc in coincInjTriggers:
    if coinc.stat < loudest_stat:
      coinc.stat = -1

#####################################################################
# histogram triggers in mass1-distance space
xedges = arange(0, 41, 2)
yedges = asarray([0, 6, 8, 10, 12, 14, 16, 18, 20, 30, 41])
foundsq = square(xedges, yedges, coincInjTriggers, "found")
missedsq = square(xedges, yedges, coincInjTriggers, "missed")

#####################################################################
# if there are coincident triggers on source
if coincTriggers and not opts.loudest_event_cut:
  # loop over each candidate
  for candidate in coincTriggers:
    fa_array = zeros(len(seglist), dtype=int)

    # cut out those triggers near to the candidate, and
    # evaulate the p(c|0) based on that
    triggers_within_epsilon = \
        offsourceTriggers.getTriggersWithinEpsilon(candidate, opts.epsilon)

    for coinc in triggers_within_epsilon:
      # index by end time of alphabetically first IFO in coinc
      end_time = getattr(coinc, coinc.get_ifos()[1][0]).end_time
      fa_array[seglist.find(end_time)] = 1

    if opts.verbose: print fa_array
    pczero = fa_array.sum() / len(seglist)

    print "p(c|0) = %f" % pczero

    # cut out those injection triggers near to the candidate, and
    # evaulate the p(c|signal with lambda) based on that
    injTriggers_within_epsilon = \
        coincInjTriggers.getTriggersWithinEpsilon(candidate, opts.epsilon)

    print "Number of injections within epsilon: %f" % \
        len(injTriggers_within_epsilon)

    foundwithinepsilonsq = \
        square(xedges, yedges, injTriggers_within_epsilon, "found")

    pcsignalsq = foundwithinepsilonsq / (missedsq + foundsq + 1.0e-10)
else:
  # p(no triggers | no signal )
  #
  # number of segments without a trigger / total number of segments
  # this is also the correct branch to take for the loudest-event analysis
  tmparray = zeros(len(seglist), dtype=int)

  for coinc in offsourceTriggers:
    # index by end time of alphabetically first IFO in coinc
    end_time = getattr(coinc, coinc.get_ifos()[1][0]).end_time
    if end_time in seglist:
      tmparray[seglist.find(end_time)] = 1

  if opts.verbose: print tmparray
  pczero = 1.0 - tmparray.sum() / len(seglist)

  print "p(c|0) = %f" % pczero

  # p(no triggers | signal with parameters lambda)
  #
  # number of missed injections with parameters lambda / total number
  # of injections with parameter lambda
  pcsignalsq = missedsq / (missedsq + foundsq + 1.0e-10)

  pcsignal = missedsq.sum() / (missedsq.sum() + foundsq.sum() + 1.0e-10)
  print "p(c|h) = %f" % pcsignal

#####################################################################
# generate plots

im_extent = [min(xedges), max(xedges), min(yedges), max(yedges)]

#figure()
##imshow(pcsignalsq, origin='lower')
#hold(True)
#IC = contourf(xedges, yedges, pcsignalsq)
#xlabel(r"$m_1 (M_\odot)$")
#ylabel(r"$D (\mathrm{Mpc})$")
#colorbar(IC)

figure()
palette = cm
IM = imshow(pcsignalsq, origin='lower', extent=im_extent,
  interpolation='nearest')
hold(True)
contour(pcsignalsq, extent=im_extent)
colorbar(IM)
axis('image')
#axvline(candmass)
title(r'$p[\mathrm{candidate}|h(m_1,D)]$')
xlabel(r"$m_1 (M_\odot)$")
ylabel(r"$D (\mathrm{Mpc})$")
savefig("pcsignal.%s" % opts.figure_type)

figure()
palette = cm
IM = imshow(foundsq + missedsq, origin='lower', extent=im_extent,
  interpolation='nearest')
hold(True)
contour(foundsq + missedsq, extent=im_extent)
colorbar(IM)
axis('image')
#axvline(candmass)
title('Number of injections made')
xlabel(r"$m_1 (M_\odot)$")
ylabel(r"$D (\mathrm{Mpc})$")
savefig("made-injections.%s"  % opts.figure_type)

figure()
palette = cm
IM = imshow(foundsq / (foundsq + missedsq + 1.0e-10), origin='lower',
  extent=im_extent, interpolation='nearest')
hold(True)
contour(foundsq / (foundsq + missedsq + 1.0e-10), extent=im_extent)
colorbar(IM)
axis('image')
#axvline(candmass)
title('Fraction of injections found')
xlabel(r"$m_1 (M_\odot)$")
ylabel(r"$D (\mathrm{Mpc})$")
savefig("found-fraction.%s" % opts.figure_type)

if opts.show_plot:
  show()
