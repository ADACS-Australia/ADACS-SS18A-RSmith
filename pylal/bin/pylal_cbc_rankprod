#!/usr/bin/python
#
# Copyright (C) 2011 Thomas Dent
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
##############################################################################
# What this program does or should do:
# 
# reads in clustered single-ifo trigger files; 
# vetoes them;
# histograms them over a chosen detection statistic;
# ranks by their statistic values; 
# for each ifo, stores this ranking in a dictionary keyed on the gps ns time;
# reads in clustered coincidence files;
# calculates the appropriate coincident FAP for each coinc;
# counts the number of coincidences and converts this into a total FAN;
# finds the appropriate livetime and converts FAN into FAR;
# makes an IFAR-like graph;
# outputs details of coincident events in order of significance


from __future__ import division

__prog__ = "pylal_cbc_rankprod"
__title__ = "Ranks CBC events according to a chosen statistic (for single-ifo triggers) or product of single-ifo ranks (for coincs)."

from glue import lal
from glue import segmentsUtils
from glue.ligolw import lsctables
from pylal import InspiralUtils
from pylal import SnglInspiralUtils as sniuls
from pylal import CoincInspiralUtils as coiuls
from pylal import git_version

from optparse import OptionParser
from matplotlib import use
use('Agg')
from pylab import *
import numpy


##############################################################################
# redefine the SnglInspiral columns of interest
##############################################################################
lsctables.SnglInspiralTable.loadcolumns = [
    "ifo",
    "end_time",
    "end_time_ns",
#    "eff_distance",
    "mass1",
    "mass2",
    "mtotal",
    "mchirp",
    "eta",
    "snr",
    "chisq",
    "chisq_dof",
#    "bank_chisq",
#    "bank_chisq_dof",
#    "cont_chisq",
#    "cont_chisq_dof",
#    "rsqveto_duration",
#    "sigmasq",
#    "alpha",
#    "template_duration",
#    "ttotal",
    "event_id",
    "process_id"]


##############################################################################
# Functions #

def get_statistics(sngls, statistic, fac=50., index=6.):
  statistics = {}
  if statistic == "snr":
    for trig in sngls:
      gpsns = 10**9*trig.end_time + trig.end_time_ns
      statistics[gpsns] = [trig.snr, trig.mchirp, trig.eta, None]
  elif statistic == "snr_over_chi":
    for trig in sngls:
      gpsns = 10**9*trig.end_time + trig.end_time_ns
      if not trig.chisq == 0:
        statistics[gpsns] = [trig.snr/trig.chisq**(1./2), trig.mchirp, trig.eta, None]
      else: 
        raise ValueError, "Trigger at end time "+str(gps)+" had a zero chisq value: cannot use snrchi statistic!"
  elif statistic == "effective_snr":
    for trig in sngls:
      gpsns = 10**9*trig.end_time + trig.end_time_ns
      statistics[gpsns] = [trig.get_effective_snr(fac=fac), trig.mchirp, trig.eta, None]
  elif statistic == "new_snr":
    for trig in sngls:
      gpsns = 10**9*trig.end_time + trig.end_time_ns
      statistics[gpsns] = [trig.get_new_snr(index=index), trig.mchirp, trig.eta, None]
  
  statvals = [statistics[gpsns][0] for gpsns in statistics.keys()]
  print >> sys.stdout, "Sorting "+str(len(statvals))+" statistic values..."
  statvals = list(numpy.sort(array(statvals),kind="mergesort"))
  statvals.reverse()
  print >> sys.stdout, "Assigning ranks to statistic values..."
  ranks = {}
  for i,stat in enumerate(statvals):
    # the rank of a stat is the first place it occurs in the sorted 
    # list: note that a given value may appear more than once
    ranks[stat] = 1+i
      #+ (statvals.count(stat)-1)/2  -- bugger, the 
      #FAP calculation relies on having an integer for small values...
  # assign the statistic ranks to their gps ns times
  print >> sys.stdout, "Assigning ranks to gps times..."
  for gpsns in statistics.keys():
    statistics[gpsns][3] = ranks[statistics[gpsns][0]]
  print >> sys.stdout, "Done!"
 
  return statistics, ranks

def calculate_FAP(ranklist,lenlist):
  if len(ranklist) == 2:
    # http://oeis.org/A006218: number of ordered pairs of integers whose product
    # is less than n, valid if the rank product is not greater than the number
    # of triggers in either ifo
    integerseq = (0,1,3,5,8,10,14,16,20,23,27)
    rankprod = ranklist[0]*ranklist[1]
    if rankprod < 10 and min(lenlist) > 9:
      louderprods = integerseq[rankprod]
      jointfap = louderprods/lenlist[0]/lenlist[1]
    elif rankprod < min(lenlist):
    # asymptotic formula for the above
      louderprods = rankprod*(log(rankprod)+2*0.57721-1)
      jointfap = louderprods/lenlist[0]/lenlist[1]
    else:
    # Drew's approximate continuous integral
      fapproduct = ranklist[0]*ranklist[1]/lenlist[0]/lenlist[1]
      jointfap = fapproduct*(1 - log(fapproduct))
  else:
    raise ValueError, "I can't deal with a product of more than 2 ranks. Sorry"

  #print jointfap
  return jointfap

#############################################################################
# Help, options and suchlike #

usage = """
Ranks single-ifo triggers by the chosen statistic and coincs by the product of 
single-ifo ranks. Finally, estimates coincident FAP, FAN and FAR. 

Best results should be obtained by using clustered triggers to mitigate the 
effect of correlations on short time scales.
"""

def parse_command_line():

  parser = OptionParser(usage=usage, version=git_version.verbose_msg)

  parser.add_option("-C","--cache-file",action="store",type="string",
    help="Analysis cache file")
  parser.add_option("-t","--trig-pattern",action="store",type="string",
    help="Sieve for files containing single-ifo triggers")
  parser.add_option("-c","--coinc-pattern",action="store",type="string",
    help="Sieve for files containing coincs")
  parser.add_option("-i","--inj-pattern",action="store",type="string",
    help="Sieve for files containing injections (not implemented yet)")
  parser.add_option("-f","--coinc-file",action="store",type="string",
    help="Coinc file to be ranked")

  parser.add_option("-I","--ifo-list",action="store",type="string",
    help="Comma-separated list of ifos for which events are to be ranked: at present only 2 ifos may be used.")
  parser.add_option("-s","--gps-start-time",action="store",type="int",
    help="When to start considering triggers")
  parser.add_option("-e","--gps-end-time",action="store",type="int",
    help="And when to stop")
  parser.add_option("-V","--veto-files",action="store",type="string",
    help="Comma-separated list of veto files (segwizard format) to be applied to single-ifo triggers")
  parser.add_option("-D","--datatype",action="store",type="string",
    help="What type of data we are ranking. Required")
  parser.add_option("-S","--statistic",action="store",type="string",
    help="Single-ifo ranking statistic: must be snr, snrchi, effective_snr or new_snr")

  parser.add_option("-Z","--user-tag",action="store",type="string",default=None,
    help="a user tag for the output filenames")
  parser.add_option("-G", "--ifo-tag",action="store",type="string",default=None,
    help="sets the IFO tag for plots")
  parser.add_option("-O","--enable-output",action="store_true",default=True,
    help="enable the generation of the html and cache documents")
  parser.add_option("-o","--output-path",action="store",type="string",default="./",
    help="path for figures to be output to")
  parser.add_option("", "--figure-resolution",action="store",type="int",default=50,
    help="resolution of the figure thumbnails (50 dpi by default)")
  parser.add_option("-v","--verbose",action="store_true",default=False,
    help="print extra information")

  (opts,args) = parser.parse_args()

  if not (opts.cache_file and opts.trig_pattern):
    raise ValueError, "A cache and single-ifo trigger pattern must be given!"
  if opts.inj_pattern: 
    raise ValueError, "Sorry, injections are not handled yet."
  if opts.coinc_pattern and opts.coinc_file:
    raise ValueError, "Cannot have both a coinc-pattern and a coinc file!"
  if len(opts.ifo_list.split(","))<1 or len(opts.ifo_list.split(","))>2:
    raise ValueError, "The ifo list must contain either 1 or 2 ifos; 3 or more is not handled yet."
  if not (opts.datatype and opts.datatype in ["full_data","playground","injection"]) :
    raise ValueError, "Please specify a data type (full data, playground or injection)."
  if not (opts.gps_start_time and opts.gps_end_time):
    raise ValueError, "A gps start and end time are required."
  if not (opts.statistic and opts.statistic in ["snr","snrchi","effective_snr","new_snr"]):
    raise ValueError, "A statistic type is required: choose from snr, snrchi, effective_snr, new_snr."  

  return opts, sys.argv[1:]


##############################################################################
# MAIN #

opts, args = parse_command_line()
opts = InspiralUtils.initialise(opts,__prog__,git_version.verbose_msg)

ifocolors = InspiralUtils.colors
fnameList = []   # use for the cache file
tagList= []   # use for the cache file
comments = ""  # for the html output if needed

ifos = tuple(opts.ifo_list.split(","))

if opts.veto_files:
  comments += InspiralUtils.message(opts, "Veto files are "+opts.veto_files)

comments += InspiralUtils.message(opts, "Statistic is "+opts.statistic+"\n")

allCache = lal.Cache.fromfile(open(opts.cache_file))

coincFiles = []
if opts.coinc_pattern:
  # Specify exact match because otherwise THINCA_SECOND_H1L1_FULL_DATA would pick up
  # *FULL_DATA_CAT_*_VETO as well
  coinc_cache = allCache.sieve(description=opts.coinc_pattern, exact_match=True)
  found, missed = coinc_cache.checkfilesexist()
  coincFiles = found.pfnlist()
  if not len(coincFiles):
    print >>sys.stderr, "WARNING: No file in %s matches the coinc_pattern '%s'." % (opts.cache_file, opts.coinc_pattern)
  # filter coinc files such that the start time is before the selected gps end time
  # and the end time is after the selected gps start time
  coincFiles = [ file for file in coincFiles if int(file.split("-")[-2]) <= opts.gps_end_time and \
    int(file.split("-")[-2])+int(file.split("-")[-1].split(".")[0]) >= opts.gps_start_time ]
if opts.coinc_file:
  coincFiles = [opts.coinc_file]

trigFiles = {}
vetofiles = {}
statistics = {}
ranks = {}
fig_num = 0
haveTrigs = False

# Read in single inspiral files

for ifo in ifos:
  # each entry in the statistics dictionary is a dictionary keyed on the trigger gps time in ns
  statistics[ifo] = {}
  ranks[ifo] = {}
  if opts.veto_files:
    # this is a way to assign veto files to ifos, somewhat kludgey, relying on the ifo name
    # being in the path to the file
    vetofiles[ifo] = [file for file in opts.veto_files.split(",") if file.find(ifo+"-")>-1]
  else:
    vetofiles[ifo] = []
  trig_cache = allCache.sieve(description=opts.trig_pattern, ifos=ifo)
  found, missed = trig_cache.checkfilesexist()
  trigFiles[ifo] = found.pfnlist()
  # filter the files such that the start time is before the selected gps end time
  # and the end time is after the selected gps start time
  trigFiles[ifo] = [ file for file in trigFiles[ifo] if int(file.split("-")[-2]) <= opts.gps_end_time and \
    int(file.split("-")[-2])+int(file.split("-")[-1].split(".")[0]) >= opts.gps_start_time ]

  # Read triggers
  if not len(trigFiles[ifo]):
    print >>sys.stderr, "WARNING: No file in %s for ifo %s matches the trig_pattern '%s'" % (opts.cache_file, ifo, opts.trig_pattern)
    trigFiles[ifo] = None
  else:
    print >>sys.stdout, "Reading "+str(len(trigFiles[ifo]))+" files for ifo "+ifo+" with the pattern "+opts.trig_pattern
    comments += InspiralUtils.message(opts, "Reading "+str(len(trigFiles[ifo]))+" files for ifo "+ifo+" with the pattern "+opts.trig_pattern)
    snglTrigs = sniuls.ReadSnglInspiralFromFiles(trigFiles[ifo], verbose=opts.verbose)
    if len(snglTrigs):
      snglTrigs.ifocut(ifo, inplace=True) # do this in case single-ifo triggers are being read in from COIREs
      comments += InspiralUtils.message(opts, "Read %d triggers from %s" % (len(snglTrigs), ifo) )
      snglTrigsinTime = lsctables.New(lsctables.SnglInspiralTable)
      for trig in snglTrigs:
        if trig.end_time >= opts.gps_start_time and trig.end_time < opts.gps_end_time:
          snglTrigsinTime.append(trig) 
      #buggy when vetoing! snglTrigsinTime = [trig for trig in snglTrigs if trig.end_time >= opts.gps_start_time and trig.end_time < opts.gps_end_time]
      del snglTrigs
      comments += InspiralUtils.message(opts, "%d triggers lie within GPS %d to %d" % (len(snglTrigsinTime), \
        opts.gps_start_time, opts.gps_end_time) )
      if len(snglTrigsinTime):
        haveTrigs = True
      # apply the vetoes
      if vetofiles[ifo]:
        for vfile in vetofiles[ifo]:
          comments += InspiralUtils.message(opts, "Applying vetos from "+vfile)
          seglist = segmentsUtils.fromsegwizard(open(vfile))
          snglTrigsinTime = snglTrigsinTime.veto(seglist)
          comments += InspiralUtils.message(opts, "%d remain in %s after vetoing" % (len(snglTrigsinTime), ifo))
      statistics[ifo],ranks[ifo] = get_statistics(snglTrigsinTime, statistic=opts.statistic)
    else:
      comments += InspiralUtils.message(opts, "No triggers were found in the files for "+ifo+"!")
    del snglTrigsinTime

  if len(statistics[ifo]):

    # make a plot of statistic vs. time
    trigtitle = ifo+" "+opts.trig_pattern+" triggers"
    gpsns = statistics[ifo].keys()
    statvalues = array([statistics[ifo][time][0] for time in gpsns])
    fig_num +=1
    figure(fig_num)
    if opts.statistic == 'snr':
      semilogy(array([time/10**9-opts.gps_start_time for time in gpsns]), \
        array([statistics[ifo][time][0] for time in gpsns]), '+', markersize=10, color=ifocolors[ifo])
    else:
      plot(array([time/10**9-opts.gps_start_time for time in gpsns]), \
        array([statistics[ifo][time][0] for time in gpsns]), '+', markersize=10, color=ifocolors[ifo])
    grid(True)
    ylim(0.9*min(statvalues),1.1*max(statvalues))
    xlabel(r"Time after start of experiment (s)",size="x-large")
    ylabel(r"Statistic value "+opts.statistic,size="x-large")
    title(trigtitle,size="large")
    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, ifo+"_"+opts.statistic+"_vs_time")
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append(ifo+"_statistic_vs_time")
    close(fig_num)

    # and a histogram of statistic
    fig_num +=1
    figure(fig_num)
    bins = arange(0.98*min(statvalues),1.02*max(statvalues),(1.02*max(statvalues)-0.98*min(statvalues))/50)
    counts, edges = histogram(statvalues, bins=bins, new=True)
    cum_counts = counts[::-1].cumsum()[::-1]
    semilogy(0.5*(edges[1:]+edges[:-1]), cum_counts, '-+', color=ifocolors[ifo])
    grid(True)
    ylim(0.5,2*len(statvalues))
    xlim(min(statvalues),1.02*max(statvalues))
    xlabel(r"Statistic value "+opts.statistic,size="x-large")
    ylabel(r"Cumulative number",size="x-large")
    title(trigtitle,size="large")
    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, ifo+"_"+opts.statistic+"_cum_hist")
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append(ifo+"_statistic_cum_hist")
    close(fig_num)

    # and a plot of rank vs. statistic
    fig_num +=1
    figure(fig_num)
    semilogy(statvalues, array([ranks[ifo][stat] for stat in statvalues]), '.', color=ifocolors[ifo])
    grid(True)
    xlabel(r"Statistic value "+opts.statistic,size="x-large")
    ylabel(r"Trigger rank",size="x-large")
    ylim(0.5,2*len(statvalues))
    title(trigtitle,size="large")
    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, ifo+"_"+opts.statistic+"_rank")
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append(ifo+"_statistic_rank")
    close(fig_num)

if not haveTrigs:
  raise ValueError, "No triggers were found; I cannot continue"

# read coinc files: these should already be vetoed by thinca to the desired level

if (opts.coinc_pattern or opts.coinc_file) and len(coincFiles):
  if opts.coinc_pattern:
    print >>sys.stdout, "Reading "+str(len(coincFiles))+" files with the pattern "+opts.coinc_pattern
    comments += InspiralUtils.message(opts, "")
    comments += InspiralUtils.message(opts, "Reading "+str(len(coincFiles))+" files with the pattern "+opts.coinc_pattern)
  else:
    comments += InspiralUtils.message(opts, "Reading coincs from "+opts.coinc_file)
  # we don't use the coinc statistic calculated by the coiuls module
  coincEvents = coiuls.readCoincInspiralFromFiles(coincFiles, coiuls.coincStatistic("snr"))
  if len(coincEvents) == 0: 
    numCoincs = 0
  coincEvents = coincEvents[0]
  comments += InspiralUtils.message(opts, str(len(coincEvents))+" coincident events were found")

  # get the single-ifo ranks and calculate the joint FAPs and FANs
  if len(coincEvents):
    coincFAPs = []
    ranklengths = [len(ranks[ifo]) for ifo in ifos]
    coincEventsinTime = []
    for coinc in coincEvents:
      ranklist = []
      inTime = True
      for ifo in ifos:
        endTime = getattr(coinc,ifo).end_time
        if endTime >= opts.gps_start_time and endTime < opts.gps_end_time:
          gpsns = 10**9*endTime + getattr(coinc,ifo).end_time_ns
          ranklist.append(statistics[ifo][gpsns][3])
        else:
          inTime = False
      if len(ranklist) and inTime:
        coincFAPs.append(calculate_FAP(ranklist,ranklengths))
        coincEventsinTime.append(coinc)
    numCoincs = len(coincEventsinTime)
    if numCoincs:
      comments += InspiralUtils.message(opts, str(numCoincs)+" events lie within the specified GPS start and end times")
      coincFANs = [FAP*numCoincs for FAP in coincFAPs]
    else:
      comments += InspiralUtils.message(opts, "No coincident events fell within the specified\
        GPS start and end times!")
    #print coincFANs

    # order the coincs by FAN
    sortedCoincEvents = coiuls.coincInspiralTable()
    fan_coinc_list = zip(coincFANs,[coinc for coinc in coincEventsinTime])
    fan_coinc_list.sort()
    sortedCoincEvents = [coinc for (coincFAN,coinc) in fan_coinc_list]
    sortedFANs = [coincFAN for (coincFAN,coinc) in fan_coinc_list]

    # make an IFAN graph
    fig_num +=1
    figure(fig_num)
    loglog(array(sortedFANs)**-1,arange(1,len(sortedFANs)+1),'bv',markersize=10,markeredgecolor=None)
    grid(True)
    ylim(0.9,1.5*numCoincs)
    xlabel(r"1/FAN",size="x-large")
    ylabel("Cumulative number",size="x-large")
    title(opts.ifo_tag,size="large")
    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, "coinc_IFAN")
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append("coinc_ifan")
    close(fig_num)
  
    for i,coinc in enumerate(sortedCoincEvents):
      if i < 20:
        coincgps = []
        ranklist = []
        for ifo in ifos:
          gpsns = 10**9*getattr(coinc,ifo).end_time + getattr(coinc,ifo).end_time_ns
          coincgps.append(gpsns)
          ranklist.append(statistics[ifo][gpsns][3])
        gps = sum(coincgps)/coinc.numifos /10**9
        mchirp = sum([getattr(coinc,ifo).mchirp for ifo in ifos])/coinc.numifos
        snrs = [getattr(coinc,ifo).snr for ifo in ifos]
        chisqs = [getattr(coinc,ifo).chisq for ifo in ifos]
        comments += InspiralUtils.message(opts, "")
        comments += InspiralUtils.message(opts, "Coinc with rank %d: FAN = %.3G, triggers\
          ranked (%d,%d) in (%s,%s)" % (i+1, sortedFANs[i], ranklist[0], ranklist[1], ifos[0], ifos[1]) )
        comments += InspiralUtils.message(opts, "GPS time %.3f  chirp mass %.2f  SNR (%.2f,%.2f),\
          chisq (%.1f,%.1f) in (%s,%s)" % (gps, mchirp, snrs[0], snrs[1], chisqs[0], chisqs[1], ifos[0], ifos[1]) )

# finalize

html_filename = InspiralUtils.write_html_output(opts, args, fnameList, \
      tagList, comment=comments)
InspiralUtils.write_cache_output(opts, html_filename, fnameList)

print >> sys.stdout, "Finished!"
