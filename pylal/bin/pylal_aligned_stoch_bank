#!/usr/bin/env python

# Copyright (C) 2011 Ian W. Harry
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
Stochastic aligned spin bank generator.
"""

from __future__ import division
import matplotlib
matplotlib.use('Agg')
import pylab
import time
start = int(time.time()*10**6)
elapsed_time = lambda: int(time.time()*10**6-start)

import os,sys,optparse
import tempfile
import ConfigParser
import numpy
from pylal import geom_aligned_bank_utils,git_version
from glue import pipeline

__author__  = "Ian Harry <ian.harry@astro.cf.ac.uk>"
__version__ = "git id %s" % git_version.id
__date__    = git_version.date

# Read command line options
usage = """usage: %prog [options]"""
_desc = __doc__[1:]
parser = optparse.OptionParser(usage, version=__version__, description=_desc)
parser.add_option("-v", "--verbose", action="store_true", default=False,\
                    help="verbose output, default: %default")
parser.add_option("-a", "--psd-file", action="store", type="string",\
                   default=None,\
                   help="ASCII file containing the PSD.")
parser.add_option("-o", "--pn-order", action="store", type="string",\
                   default=None,\
                   help="""Determines the PN order to use, choices are:
    * "twoPN": will include spin and non-spin terms up to 2PN in phase
    * "threePointFivePN": will include non-spin terms to 3.5PN, spin to 2.5PN
    * "taylorF4_45PN": use the R2D2 metric with partial terms to 4.5PN""")
parser.add_option("-f", "--f0", action="store", type="float",\
                  default=70., help="f0 for use in metric calculation," +\
                                    "default: %default")
parser.add_option("-l", "--f-low", action="store", type="float",\
                  default=15., help="f_low for use in metric calculation," +\
                                    "default: %default")
parser.add_option("-u", "--f-upper", action="store", type="float",\
                  default=2000., help="f_up for use in metric calculation," +\
                                      "default: %default")
parser.add_option("-d", "--delta-f", action="store", type="float",\
                  default=0.001, help="delta_f for use in metric calculation,"+\
                                      "linear interpolation used to get this,"+\
                                      "default: %default")
parser.add_option("-m", "--min-match", action="store", type="float",\
                  default=0.03, help="Minimum match to generate bank with"+\
                                      "default: %default")
parser.add_option("-y", "--min-mass1", action="store", type="float",\
                  default=0.03, help="Minimum mass1 to generate bank with"+\
                                     ", mass1 *must* be larger than mass2" +\
                                      "default: %default")
parser.add_option("-Y", "--max-mass1", action="store", type="float",\
                  default=0.03, help="Maximum mass1 to generate bank with"+\
                                      "default: %default")
parser.add_option("-z", "--min-mass2", action="store", type="float",\
                  default=0.03, help="Minimum mass2 to generate bank with"+\
                                      "default: %default")
parser.add_option("-Z", "--max-mass2", action="store", type="float",\
                  default=0.03, help="Maximum mass2 to generate bank with"+\
                                      "default: %default")
parser.add_option("-x", "--max-ns-spin-mag", action="store", type="float",\
                  default=0.03, help="Maximum neutron star spin magnitude"+\
                                      "default: %default")
parser.add_option("-X", "--max-bh-spin-mag", action="store", type="float",\
                  default=0.03, help="Maximum black hole spin magnitude"+\
                                      "default: %default")
parser.add_option("-n", "--nsbh-flag", action="store_true", default=False,\
                    help="Set this if running with NSBH, default: %default")

(opts,args) = parser.parse_args()

opts.min_total_mass = opts.min_mass1 + opts.min_mass2
opts.max_total_mass = opts.max_mass1 + opts.max_mass2
opts.min_comp_mass = opts.min_mass2
opts.max_comp_mass = opts.max_mass2
opts.split_bank_num = 100

# This could be altered to do an exact match if desired
def dist(vsA,entryA,MMdistA):
  val = (vsA[0] - entryA[0])**2
  for i in range(1,len(vsA)):
    val += (vsA[i] - entryA[i])**2
  return (numpy.sqrt(val) < MMdistA)

# Begin by calculating a metric
evals,evecs = geom_aligned_bank_utils.determine_eigen_directions(opts.psd_file,\
    opts.pn_order,opts.f0,opts.f_low,opts.f_upper,opts.delta_f,\
    verbose=opts.verbose,elapsed_time=elapsed_time)

if opts.verbose:
  print >>sys.stdout, "Calculating covariance matrix at %d." %(elapsed_time())

vals = geom_aligned_bank_utils.estimate_mass_range_slimline(1000000,\
       opts.pn_order,evals['fixed'],evecs['fixed'],opts.max_mass1,\
       opts.min_mass1,opts.max_mass2,opts.min_mass2,\
       opts.max_ns_spin_mag,opts.f0,\
       covary=False,maxBHspin=opts.max_bh_spin_mag)
cov = numpy.cov(vals)
evalsCV,evecsCV = numpy.linalg.eig(cov)

if opts.verbose:
  print>> sys.stdout, "Covariance matrix calculated at %d." %(elapsed_time())

vals = geom_aligned_bank_utils.estimate_mass_range_slimline(1000000,\
       opts.pn_order,evals['fixed'],evecs['fixed'],opts.max_mass1,\
       opts.min_mass1,opts.max_mass2,opts.min_mass2,\
       opts.max_ns_spin_mag,opts.f0,\
       covary=True,evecsCV=evecsCV,maxBHspin=opts.max_bh_spin_mag)

chi1Max = vals[0].max()
chi1Min = vals[0].min()
chi1Diff = chi1Max - chi1Min
chi2Max = vals[1].max()
chi2Min = vals[1].min()
chi2Diff = chi2Max - chi2Min
chi1Min = chi1Min - 0.05*chi1Diff
chi1Max = chi1Max + 0.05*chi1Diff
chi2Min = chi2Min - 0.05*chi2Diff
chi2Max = chi2Max + 0.05*chi2Diff

vals = None

# Set up the bank into sections
massbank = []
bank = {}
MMdist = (opts.min_match)**0.5
for i in range(int((chi1Max - chi1Min) // MMdist)):
  bank[i] = {}
  for j in range(int((chi2Max - chi2Min) // MMdist)):
    bank[i][j] = []

maxi = int((chi1Max - chi1Min) // MMdist)
maxj = int((chi2Max - chi2Min) // MMdist)
# Initialise counters
N = 0
Np = 0
Ns = 0

# Begin making the thing
outbins = [[0,0],[0,1],[1,0],[0,-1],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]
while(1):
  if not (Ns % 100000):
    rTotmass,rEta,rBeta,rSigma,rGamma,rSpin1z,rSpin2z =\
        geom_aligned_bank_utils.get_random_mass_slimline(\
        100000,opts.min_mass1,opts.max_mass1,opts.min_mass2,opts.max_mass2,\
        opts.max_ns_spin_mag,maxBHspin = opts.max_bh_spin_mag,return_spins=True)
    diff = (rTotmass*rTotmass * (1-4*rEta))**0.5
    rMass1 = (rTotmass + diff)/2.
    rMass2 = (rTotmass - diff)/2.
    rChis = (rSpin1z + rSpin2z)/2.
    vecs = geom_aligned_bank_utils.get_cov_params(rTotmass,rEta,rBeta,rSigma,\
        rGamma,rChis,opts.f0,evecs['fixed'],evals['fixed'],evecsCV,opts.pn_order)
      
    vecs = numpy.array(vecs)
    Ns = 0
  if not (Np % 10000) and opts.verbose:
    print "Seeds",Np
  vs = vecs[:,Ns]
  v1Bin = int((vs[0] - chi1Min) // MMdist)
  v2Bin = int((vs[1] - chi2Min) // MMdist)
  store = True
  Np = Np + 1
  for i,j in outbins:
    if store:
      for entry in bank[v1Bin+i][v2Bin+j]:
        if dist(vs,entry,MMdist):
          store = False
          break
  if not store:
    Ns = Ns + 1
    continue
  bank[v1Bin][v2Bin].append([vs[0],vs[1],vs[2],vs[3],vs[4],vs[5],vs[6],vs[7]])
  massbank.append([rMass1[Ns],rMass2[Ns],rSpin1z[Ns],rSpin2z[Ns]])
  N = N + 1
  if not (N % 100000):
    print "Templates",N
  if Np > 100000000:
    break
  Ns = Ns + 1  

outfile=open('stochastic_bank_mass.dat','w')
outfile2=open('stochastic_bank_evs.dat','w')

for i in range(int((chi1Max - chi1Min) // MMdist)):
  for j in range(int((chi2Max - chi2Min) // MMdist)):
    for entry in bank[i][j]:
      outfile2.write('%.16e %.16e %.16e %.16e %.16e %.16e %.16e %.16e\n' %(entry[0],entry[1],entry[2],entry[3],entry[4],entry[5],entry[6],entry[7]))
outfile2.close()

for masses in massbank:
  outfile.write('%.16e %.16e %.16e %.16e\n' %(masses[0],masses[1],masses[2],masses[3]))
outfile.close()

  
