#!/usr/bin/python
#
# Copyright (C) 2009  Drew Keppel
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import math
import matplotlib
matplotlib.rcParams.update({
	"font.size": 8.0,
	"axes.titlesize": 10.0,
	"axes.labelsize": 10.0,
	"xtick.labelsize": 8.0,
	"ytick.labelsize": 8.0,
	"legend.fontsize": 8.0,
	"figure.dpi": 400,
	"savefig.dpi": 400,
	"text.usetex": True,
	"path.simplify": True
})
from matplotlib import figure
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
try:
	from matplotlib.transforms import offset_copy
except:
	# FIXME: wrong matplotlib version, disable this feature;  figure
	# out how to do this portably later.
	pass
import numpy
from optparse import OptionParser
try:
	import sqlite3
except ImportError:
	# pre 2.5.x
	from pysqlite2 import dbapi2 as sqlite3
import sys

from glue import lal
from glue.ligolw import table
from glue.ligolw import dbtables
from pylal import git_version

__author__ = "Drew Keppel <drew.keppel@ligo.org>"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "Name: %%prog\n%s" % git_version.verbose_msg
	)
	parser.add_option("-b", "--base", metavar = "base", default = "cbc_plotroc", help = "Set the prefix for output filenames (default = \"cbc_plotroc\")")
	parser.add_option("-f", "--format", metavar = "{\"png\",\"pdf\",\"svg\",\"eps\",...}", action = "append", default = ["png"], help = "Set the output image format.  Can be given multiple times (default = \"png\")")
	parser.add_option("-c", "--add-cache", metavar = "file.cache", action = "append", default = [], help = "Cache file containing injection sqlite files for plotting ROC curves")
	parser.add_option("-l", "--add-label", metavar = "label", action = "append", default = [], help = "Label for plotting ROC curve.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	if len(filenames):
		print >> sys.stderr, "Error: No filenames should be given as arguments."
		sys.exit(1)

	return options


#
# =============================================================================
#
#                                   Database
#
# =============================================================================
#


class CoincDatabase(object):
	def __init__(self, connection, verbose = False):
		"""
		Compute and record some summary information about the
		database.
		"""

		self.connection = connection
		xmldoc = dbtables.get_xml(connection)

		cursor = connection.cursor()

		# find the tables
		try:
			self.sngl_inspiral_table = table.get_table(xmldoc, dbtables.lsctables.SnglInspiralTable.tableName)
		except ValueError:
			self.sngl_inspiral_table = None
		try:
			self.sim_inspiral_table = table.get_table(xmldoc, dbtables.lsctables.SimInspiralTable.tableName)
		except ValueError:
			self.sim_inspiral_table = None
		try:
			self.coinc_def_table = table.get_table(xmldoc, dbtables.lsctables.CoincDefTable.tableName)
			self.coinc_table = table.get_table(xmldoc, dbtables.lsctables.CoincTable.tableName)
			self.time_slide_table = table.get_table(xmldoc, dbtables.lsctables.TimeSlideTable.tableName)
		except ValueError:
			self.coinc_def_table = None
			self.coinc_table = None
			self.time_slide_table = None
		try:
			self.coinc_inspiral_table = table.get_table(xmldoc, dbtables.lsctables.CoincInspiralTable.tableName)
		except ValueError:
			self.coinc_inspiral_table = None

		# determine a few coinc_definer IDs
		# FIXME:  don't hard-code the numbers
		if self.coinc_def_table is not None:
			try:
				self.ii_definer_id = self.coinc_def_table.get_coinc_def_id("inspiral", 0, create_new = False)
			except KeyError:
				self.ii_definer_id = None
			try:
				self.si_definer_id = self.coinc_def_table.get_coinc_def_id("inspiral", 1, create_new = False)
			except KeyError:
				self.si_definer_id = None
			try:
				self.sc_definer_id = self.coinc_def_table.get_coinc_def_id("inspiral", 2, create_new = False)
			except KeyError:
				self.sc_definer_id = None
		else:
			self.ii_definer_id = None
			self.si_definer_id = None
			self.sc_definer_id = None

		# verbosity
		if verbose:
			print >>sys.stderr, "database overview:"
			if self.sngl_inspiral_table is not None:
				print >>sys.stderr, "\tinspiral events: %d" % len(self.sngl_inspiral_table)
			if self.sim_inspiral_table is not None:
				print >>sys.stderr, "\tinjections: %d" % len(self.sim_inspiral_table)
			if self.time_slide_table is not None:
				print >>sys.stderr, "\ttime slides: %d" % cursor.execute("SELECT COUNT(DISTINCT(time_slide_id)) FROM time_slide").fetchone()[0]
			if self.coinc_def_table is not None:
				for description, n in cursor.execute("SELECT description, COUNT(*) FROM coinc_definer NATURAL JOIN coinc_event GROUP BY coinc_def_id"):
					print >>sys.stderr, "\t%s: %d" % (description, n)

#
# =============================================================================
#
#                                  Utilities
#
# =============================================================================
#


def create_plot(x_label = None, y_label = None, width = 165.0, aspect = (1 + math.sqrt(5)) / 2):
	fig = figure.Figure()
	FigureCanvas(fig)
	fig.set_size_inches(width / 25.4, width / 25.4 / aspect)
	axes = fig.gca()
	axes.grid(True)
	if x_label is not None:
		axes.set_xlabel(x_label)
	if y_label is not None:
		axes.set_ylabel(y_label)
	return fig, axes



#
# =============================================================================
#
#                              ROC Plots
#
# =============================================================================
#

class ROCPlots(object):
	def __init__(self):
		self.stats = {}

	def add_contents(self,label,contents):
		if contents.sim_inspiral_table:
			for far, distance in contents.connection.cursor().execute("""
SELECT
	coinc_inspiral.combined_far,
	-- Work out the correction factor for injection population distances
	CASE (SELECT value FROM process_params WHERE program =="inspinj" AND param =="--d-distr")
		WHEN "log10" THEN  sim_inspiral.distance * sim_inspiral.distance * sim_inspiral.distance
		WHEN "linear" THEN  sim_inspiral.distance * sim_inspiral.distance
		ELSE 1.0 END
FROM
	coinc_event
	JOIN coinc_inspiral ON (
		coinc_inspiral.coinc_event_id == coinc_event.coinc_event_id
	)
	JOIN coinc_event_map AS mapA ON (mapA.event_id == coinc_event.coinc_event_id AND mapA.table_name == "coinc_event")
	JOIN coinc_event_map AS mapB ON (mapB.coinc_event_id == mapA.coinc_event_id AND mapB.table_name == "sim_inspiral")
	JOIN sim_inspiral ON (mapB.event_id == sim_inspiral.simulation_id)
WHERE
	-- require coinc to not be background (= at least one of its time slide offsets is non-zero)
	-- FIXME this has to call a function to get coinc_def id
	NOT EXISTS (
		SELECT
			*
		FROM
			time_slide
		WHERE
			time_slide.time_slide_id == coinc_event.time_slide_id
			AND time_slide.offset != 0
	)
			"""):
				self.stats.setdefault(label,[]).append((far, distance))

	def finish(self):
		norm = 0
		for label in self.stats.keys():
			norm = max(sum([x[1] for x in self.stats[label]]), norm)
		for label in self.stats.keys():
			self.stats[label] = [(x[0],x[1]/norm) for x in self.stats[label]]
			self.stats[label].sort()
		fig, axes = create_plot(r"False Alarm Rate", r"Relative Volume", aspect = 1.0, width=100)
		axes.hold(1)
		for label in self.stats.keys():
			axes.semilogx([x[0] for x in self.stats[label]], numpy.cumsum([x[1] for x in self.stats[label]]), label=label)
		axes.set_ylim(0,1)
		axes.legend(loc='lower right')
		axes.hold(0)
		return fig, "ROC"

#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# Parse command line
#


options = parse_command_line()


#
# Process files
#

plot = ROCPlots()

for n, (label, cachename) in enumerate(zip(options.add_label, options.add_cache)):
	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(options.add_cache), cachename)
	filenames = [lal.CacheEntry(line).path() for line in file(cachename)]

	for m, filename in enumerate(filenames):
		if options.verbose:
			print >>sys.stderr, "%d/%d: %s" % (n + 1, len(options.add_cache), cachename)
			print >>sys.stderr, "%d/%d: %s" % (m + 1, len(filenames), filename)
		working_filename = dbtables.get_connection_filename(filename, verbose = options.verbose)
		connection = sqlite3.connect(working_filename)
		contents = CoincDatabase(connection, verbose = options.verbose)
		plot.add_contents(label, contents)
		connection.close()
		dbtables.discard_connection_filename(filename, working_filename, verbose = options.verbose)


#
# Finish and write plots, deleting them as we go to save memory
#


filename_template = "%s_%s.%s"
fig, filename_fragment = plot.finish()
for format in options.format:
	filename = filename_template % (options.base, filename_fragment, format)
	if options.verbose:
		print >>sys.stderr, "writing %s ..." % filename
	fig.savefig(filename)
