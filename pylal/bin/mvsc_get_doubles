#!/usr/bin/python
try:
	import sqlite3
except ImportError:
	# pre 2.5.x
	from pysqlite2 import dbapi2 as sqlite3
from glue.ligolw import dbtables 
from glue.ligolw import table
from glue.ligolw import ilwd
from glue import segments
from pylal.xlal import tools as xlaltools
from pylal.xlal.datatypes import snglinspiraltable
from pylal import SnglInspiralUtils
from pylal import db_thinca_rings
from pylal import git_version
from pylal import mvsc_queries
from time import clock,time
from optparse import *
import glob
import sys
import random

from pylal import ligolw_thinca
usage="""
example command line:
%prog --instruments=H1,L1 database1.sqlite database2.sqlite etc.
or, if you are brave:
%prog --instruments=H1,L1 *.sqlite
this code turns sqlite databases into .pat files for MVSC
each row in the .pat file contains a vector of parameters that characterize the double coincident trigger
"""

__author__ = "Kari Hodge <khodge@ligo.caltech.edu>"

parser=OptionParser(usage=usage,version=git_version.verbose_msg)
parser.add_option("", "--number", default=10, type="int", help="number for round robin")
parser.add_option("", "--instruments", help="pair that you want to get like H1,L1")
parser.add_option("", "--factor", default=50.0, type="float", help="the value of the magic number factor in the effective snr formula, should be 50 for highmass and 250 for lowmass")
parser.add_option("", "--output-tag", default="", help="a string added to all filenames to help you keep track of things") 
parser.add_option("", "--apply-weights", default=False, help="calculates weight for all found injections, saves in .pat file (all bkg events get weight=1), if this option is not supplied, all events get a weight of 1, so still use -a 4 in the Spr* executables")
(opts,databases)=parser.parse_args()
ifos=opts.instruments.strip().split(',')
ifos.sort()

time1=time()


class SnglInspiral(snglinspiraltable.SnglInspiralTable):
	"""
	You need to make this subclass of xlaltools.SnglInspiralTable because the C version doesn't have the methods 
	you need to slide the triggers on the ring, which you need to do for a correct calculation of ethinca
	"""
	__slots__ = ()

	def get_end(self):
		return dbtables.lsctables.LIGOTimeGPS(self.end_time, self.end_time_ns)

	def set_end(self, gps):
		self.end_time, self.end_time_ns = gps.seconds, gps.nanoseconds

dbtables.lsctables.SnglInspiralTable.RowType = SnglInspiral

parameters = mvsc_queries.CandidateEventQuery.parameters
print "your MVSC analysis will use the following dimensions: "+parameters
 
injections = {}
injections_info = {}
normalization = {}
zerolag = []
zerolag_info = []
timeslides = []
timeslides_info = []

for database in databases:
	local_disk = None #"/tmp"
	working_filename = dbtables.get_connection_filename(database, tmp_path = local_disk, verbose = True)
	connection = sqlite3.connect(working_filename)
	dbtables.DBTable_set_connection(connection)
	xmldoc = dbtables.get_xml(connection)
	cursor = connection.cursor()
	num_sngl_cols = len(table.get_table(xmldoc, dbtables.lsctables.SnglInspiralTable.tableName).dbcolumnnames)
	rings = db_thinca_rings.get_thinca_rings_by_available_instruments(connection)
	offset_vectors = dbtables.lsctables.table.get_table(dbtables.get_xml(connection), dbtables.lsctables.TimeSlideTable.tableName).as_dict()
	sngl_inspiral_row_from_cols = table.get_table(xmldoc, dbtables.lsctables.SnglInspiralTable.tableName).row_from_cols
	def calc_effective_snr(snr, chisq, chisq_dof, fac=opts.factor):
		return snr/ (1 + snr**2/fac)**(0.25) / (chisq/(2*chisq_dof - 2) )**(0.25)
	
	def calc_ethinca(rowA,rowB,time_slide_id,rings=rings,offset_vectors=offset_vectors):
		flatrings = segments.segmentlist()
		for value in rings.values():
			flatrings.extend(value)
		rowA = sngl_inspiral_row_from_cols(rowA)
		SnglInspiralUtils.slideTriggersOnRings([rowA],flatrings,offset_vectors[time_slide_id])
		rowB = sngl_inspiral_row_from_cols(rowB)
		SnglInspiralUtils.slideTriggersOnRings([rowB],flatrings,offset_vectors[time_slide_id])
		return xlaltools.XLALCalculateEThincaParameter(rowA,rowB)
	
	def calc_delta_t(trigger1_ifo, trigger1_end_time, trigger1_end_time_ns, trigger2_ifo, trigger2_end_time, trigger2_end_time_ns, time_slide_id, rings = rings, offset_vectors = offset_vectors):
		time_slide_id = ilwd.get_ilwdchar(time_slide_id)
		trigger1_true_end_time = dbtables.lsctables.LIGOTimeGPS(trigger1_end_time, trigger1_end_time_ns)
		trigger2_true_end_time = dbtables.lsctables.LIGOTimeGPS(trigger2_end_time, trigger2_end_time_ns)
		# find the instruments that were on at trigger 1's end time and
		# find the ring that contains this trigger
		try:
			[ring] = [segs[segs.find(trigger1_end_time)] for segs in rings.values() if trigger1_end_time in segs]
		except ValueError:
			# FIXME THERE SEEMS TO BE A BUG IN	THINCA!	Occasionally thinca records a trigger on the upper boundary
			# of its ring.	This would make it outside the ring which is very problematic.	It needs to be fixed in thinca
			# for now we'll allow the additional check that the other trigger is in the ring and use it.
				print >>sys.stderr, "trigger1 found not on a ring, trying trigger2"
				[ring] = [segs[segs.find(trigger2_end_time)] for segs in rings.values() if trigger2_end_time in segs]
		# now we can unslide the triggers on the ring
		try:
			trigger1_true_end_time = SnglInspiralUtils.slideTimeOnRing(trigger1_true_end_time, offset_vectors[time_slide_id][trigger1_ifo], ring)
			trigger2_true_end_time = SnglInspiralUtils.slideTimeOnRing(trigger2_true_end_time, offset_vectors[time_slide_id][trigger2_ifo], ring)
			out = abs(trigger1_true_end_time - trigger2_true_end_time)
			return float(out)
		except:
			print >> sys.stderr, "calc delta t failed because one of the trigger's true end times landed on the upper boundary of the thinca ring. See: trigger 1: ", trigger1_true_end_time, "trigger 2: ", trigger2_true_end_time, "ring: ", ring
			out = float(abs(trigger1_true_end_time - trigger2_true_end_time)) % 1
			if out > 0.5:
				out = 1.0 - out
			print >> sys.stderr, "SO...delta t has been set to: ", out, "in accordance with the mod 1 hack"
			return out
	connection.create_function("calc_delta_t", 7, calc_delta_t)
	connection.create_function("calc_effective_snr", 3, calc_effective_snr)
# in S6, the timeslides, zerolag, and injections are all stored in the same sqlite database, thus this database must include a sim inspiral table
# if you provide a database that does not include injections, the code will still run as long as one of the databases you provide includes injections 
	try:
		sim_inspiral_table = table.get_table(xmldoc, dbtables.lsctables.SimInspiralTable.tableName)
		is_injections = True
	except ValueError:
		is_injections = False

	if is_injections:
# get the names of each injection run, so that we can normalize the weights given to the triggers
		for injset in connection.cursor().execute("""
			SELECT
				value
			FROM
				process_params
			WHERE
				program = 'inspinj'
				AND param == '--userTag'
			"""): 
				injset = str(injset[0])
				normalization[injset]=0
				injections[injset]=[]
				injections_info[injset]=[]
				for values in connection.cursor().execute(''.join([mvsc_queries.CandidateEventQuery.select_dimensions,mvsc_queries.CandidateEventQuery.add_join_injections]), (ifos[0],ifos[1],injset,) ):
						normalization[injset]=normalization[injset]+values[-1]
						injections[injset].append((calc_ethinca(values[1:num_sngl_cols+1],values[num_sngl_cols+1:2*num_sngl_cols+1],ilwd.get_ilwdchar(values[2*num_sngl_cols+1]),rings,offset_vectors,),) + values[2*num_sngl_cols+2:] + (1,))
						injections_info[injset].append([values[0], database])

	#FIXME: look up coinc_definer_id from cefinition in pylal
# get the timeslide/full_data triggers
	for values in connection.cursor().execute(''.join([mvsc_queries.CandidateEventQuery.select_dimensions,mvsc_queries.CandidateEventQuery.add_join_fulldata]), tuple(ifos) ):
		if values[-1] == 'slide':	
			timeslides.append((calc_ethinca(values[1:num_sngl_cols+1],values[num_sngl_cols+1:2*num_sngl_cols+1],ilwd.get_ilwdchar(values[2*num_sngl_cols+1]),rings,offset_vectors),) + values[2*num_sngl_cols+2:-1] + (1,) + (0,))
			timeslides_info.append([values[0], database])
		if values[-1] == 'all_data':
			zerolag.append((calc_ethinca(values[1:num_sngl_cols+1],values[num_sngl_cols+1:2*num_sngl_cols+1],ilwd.get_ilwdchar(values[2*num_sngl_cols+1]),rings,offset_vectors),) + values[2*num_sngl_cols+2:-1] + (1,) + (0,))
			zerolag_info.append([values[0], database])
	dbtables.put_connection_filename(database, working_filename, verbose = True)

# now we will normalize the weighting column by multiplying it by the number of found injections in the injection set, and dividing by the sum of the efficiency factors for all found injections in the injection set, then we can put all injections into the same list
#FIXME: there are better ways to implement the weighting, please think about it before applying 
allinjections=[]
allinjections_info=[]

for key in injections.keys():
	print "injection set", key
	print "sum of all efficiency factors for injection set", normalization[key]
	print "number of triggers in injection set", len(injections[key])
	for row in range(len(injections[key])):
		injtmp = list(injections[key][row])
		if opts.apply_weights:
			injtmp[-2] = injtmp[-2]*float(len(injections[key]))/normalization[key]
		else:
			injtmp[-2] = 1
		allinjections.append(injtmp)
		allinjections_info.append(list(injections_info[key][row]))


random.seed(1)
random.shuffle(allinjections)
random.seed(1)
random.shuffle(allinjections_info)
random.seed(2)
random.shuffle(timeslides)
random.seed(2)
random.shuffle(timeslides_info)

# this part of the code writes the triggers' information into .pat files, in the format needed for SprBaggerDecisionTreeApp
# to get the MVSC rank for each timeslide and injection, we do a round-robin of training and testing, with the number of rounds determined by opts.number
# for example,	if opts.number is 10, each round will train a random forest of bagged decision trees on 90% of the timeslides and injections
# then we'd run the remaining 10% through the trained forest to get their MVSC rank
# in this case, we'd do this 10 times, ensuring that every timeslide and injection gets ranked 
Nrounds = opts.number
Ninj = len(allinjections)
Nslide = len(timeslides)

trstr = 'training' 
testr = 'evaluation'
zlstr = 'zerolag'

print "there are ", len(timeslides), " timeslide doubles in ", ''.join(ifos), " and triple coincidences"
print "there are ", len(allinjections), " injection doubles in ", ''.join(ifos), " and triple coincidences"
print "there are ", len(zerolag), " zerolag doubles in ", ''.join(ifos), " and triple coincidences"

if len(allinjections) != 0:	
	Nparams = len(allinjections[0]) - 2

	def open_file_write_headers(filetype, set_num, ifos, Nparams=Nparams):
		f = open(''.join(ifos) + '_' + opts.output_tag + '_set' + str(set_num) + '_' + str(filetype) +	'.pat', 'w')
		f.write(str(Nparams) + '\n')
		f.write(parameters + "\n")
		return f
	
	for i in range(Nrounds):
		f_training = open_file_write_headers(trstr, i, ifos)
		f_testing = open_file_write_headers(testr, i, ifos)
		f_testing_info=open(''.join(ifos) + '_' + opts.output_tag + '_set' + str(i) + '_' + str(testr) + '_info.pat', 'w')
		set_inj = list(allinjections)
		set_inj_info = list(allinjections_info)
		set_slide = list(timeslides)
		set_slide_info = list(timeslides_info)
		# get 10% of the timeslides and injections, which you will run through the forest that you've trained on the other 90%
		set_i_inj= set_inj[i*Ninj/Nrounds : (i+1)*Ninj/Nrounds]
		set_i_inj_info= set_inj_info[i*Ninj/Nrounds : (i+1)*Ninj/Nrounds]
		set_i_slide = set_slide[i*Nslide/Nrounds : (i+1)*Nslide/Nrounds]
		set_i_slide_info = set_slide_info[i*Nslide/Nrounds : (i+1)*Nslide/Nrounds]
		for row in set_i_inj:
			f_testing.write("%s\n" % " ".join(map(str,row)))
		for row in set_i_inj_info:
			f_testing_info.write("%s\n" % " ".join(map(str,row)))
		for row in set_i_slide:
			f_testing.write("%s\n" % " ".join(map(str,row)))
		for row in set_i_slide_info:
			f_testing_info.write("%s\n" % " ".join(map(str,row)))
		# delete the 10%, and save the remaining 90% into the training file
		del(set_inj[i*Ninj/Nrounds : (i+1)*Ninj/Nrounds])
		del(set_slide[i*Nslide/Nrounds : (i+1)*Nslide/Nrounds])
		for row in set_inj:
			f_training.write("%s\n" % " ".join(map(str,row)))
		for row in set_slide:
			f_training.write("%s\n" % " ".join(map(str,row)))
	f_zerolag=open(''.join(ifos) + '_' + opts.output_tag + '_' + str(zlstr) + '.pat','w')
	f_zerolag.write(str(Nparams) + '\n')
	f_zerolag.write(parameters + "\n")
	for row in zerolag:
		f_zerolag.write("%s\n" % " ".join(map(str,row)))
	f_zerolag_info=open(''.join(ifos) + '_' + opts.output_tag + '_' + str(zlstr) + '_info.pat', 'w')
	for row in zerolag_info:
		f_zerolag_info.write("%s\n" % " ".join(map(str,row)))
else: print "There were no injections found for the specified ifo combination %s" % ifos

time2=time()
elapsed_time=time2-time1
print "elapsed time:", elapsed_time
