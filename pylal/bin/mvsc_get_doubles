#!/usr/bin/python
try:
	import sqlite3
except ImportError:
	# pre 2.5.x
	from pysqlite2 import dbapi2 as sqlite3
from glue.ligolw import dbtables 
from glue.ligolw import table
from glue.ligolw import ilwd
from glue import segments
from pylal.xlal import tools as xlaltools
from pylal.xlal.datatypes import snglinspiraltable
from pylal import SnglInspiralUtils
from pylal import db_thinca_rings
from pylal import git_version
from time import clock,time
from optparse import *
import glob
import sys
import random

from pylal import ligolw_thinca
usage="""
example command line:
%prog --instruments=H1,L1 database1.sqlite database2.sqlite etc.
or, if you are brave:
%prog --instruments=H1,L1 *.sqlite
this code turns sqlite databases into .pat files for MVSC
each row in the .pat file contains a vector of parameters that characterize the double coincident trigger
"""

__author__ = "Kari Hodge <khodge@ligo.caltech.edu>"

parser=OptionParser(usage=usage,version=git_version.verbose_msg)
parser.add_option("", "--number", default=10, type="int", help="number for round robin")
parser.add_option("", "--instruments", help="pair that you want to get like H1,L1")
parser.add_option("", "--factor", default=50.0, type="float", help="the value of the magic number factor in the effective snr formula, should be 50 for highmass and 250 for lowmass")
parser.add_option("", "--trainingstr", default="training", help="the string in the output .pat files that indicates it will be used as the training set in SprBaggerDecisionTreeApp") 
parser.add_option("", "--testingstr", default="testing", help="the string in the output .pat files that indicates it will be used as the testing set in SprOutputWriterApp") 
parser.add_option("", "--zerolagstr", default="zerolag", help="the string in the output .pat files that indicates it contains zerlag data, which will be run through SprOutputWriterApp") 
(opts,databases)=parser.parse_args()
ifos=opts.instruments.strip().split(',')
ifos.sort()

time1=time()

class SnglInspiral(snglinspiraltable.SnglInspiralTable):
	"""
	You need to make this subclass of xlaltools.SnglInspiralTable because the C version doesn't have the methods 
	you need to slide the triggers on the ring, which you need to do for a correct calculation of ethinca
	"""
	__slots__ = ()

	def get_end(self):
		return dbtables.lsctables.LIGOTimeGPS(self.end_time, self.end_time_ns)

	def set_end(self, gps):
		self.end_time, self.end_time_ns = gps.seconds, gps.nanoseconds

dbtables.lsctables.SnglInspiralTable.RowType = SnglInspiral

def calc_effective_snr(snr, chisq, chisq_dof, fac=opts.factor):
	return snr/ (1 + snr**2/fac)**(0.25) / (chisq/(2*chisq_dof - 2) )**(0.25)

def calc_ethinca(rowA,rowB):
	rowA = table.get_table(xmldoc, dbtables.lsctables.SnglInspiralTable.tableName).row_from_cols(rowA)
	rowB = table.get_table(xmldoc, dbtables.lsctables.SnglInspiralTable.tableName).row_from_cols(rowB)
	return xlaltools.XLALCalculateEThincaParameter(rowA,rowB)

injections = {}
injections_info = {}
normalization = {}
zerolag = []
zerolag_info = []
timeslides = []
timeslides_info = []

for database in databases:
	local_disk = None #"/tmp"
	working_filename = dbtables.get_connection_filename(database, tmp_path = local_disk, verbose = True)
	connection = sqlite3.connect(working_filename)
	dbtables.DBTable_set_connection(connection)
	xmldoc = dbtables.get_xml(connection)
	cursor = connection.cursor()
	num_sngl_cols = len(table.get_table(xmldoc, dbtables.lsctables.SnglInspiralTable.tableName).dbcolumnnames)
	# to determine whether or not the database is full of timeslides/zerolag or injections, check if there exists a sim_inspiral table 
	try:
		sim_inspiral_table = table.get_table(xmldoc, dbtables.lsctables.SimInspiralTable.tableName)
		is_injections = True
	except ValueError:
		is_injections = False

	if is_injections:
		def calc_delta_t_inj(trigger1_end_time, trigger1_end_time_ns, trigger2_end_time, trigger2_end_time_ns):
			try:
				return abs((trigger1_end_time - trigger2_end_time) + (trigger1_end_time_ns - trigger2_end_time_ns)*1e-9)
			except: print "calc_delta_t_inj() failed"
		connection.create_function("calc_delta_t_inj", 4, calc_delta_t_inj)
		connection.create_function("calc_effective_snr", 3, calc_effective_snr)
		
# get the names of each injection run, so that we can normalize the weights given to the triggers
		for injset in connection.cursor().execute("""
			SELECT
				value
			FROM
				process_params
			WHERE
				program = 'inspinj'
				AND param == '--userTag'
			"""): 
				injset = str(injset[0])
				normalization[injset]=0
				injections[injset]=[]
				injections_info[injset]=[]
				for values in connection.cursor().execute("""
				SELECT
					coinc_inspiral.coinc_event_id,
					snglA.*,
					snglB.*,
					calc_delta_t_inj(snglA.end_time, snglA.end_time_ns, snglB.end_time, snglB.end_time_ns),
					abs(2*(snglA.mchirp - snglB.mchirp)/(snglA.mchirp+snglB.mchirp)),
					abs(2*(snglA.eta - snglB.eta)/(snglA.eta+snglB.eta)),
					snglA.snr,
					snglB.snr,
					snglA.chisq/snglA.chisq_dof,
					snglB.chisq/snglB.chisq_dof,
					calc_effective_snr(snglA.snr, snglA.chisq, snglA.chisq_dof),
					calc_effective_snr(snglB.snr, snglB.chisq, snglB.chisq_dof),
					snglA.rsqveto_duration,
					snglB.rsqveto_duration,
					CASE snglA.bank_chisq_dof
						WHEN 0.0 THEN 1.0
						ELSE snglA.bank_chisq/snglA.bank_chisq_dof END,
					CASE snglB.bank_chisq_dof
						WHEN 0.0 THEN 1.0
						ELSE snglB.bank_chisq/snglB.bank_chisq_dof END,
					CASE snglA.bank_chisq_dof
						WHEN 0.0 THEN 1.0
						ELSE snglA.cont_chisq/snglA.cont_chisq_dof END,
					CASE snglB.cont_chisq_dof
						WHEN 0.0 THEN 1.0
						ELSE snglB.cont_chisq/snglB.cont_chisq_dof END,
					coinc_inspiral.snr,
					CASE (SELECT value FROM process_params WHERE program == "inspinj" AND param == "--d-distr" AND process_params.process_id == sim_inspiral.process_id)
						WHEN "log10" THEN 3*sim_inspiral.distance*sim_inspiral.distance*sim_inspiral.distance
						WHEN "uniform" THEN 3*sim_inspiral.distance*sim_inspiral.distance
						ELSE 1.0 END
				FROM
					coinc_inspiral 
					JOIN coinc_event_map AS mapA ON (mapA.coinc_event_id == coinc_inspiral.coinc_event_id)
					JOIN coinc_event_map AS mapB ON (mapB.coinc_event_id == coinc_inspiral.coinc_event_id)
					JOIN sngl_inspiral AS snglA ON (snglA.event_id == mapA.event_id)
					JOIN sngl_inspiral AS snglB ON (snglB.event_id == mapB.event_id)
					JOIN coinc_event_map AS mapC ON (mapC.event_id == coinc_inspiral.coinc_event_id)
					JOIN coinc_event_map AS mapD ON (mapD.coinc_event_id == mapC.coinc_event_id)
					JOIN sim_inspiral ON (sim_inspiral.simulation_id == mapD.event_id)
					JOIN coinc_event AS sim_coinc_event ON (sim_coinc_event.coinc_event_id == mapD.coinc_event_id)
					JOIN coinc_event AS insp_coinc_event ON (insp_coinc_event.coinc_event_id == mapA.coinc_event_id)
					JOIN coinc_definer ON (coinc_definer.coinc_def_id == sim_coinc_event.coinc_def_id)
					JOIN process_params ON (process_params.process_id == sim_inspiral.process_id)
				WHERE
					coinc_definer.search == 'inspiral'
					AND coinc_definer.search_coinc_type == 2
					AND mapA.table_name == 'sngl_inspiral'
					AND mapB.table_name == 'sngl_inspiral'
					AND mapC.table_name == 'coinc_event'
					AND mapD.table_name == 'sim_inspiral'
					AND snglA.ifo == ?
					AND snglB.ifo == ?
					AND process_params.program == 'inspinj' AND process_params.param == '--userTag' AND process_params.value == ?
					""", (ifos[0],ifos[1],injset,) ):
						normalization[injset]=normalization[injset]+values[-1]
						injections[injset].append((calc_ethinca(values[1:num_sngl_cols+1],values[num_sngl_cols+1:2*num_sngl_cols+1]),) + values[2*num_sngl_cols+1:] + (1,))
						injections_info[injset].append([values[0], database])
		dbtables.put_connection_filename(database, working_filename, verbose = True)

	rings = db_thinca_rings.get_thinca_rings_by_available_instruments(connection)
	offset_vectors = dbtables.lsctables.table.get_table(dbtables.get_xml(connection), dbtables.lsctables.TimeSlideTable.tableName).as_dict()
	sngl_inspiral_row_from_cols = table.get_table(xmldoc, dbtables.lsctables.SnglInspiralTable.tableName).row_from_cols
	def calc_ethinca_ts(rowA,rowB,time_slide_id,rings=rings,offset_vectors=offset_vectors):
		flatrings = segments.segmentlist()
		for value in rings.values():
			flatrings.extend(value)
		rowA = sngl_inspiral_row_from_cols(rowA)
		SnglInspiralUtils.slideTriggersOnRings([rowA],flatrings,offset_vectors[time_slide_id])
		rowB = sngl_inspiral_row_from_cols(rowB)
		SnglInspiralUtils.slideTriggersOnRings([rowB],flatrings,offset_vectors[time_slide_id])
		return xlaltools.XLALCalculateEThincaParameter(rowA,rowB)

	def calc_delta_t(trigger1_ifo, trigger1_end_time, trigger1_end_time_ns, trigger2_ifo, trigger2_end_time, trigger2_end_time_ns, time_slide_id, rings = rings, offset_vectors = offset_vectors):
		time_slide_id = ilwd.get_ilwdchar(time_slide_id)
		trigger1_true_end_time = dbtables.lsctables.LIGOTimeGPS(trigger1_end_time, trigger1_end_time_ns)
		trigger2_true_end_time = dbtables.lsctables.LIGOTimeGPS(trigger2_end_time, trigger2_end_time_ns)
		# find the instruments that were on at trigger 1's end time and
		# find the ring that contains this trigger
		try:
			[ring] = [segs[segs.find(trigger1_end_time)] for segs in rings.values() if trigger1_end_time in segs]
		except ValueError:
			# FIXME THERE SEEMS TO BE A BUG IN	THINCA!	Occasionally thinca records a trigger on the upper boundary
			# of its ring.	This would make it outside the ring which is very problematic.	It needs to be fixed in thinca
			# for now we'll allow the additional check that the other trigger is in the ring and use it.
				print >>sys.stderr, "trigger1 found not on a ring, trying trigger2"
				[ring] = [segs[segs.find(trigger2_end_time)] for segs in rings.values() if trigger2_end_time in segs]
		# now we can unslide the triggers on the ring
		try:
			trigger1_true_end_time = SnglInspiralUtils.slideTimeOnRing(trigger1_true_end_time, offset_vectors[time_slide_id][trigger1_ifo], ring)
			trigger2_true_end_time = SnglInspiralUtils.slideTimeOnRing(trigger2_true_end_time, offset_vectors[time_slide_id][trigger2_ifo], ring)
			out = abs(trigger1_true_end_time - trigger2_true_end_time)
			return float(out)
		except:
			print >> sys.stderr, "calc delta t failed because one of the trigger's true end times landed on the upper boundary of the thinca ring. See: trigger 1: ", trigger1_true_end_time, "trigger 2: ", trigger2_true_end_time, "ring: ", ring
			out = float(abs(trigger1_true_end_time - trigger2_true_end_time)) % 1
			if out > 0.5:
				out = 1.0 - out
			print >> sys.stderr, "SO...delta t has been set to: ", out, "in accordance with the mod 1 hack"
			return out


	connection.create_function("calc_delta_t", 7, calc_delta_t)
	connection.create_function("calc_effective_snr", 3, calc_effective_snr)


	#FIXME: look up coinc_definer_id from cefinition in pylal
	for values in connection.cursor().execute("""
	SELECT
		coinc_inspiral.coinc_event_id,
		snglA.*,
		snglB.*,
		coinc_event.time_slide_id,
		calc_delta_t(snglA.ifo, snglA.end_time, snglA.end_time_ns, snglB.ifo, snglB.end_time, snglB.end_time_ns, coinc_event.time_slide_id),
		abs(2*(snglA.mchirp - snglB.mchirp)/(snglA.mchirp+snglB.mchirp)),
		abs(2*(snglA.eta - snglB.eta)/(snglA.eta+snglB.eta)),
		snglA.snr,
		snglB.snr,
		snglA.chisq/snglA.chisq_dof,
		snglB.chisq/snglB.chisq_dof,
		calc_effective_snr(snglA.snr, snglA.chisq, snglA.chisq_dof),
		calc_effective_snr(snglB.snr, snglB.chisq, snglB.chisq_dof),
		snglA.rsqveto_duration,
		snglB.rsqveto_duration,
		CASE snglA.bank_chisq_dof
			WHEN 0.0 THEN 1.0
			ELSE snglA.bank_chisq/snglA.bank_chisq_dof END,
		CASE snglB.bank_chisq_dof
			WHEN 0.0 THEN 1.0
			ELSE snglB.bank_chisq/snglB.bank_chisq_dof END,
		CASE snglA.bank_chisq_dof
			WHEN 0.0 THEN 1.0
			ELSE snglA.cont_chisq/snglA.cont_chisq_dof END,
		CASE snglB.cont_chisq_dof
			WHEN 0.0 THEN 1.0
			ELSE snglB.cont_chisq/snglB.cont_chisq_dof END,
		coinc_inspiral.snr,
		EXISTS (
			SELECT
				*
			FROM
				time_slide
			WHERE
				time_slide.time_slide_id == coinc_event.time_slide_id
				AND time_slide.offset != 0
		)
	FROM
		coinc_inspiral 
		JOIN coinc_event_map AS mapA ON (mapA.coinc_event_id == coinc_inspiral.coinc_event_id)
		JOIN coinc_event_map AS mapB ON (mapB.coinc_event_id == coinc_inspiral.coinc_event_id)
		JOIN sngl_inspiral AS snglA ON (snglA.event_id == mapA.event_id)
		JOIN sngl_inspiral AS snglB ON (snglB.event_id == mapB.event_id)
		JOIN coinc_event ON (mapA.coinc_event_id == coinc_event.coinc_event_id)
		JOIN coinc_definer ON (coinc_definer.coinc_def_id == coinc_event.coinc_def_id)
	WHERE
		coinc_definer.search == 'inspiral'
		AND coinc_definer.search_coinc_type == 0
		AND mapA.table_name == 'sngl_inspiral'
		AND mapB.table_name == 'sngl_inspiral'
		AND NOT EXISTS (
			SELECT
				*
			FROM
				coinc_event AS sim_coinc_event
				JOIN coinc_event_map AS mapD ON (mapD.coinc_event_id == sim_coinc_event.coinc_event_id)
				JOIN coinc_event_map AS mapC ON (mapD.coinc_event_id == mapC.coinc_event_id)
				JOIN coinc_definer AS sim_coinc_definer ON (sim_coinc_definer.coinc_def_id == sim_coinc_event.coinc_def_id)
			WHERE
				mapC.event_id == coinc_inspiral.coinc_event_id
				AND mapC.table_name == 'coinc_event'
				AND mapD.table_name == 'sim_inspiral'
				AND sim_coinc_definer.search_coinc_type == 2
		)
		AND snglA.ifo == ?
		AND snglB.ifo == ?
		""", tuple(ifos) ):
			is_background = values[-1]
			values = values[:-1]
			if is_background:
				timeslides.append((calc_ethinca_ts(values[1:num_sngl_cols+1],values[num_sngl_cols+1:2*num_sngl_cols+1],ilwd.get_ilwdchar(values[2*num_sngl_cols+1]),rings,offset_vectors),) + values[2*num_sngl_cols+2:] + (1,) + (0,))
				timeslides_info.append([values[0], database])
			else:
				zerolag.append((calc_ethinca(values[1:num_sngl_cols+1],values[num_sngl_cols+1:2*num_sngl_cols+1]),) + values[2*num_sngl_cols+2:] + (1,) + (0,))
				zerolag_info.append([values[0], database])

	dbtables.put_connection_filename(database, working_filename, verbose = True)

# now we will normalize the weighting column by multiplying it by the number of found injections in the injection set, and dividing by the sum of the efficiency factors for all found injections in the injection set, then we can put all injections into the same list
allinjections=[]
allinjections_info=[]

for key in injections.keys():
	print "injection set", key
	print "sum of all efficiency factors for injection set", normalization[key]
	print "number of triggers in injection set", len(injections[key])
	for row in range(len(injections[key])):
		injtmp = list(injections[key][row])
		injtmp[-2] = injtmp[-2]*float(len(injections[key]))/normalization[key]
		allinjections.append(injtmp)
		allinjections_info.append(injections_info[key])

random.seed(1)
random.shuffle(allinjections)
random.seed(1)
random.shuffle(allinjections_info)
random.seed(2)
random.shuffle(timeslides)
random.seed(2)
random.shuffle(timeslides_info)

# this part of the code writes the triggers' information into .pat files, in the format needed for SprBaggerDecisionTreeApp
# to get the MVSC rank for each timeslide and injection, we do a round-robin of training and testing, with the number of rounds determined by opts.number
# for example,	if opts.number is 10, each round will train a random forest of bagged decision trees on 90% of the timeslides and injections
# then we'd run the remaining 10% through the trained forest to get their MVSC rank
# in this case, we'd do this 10 times, ensuring that every timeslide and injection gets ranked 
Nrounds = opts.number
Ninj = len(allinjections)
Nslide = len(timeslides)
print Ninj

trstr = opts.trainingstr
testr = opts.testingstr
zlstr = opts.zerolagstr


if len(allinjections) != 0:	
	Nparams = len(allinjections[0]) - 2

	def open_file_write_headers(filetype, set_num, ifos, Nparams=Nparams):
		f = open(''.join(ifos) + '_set' + str(set_num) + '_' + str(filetype) +	'.pat', 'w')
		f.write(str(Nparams) + '\n')
		f.write("ethinca delta_t ab_dmchirp_rel ab_deta_rel a_snr b_snr a_chisq_red b_chisq_red a_effective_snr b_effective_snr a_rsq_veto_duration b_rsq_veto_duration a_bank_chisq_red b_bank_chisq_red a_cont_chisq_red b_cont_chisq_red coinc_inspiral_snr \n")
		return f
	
	for i in range(Nrounds):
		f_training = open_file_write_headers(trstr, i, ifos)
		f_testing = open_file_write_headers(testr, i, ifos)
		f_testing_info=open(''.join(ifos) + '_set' + str(i) + '_' + str(testr) + '_info.pat', 'w')
		set_inj = list(allinjections)
		set_inj_info = list(allinjections_info)
		print len(set_inj)
		print len(set_inj_info)
		set_slide = list(timeslides)
		set_slide_info = list(timeslides_info)
		# get 10% of the timeslides and injections, which you will run through the forest that you've trained on the other 90%
		set_i_inj= set_inj[i*Ninj/Nrounds : (i+1)*Ninj/Nrounds]
		set_i_inj_info= set_inj_info[i*Ninj/Nrounds : (i+1)*Ninj/Nrounds]
		set_i_slide = set_slide[i*Nslide/Nrounds : (i+1)*Nslide/Nrounds]
		set_i_slide_info = set_slide_info[i*Nslide/Nrounds : (i+1)*Nslide/Nrounds]
		print len(set_i_inj)
		print len(set_i_inj_info)
		for row in set_i_inj:
			f_testing.write("%s\n" % " ".join(map(str,row)))
		for row in set_i_inj_info:
			f_testing_info.write("%s\n" % " ".join(map(str,row)))
		for row in set_i_slide:
			f_testing.write("%s\n" % " ".join(map(str,row)))
		for row in set_i_slide_info:
			f_testing_info.write("%s\n" % " ".join(map(str,row)))
		# delete the 10%, and save the remaining 90% into the training file
		del(set_inj[i*Ninj/Nrounds : (i+1)*Ninj/Nrounds])
		del(set_slide[i*Nslide/Nrounds : (i+1)*Nslide/Nrounds])
		for row in set_inj:
			f_training.write("%s\n" % " ".join(map(str,row)))
		for row in set_slide:
			f_training.write("%s\n" % " ".join(map(str,row)))
	f_zerolag=open(''.join(ifos) + '_' + str(zlstr) + '.pat','w')
	f_zerolag.write(str(Nparams) + '\n')
	f_zerolag.write("ethinca delta_t ab_dmchirp_rel ab_deta_rel a_snr b_snr a_chisq_red b_chisq_red a_effective_snr b_effective_snr a_rsq_veto_duration b_rsq_veto_duration a_bank_chisq_red b_bank_chisq_red a_cont_chisq_red b_cont_chisq_red coinc_inspiral_snr \n")
	for row in zerolag:
		f_zerolag.write("%s\n" % " ".join(map(str,row)))
	f_zerolag_info=open(''.join(ifos) + '_' + str(zlstr) + '_info.pat', 'w')
	for row in zerolag_info:
		f_zerolag_info.write("%s\n" % " ".join(map(str,row)))
else: print "There were no injections found for the specified ifo combination %s" % ifos

time2=time()
elapsed_time=time2-time1
print "elapsed time:", elapsed_time
