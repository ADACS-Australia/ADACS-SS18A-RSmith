#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2008  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import bisect
from optparse import OptionParser
try:
	import sqlite3
except ImportError:
	# pre 2.5.x
	from pysqlite2 import dbapi2 as sqlite3
import sys


from glue import iterutils
from glue import segments
from glue.ligolw import lsctables
from glue.ligolw import dbtables
from pylal import ligolw_thinca
from pylal import llwapp
from pylal import rate
from pylal.date import LIGOTimeGPS


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog [options] [file ...]",
		description = "%prog does blah blah blah."
	)
	parser.add_option("-i", "--instruments", metavar = "name[,name,...]", help = "Set the list of instruments.  Example H1,H2,L1.  Required.")
	parser.add_option("-b", "--mass-bins", metavar = "m0,m1[,m2,...]", help = "Set the boundaries of the mass bins.  The lowest and highest bounds must be explicitly listed.  Example 0,5,inf.  Required.")
	parser.add_option("-p", "--live-time-program", metavar = "name", help = "Set the name of the program whose entries in the search_summary table will set the search live time.  Required.")
	parser.add_option("-t", "--tmp-space", metavar = "path", help = "Path to a directory suitable for use as a work area while manipulating the database file.  The database file will be worked on in this directory, and then moved to the final location when complete.  This option is intended to improve performance when running in a networked environment, where there might be a local disk with higher bandwidth than is available to the filesystem on which the final output will reside.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	#
	# parse the instruments
	#

	if options.instruments is None:
		raise ValueError, "required option -i or --instruments missing"
	options.instruments = options.instruments.split(",")
	options.instruments.sort()

	#
	# parse mass bins
	#

	if options.mass_bins is None:
		raise ValueError, "missing required option -b or --mass-bins"
	options.mass_bins = map(float, options.mass_bins.strip().split(","))
	if len(options.mass_bins) < 2:
		raise ValueError, "must supply at least two mass bin boundaries"
	options.mass_bins.sort()

	#
	# other
	#

	if options.live_time_program is None:
		raise ValueError, "missing required option -p or --live-time-program"

	#
	# done
	#

	return options, (filenames or [None])


#
# =============================================================================
#
#                                 Book-Keeping
#
# =============================================================================
#


class Summary(object):
	def __init__(self, mass_bins):
		self.mass_bins = mass_bins
		self.snrs = tuple(list() for n in range(len(mass_bins)))

	def add_coinc(self, mean_mchirp, snr):
		self.snrs[self.mass_bins[mean_mchirp]].append(snr)

	def count(self, mean_mchrip, snr):
		return len([x for x in self.snrs[self.mass_bins[mean_mchirp]] if x >= snr])


def create_summaries(instruments, mass_bins):
	"""
	Returns a dictionary of Summary objects indexed by inspiral coinc
	type (see pylal.ligolw_thinca.InspiralCoincTypes) and a boolean
	indicating if the LHO amplitude consistency cut was applied.

	Example:

	instruments = ("H1", "H2", "L1")
	mass_bins = rate.IrregularBins([0.0, 5.0, float("inf")])
	summaries = create_summaries(instruments, mass_bins)
	summaries[(5, True)].add_coinc(6.5, 12.5)

	The last line retrieves the Summary object for H1,L1 coincs in
	H1,H2,L1 time (because the amplitude cut was applied so H2 must
	have been on) and adds a coinc with a combined SNR of 12.5 to the
	mass bin matching a mean chirp mass of 6.5.
	"""
	#
	# make sure instrument list is sorted
	#

	instruments = list(instruments)
	instruments.sort()

	#
	# iterate over instrument combinations
	#

	summaries = {}
	for combo in [combo for m in range(2, len(instruments) + 1) for combo in iterutils.choices(instruments, m)]:
		#
		# look up the inspiral coincidence type for this instrument
		# combo
		#

		coinc_type = ligolw_thinca.InspiralCoincTypes[combo].search_coinc_type

		#
		# if both LHO antennas provided a trigger for the coinc -->
		# one coinc type, with amplitude consistency cut;  if one
		# LHO antenna provided a trigger for the coinc --> two
		# coinc types, with and without amplitude consistency cut;
		# if neither LHO antenna contributed a trigger for the
		# coinc --> one coinc type, without amplitude consistency
		# cut.
		#

		if ("H1" in combo) and ("H2" in combo):
			summaries[(coinc_type, True)] = Summary(mass_bins)
		elif ("H1" in combo) or ("H2" in combo):
			summaries[(coinc_type, True)] = Summary(mass_bins)
			summaries[(coinc_type, False)] = Summary(mass_bins)
		else:
			summaries[(coinc_type, False)] = Summary(mass_bins)

	return summaries


#
# =============================================================================
#
#                                   Queries
#
# =============================================================================
#


def create_coinc_inspiral_view(connection):
	"""
	Constructs a temporary view named coinc_inspiral with three columns:

	coinc_event_id: the coinc_event_id of this coinc

	mean_mchirp: the average of the mchirps of the inspiral triggers in
	this coinc

	snr: the combined effective SNR for the coinc (currently the
	minimum of the SNRs of the triggers in the coinc)

	lho_ampl_cut_applied: true if both H1 and H2 were on for this coinc

	A "temporary view" is a query whose result is made to appear to be
	another table in the database.  It can be used in other queries,
	used in joins, etc., as though it was a table.  It is removed from
	the database when the connection is closed.
	"""
	connection.cursor().execute("""
CREATE TEMPORARY VIEW
	coinc_inspiral
AS
	SELECT
		coinc_event.coinc_event_id AS coinc_event_id,
		AVG(sngl_inspiral.mchirp) AS mean_mchirp,
		MIN(sngl_inspiral.snr) AS snr,
		EXISTS (
			SELECT
				*
			FROM
				time_slide AS offset_a
				JOIN time_slide AS offset_b ON (
					offset_a.time_slide_id == offset_b.time_slide_id
					AND offset_a.instrument == 'H1'
					AND offset_b.instrument == 'H2'
				)
			WHERE
				offset_a.time_slide_id == coinc_event.time_slide_id
		) AS lho_ampl_cut_applied
	FROM
		sngl_inspiral
		JOIN coinc_event_map ON (
			coinc_event_map.table_name == 'sngl_inspiral'
			AND coinc_event_map.event_id == sngl_inspiral.event_id
		)
		JOIN coinc_event ON (
			coinc_event.coinc_event_id == coinc_event_map.coinc_event_id
		)
	GROUP BY
		coinc_event.coinc_event_id
	""")


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# command line
#


options, filenames = parse_command_line()


#
# initialize book-keeping
#


seglists = segments.segmentlistdict()
background = create_summaries(options.instruments, rate.IrregularBins(options.mass_bins))


#
# iterate over database files accumulating background statistics
#


for n, filename in enumerate(filenames):
	#
	# open the database
	#

	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename)
	working_filename = dbtables.get_connection_filename(filename, tmp_path = options.tmp_space, verbose = options.verbose)
	connection = sqlite3.connect(working_filename)
	dbtables.DBTable_set_connection(connection)
	xmldoc = dbtables.DBTable_get_xml()

	#
	# prepare database
	#

	create_coinc_inspiral_view(connection)

	#
	# retrieve the segment lists
	#

	seglists |= llwapp.segmentlistdict_fromsearchsummary(xmldoc, options.live_time_program).coalesce()

	#
	# count background coincs by type and mass bin
	#

	for inspiral_coinc_type, mean_mchirp, snr, lho_ampl_cut_applied in connection.cursor().execute("""
SELECT
	coinc_definer.search_coinc_type,
	coinc_inspiral.mean_mchirp,
	coinc_inspiral.snr,
	coinc_inspiral.lho_ampl_cut_applied
FROM
	coinc_event
	JOIN coinc_definer ON (
		coinc_definer.coinc_def_id == coinc_event.coinc_def_id
		AND coinc_definer.search == 'inspiral'
	)
	JOIN coinc_inspiral ON (
		coinc_inspiral.coinc_event_id == coinc_event.coinc_event_id
	)
WHERE
	-- require coinc to be non-zero-lag
	EXISTS (
		SELECT
			*
		FROM
			time_slide
		WHERE
			time_slide.time_slide_id == coinc_event.time_slide_id
			AND time_slide.offset != 0
	)
	"""):
		#
		# add the coinc's SNR to the list of SNRs for the
		# appropriate coinc type
		#

		background[(inspiral_coinc_type, lho_ampl_cut_applied)].add_coinc(mean_mchirp, snr)

	#
	# close the database
	#

	connection.close()
	dbtables.discard_connection_filename(filename, working_filename, verbose = options.verbose)


#
# compute live time corresponding to each coinc type
#


# FIXME:  do this.


#
# iterate over database files assigning false-alarm rates to coincs
#


for n, filename in enumerate(filenames):
	#
	# open the database
	#

	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename)
	working_filename = dbtables.get_connection_filename(filename, tmp_path = options.tmp_space, verbose = options.verbose)
	connection = sqlite3.connect(working_filename)
	dbtables.DBTable_set_connection(connection)

	#
	# prepare database
	#

	create_coinc_inspiral_view(connection)


	#
	# count background coincs by type and mass bin
	#

	for coinc_event_id, inspiral_coinc_type, mean_mchirp, snr, lho_ampl_cut_applied in connection.cursor().execute("""
SELECT
	coinc_event.coinc_event_id,
	coinc_definer.search_coinc_type,
	coinc_inspiral.mean_mchirp,
	coinc_inspiral.snr,
	coinc_inspiral.lho_ampl_cut_applied
FROM
	coinc_event
	JOIN coinc_definer ON (
		coinc_definer.coinc_def_id == coinc_event.coinc_def_id
		AND coinc_definer.search == 'inspiral'
	)
	JOIN coinc_inspiral ON (
		coinc_inspiral.coinc_event_id == coinc_event.coinc_event_id
	)
WHERE
	-- require coinc to be zero-lag
	NOT EXISTS (
		SELECT
			*
		FROM
			time_slide
		WHERE
			time_slide.time_slide_id == coinc_event.time_slide_id
			AND time_slide.offset != 0
	)
	"""):
		print "found zero-lag %g SNR type %d coinc (%s LHO ampl. cut) with M_chirp = %g, %d like it in background" % (snr, inspiral_coinc_type, lho_ampl_cut_applied and "with" or "without", mean_mchirp, background[(inspiral_coinc_type, lho_ampl_cut_applied)].count(mean_mchirp, snr))

	#
	# close the database
	#

	connection.close()
	dbtables.discard_connection_filename(filename, working_filename, verbose = options.verbose)
