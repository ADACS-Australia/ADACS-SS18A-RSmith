#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2008  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import itertools
from optparse import OptionParser
try:
	import sqlite3
except ImportError:
	# pre 2.5.x
	from pysqlite2 import dbapi2 as sqlite3
import sys


from glue import iterutils
from glue import segments
from glue.ligolw import lsctables
from glue.ligolw import dbtables
from glue.ligolw import utils
from glue.ligolw.utils import segments as ligolw_segments
from pylal import ligolw_thinca
from pylal import ligolw_tisi
from pylal import llwapp
from pylal import rate
from pylal import SnglInspiralUtils


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog [options] [file ...]",
		description = "%prog does blah blah blah."
	)
	parser.add_option("-i", "--instruments", metavar = "name[,name,...]", help = "Set the list of instruments.  Example H1,H2,L1.  Required.")
	parser.add_option("-b", "--mass-bins", metavar = "m0,m1[,m2,...]", help = "Set the boundaries of the mass bins.  The lowest and highest bounds must be explicitly listed.  Example 0,5,inf.  Required.")
	parser.add_option("-p", "--live-time-program", metavar = "name", help = "Set the name of the program whose entries in the search_summary table will set the search live time.  Required.")
	parser.add_option("--veto-segments", help = "Load veto segments from this XML document.  See ligolw_segments for information on constructing such a document.")
	parser.add_option("--veto-segments-name", help = "Set the name of the veto segments to use from the XML document.")
	parser.add_option("-t", "--tmp-space", metavar = "path", help = "Path to a directory suitable for use as a work area while manipulating the database file.  The database file will be worked on in this directory, and then moved to the final location when complete.  This option is intended to improve performance when running in a networked environment, where there might be a local disk with higher bandwidth than is available to the filesystem on which the final output will reside.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	#
	# parse the instruments
	#

	if options.instruments is None:
		raise ValueError, "required option -i or --instruments missing"
	options.instruments = set(options.instruments.split(","))

	#
	# parse mass bins
	#

	if options.mass_bins is None:
		raise ValueError, "missing required option -b or --mass-bins"
	options.mass_bins = sorted(map(float, options.mass_bins.split(",")))
	if len(options.mass_bins) < 2:
		raise ValueError, "must supply at least two mass bin boundaries"
	options.mass_bins = rate.IrregularBins(options.mass_bins)

	#
	# other
	#

	if options.live_time_program is None:
		raise ValueError, "missing required option -p or --live-time-program"
	if options.veto_segments and not options.veto_segments_name:
		raise ValueError, "must specify --veto-segments-name if --veto-sements is specified"

	#
	# done
	#

	return options, (filenames or [None])


#
# =============================================================================
#
#                                 Book-Keeping
#
# =============================================================================
#


class Summaries(object):
	def __init__(self, instruments, mass_bins, vetosegments):
		self.mass_bins = mass_bins
		self.vetosegments = vetosegments

		#
		# put the instruments in alphabetical order so that the
		# instrument combinations generated by choices() below come
		# out with the instruments sorted
		#

		self.instruments = sorted(instruments)

		#
		# iterate over instrument combinations creating bins for
		# the different categories of coinc.  each choice of
		# instruments that were on and instruments that
		# participated defines a unique coinc category
		#

		self.snrs = {}
		for on_instruments in (combo for m in range(2, len(self.instruments) + 1) for combo in iterutils.choices(self.instruments, m)):
			for participating_instruments in (combo for m in range(2, len(on_instruments) + 1) for combo in iterutils.choices(on_instruments, m)):
				self.snrs[(",".join(on_instruments), ",".join(participating_instruments))] = tuple(list() for n in range(len(mass_bins)))

		#
		# initialize the live-time book-keeping
		#

		self.rings = segments.segmentlist()
		self.offset_vectors = {}
		self.cached_livetime = {}

	def add_rings(self, rings):
		self.rings.extend(rings)
		self.rings.sort()
		# FIXME: use any() built-in when Python 2.5 is required
		if iterutils.any(a.intersects(b) for a, b in itertools.izip(self.rings[:-1], self.rings[1:])):
			raise ValueError, "found non-disjoint rings %s and %s" % (repr(a), repr(b))

	def set_offset_vectors(self, offset_vectors):
		self.offset_vectors = offset_vectors

	def livetime(self, on_instruments, offsetvector):
		on_instruments = set(on_instruments.split(","))
		return SnglInspiralUtils.compute_thinca_livetime(on_instruments, set(self.instruments) - on_instruments, self.rings, self.vetosegments, offsetvector)

	def add_coinc(self, on_instruments, participating_instruments, mchirp, snr):
		self.snrs[(on_instruments, participating_instruments)][self.mass_bins[mchirp]].append(snr)

	def count(self, on_instruments, participating_instruments, mchirp, snr):
		"""
		Return the number of coincs in the category defined by
		(on_instruments, participating_instruments) that are in the
		mass bin corresponding to mchirp and have a combined SNR
		greater than or equal to snr.  The on_ and
		participating_instruments are strings containing the
		instruments in alphabetical order separated by commas
		"""
		snrs = self.snrs[(on_instruments, participating_instruments)][self.mass_bins[mchirp]]
		return len([x for x in snrs if x >= snr])

	def rate(self, time_slide_id, on_instruments, participating_instruments, mchirp, snr):
		try:
			livetime = self.cached_livetime[(on_instruments, participating_instruments)]
		except KeyError:
			# FIXME:  calculate and store the background
			# livetime for this category
			livetime = self.cached_livetime[(on_instruments, participating_instruments)] = self.livetime(on_instruments, self.offset_vectors[time_slide_id])
		return self.count(on_instruments, participating_instruments, mchirp, snr) / livetime


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# command line
#


options, filenames = parse_command_line()

if options.veto_segments:
	dbtables.ligolwtypes.ToPyType["ilwd:char"] = unicode
	connection = sqlite3.connect(":memory:")
	dbtables.DBTable_set_connection(connection)
	options.veto_segments = ligolw_segments.segmenttable_get_by_name(utils.load_filename(options.veto_segments, gz = (options.veto_segments or "stdin").endswith(".gz"), verbose = options.verbose), options.veto_segments_name).coalesce()
	connection.close()
	dbtables.DBTable_set_connection(None)


#
# initialize book-keeping
#


background = Summaries(options.instruments, options.mass_bins, options.veto_segments)


#
# iterate over database files accumulating background statistics
#


if options.verbose:
	print >>sys.stderr, "collecting background statistics ..."


for n, filename in enumerate(filenames):
	#
	# open the database
	#

	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename)
	working_filename = dbtables.get_connection_filename(filename, tmp_path = options.tmp_space, verbose = options.verbose)
	connection = sqlite3.connect(working_filename)
	dbtables.DBTable_set_connection(connection)
	xmldoc = dbtables.get_xml(connection)

	#
	# retrieve and store the ring boundaries.  all segments from all
	# segment lists in the search summary table are collected into a
	# single list and uniqueified with set().
	#

	background.add_rings(set(seg for segs in llwapp.segmentlistdict_fromsearchsummary(xmldoc, options.live_time_program).values() for seg in segs))

	#
	# count background coincs by type and mass bin
	#

	for on_instruments, participating_instruments, mchirp, snr in connection.cursor().execute("""
SELECT
	coinc_event.instruments,
	coinc_inspiral.ifos,
	coinc_inspiral.mchirp,
	coinc_inspiral.snr
FROM
	coinc_event
	JOIN coinc_inspiral ON (
		coinc_inspiral.coinc_event_id == coinc_event.coinc_event_id
	)
WHERE
	-- require coinc to be background (= at least one of its time slide offsets is non-zero)
	EXISTS (
		SELECT
			*
		FROM
			time_slide
		WHERE
			time_slide.time_slide_id == coinc_event.time_slide_id
			AND time_slide.offset != 0
	)
	"""):
		#
		# add the coinc's SNR to the list of SNRs for the
		# appropriate coinc type
		#

		background.add_coinc(on_instruments, participating_instruments, mchirp, snr)

	#
	# close the database
	#

	connection.close()
	dbtables.discard_connection_filename(filename, working_filename, verbose = options.verbose)


#
# iterate over database files assigning false-alarm rates to coincs
#


if options.verbose:
	print >>sys.stderr, "calculating and recording false alarm rates ..."


for n, filename in enumerate(filenames):
	#
	# open the database
	#

	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename)
	working_filename = dbtables.get_connection_filename(filename, tmp_path = options.tmp_space, verbose = options.verbose)
	connection = sqlite3.connect(working_filename)
	dbtables.DBTable_set_connection(connection)
	xmldoc = dbtables.get_xml(connection)

	#
	# prepare the database
	#

	connection.create_function("background_count", 4, background.count)
	connection.create_function("background_rate", 5, background.rate)

	#
	# retrieve the time slide vectors used in this document
	#

	background.set_offset_vectors(lsctables.table.get_table(xmldoc, lsctables.TimeSlideTable.tableName).as_dict())

	#
	# count background coincs by type and mass bin
	#

	connection.cursor().execute("""
UPDATE
	coinc_inspiral
SET
	false_alarm_rate = (
		SELECT
			background_rate(
				coinc_event.time_slide_id,
				coinc_event.instruments,
				coinc_inspiral.ifos,
				coinc_inspiral.mchirp,
				coinc_inspiral.snr
			)
		FROM
			coinc_event
			JOIN coinc_definer ON (
				coinc_definer.coinc_def_id == coinc_event.coinc_def_id
			)
		WHERE
			coinc_event.coinc_event_id == coinc_inspiral.coinc_event_id
	)
	""")
	connection.commit()

	#
	# close the database
	#

	connection.close()
	dbtables.put_connection_filename(filename, working_filename, verbose = options.verbose)
