#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2007  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import glob
import math
import numpy
from optparse import OptionParser
from pysqlite2 import dbapi2 as sqlite3
from scipy.stats import stats
import sys

from glue import segments
from glue.ligolw import ligolw
from glue.ligolw import array
from glue.ligolw import dbtables
from glue.ligolw import utils
from pylal import itertools
from pylal import rate
from pylal import SnglBurstUtils
from pylal.date import LIGOTimeGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")

	parser.add_option("-i", "--injection-glob", metavar = "pattern", default = None, help = "shell filename pattern for injection files")
	parser.add_option("-b", "--background-glob", metavar = "pattern", default = None, help = "shell filename pattern for non-injection files")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	return options, (filenames or [None])


#
# =============================================================================
#
#                                 Bookkeeping
#
# =============================================================================
#


#
# Plot of showing grid of distributions for individual deltas
#


class Plot1(object):
	def __init__(self, instruments, dtinterval, dfinterval, dhinterval):
		self.instruments = instruments

		self.fig = SnglBurstUtils.figure.Figure()
		SnglBurstUtils.FigureCanvas(self.fig)

		# how many instrument pairs are there?
		n_horiz = len(list(itertools.choices(instruments, 2)))

		# each sub plot's aspect ratio is the golden ratio
		size = 12.0
		n_vert = 3
		self.fig.set_size_inches(size * n_horiz / n_vert, size / ((1 + math.sqrt(5)) / 2))

		# initialize the axes
		self.dt_axes = {}
		self.df_axes = {}
		self.dh_axes = {}
		for i, pair in enumerate(map(tuple, itertools.choices(instruments, 2))):
			vlabel_allowance = .05
			hlabel_allowance = .03
			border = .007
			left = float(i) / n_horiz + hlabel_allowance + border
			width = 1.0 / n_horiz - hlabel_allowance - 2 * border
			height = 1.0 / n_vert

			self.dt_axes[pair] = self.fig.add_axes((left, 0 * height + vlabel_allowance + border, width, height - vlabel_allowance - 2 * border))
			self.df_axes[pair] = self.fig.add_axes((left, 1 * height + vlabel_allowance + border, width, height - vlabel_allowance - 2 * border))
			self.dh_axes[pair] = self.fig.add_axes((left, 2 * height + vlabel_allowance + border, width, height - vlabel_allowance - 2 * border))

			self.dt_axes[pair].set_xlabel(r"$(t_{\mathrm{%s}} - t_{\mathrm{%s}}) / \left< \Delta t \right>$" % pair)
			self.dt_axes[pair].set_ylabel(r"$P$")
			self.df_axes[pair].set_xlabel(r"$(f_{\mathrm{%s}} - f_{\mathrm{%s}}) / \left< \Delta f \right>$" % pair)
			self.df_axes[pair].set_ylabel(r"$P$")
			self.dh_axes[pair].set_xlabel(r"$({h_{\mathrm{rss}}}_{\mathrm{%s}} - {h_{\mathrm{rss}}}_{\mathrm{%s}}) / \left< h_{\mathrm{rss}} \right>$" % pair)
			self.dh_axes[pair].set_ylabel(r"$P$")

		# initialize the binnings
		self.inj_dt = {}
		self.bak_dt = {}
		self.inj_df = {}
		self.bak_df = {}
		self.inj_dh = {}
		self.bak_dh = {}
		for pair in map(tuple, itertools.choices(instruments, 2)):
			self.inj_dt[pair] = rate.Rate(dtinterval, abs(dtinterval) / 75.0)
			self.bak_dt[pair] = rate.Rate(dtinterval, abs(dtinterval) / 75.0)
			self.inj_df[pair] = rate.Rate(dfinterval, abs(dfinterval) / 75.0)
			self.bak_df[pair] = rate.Rate(dfinterval, abs(dfinterval) / 75.0)
			self.inj_dh[pair] = rate.Rate(dhinterval, abs(dhinterval) / 75.0)
			self.bak_dh[pair] = rate.Rate(dhinterval, abs(dhinterval) / 75.0)

	def add_inj(self, pair, dt, df, dh):
		# IndexError == not on plot
		try:
			self.inj_dt[pair][dt] = 1.0
		except IndexError:
			pass
		try:
			self.inj_df[pair][df] = 1.0
		except IndexError:
			pass
		try:
			self.inj_dh[pair][dh] = 1.0
		except IndexError:
			pass

	def add_bak(self, pair, dt, df, dh):
		# IndexError == not on plot
		try:
			self.bak_dt[pair][dt] = 1.0
		except IndexError:
			pass
		try:
			self.bak_df[pair][df] = 1.0
		except IndexError:
			pass
		try:
			self.bak_dh[pair][dh] = 1.0
		except IndexError:
			pass

	def finish(self):
		for pair in map(tuple, itertools.choices(self.instruments, 2)):
			self.inj_dt[pair].array /= numpy.sum(self.inj_dt[pair].array)
			self.bak_dt[pair].array /= numpy.sum(self.bak_dt[pair].array)
			self.inj_df[pair].array /= numpy.sum(self.inj_df[pair].array)
			self.bak_df[pair].array /= numpy.sum(self.bak_df[pair].array)
			self.inj_dh[pair].array /= numpy.sum(self.inj_dh[pair].array)
			self.bak_dh[pair].array /= numpy.sum(self.bak_dh[pair].array)
			self.dt_axes[pair].plot(self.inj_dt[pair].xvals(), self.inj_dt[pair].filtered(), "r")
			self.dt_axes[pair].plot(self.bak_dt[pair].xvals(), self.bak_dt[pair].filtered(), "k")
			self.df_axes[pair].plot(self.inj_df[pair].xvals(), self.inj_df[pair].filtered(), "r")
			self.df_axes[pair].plot(self.bak_df[pair].xvals(), self.bak_df[pair].filtered(), "k")
			self.dh_axes[pair].plot(self.inj_dh[pair].xvals(), self.inj_dh[pair].filtered(), "r")
			self.dh_axes[pair].plot(self.bak_dh[pair].xvals(), self.bak_dh[pair].filtered(), "k")


#
# Delta f vs. Delta t scatter plot
#


class Plot2(object):
	def __init__(self):
		self.fig = SnglBurstUtils.figure.Figure()
		SnglBurstUtils.FigureCanvas(self.fig)
		self.fig.set_size_inches(10.0, 10.0 / ((1 + math.sqrt(5)) / 2))
		self.axes = self.fig.gca()
		self.axes.set_title(r"Parameter Reconstruction Independence")
		self.axes.set_xlabel(r"$(t_{\mathrm{%s}} - t_{\mathrm{%s}}) / \left< \Delta t \right>$" % ("H1", "H2"))
		self.axes.set_ylabel(r"$(f_{\mathrm{%s}} - f_{\mathrm{%s}}) / \left< \Delta f \right>$" % ("H1", "H2"))
		self.inj_x = []
		self.inj_y = []
		self.bak_x = []
		self.bak_y = []

	def add_inj(self, pair, x, y):
		self.inj_x.append(x)
		self.inj_y.append(y)

	def add_bak(self, pair, x, y):
		self.bak_x.append(x)
		self.bak_y.append(y)

	def finish(self):
		self.axes.plot(self.inj_x, self.inj_y, "r+")
		self.axes.plot(self.bak_x, self.bak_y, "k+")
		self.axes.legend(["Injections", "Accidentals"])


#
# Covariance matrix
#


def covariance_normalize(c):
	"""
	Normalize a covariance matrix so that the variances (diagonal
	elements) are 1.
	"""
	std_dev = numpy.sqrt(numpy.diagonal(c))
	return c / numpy.outer(std_dev, std_dev)


class Covariance(object):
	def __init__(self):
		self.inj_observations = []
		self.bak_observations = []

	def add_inj(self, dt, df, dh):
		self.inj_observations.append((dt, df, dh))

	def add_bak(self, dt, df, dh):
		self.bak_observations.append((dt, df, dh))

	def finish(self):
		self.inj_observations = numpy.array(self.inj_observations)
		self.bak_observations = numpy.array(self.bak_observations)
		self.inj_cov = covariance_normalize(stats.cov(self.inj_observations))
		self.bak_cov = covariance_normalize(stats.cov(self.bak_observations))


#
# =============================================================================
#
#                                  Interface
#
# =============================================================================
#


class Plots(object):
	def __init__(self, instruments, dtinterval, dfinterval, dhinterval):
		self.instruments = instruments
		self.n_time_slides = None
		self.n_background_events = 0

		self.plot1 = Plot1(instruments, dtinterval, dfinterval, dhinterval)
		self.plot2 = Plot2()
		self.covariance = Covariance()


	def add_background(self, contents):
		# count the number of time slides (assume all input files
		# list the exact same time slides)
		if self.n_time_slides is None:
			self.n_time_slides = contents.connection.cursor().execute("""SELECT COUNT(DISTINCT time_slide_id) FROM time_slide""").fetchone()[0]

		# iterate over non-zero-lag burst+burst coincidences
		# involving the two desired instruments
		for pair in map(tuple, itertools.choices(self.instruments, 2)):
			for b1_confidence, b1_peak_time, b1_peak_time_ns, b1_duration, b1_peak_frequency, b1_bandwidth, b1_hrss, b2_confidence, b2_peak_time, b2_peak_time_ns, b2_duration, b2_peak_frequency, b2_bandwidth, b2_hrss in contents.connection.cursor().execute("""
SELECT b1.confidence, b1.peak_time + t1.offset, b1.peak_time_ns, b1.ms_duration, b1.peak_frequency, b1.ms_bandwidth, b1.ms_hrss, b2.confidence, b2.peak_time + t2.offset, b2.peak_time_ns, b2.ms_duration, b2.peak_frequency, b2.ms_bandwidth, b2.ms_hrss FROM
	sngl_burst AS b1
	JOIN coinc_event_map AS a ON (
		a.event_id == b1.event_id
		AND a.table_name == 'sngl_burst'
	)
	JOIN coinc_event_map AS b ON (
		b.coinc_event_id == a.coinc_event_id
	)
	JOIN sngl_burst AS b2 ON (
		b.event_id == b2.event_id
		AND b.table_name == 'sngl_burst'
	)
	JOIN coinc_event ON (
		coinc_event.coinc_event_id == a.coinc_event_id
	)
	JOIN time_slide AS t1 ON (
		coinc_event.time_slide_id == t1.time_slide_id
		AND b1.ifo == t1.instrument
	)
	JOIN time_slide AS t2 ON (
		coinc_event.time_slide_id == t2.time_slide_id
		AND b2.ifo == t2.instrument
	)
WHERE
	coinc_event.coinc_def_id == ?
	AND EXISTS (SELECT * FROM time_slide WHERE time_slide.time_slide_id == coinc_event.time_slide_id AND time_slide.offset != 0)
	AND b1.ifo == ?
	AND b2.ifo == ?
			""", (contents.bb_definer_id, pair[0], pair[1])):
				self.n_background_events += 1

				dt = float(LIGOTimeGPS(b1_peak_time, b1_peak_time_ns) - LIGOTimeGPS(b2_peak_time, b2_peak_time_ns)) / ((b1_duration + b2_duration) / 2)
				df = (b1_peak_frequency - b2_peak_frequency) / ((b1_bandwidth + b2_bandwidth) / 2)
				dh = (b1_hrss - b2_hrss) / ((b1_hrss + b2_hrss) / 2)

				self.plot1.add_bak(pair, dt, df, dh)
				self.plot2.add_bak(pair, dt, df)
				self.covariance.add_bak(dt, df, dh)


	def add_injections(self, contents):
		# iterate over injections recovered in both of the two
		# desired instruments
		for pair in map(tuple, itertools.choices(self.instruments, 2)):
			for b1_confidence, b1_peak_time, b1_peak_time_ns, b1_duration, b1_peak_frequency, b1_bandwidth, b1_hrss, b2_confidence, b2_peak_time, b2_peak_time_ns, b2_duration, b2_peak_frequency, b2_bandwidth, b2_hrss in contents.connection.cursor().execute("""
SELECT b1.confidence, b1.peak_time + t1.offset, b1.peak_time_ns, b1.ms_duration, b1.peak_frequency, b1.ms_bandwidth, b1.ms_hrss, b2.confidence, b2.peak_time + t2.offset, b2.peak_time_ns, b2.ms_duration, b2.peak_frequency, b2.ms_bandwidth, b2.ms_hrss FROM
	sngl_burst AS b1
	JOIN coinc_event_map AS a ON (
		a.event_id == b1.event_id
		AND a.table_name == 'sngl_burst'
	)
	JOIN coinc_event_map AS b ON (
		b.coinc_event_id == a.coinc_event_id
	)
	JOIN sngl_burst AS b2 ON (
		b.event_id == b2.event_id
		AND b.table_name == 'sngl_burst'
	)
	JOIN coinc_event ON (
		coinc_event.coinc_event_id == a.coinc_event_id
	)
	JOIN time_slide AS t1 ON (
		coinc_event.time_slide_id == t1.time_slide_id
		AND b1.ifo == t1.instrument
	)
	JOIN time_slide AS t2 ON (
		coinc_event.time_slide_id == t2.time_slide_id
		AND b2.ifo == t2.instrument
	)
WHERE
	coinc_event.coinc_def_id == ?
	AND b1.ifo == ?
	AND b2.ifo == ?
			""", (contents.sb_definer_id, pair[0], pair[1])):
				dt = float(LIGOTimeGPS(b1_peak_time, b1_peak_time_ns) - LIGOTimeGPS(b2_peak_time, b2_peak_time_ns)) / ((b1_duration + b2_duration) / 2)
				df = (b1_peak_frequency - b2_peak_frequency) / ((b1_bandwidth + b2_bandwidth) / 2)
				dh = (b1_hrss - b2_hrss) / ((b1_hrss + b2_hrss) / 2)

				self.plot1.add_inj(pair, dt, df, dh)
				self.plot2.add_inj(pair, dt, df)
				self.covariance.add_inj(dt, df, dh)

	def finish(self):
		self.plot1.finish()
		self.plot2.finish()
		self.covariance.finish()

		print >>sys.stderr, "=== Summary ==="
		print >>sys.stderr, "Non-injection average event rate = %g events / time slide" % (float(self.n_background_events) / self.n_time_slides)
		print >>sys.stderr, "Injection normalized covariance matrix ="
		print >>sys.stderr, str(self.covariance.inj_cov)
		print >>sys.stderr, "Background normalized covariance matrix ="
		print >>sys.stderr, str(self.covariance.bak_cov)

		write_likelihood_control("ligolw_burca_likelihood_control.xml.gz", self.plot1)


#
# =============================================================================
#
#                          Likelihood Control Output
#
# =============================================================================
#


def write_likelihood_control(filename, plot1, verbose = False):
	xmldoc = ligolw.Document()
	xmldoc.appendChild(ligolw.LIGO_LW())
	for pair in map(tuple, itertools.choices(plot1.instruments, 2)):
		xmldoc.childNodes[-1].appendChild(array.from_array(u"%s_%s_dt" % pair, numpy.array([plot1.inj_dt[pair].xvals(), plot1.inj_dt[pair].array, plot1.bak_dt[pair].array]), (u"dt", u"dt,P_inj,P_bak")))
		xmldoc.childNodes[-1].appendChild(array.from_array(u"%s_%s_df" % pair, numpy.array([plot1.inj_df[pair].xvals(), plot1.inj_df[pair].array, plot1.bak_df[pair].array]), (u"df", u"df,P_inj,P_bak")))
		xmldoc.childNodes[-1].appendChild(array.from_array(u"%s_%s_dh" % pair, numpy.array([plot1.inj_dh[pair].xvals(), plot1.inj_dh[pair].array, plot1.bak_dh[pair].array]), (u"dh", u"dh,P_inj,P_bak")))
	utils.write_filename(xmldoc, filename, verbose = verbose, gz = (filename or "stdout")[-3:] == ".gz")


#
# =============================================================================
#
#                                     Plot
#
# =============================================================================
#


options, filenames = parse_command_line()


plots = Plots(["H1", "H2", "L1"], segments.segment(-1.0, +1.0), segments.segment(-5.0, +5.0), segments.segment(-2.0, +2.0))


if options.verbose:
	print >>sys.stderr, "=== Injections ==="

filenames = glob.glob(options.injection_glob)
for n, filename in enumerate(utils.sort_files_by_size(filenames, options.verbose, reverse = True)):

	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename)
	connection = sqlite3.connect(filename)
	dbtables.DBTable_set_connection(connection)
	database = SnglBurstUtils.CoincDatabase().summarize(dbtables.DBTable_get_xml(), "lalapps_power", options.verbose)

	plots.add_injections(database)

	connection.close()


if options.verbose:
	print >>sys.stderr, "=== Background ==="

filenames = glob.glob(options.background_glob)
for n, filename in enumerate(utils.sort_files_by_size(filenames, options.verbose, reverse = True)):

	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename)
	connection = sqlite3.connect(filename)
	dbtables.DBTable_set_connection(connection)
	database = SnglBurstUtils.CoincDatabase().summarize(dbtables.DBTable_get_xml(), "power", options.verbose)

	plots.add_background(database)

	connection.close()


plots.finish()

plots.plot1.fig.savefig("ligolw_burca_tailor.png")
plots.plot2.fig.savefig("ligolw_burca_tailor_2.png")
