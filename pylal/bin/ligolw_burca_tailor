#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2007  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import glob
import math
from optparse import OptionParser
from pysqlite2 import dbapi2 as sqlite3
import sys


from glue.ligolw import dbtables
from glue.ligolw import utils
from pylal import ligolw_burca_tailor
from pylal import SnglBurstUtils
from pylal import snglcoinc


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog [options] -i|--injection-glob pattern -b|--background-glob pattern",
		description = "%prog analyzes a collection of SQLite database files converted from ligolw_burca XML outputs, and measures probability distributions for a variety of parameters computed from the coincidences therein.  The measured distributions are recorded separately for coincidences identified as injections, and coincidences identified as non-zero-lag backgrouds.  The distributions are written to a likelihood data file in XML format, which can be used by ligolw_burca in a second pass to assign likelihoods to each coincidence in a collection of input files.  The command line arguments are used to provide shell path patterns for the files to obtain injection data from, and the files to obtain background data from."
	)
	parser.add_option("-c", "--control-file", metavar = "filename", default = "ligolw_burca_likelihood_control.xml.gz", help = "Set the name of the likelihood control file to write (default = \"ligolw_burca_likelihood_control.xml.gz\").")
	parser.add_option("-i", "--injection-glob", metavar = "pattern", help = "Shell filename pattern for injection files.")
	parser.add_option("-b", "--background-glob", metavar = "pattern", help = "Shell filename pattern for non-injection files.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	if options.background_glob is None:
		raise ValueError, "missing required --background-glob argument"
	if options.injection_glob is None:
		raise ValueError, "missing required --injection-glob argument"

	return options, (filenames or [None])


#
# =============================================================================
#
#                                 Bookkeeping
#
# =============================================================================
#


#
# Make a plot from a Delta_Distributions object.
#


def plot_Deltas(deltas):
	#
	# Create a figure.
	#

	fig = SnglBurstUtils.figure.Figure()
	SnglBurstUtils.FigureCanvas(fig)

	#
	# How many instrument pairs are there?
	#

	n_horiz = len(deltas.thresholds.keys())

	#
	# Each sub plot's aspect ratio is the golden ratio.
	#

	size = 12.0
	n_vert = 3
	fig.set_size_inches(size * n_horiz / n_vert, size / ((1 + math.sqrt(5)) / 2))

	#
	# Iterate over instrument pairs.
	#

	for i, pair in enumerate(deltas.thresholds.keys()):
		#
		# Construct the axes for this instrument pair.
		#

		vlabel_allowance = .05
		hlabel_allowance = .03
		border = .007
		left = float(i) / n_horiz + hlabel_allowance + border
		width = 1.0 / n_horiz - hlabel_allowance - 2 * border
		height = 1.0 / n_vert

		dt_axes = fig.add_axes((left, 0 * height + vlabel_allowance + border, width, height - vlabel_allowance - 2 * border))
		df_axes = fig.add_axes((left, 1 * height + vlabel_allowance + border, width, height - vlabel_allowance - 2 * border))
		dh_axes = fig.add_axes((left, 2 * height + vlabel_allowance + border, width, height - vlabel_allowance - 2 * border))

		dt_axes.set_xlabel(r"$(t_{\mathrm{%s}} - t_{\mathrm{%s}}) / \left< \Delta t \right>$" % pair)
		dt_axes.set_ylabel(r"$P$")
		df_axes.set_xlabel(r"$(f_{\mathrm{%s}} - f_{\mathrm{%s}}) / \left< \Delta f \right>$" % pair)
		df_axes.set_ylabel(r"$P$")
		dh_axes.set_xlabel(r"$({h_{\mathrm{rss}}}_{\mathrm{%s}} - {h_{\mathrm{rss}}}_{\mathrm{%s}}) / \left< h_{\mathrm{rss}} \right>$" % pair)
		dh_axes.set_ylabel(r"$P$")

		#
		# Plot the data on them.
		#

		dt_axes.plot(deltas.inj_dt[pair].xvals(), deltas.inj_dt[pair].filtered(), "r")
		dt_axes.plot(deltas.bak_dt[pair].xvals(), deltas.bak_dt[pair].filtered(), "k")
		df_axes.plot(deltas.inj_df[pair].xvals(), deltas.inj_df[pair].filtered(), "r")
		df_axes.plot(deltas.bak_df[pair].xvals(), deltas.bak_df[pair].filtered(), "k")
		dh_axes.plot(deltas.inj_dh[pair].xvals(), deltas.inj_dh[pair].filtered(), "r")
		dh_axes.plot(deltas.bak_dh[pair].xvals(), deltas.bak_dh[pair].filtered(), "k")

	#
	# Done.
	#

	return fig


#
# Make a plot from a scatter object
#


def plot_Scatter(scatter):
	fig = SnglBurstUtils.figure.Figure()
	SnglBurstUtils.FigureCanvas(fig)
	fig.set_size_inches(10.0, 10.0 / ((1 + math.sqrt(5)) / 2))
	axes = fig.gca()
	axes.set_title(r"Parameter Reconstruction Independence")
	axes.plot(scatter.inj_x, scatter.inj_y, "r+")
	axes.plot(scatter.bak_x, scatter.bak_y, "k+")
	axes.legend(["Injections", "Accidentals"])
	return fig


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# Command line.
#


options, filenames = parse_command_line()


#
# Clear the statistics book-keep object.
#


stats = None


#
# Iterate over non-injection files
#


if options.verbose:
	print >>sys.stderr, "=== Background ==="

filenames = glob.glob(options.background_glob)
if not len(filenames):
	raise ValueError, "error:  no background files found"

for n, filename in enumerate(utils.sort_files_by_size(filenames, options.verbose, reverse = True)):
	#
	# Open the database file.
	#

	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename)
	connection = sqlite3.connect(filename)
	dbtables.DBTable_set_connection(connection)
	database = SnglBurstUtils.CoincDatabase().summarize(dbtables.DBTable_get_xml(), "power", options.verbose)

	#
	# If not already done, recover the --thresholds arguments, and
	# construct a book-keeping object.
	#

	if stats is None:
		stats = ligolw_burca_tailor.Stats(ligolw_burca_tailor.dbget_thresholds(connection))

	#
	# Record statistics.
	#

	stats.add_background(database)
	connection.close()


#
# Iterate over injection files.
#


if options.verbose:
	print >>sys.stderr, "=== Injections ==="

filenames = glob.glob(options.injection_glob)
if not len(filenames):
	raise ValueError, "error:  no injections files found"

for n, filename in enumerate(utils.sort_files_by_size(filenames, options.verbose, reverse = True)):
	#
	# Open the database file.
	#

	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename)
	connection = sqlite3.connect(filename)
	dbtables.DBTable_set_connection(connection)
	database = SnglBurstUtils.CoincDatabase().summarize(dbtables.DBTable_get_xml(), "lalapps_power", options.verbose)

	#
	# Record statistics.
	#

	stats.add_injections(database)
	connection.close()


#
# Post-process and generate plots.
#


stats.finish()

print >>sys.stderr, "=== Summary ==="
print >>sys.stderr, "Non-injection average event rate = %g events / time slide" % (float(stats.n_background_events) / stats.n_time_slides)
print >>sys.stderr, "Injection normalized covariance matrix ="
print >>sys.stderr, str(stats.covariance.inj_cov)
print >>sys.stderr, "Background normalized covariance matrix ="
print >>sys.stderr, str(stats.covariance.bak_cov)

plot_Deltas(stats.deltas).savefig("ligolw_burca_tailor.png")
fig = plot_Scatter(stats.scatter)
fig.gca().set_xlabel(r"$(t_{\mathrm{%s}} - t_{\mathrm{%s}}) / \left< \Delta t \right>$" % ("H1", "H2"))
fig.gca().set_ylabel(r"$(f_{\mathrm{%s}} - f_{\mathrm{%s}}) / \left< \Delta f \right>$" % ("H1", "H2"))
fig.savefig("ligolw_burca_tailor_2.png")


#
# Write likelihood control file for second ligolw_burca pass.
#


likelihood_control = ligolw_burca_tailor.gen_likelihood_control(stats.deltas)
utils.write_filename(likelihood_control, options.control_file, verbose = options.verbose, gz = options.control_file[-3:] == ".gz")
