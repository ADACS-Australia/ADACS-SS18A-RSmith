#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2007  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import glob
import math
from optparse import OptionParser
from pysqlite2 import dbapi2 as sqlite3
import string
import sys


from glue import segments
from glue import lal
from glue.ligolw import dbtables
from glue.ligolw import utils
from pylal import ligolw_burca_tailor
from pylal import SnglBurstUtils
from pylal.date import LIGOTimeGPS


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


T010150_letters = set(string.ascii_lowercase + string.ascii_uppercase + string.digits + "_+#")


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog [options] <-i|--injection-glob pattern | --injection-cache filename> <-b|--background-glob pattern | --background-cache filename> [filename ...]",
		description = "%prog analyzes a collection of SQLite3 database files containing ligolw_burca outputs, and measures probability distributions for a variety of parameters computed from the coincidences therein.  The distributions are written to a likelihood data file in XML format, which can be used by ligolw_burca for the excesspower2 algorithm in which a second pass assigns likelihoods to each coincidence.  The command line arguments are used to provide shell patterns for the files from which to obtain injection and backgroun coincidences.  If file names are given on the command line following the arguments, then likelihood data is loaded from those files and added to the output."
	)
	parser.add_option("--background-cache", metavar = "filename", default = [], action = "append", help = "Filename for LAL cache of non-injection files.")
	parser.add_option("-b", "--background-glob", metavar = "pattern", default = [], action = "append", help = "Shell filename pattern for non-injection files.")
	parser.add_option("--injection-cache", metavar = "filename", default = [], action = "append", help = "Filename for LAL cache of injection files.")
	parser.add_option("-i", "--injection-glob", metavar = "pattern", default = [], action = "append", help = "Shell filename pattern for injection files.")
	parser.add_option("--max-hrss-ratio", metavar = "ratio", type = "float", default = 4.0, help = "When measuring the distribution of coincidence parameters associated with injections, discard any sngl_burst events from the coincs whose measured h_rss differs from the correct value for that instrument by more than this factor.  This helps ensure that the injection distributions are not being measured from accidentals.  Default = 4.0")
	parser.add_option("--max-frequency-ratio", metavar = "ratio", type = "float", default = 2.0, help = "When measuring the distribution of coincidence parameters associated with injections, discard any sngl_burst events from the coincs whose measured peak frequency differs from the correct value by more than this factor.  This helps ensure that the injection distributions are not being measured from accidentals.  Default = 2.0")
	parser.add_option("-o", "--output", metavar = "filename", default = None, help = "Set the name of the likelihood control file to write (default = stdout).")
	parser.add_option("--T010150", metavar = "description", default = None, help = "Write the output to a file whose name is compatible with the file name format described in LIGO-T010150-00-E, \"Naming Convention for Frame Files which are to be Processed by LDAS\".  The description string will be used to form the second field in the file name.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	if not filenames:
		if not options.background_glob and not options.background_cache:
			raise ValueError, "missing required --background-glob or --background-cache argument"
		if not options.injection_glob and not options.injection_cache:
			raise ValueError, "missing required --injection-glob or --injection-cache argument"
	if options.T010150 is not None:
		if options.output is not None:
			raise ValueError, "cannot set both --T010150 and --output"
		if options.T010150 == "":
			options.T010150 = "EXCESSPOWER_LIKELIHOOD"
		elif set(options.T010150) - T010150_letters:
			raise ValueError, "invalid description \"%s\"" % options.T010150

	return options, filenames


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# Command line.
#


options, filenames = parse_command_line()


#
# Load pre-computed likelihood data.
#


if filenames is not None:
	extra_data, segs = ligolw_burca_tailor.coinc_params_distributions_from_filenames(filenames, u"ligolw_burca_tailor", verbose = options.verbose)
else:
	extra_data, segs = None, segments.segmentlistdict()


#
# Clear the statistics book-keeping object.
#


stats = None
instruments = set()


#
# Iterate over non-injection files
#


if options.verbose:
	print >>sys.stderr, "=== Background ==="

filenames = [f for g in options.background_glob for f in glob.glob(g)] + [lal.CacheEntry(line, coltype = LIGOTimeGPS).path() for f in options.background_cache for line in file(f)]

for n, filename in enumerate(utils.sort_files_by_size(filenames, options.verbose, reverse = True)):
	#
	# Open the database file.
	#

	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename),

	connection = sqlite3.connect(filename)
	dbtables.DBTable_set_connection(connection)

	#
	# Summarize the database.
	#

	database = SnglBurstUtils.CoincDatabase().summarize(dbtables.DBTable_get_xml(), "lalapps_power", options.verbose)
	instruments |= database.instruments
	segs |= database.seglists

	#
	# If not already done, recover the --thresholds arguments, and
	# construct a DistributionsStats instance to populate a
	# CoincParamsDistributions book-keeping object from the information
	# in the input files.
	#

	if stats is None:
		stats = ligolw_burca_tailor.DistributionsStats(options.max_hrss_ratio, options.max_frequency_ratio, ligolw_burca_tailor.dbget_thresholds(connection))

	#
	# Record statistics.
	#

	stats.add_background(database)

	#
	# Clean up.
	#

	del database, connection


#
# Iterate over injection files.
#


if options.verbose:
	print >>sys.stderr, "=== Injections ==="

filenames = [f for g in options.injection_glob for f in glob.glob(g)] + [lal.CacheEntry(line, coltype = LIGOTimeGPS).path() for f in options.injection_cache for line in file(f)]

for n, filename in enumerate(utils.sort_files_by_size(filenames, options.verbose, reverse = True)):
	#
	# Open the database file.
	#

	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename),

	connection = sqlite3.connect(filename)
	dbtables.DBTable_set_connection(connection)

	#
	# Summarize the database.
	#

	database = SnglBurstUtils.CoincDatabase().summarize(dbtables.DBTable_get_xml(), "lalapps_power", options.verbose)
	instruments |= database.instruments
	segs |= database.seglists

	#
	# If not already done, recover the --thresholds arguments, and
	# construct a DistributionsStats instance to populate a
	# CoincParamsDistributions book-keeping object from the information
	# in the input files.
	#

	if stats is None:
		stats = ligolw_burca_tailor.DistributionsStats(options.max_hrss_ratio, options.max_frequency_ratio, ligolw_burca_tailor.dbget_thresholds(connection))

	#
	# Record statistics.
	#

	stats.add_injections(database)

	#
	# Clean up.
	#

	del database, connection


#
# Do we have any data?
#


if stats is None and extra_data is None:
	if options.verbose:
		print >>sys.stderr, "warning:  no input files!"
	sys.exit()
elif stats is None and extra_data is not None:
	coinc_params_distributions = extra_data
elif stats is not None and extra_data is None:
	coinc_params_distributions = stats.distributions
else:
	coinc_params_distributions = stats.distributions
	coinc_params_distributions += extra_data


#
# Output.
#


def T010150_basename(instruments, description, seglists):
	instruments = list(instruments)
	instruments.sort()
	seg = seglists.extent_all()
	return "%s-%s-%s-%s" % ("+".join(instruments), description, str(seg[0]), str(abs(seg)))


if options.T010150:
	filename = T010150_basename(instruments, options.T010150, segs) + ".xml.gz"
else:
	filename = options.output


xmldoc = ligolw_burca_tailor.gen_likelihood_control(coinc_params_distributions, seglists)
utils.write_filename(xmldoc, filename, verbose = options.verbose, gz = (filename or "stdout").endswith(".gz"))
