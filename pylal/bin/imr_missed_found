#!/usr/bin/python
import sys
try:
        import sqlite3
except ImportError:
        # pre 2.5.x
        from pysqlite2 import dbapi2 as sqlite3

import math
import numpy
from optparse import OptionParser
from glue import segments
from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import dbtables
from glue.ligolw import utils
from glue.ligolw import table
from glue import segmentsUtils
from glue.ligolw.utils import process
from glue.ligolw.utils import segments as ligolw_segments

from pylal import db_thinca_rings
from pylal import llwapp
from pylal import rate
from pylal import SimInspiralUtils
from pylal.xlal.datatypes.ligotimegps import LIGOTimeGPS

from pylal import spawaveform
import math
import matplotlib
matplotlib.use('Agg')
import pylab
from scipy import optimize
from scipy import special


from pylal import git_version
__author__ = "Chad Hanna <channa@ligo.caltech.edu>, Satya Mohapatra <satya@physics.umass.edu>"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date

lsctables.LIGOTimeGPS = LIGOTimeGPS

class Summary(object):
	def __init__(self, opts, flist):
		self.segments = segments.segmentlistdict()
		self.non_inj_fnames = []
		self.inj_fnames = []
		self.found = {}
		self.missed = {}
		self.opts = opts
		self.veto_segments = segments.segmentlistdict()
		self.zero_lag_segments = {}
		self.instruments = []
		self.livetime = {}
		self.multi_burst_table = None
		self.coinc_inspiral_table = None
		self.coinc_ringdown_table = None

		for f in flist:
			if opts.verbose:
				print >> sys.stderr, "Gathering stats from: %s...." % (f,)
			working_filename = dbtables.get_connection_filename(f, tmp_path=opts.tmp_space, verbose = opts.verbose)
			connection = sqlite3.connect(working_filename)
			dbtables.DBTable_set_connection(connection)
			xmldoc = dbtables.get_xml(connection)

			sim = False
			# look for a sim table
			try:
				sim_inspiral_table = table.get_table(xmldoc, dbtables.lsctables.SimInspiralTable.tableName)
				self.inj_fnames.append(f)
				sim = True
			except ValueError:
				self.non_inj_fnames.append(f)

			# FIGURE OUT IF IT IS A BURST OR INSPIRAL RUN OR RINGDOWN RUN
			try:
				self.multi_burst_table = table.get_table(xmldoc, dbtables.lsctables.MultiBurstTable.tableName)
			except ValueError:
				self.multi_burst_table = None
			try:
				self.coinc_inspiral_table = table.get_table(xmldoc, dbtables.lsctables.CoincInspiralTable.tableName)
			except ValueError:
				self.coinc_inspiral_table = None

			try:
				self.coinc_ringdown_table = table.get_table(xmldoc, dbtables.lsctables.CoincRingdownTable.tableName)
			except ValueError:
				self.coinc_ringdown_table = None

			if self.multi_burst_table is not None and self.coinc_inspiral_table is not None:
				print >>sys.stderr, "both burst and inspiral tables found.  Aborting"
				raise ValueError

			if self.coinc_inspiral_table is not None and self.coinc_ringdown_table is not None:
				print >>sys.stderr, "both ringdown and inspiral tables found.  Aborting"
				raise ValueError

			if self.multi_burst_table is not None and self.coinc_ringdown_table is not None:
				print >>sys.stderr, "both burst and ringdown tables found.  Aborting"
				raise ValueError

			if not sim:
				self.get_instruments(connection)
				self.segments += self.get_segments(connection,xmldoc)

			dbtables.discard_connection_filename(f, working_filename, verbose = opts.verbose)
			dbtables.DBTable_set_connection(None)

		# remove redundant instruments
		self.instruments = list(set(self.instruments))

		# segments and livetime by instruments
		for i in self.instruments:
			self.zero_lag_segments[i] = self.segments.intersection(i) - self.segments.union(set(self.segments.keys()) - i)
			self.livetime[i] = float(abs(self.zero_lag_segments[i]))

	def get_segments(self, connection,xmldoc):
		segs = segments.segmentlistdict()
		if self.coinc_inspiral_table is not None:
			segs = db_thinca_rings.get_thinca_zero_lag_segments(connection, program_name = self.opts.live_time_program)

		if self.coinc_ringdown_table is not None:
			if opts.live_time_program == "lalapps_ring":
				segs = llwapp.segmentlistdict_fromsearchsummary(xmldoc, self.opts.live_time_program).coalesce()
		if self.multi_burst_table is not None:
			#FIXME CWB case of rings not handled
			if opts.live_time_program == "omega_to_coinc":
				segs = llwapp.segmentlistdict_fromsearchsummary(xmldoc, self.opts.live_time_program).coalesce()
			if opts.live_time_program == "waveburst":
				segs = db_thinca_rings.get_thinca_zero_lag_segments(connection, program_name = self.opts.live_time_program)
		segs -= self.get_veto_segments(connection, xmldoc)
		return segs

	def get_veto_segments(self, connection, xmldoc=None):
		if self.coinc_inspiral_table is not None:
			if self.opts.veto_segments_name is not None: return db_thinca_rings.get_veto_segments(connection, self.opts.veto_segments_name)
		if self.coinc_ringdown_table is not None:
			if self.opts.veto_segments_name is not None: return ligolw_segments.segmenttable_get_by_name(xmldoc, self.opts.veto_segments_name).coalesce()
		# FIXME BURST CASE VETOS NOT HANDLED
		else: return segments.segmentlistdict()

	def get_instruments(self, connection):
		for i in connection.cursor().execute('SELECT DISTINCT(instruments) FROM coinc_event WHERE instruments!=""'):
			if i[0]: self.instruments.append(frozenset(lsctables.instrument_set_from_ifos(i[0])))

	def get_injections(self, instruments, FAR=float("inf")):
		injfnames = self.inj_fnames
		zero_lag_segments = self.zero_lag_segments[instruments]
		verbose = self.opts.verbose
		found = []
		missed = []
		sims = []
		print >>sys.stderr, ""
		for cnt, f in enumerate(injfnames):
			print >>sys.stderr, f +  " getting injections below FAR: " + str(FAR) + ":\t%.1f%%\r" % (100.0 * cnt / len(injfnames),),
			working_filename = dbtables.get_connection_filename(f, tmp_path = opts.tmp_space, verbose = verbose)
			connection = sqlite3.connect(working_filename)
			dbtables.DBTable_set_connection(connection)
			xmldoc = dbtables.get_xml(connection)
			# DON'T BOTHER CONTINUING IF THE INSTRUMENTS OF INTEREST ARE NOT HERE
			instruments_in_this_file = []
			for i in connection.cursor().execute('SELECT DISTINCT(instruments) FROM coinc_event WHERE instruments!=""'):
				if i[0]: instruments_in_this_file.append(frozenset(lsctables.instrument_set_from_ifos(i[0])))
			if instruments not in instruments_in_this_file:
				connection.close()
				dbtables.discard_connection_filename(f, working_filename, verbose = verbose)
				dbtables.DBTable_set_connection(None)
				continue

			# WORK OUT CORRECT SEGMENTS FOR THIS FILE WHERE WE SHOULD SEE INJECTIONS
			segs = self.get_segments(connection, xmldoc)

			zero_lag_segments  = segs.intersection(instruments) - segs.union(set(segs.keys()) - instruments)

			###############

			if self.coinc_ringdown_table is not None:
				# check to see if a maxextent option was used in cafe/rinca land
				coinc_end_time_seg_param = process.get_process_params(xmldoc, "ligolw_rinca", "--coinc-end-time-segment")
				if len(coinc_end_time_seg_param) == 1:
					segl = segmentsUtils.from_range_strings(coinc_end_time_seg_param,boundtype=float)
					zero_lag_segments = zero_lag_segments & segl
			else:
				# FIXME what would that mean if it is greater than one???
				pass

			# DEFINE THE INJECTION WAS MADE FUNCTION
			def injection_was_made(geocent_end_time, geocent_end_time_ns, zero_lag_segments = zero_lag_segments):
				"""
				return True if injection was made in the given segmentlist
				"""
				return lsctables.LIGOTimeGPS(geocent_end_time, geocent_end_time_ns) in zero_lag_segments

			connection.create_function("injection_was_made", 2, injection_was_made)
			make_sim_inspiral = lsctables.table.get_table(dbtables.get_xml(connection), lsctables.SimInspiralTable.tableName).row_from_cols
			if not self.coinc_ringdown_table:
				sims.extend(lsctables.table.get_table(dbtables.get_xml(connection), lsctables.SimInspiralTable.tableName))
			# INSPIRAL
			if self.coinc_inspiral_table is not None:
				for values in connection.cursor().execute("""
SELECT
  sim_inspiral.*,
  -- true if injection matched a coinc below the false alarm rate threshold
  EXISTS (
    SELECT
      *
    FROM
      coinc_event_map AS mapa
      JOIN coinc_event_map AS mapb ON (
        mapa.coinc_event_id == mapb.coinc_event_id
      )
      JOIN coinc_inspiral ON (
        mapb.table_name == "coinc_event"
        AND mapb.event_id == coinc_inspiral.coinc_event_id
      )
    WHERE
      mapa.table_name == "sim_inspiral"
      AND mapa.event_id == sim_inspiral.simulation_id
      AND coinc_inspiral.combined_far < ?
  )
FROM
  sim_inspiral
WHERE
  -- only interested in injections that were injected
  injection_was_made(sim_inspiral.geocent_end_time, sim_inspiral.geocent_end_time_ns)
				""", (FAR,)):
					sim = make_sim_inspiral(values)
					if values[-1]:
						found.append(sim)
					else:
						missed.append(sim)

# RINGDOWN
                        if self.coinc_ringdown_table is not None:
                                for values in connection.cursor().execute("""
SELECT
  sim_inspiral.*,
  -- true if injection matched a coinc below the false alarm rate threshold
  EXISTS (
    SELECT
      *
    FROM
      coinc_event_map AS mapa
      JOIN coinc_event_map AS mapb ON (
        mapa.coinc_event_id == mapb.coinc_event_id
      )
      JOIN coinc_ringdown ON (
        mapb.table_name == "coinc_event"
        AND mapb.event_id == coinc_ringdown.coinc_event_id
      )
    WHERE
      mapa.table_name == "sim_inspiral"
      AND mapa.event_id == sim_inspiral.simulation_id
      AND coinc_ringdown.false_alarm_rate < ?
  )
FROM
  sim_inspiral
WHERE
  -- only interested in injections that were injected
  injection_was_made(sim_inspiral.geocent_end_time, sim_inspiral.geocent_end_time_ns)
                                """, (FAR,)):
                                        sim = make_sim_inspiral(values)
                                        if values[-1]:
                                                found.append(sim)
                                        else:
						missed.append(sim)


			# BURSTS
			if self.multi_burst_table is not None:
				for values in connection.cursor().execute("""
SELECT
  sim_inspiral.*,
  -- true if injection matched a coinc below the false alarm rate threshold
  EXISTS (
    SELECT
      *
    FROM
      coinc_event_map AS mapa
      JOIN coinc_event_map AS mapb ON (
        mapa.coinc_event_id == mapb.coinc_event_id
      )
      JOIN multi_burst ON (
        mapb.table_name == "coinc_event"
        AND mapb.event_id == multi_burst.coinc_event_id
      )
    WHERE
      mapa.table_name == "sim_inspiral"
      AND mapa.event_id == sim_inspiral.simulation_id
      AND multi_burst.false_alarm_rate < ?
  )
FROM
  sim_inspiral
WHERE
  -- only interested in injections that were injected
  injection_was_made(sim_inspiral.geocent_end_time, sim_inspiral.geocent_end_time_ns)
				""", (FAR,)):
					sim = make_sim_inspiral(values)
					if values[-1]:
						found.append(sim)
					else:
						missed.append(sim)
			# done
			dbtables.discard_connection_filename(f, working_filename, verbose = verbose)
			dbtables.DBTable_set_connection(None)

			print >>sys.stderr, "\nFound = %d Missed = %d" % (len(found), len(missed))
		return found, missed, sims

	def set_instruments_to_calculate(self):
		if self.opts.instruments is None: return self.instruments
		if self.opts.instruments in self.instruments:
			#return frozenset(lsctables.instrument_set_from_ifos(i[0]))
			return [self.opts.instruments]
		else:
			print >> sys.stderr, "Instruments %s do not exist in DB, nothing will be calculated" % (self.instruments,)
		return []


def parse_command_line():
	parser = OptionParser(version=git_version.verbose_msg, usage = "%prog [options] [file ...]", description = "%prog computes missed found plots")
	parser.add_option("--instruments", metavar = "name[,name,...]", help = "Set the list of instruments.  Required.  Example \"H1,H2,L1\"")
	parser.add_option("--live-time-program", default = "thinca", metavar = "name", help = "Set the name of the program whose rings will be extracted from the search_summary table.  Default = \"thinca\".")
	parser.add_option("--output-nametag", dest= "outnametag", default = "omega", metavar = "name", help = "Set the name of the program whose rings will be extracted from the search_summary table.  Default = \"omega\".")
	parser.add_option("--far", help = "FAR to use for injection finding instead of loudest event", default=float("inf"), type="float")
	parser.add_option("--veto-segments-name", default = "vetoes", help = "Set the name of the veto segments to use from the XML document.")
	parser.add_option("-t", "--tmp-space", metavar = "path", help = "Path to a directory suitable for use as a work area while manipulating the database file.  The database file will be worked on in this directory, and then moved to the final location when complete.  This option is intended to improve performance when running in a networked environment, where there might be a local disk with higher bandwidth than is available to the filesystem on which the final output will reside.")
	parser.add_option("--verbose", action = "store_true", help = "Be verbose.")

	opts, filenames = parser.parse_args()

	#if opts.instruments: opts.instruments = lsctables.instrument_set_from_ifos(opts.instruments)
	if opts.instruments: opts.instruments = frozenset(lsctables.instrument_set_from_ifos(opts.instruments))
	if not filenames:
		print >>sys.stderr, "must specify at least one database file"
		sys.exit(1)
	return opts, filenames

opts, filenames = parse_command_line()

summ = Summary(opts, filenames)

def inbin(x, y, xbottom, xtop, ybottom, ytop):
	xmasked = numpy.ma.masked_outside(x, xbottom, xtop)
	ymasked = numpy.ma.masked_array(y, mask = xmasked.mask)
	total = numpy.ma.masked_outside(ymasked, ybottom, ytop)
	return numpy.ma.count(total)

#final spin
def finalspin(m1, m2, s1z, s2z):
    G = 6.67259e-11     	#Gravitational constant
    c = 2.99792458e8    	#Speed of light
    M_sun = 1.98892e30  	#Solar mass
    Mpc = 3.0856775807e22	#Megaparsec (in meters)
    s4 = -0.129
    s5 = -0.384
    t0 = -2.686
    t2 = -3.454
    t3 = 2.353
    s1x = 0
    s1y = 0
    s2x = 0
    s2y = 0
    M = m1 + m2
    q = m2/m1
    eta = m1*m2/(m1+m2)**2
    a1 = math.sqrt(s1x**2 + s1y**2 + s1z**2)
    a2 = math.sqrt(s2x**2 + s2y**2 + s2z**2)
    if (a1 != 0) and (a2 != 0): cosa = (s1x*s2x + s1y*s2y + s1z*s2z)/(a1*a2)
    else:cosa = 0
    if a1 != 0: cosb = s1z/a1
    else: cosb = 0
    if a2 != 0: cosc = s2z/a2
    else: cosc = 0
    l = (s4/(1+q**2)**2 * (a1**2 + (a2**2)*(q**4) + 2*a1*a2*(q**2)*cosa) + (s5*eta + t0 + 2)/(1+q**2) * (a1*cosb + a2*(q**2)*cosc) + 2*math.sqrt(3.) + t2*eta + t3*(eta**2))
    afin = 1/(1+q)**2 * math.sqrt(a1**2 + (a2**2)*(q**4) + 2*a1*a2*(q**2)*cosa + 2*(a1*cosb + a2*(q**2)*cosc)*l*q + (l**2)*(q**2))
    return afin




def get_log_bin_vec(start,stop,bins):
  #edges vector
  bv = numpy.logspace(math.log(start,10), math.log(stop,10), bins)
  #center vector (edges vector length -1)
  cv = []
  for n in range(1,len(bv)):
    # compute bin centers 
    cv.append(bv[n-1]+10**( ( math.log(bv[n],10)-math.log(bv[n-1],10) ) / 2.0) )
  return bv, numpy.array(cv)



def bin(Sims, bv):
  out = {}
  for n in range(1,len(binVec)):
    out[n-1] = []
    for r in Sims:
      if r > bv[n-1] and r < bv[n]: out[n-1].append(r)
  return out



fitfunc = lambda p, x: p[3]*(1.+(special.erf((p[0]-x*p[2])/(p[1]))))
errfunc = lambda p, y, x: fitfunc(p,x) - y
  

#Missed-Found plots
fignum = 0
for instruments in summ.set_instruments_to_calculate():
    found, missed, sims = summ.get_injections(instruments,opts.far)
    fignum = fignum + 1

    if len(sims) > 0:
      pylab.figure(fignum)
      pylab.plot([s.mass1 for s in sims], [s.mass2 for s in sims],'.')
      pylab.xlabel('Injected Mass One ($M_\odot$)')
      pylab.ylabel('Injected Mass Two ($M_\odot$)')
      pylab.title('Injected Mass One Vs Mass Two')
      pylab.savefig(opts.outnametag + '_' +'mass1_mass2.png')

      fignum = fignum + 1
      pylab.figure(fignum)
      pylab.plot([s.spin1z for s in sims], [s.spin2z for s in sims],'.')
      pylab.xlabel('Injected Spin One z')
      pylab.ylabel('Injected Spin Two z')
      pylab.title('Injected Spin One Vs Spin Two')
      pylab.savefig(opts.outnametag + '_' + 'spin1_spin2.png')

      fignum = fignum + 1
      pylab.figure(fignum)
      pylab.hexbin([s.mass1 for s in sims], [s.mass2 for s in sims],bins='log',cmap=matplotlib.cm.jet)
      pylab.xlabel('Injected Mass One ($M_\odot$)')
      pylab.ylabel('Injected Mass Two ($M_\odot$)')
      pylab.title('Injected Mass One Vs Mass Two')
      cb = pylab.colorbar()
      cb.set_label('log10(N)')
      pylab.savefig(opts.outnametag + '_' + 'mass1_mass2_hist.png')


      fignum = fignum + 1
      pylab.figure(fignum)
      pylab.hist([s.mass1/s.mass2 for s in sims])
      pylab.xlabel('Mass One / Mass Two')
      pylab.title('Injected Mass One/ Mass Two')
      pylab.savefig(opts.outnametag + '_' + 'ratiomass1mass2_hist.png')


      fignum = fignum + 1
      pylab.figure(fignum)
      pylab.hexbin([s.spin1z for s in sims], [s.spin2z for s in sims],bins='log', cmap=matplotlib.cm.jet)
      pylab.xlabel('Injected Spin One z')
      pylab.ylabel('Injected Spin Two z')
      pylab.title('Injected Spin One Vs Spin Two')
      cb = pylab.colorbar()
      cb.set_label('log10(N)')
      pylab.savefig(opts.outnametag + '_' + 'spin1_spin2_hist.png')
	
    fignum = fignum + 1
    pylab.figure(fignum)
    pylab.semilogy([f.mchirp for f in found], [f.eff_dist_l for f in found],'.')
    pylab.semilogy([m.mchirp for m in missed], [m.eff_dist_l for m in missed],'k.')
    pylab.xlabel('Chirp Mass ($M_\odot$)')
    pylab.ylabel('Effective Distance (Mpc): L1')
    pylab.title('Missed-Found:L1 Effective Distance vs Chirp Mass')
    pylab.savefig(opts.outnametag + '_' + 'L1effdist_chirpmass.png')

    

    fignum = fignum + 1
    pylab.figure(fignum)
    pylab.semilogy([f.mass1+f.mass2 for f in found], [f.eff_dist_l for f in found],'.')
    pylab.semilogy([m.mass1+m.mass2 for m in missed], [m.eff_dist_l for m in missed],'k.')
    pylab.xlabel('Total Mass ($M_\odot$)')
    pylab.ylabel('Effective Distance (Mpc): L1')
    pylab.title('Missed-Found:L1 Effective Distance vs Total Mass')
    pylab.savefig(opts.outnametag + '_' + 'L1effdist_mass.png')

    fignum = fignum + 1
    pylab.figure(fignum)
    pylab.semilogy([spawaveform.computechi(f.mass1, f.mass2, f.spin1z, f.spin2z) for f in found], [f.eff_dist_l for f in found],'.')
    pylab.semilogy([spawaveform.computechi(m.mass1, m.mass2, m.spin1z, f.spin2z) for m in missed], [m.eff_dist_l for m in missed],'k.')
    pylab.xlabel('Mass Weighted Spin')
    pylab.ylabel('Effective Distance (Mpc): L1')
    pylab.title('Missed-Found:L1 Effective Distance vs Mass Weighted Spin')
    pylab.savefig(opts.outnametag + '_' + 'L1effdist_massweightedspin.png')

    fignum = fignum + 1
    pylab.figure(fignum)
    pylab.semilogy([finalspin(f.mass1, f.mass2, f.spin1z, f.spin2z) for f in found], [f.eff_dist_l for f in found],'.')
    pylab.semilogy([finalspin(m.mass1, m.mass2, m.spin1z, m.spin2z) for m in missed], [m.eff_dist_l for m in missed],'k.')
    pylab.xlabel('Final Spin')
    pylab.ylabel('Effective Distance (Mpc): L1')
    pylab.title('Missed-Found:L1 Effective Distance vs Final Spin')
    pylab.savefig(opts.outnametag + '_' + 'L1effdist_finalspin.png')

    fignum = fignum + 1
    pylab.figure(fignum)
    pylab.semilogy([f.mchirp for f in found], [f.eff_dist_h for f in found],'.')
    pylab.semilogy([m.mchirp for m in missed], [m.eff_dist_h for m in missed],'k.')
    pylab.xlabel('ChirpMass ($M_\odot$)')
    pylab.ylabel('Effective Distance (Mpc): H1')
    pylab.title('Missed-Found:H1 Effective Distance vs Chirp Mass')
    pylab.savefig(opts.outnametag + '_' + 'H1effdist_chirpmass.png')

    fignum = fignum + 1
    pylab.figure(fignum)
    pylab.semilogy([f.mass1+f.mass2 for f in found], [f.eff_dist_h for f in found],'.')
    pylab.semilogy([m.mass1+m.mass2 for m in missed], [m.eff_dist_h for m in missed],'k.')
    pylab.xlabel('Total Mass ($M_\odot$)')
    pylab.ylabel('Effective Distance (Mpc): H1')
    pylab.title('Missed-Found:H1 Effective Distance vs Total Mass')
    pylab.savefig(opts.outnametag + '_' + 'H1effdist_mass.png')

    fignum = fignum + 1
    pylab.figure(fignum)
    pylab.semilogy([spawaveform.computechi(f.mass1, f.mass2, f.spin1z, f.spin2z) for f in found], [f.eff_dist_h for f in found],'.')
    pylab.semilogy([spawaveform.computechi(m.mass1, m.mass2, m.spin1z, f.spin2z) for m in missed], [m.eff_dist_h for m in missed],'k.')
    pylab.xlabel('Mass Weighted Spin')
    pylab.ylabel('Effective Distance (Mpc): H1')
    pylab.title('Missed-Found:H1 Effective Distance vs Mass Weighted Spin')
    pylab.savefig(opts.outnametag + '_' + 'H1effdist_massweightedspin.png')

    fignum = fignum + 1
    pylab.figure(fignum)
    pylab.semilogy([finalspin(f.mass1, f.mass2, f.spin1z, f.spin2z) for f in found], [f.eff_dist_h for f in found],'.')
    pylab.semilogy([finalspin(m.mass1, m.mass2, m.spin1z, m.spin2z) for m in missed], [m.eff_dist_h for m in missed],'k.')
    pylab.xlabel('Final Spin')
    pylab.ylabel('Effective Distance (Mpc): H1')
    pylab.title('Missed-Found:H1 Effective Distance vs Final Spin')
    pylab.savefig(opts.outnametag + '_' + 'H1effdist_finalspin.png')

    fignum = fignum + 1
    pylab.figure(fignum)
    pylab.semilogy([f.mchirp for f in found], [f.distance for f in found],'.')
    pylab.semilogy([m.mchirp for m in missed], [m.distance for m in missed],'k.')
    pylab.xlabel('ChirpMass ($M_\odot$)')
    pylab.ylabel('Distance (Mpc)')
    pylab.title('Missed-Found:Distance vs Chirp Mass')
    pylab.savefig(opts.outnametag + '_' + 'dist_chirpmass.png')

    fignum = fignum + 1
    pylab.figure(fignum)
    pylab.semilogy([f.mass1+f.mass2 for f in found], [f.distance for f in found],'.')
    pylab.semilogy([m.mass1+m.mass2 for m in missed], [m.distance for m in missed],'k.')
    pylab.xlabel('Total Mass ($M_\odot$)')
    pylab.ylabel('Distance (Mpc)')
    pylab.title('Missed-Found:Distance vs Total Mass')
    pylab.savefig(opts.outnametag + '_' + 'dist_mass.png')

    fignum = fignum + 1
    pylab.figure(fignum)
    pylab.semilogy([spawaveform.computechi(f.mass1, f.mass2, f.spin1z, f.spin2z) for f in found], [f.distance for f in found],'.')
    pylab.semilogy([spawaveform.computechi(m.mass1, m.mass2, m.spin1z, f.spin2z) for m in missed], [m.distance for m in missed],'k.')
    pylab.xlabel('Mass Weighted Spin')
    pylab.ylabel('Distance (Mpc)')
    pylab.title('Missed-Found: Distance vs Mass Weighted Spin')
    pylab.savefig(opts.outnametag + '_' + 'dist_massweightedspin.png')

    fignum = fignum + 1
    pylab.figure(fignum)
    pylab.semilogy([finalspin(f.mass1, f.mass2, f.spin1z, f.spin2z) for f in found], [f.distance for f in found],'.')
    pylab.semilogy([finalspin(m.mass1, m.mass2, m.spin1z, m.spin2z) for m in missed], [m.distance for m in missed],'k.')
    pylab.xlabel('Final Spin')
    pylab.ylabel('Distance (Mpc)')
    pylab.title('Missed-Found: Distance vs Final Spin')
    pylab.savefig(opts.outnametag + '_' + 'dist_finalspin.png')

    #effective distance efficiency
    nbinsD = 25 
    nbinsM = 20
    nbinschi = 30
    nbinsSpin = 20
    chi_found = numpy.array([spawaveform.computechi(f.mass1, f.mass2, f.spin1z, f.spin2z) for f in found])
    chi_missed = numpy.array([spawaveform.computechi(m.mass1, m.mass2, m.spin1z, m.spin2z) for m in missed])
    chi_total = numpy.append(chi_found,chi_missed)	
    spin_found = numpy.array([finalspin(f.mass1, f.mass2, f.spin1z, f.spin2z) for f in found])
    spin_missed = numpy.array([finalspin(m.mass1, m.mass2, m.spin1z, m.spin2z) for m in missed])
    spin_total = numpy.append(spin_found,spin_missed)
    L1distance_found = numpy.array([f.eff_dist_l for f in found])
    L1distance_missed = numpy.array([m.eff_dist_l for m in missed])
    mass_missed = numpy.array([m.mass1+m.mass2 for m in missed])
    mass_found = numpy.array([f.mass1+f.mass2 for f in found])
    chirpmass_missed = numpy.array([m.mchirp for m in missed])
    chirpmass_found = numpy.array([f.mchirp for f in found])
    L1distance_total = numpy.append(L1distance_found,L1distance_missed)
    mass_total = numpy.append(mass_found,mass_missed)
    chirpmass_total = numpy.append(chirpmass_found,chirpmass_missed)
    H1distance_found = numpy.array([f.eff_dist_h for f in found])
    H1distance_missed = numpy.array([m.eff_dist_h for m in missed])
    H1distance_total = numpy.append(H1distance_found,H1distance_missed)
    distance_found = numpy.array([f.distance for f in found])
    distance_missed = numpy.array([m.distance for m in missed])
    distance_total = numpy.append(distance_found,distance_missed)
    Chiarray = pylab.linspace(numpy.min(chi_total), numpy.max(chi_total), nbinschi+1)
    Spinarray = pylab.linspace(numpy.min(spin_total), numpy.max(spin_total), nbinsSpin+1)
    Mchirparray = pylab.linspace(numpy.min(chirpmass_total), numpy.max(chirpmass_total), nbinsM+1)
    mass1_missed = numpy.array([m.mass1 for m in missed])
    mass1_found = numpy.array([m.mass1 for m in found])
    mass1_total = numpy.append(mass1_found,mass1_missed)
    mass2_missed = numpy.array([m.mass2 for m in missed])
    mass2_found = numpy.array([m.mass2 for m in found])
    mass2_total = numpy.append(mass2_found,mass2_missed)
    spin1z_missed = numpy.array([m.spin1z for m in missed])
    spin1z_found = numpy.array([m.spin1z for m in found])
    spin1z_total = numpy.append(spin1z_found,spin1z_missed)
    spin2z_missed = numpy.array([m.spin2z for m in missed])
    spin2z_found = numpy.array([m.spin2z for m in found])
    spin2z_total = numpy.append(spin2z_found,spin2z_missed)




    #L1distance-chirp mass
    fignum = fignum + 1
    pylab.figure(fignum)

    E = pylab.empty((nbinsM, nbinsD))
    Darray = pylab.linspace(math.log(numpy.min(L1distance_total)), math.log(numpy.max(L1distance_total)), nbinsD+1)
    Darray = pylab.exp(Darray)
    for i in range(nbinsM):
        for j in range(nbinsD):
      	    total = inbin(chirpmass_total, L1distance_total, Mchirparray[i], Mchirparray[i+1], Darray[j], Darray[j+1])
	    found = inbin(chirpmass_found, L1distance_found, Mchirparray[i], Mchirparray[i+1], Darray[j], Darray[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Mchirparray, Darray, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. Chirp Mass and L1:Effective Distance')
    pylab.xlabel(r'ChirpMass ($M_\odot$)')
    pylab.ylabel('L1:Effective Distance (Mpc)')
    pylab.yscale('log')
    pylab.ylim(2,10000)
    #pylab.grid(color='k')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig(opts.outnametag + '_' + 'L1effdist_chirpmass_Efficiency.png')

    #H1distance-chirp mass    
    fignum = fignum + 1
    pylab.figure(fignum)
    E = pylab.empty((nbinsM, nbinsD))
    Darray = pylab.linspace(math.log(numpy.min(H1distance_total)), math.log(numpy.max(H1distance_total)), nbinsD+1)
    Darray = pylab.exp(Darray)
    for i in range(nbinsM):
        for j in range(nbinsD):
      	    total = inbin(chirpmass_total, H1distance_total, Mchirparray[i], Mchirparray[i+1], Darray[j], Darray[j+1])
	    found = inbin(chirpmass_found, H1distance_found, Mchirparray[i], Mchirparray[i+1], Darray[j], Darray[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Mchirparray, Darray, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. Total Mass and H1:Effective Distance')
    pylab.xlabel(r'ChirpMass ($M_\odot$)')
    pylab.ylabel('H1:Effective Distance (Mpc)')
    pylab.yscale('log')
    pylab.ylim(2,10000)
    #pylab.grid(color='k')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig(opts.outnametag + '_' + 'H1effdist_chirpmass_Efficiency.png')

    #distance-chirp mass    
    fignum = fignum + 1
    pylab.figure(fignum)
    E = pylab.empty((nbinsM, nbinsD))
    Darray = pylab.linspace(math.log(numpy.min(distance_total)), math.log(numpy.max(distance_total)), nbinsD+1)
    Darray = pylab.exp(Darray)
    for i in range(nbinsM):
        for j in range(nbinsD):
      	    total = inbin(chirpmass_total, distance_total, Mchirparray[i], Mchirparray[i+1], Darray[j], Darray[j+1])
	    found = inbin(chirpmass_found, distance_found, Mchirparray[i], Mchirparray[i+1], Darray[j], Darray[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Mchirparray, Darray, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. Total Mass and Distance')
    pylab.xlabel(r'ChirpMass ($M_\odot$)')
    pylab.ylabel('Distance (Mpc)')
    pylab.yscale('log')
    pylab.ylim(2,1000)
    #pylab.grid(color='k')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig(opts.outnametag + '_' + 'dist_chirpmass_Efficiency.png')

	
    #L1distance-total mass
    fignum = fignum + 1
    pylab.figure(fignum)

    E = pylab.empty((nbinsM, nbinsD))
    Darray = pylab.linspace(math.log(numpy.min(L1distance_total)), math.log(numpy.max(L1distance_total)), nbinsD+1)
    Darray = pylab.exp(Darray)
    Marray = pylab.linspace(numpy.min(mass_total), numpy.max(mass_total), nbinsM+1)
    for i in range(nbinsM):
        for j in range(nbinsD):
      	    total = inbin(mass_total, L1distance_total, Marray[i], Marray[i+1], Darray[j], Darray[j+1])
	    found = inbin(mass_found, L1distance_found, Marray[i], Marray[i+1], Darray[j], Darray[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Marray, Darray, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. Total Mass and L1:Effective Distance')
    pylab.xlabel(r'Total Mass ($M_\odot$)')
    pylab.ylabel('L1:Effective Distance (Mpc)')
    pylab.yscale('log')
    pylab.ylim(2,10000)
    #pylab.grid(color='k')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig(opts.outnametag + '_' + 'L1effdist_mass_Efficiency.png')

    #H1distance-total mass    
    fignum = fignum + 1
    pylab.figure(fignum)
    E = pylab.empty((nbinsM, nbinsD))
    Darray = pylab.linspace(math.log(numpy.min(H1distance_total)), math.log(numpy.max(H1distance_total)), nbinsD+1)
    Darray = pylab.exp(Darray)
    for i in range(nbinsM):
        for j in range(nbinsD):
      	    total = inbin(mass_total, H1distance_total, Marray[i], Marray[i+1], Darray[j], Darray[j+1])
	    found = inbin(mass_found, H1distance_found, Marray[i], Marray[i+1], Darray[j], Darray[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Marray, Darray, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. Total Mass and H1:Effective Distance')
    pylab.xlabel(r'Total Mass ($M_\odot$)')
    pylab.ylabel('H1:Effective Distance (Mpc)')
    pylab.yscale('log')
    pylab.ylim(2,10000)
    #pylab.grid(color='k')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig(opts.outnametag + '_' + 'H1effdist_mass_Efficiency.png')

    #distance-total mass    
    fignum = fignum + 1
    pylab.figure(fignum)
    del Darray
    E = pylab.empty((nbinsM, nbinsD))
    Darray = pylab.linspace(math.log(numpy.min(distance_total)), math.log(numpy.max(distance_total)), nbinsD+1)
    Darray = pylab.exp(Darray)
    for i in range(nbinsM):
        for j in range(nbinsD):
      	    total = inbin(mass_total, distance_total, Marray[i], Marray[i+1], Darray[j], Darray[j+1])
	    found = inbin(mass_found, distance_found, Marray[i], Marray[i+1], Darray[j], Darray[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Marray, Darray, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. Total Mass and Distance')
    pylab.xlabel(r'Total Mass ($M_\odot$)')
    pylab.ylabel('Distance (Mpc)')
    pylab.yscale('log')
    pylab.ylim(2,1000)
    #pylab.grid(color='k')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig(opts.outnametag + '_' + 'dist_mass_Efficiency.png')


    #H1distance-chi
    fignum = fignum + 1
    pylab.figure(fignum)
    E = pylab.empty((nbinschi,nbinsD))
    Darray = pylab.linspace(math.log(numpy.min(H1distance_total)), math.log(numpy.max(H1distance_total)), nbinsD+1)
    Darray = pylab.exp(Darray)
    for i in range(nbinschi):
        for j in range(nbinsD):
      	    total = inbin(chi_total, H1distance_total, Chiarray[i], Chiarray[i+1], Darray[j], Darray[j+1])
	    found = inbin(chi_found, H1distance_found, Chiarray[i], Chiarray[i+1], Darray[j], Darray[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Chiarray, Darray, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. Chi and H1:Effective Distance')
    pylab.xlabel(r'Mass Weighted spin ($\chi$)')
    pylab.ylabel('H1:Effective Distance (Mpc)')
    pylab.yscale('log')
    pylab.ylim(2,10000)
    #pylab.grid(color='k')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig(opts.outnametag + '_' + 'H1effdist_chi_Efficiency.png')

    #L1distance-chi    
    fignum = fignum + 1
    pylab.figure(fignum)
    E = pylab.empty((nbinschi,nbinsD))
    Darray = pylab.linspace(math.log(numpy.min(L1distance_total)), math.log(numpy.max(L1distance_total)), nbinsD+1)
    Darray = pylab.exp(Darray)
    for i in range(nbinschi):
        for j in range(nbinsD):
      	    total = inbin(chi_total, L1distance_total, Chiarray[i], Chiarray[i+1], Darray[j], Darray[j+1])
	    found = inbin(chi_found, L1distance_found, Chiarray[i], Chiarray[i+1], Darray[j], Darray[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Chiarray, Darray, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. Chi and L1:Effective Distance')
    pylab.xlabel(r'Mass Weighted spin ($\chi$)')
    pylab.ylabel('L1:Effective Distance (Mpc)')
    pylab.yscale('log')
    pylab.ylim(2,10000)
    #pylab.grid(color='k')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig(opts.outnametag + '_' + 'L1effdist_chi_Efficiency.png')

    #distance-chi  efficiency
    fignum = fignum + 1
    pylab.figure(fignum)
    del Darray
    E = pylab.empty((nbinschi,nbinsD))
    Darray = pylab.linspace(math.log(numpy.min(distance_total)), math.log(numpy.max(distance_total)), nbinsD+1)
    Darray = pylab.exp(Darray)
    for i in range(nbinschi):
        for j in range(nbinsD):
      	    total = inbin(chi_total, distance_total, Chiarray[i], Chiarray[i+1], Darray[j], Darray[j+1])
	    found = inbin(chi_found, distance_found, Chiarray[i], Chiarray[i+1], Darray[j], Darray[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Chiarray, Darray, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. Chi and Distance')
    pylab.xlabel(r'Mass Weighted spin ($\chi$)')
    pylab.ylabel('Distance (Mpc)')
    pylab.yscale('log')
    pylab.ylim(2,1000)
    #pylab.grid(color='k')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig(opts.outnametag + '_' + 'dist_chi_Efficiency.png')

    #H1distance-FinalSpin efficiency 
    fignum = fignum + 1
    pylab.figure(fignum)
    E = pylab.empty((nbinsSpin,nbinsD))
    Darray = pylab.linspace(math.log(numpy.min(H1distance_total)), math.log(numpy.max(H1distance_total)), nbinsD+1)
    Darray = pylab.exp(Darray)
    for i in range(nbinsSpin):
        for j in range(nbinsD):
      	    total = inbin(spin_total, H1distance_total, Spinarray[i], Spinarray[i+1], Darray[j], Darray[j+1])
	    found = inbin(spin_found, H1distance_found, Spinarray[i], Spinarray[i+1], Darray[j], Darray[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Spinarray, Darray, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. Final spin and H1:Effective Distance')
    pylab.xlabel(r'Final spin ')
    pylab.ylabel('H1:Effective Distance (Mpc)')
    pylab.yscale('log')
    pylab.ylim(2,10000)
    #pylab.grid(color='k')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig(opts.outnametag + '_' + 'H1effdist_finalspin_Efficiency.png')

    #L1distance-Finalspin  efficiency  
    fignum = fignum + 1
    pylab.figure(fignum)
    E = pylab.empty((nbinsSpin,nbinsD))
    Darray = pylab.linspace(math.log(numpy.min(L1distance_total)), math.log(numpy.max(L1distance_total)), nbinsD+1)
    Darray = pylab.exp(Darray)
    for i in range(nbinsSpin):
        for j in range(nbinsD):
      	    total = inbin(spin_total, L1distance_total, Spinarray[i], Spinarray[i+1], Darray[j], Darray[j+1])
	    found = inbin(spin_found, L1distance_found, Spinarray[i], Spinarray[i+1], Darray[j], Darray[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Spinarray, Darray, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. Final spin and L1:Effective Distance')
    pylab.xlabel(r'Final spin')
    pylab.ylabel('L1:Effective Distance (Mpc)')
    pylab.yscale('log')
    pylab.ylim(2,10000)
    #pylab.grid(color='k')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig(opts.outnametag + '_' + 'L1effdist_finalspin_Efficiency.png')

    #distance-Final spin  efficiency
    fignum = fignum + 1
    pylab.figure(fignum)
    del Darray
    E = pylab.empty((nbinsSpin,nbinsD))
    Darray = pylab.linspace(math.log(numpy.min(distance_total)), math.log(numpy.max(distance_total)), nbinsD+1)
    Darray = pylab.exp(Darray)
    for i in range(nbinsSpin):
        for j in range(nbinsD):
      	    total = inbin(spin_total, distance_total, Spinarray[i], Spinarray[i+1], Darray[j], Darray[j+1])
	    found = inbin(spin_found, distance_found, Spinarray[i], Spinarray[i+1], Darray[j], Darray[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Spinarray, Darray, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. Final Spin and Distance')
    pylab.xlabel(r'Final Spin')
    pylab.ylabel('Distance (Mpc)')
    pylab.yscale('log')
    pylab.ylim(2,1000)
    #pylab.grid(color='k')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig(opts.outnametag + '_' + 'dist_finalspin_Efficiency.png')


    #Mass-Chi efficiency
    fignum = fignum + 1 
    pylab.figure(fignum)
    E = pylab.empty((nbinschi,nbinsM))
    for i in range(nbinschi):
        for j in range(nbinsM):
      	    total = inbin(chi_total, mass_total, Chiarray[i], Chiarray[i+1], Marray[j], Marray[j+1])
	    found = inbin(chi_found, mass_found, Chiarray[i], Chiarray[i+1], Marray[j], Marray[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Chiarray, Marray, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. Mass and Mass Weighted spin')
    pylab.xlabel(r'Mass Weighted spin ($\chi$)')
    pylab.ylabel('Mass ($M_\odot$)')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig('source_param' + '_'+ opts.outnametag + '_' + 'Mass_chi_Efficiency.png')


    #Mass1-Mass2 efficiency
    fignum = fignum + 1 
    pylab.figure(fignum)
    Marray1 = pylab.linspace(numpy.min(mass1_total), numpy.max(mass1_total), nbinsM+1)
    Marray2 = pylab.linspace(numpy.min(mass2_total), numpy.max(mass2_total), nbinsM+1)
    E = pylab.empty((nbinsM,nbinsM))
    for i in range(nbinsM):
        for j in range(nbinsM):
      	    total = inbin(mass2_total, mass1_total, Marray2[i], Marray2[i+1], Marray1[j], Marray1[j+1])
	    found = inbin(mass2_found, mass1_found, Marray2[i], Marray2[i+1], Marray1[j], Marray1[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Marray2, Marray1, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. Mass1 and Mass2')
    pylab.xlabel(r'Mass1 ($M_\odot$)')
    pylab.ylabel('Mass2 ($M_\odot$)')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig('source_param' + '_'+ opts.outnametag + '_' + 'Mass1_Mass2_Efficiency.png')


    #Spinz1-Spin2z efficiency
    fignum = fignum + 1 
    pylab.figure(fignum)
    Sarray1 = pylab.linspace(numpy.min(spin1z_total), numpy.max(spin1z_total), nbinsSpin+1)
    Sarray2 = pylab.linspace(numpy.min(spin2z_total), numpy.max(spin2z_total), nbinsSpin+1)
    E = pylab.empty((nbinsSpin,nbinsSpin))
    for i in range(nbinsSpin):
        for j in range(nbinsSpin):
      	    total = inbin(spin1z_total, spin2z_total, Sarray1[i], Sarray1[i+1], Sarray2[j], Sarray2[j+1])
	    found = inbin(spin1z_found, spin2z_found, Sarray1[i], Sarray1[i+1], Sarray2[j], Sarray2[j+1])
	    #Set the efficiency
	    try: E[i,j] = float(found)/float(total)
	    except ZeroDivisionError: E[i,j] = 2  
    E = numpy.ma.masked_object(E, 2)
    pylab.pcolor(Sarray1, Sarray2, E.T, cmap=matplotlib.cm.jet, alpha=0.9)
    pylab.title('Detection Efficiency vs. S1z and S2z')
    pylab.xlabel(r'Spin1z')
    pylab.ylabel('Spin2z')
    cb = pylab.colorbar()
    cb.set_label('Efficiency')
    pylab.savefig('source_param' + '_'+ opts.outnametag + '_' + 'Spin1z_Spin2z_Efficiency.png')

    # efficiency curve plots
    EffdistanceMin = min(H1distance_found + L1distance_found)
    EffdistanceMax = max(H1distance_found + L1distance_found)
    distanceMin = min(distance_found)
    distanceMax = max(distance_found)
    #binVec,centerVec = get_log_bin_vec(10,10000,20)
    #binVec1,centerVec1 = get_log_bin_vec(10,1000,20)
    binVec,centerVec = get_log_bin_vec(EffdistanceMin,EffdistanceMax,20)
    binVec1,centerVec1 = get_log_bin_vec(distanceMin,distanceMax,20)

    FoundBinH1effect = bin(H1distance_found, binVec)
    TotalBinH1effect = bin(H1distance_total, binVec)
    FoundBinL1effect = bin(L1distance_found, binVec)
    TotalBinL1effect = bin(L1distance_total, binVec)
    FoundBindist = bin(distance_found, binVec1)
    TotalBindist = bin(distance_total, binVec1)
    efficiencyH1effdist = numpy.empty(len(centerVec))
    efficiencyL1effdist = numpy.empty(len(centerVec))
    efficiencydist = numpy.empty(len(centerVec1))
    amp = numpy.empty(len(centerVec))
    for b in range(len(centerVec)):
     try: efficiencyH1effdist[b]  = float(len(FoundBinH1effect[b]))/float(len(TotalBinH1effect[b]))
     except ZeroDivisionError: efficiencyH1effdist[b] = numpy.nan

     try: efficiencyL1effdist[b]  = float(len(FoundBinL1effect[b]))/float(len(TotalBinL1effect[b]))
     except ZeroDivisionError: efficiencyL1effdist[b] = numpy.nan

     amp[b] = float(centerVec[b])
	
    def func50(x):
     return fitfunc(p1,x)-0.5
    def func90(x):
     return fitfunc(p1,x)-0.9
	
    p0 = [100.,50.,0.9999,0.55]

    wiki = open(opts.outnametag+'_'+'Efficiency.txt',"w")
    wiki.write("||'''distance'''||'''50 % distance(Mpc)'''||'''90 % distance(Mpc)'''||\n")


    p1, success = optimize.leastsq(errfunc, p0, args=(efficiencyH1effdist,amp))
    smooth = numpy.arange(1,10000,1)
    fitted_array = numpy.empty(len(smooth))
    for i in range(len(smooth)): fitted_array[i] = fitfunc(p1,smooth[i])
    x50 = optimize.fsolve(func50,50,warning=False)
    x90 = optimize.fsolve(func90,100,warning=False)
    fignum = fignum + 1
    pylab.figure(fignum)
    pylab.semilogx(amp,efficiencyH1effdist,"ro",smooth,fitted_array,"b-")
    pylab.axhline(y=0.5,xmin=0,xmax=math.log(x50,10)/math.log(10000,10)-0.14,linewidth=1, color='red')   
    pylab.axhline(y=0.9,xmin=0,xmax=math.log(x90,10)/math.log(10000,10)-0.2,linewidth=1, color='green')
    pylab.axvline(x=x50, ymin=0, ymax=0.5,linewidth=1, color='red')
    pylab.axvline(x=x90,ymin=0, ymax=0.9,linewidth=1, color='green')
    pylab.xlim(10,10000)
    pylab.ylim(0,1.05)
    pylab.title('H1 effective distance')
    pylab.xlabel('H1 effective distance (Mpc)')
    pylab.ylabel('Efficiency')	
    pylab.savefig(opts.outnametag + '_' + 'H1effdist_sigmoid.png')
    wiki.write("||'''H1 effecive distance'''||%.2f|| %.2f ||\n" % (x50,x90) )	


    p1, success = optimize.leastsq(errfunc, p0, args=(efficiencyL1effdist,amp))
    smooth = numpy.arange(1,10000,1)
    fitted_array = numpy.empty(len(smooth))
    for i in range(len(smooth)): fitted_array[i] = fitfunc(p1,smooth[i])
    x50 = optimize.fsolve(func50,50,warning=False)
    x90 = optimize.fsolve(func90,100,warning=False)
    fignum = fignum + 1
    pylab.figure(fignum)
    pylab.semilogx(amp,efficiencyL1effdist,"ro",smooth,fitted_array,"b-")
    pylab.axhline(y=0.5,xmin=0,xmax=math.log(x50,10)/math.log(10000,10)-0.14,linewidth=1, color='red')   
    pylab.axhline(y=0.9,xmin=0,xmax=math.log(x90,10)/math.log(10000,10)-0.2,linewidth=1, color='green')
    pylab.axvline(x=x50, ymin=0, ymax=0.5,linewidth=1, color='red')
    pylab.axvline(x=x90,ymin=0, ymax=0.9,linewidth=1, color='green')
    pylab.xlim(10,10000)
    pylab.ylim(0,1.05)
    pylab.title('L1 effective distance')
    pylab.xlabel('L1 effective distance (Mpc)')
    pylab.ylabel('Efficiency')	
    pylab.savefig(opts.outnametag + '_' + 'L1effdist_sigmoid.png')
    wiki.write("||'''L1 effecive distance'''||%.2f|| %.2f ||\n" % (x50,x90) )	
