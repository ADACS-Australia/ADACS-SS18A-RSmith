#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


from optparse import OptionParser
import sys


from glue import lal
from glue import segments
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import ilwd
from glue.ligolw import utils
from pylal import llwapp


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog [options] [file [file ...]]",
		description = "Removes sngl_burst events from XML files according to a variety of criteria.  Files named on the command line are read one-by-one, and over-written with the new files.  If no files are named on the command line, input is read from stdin and written to stdout.  Any file whose name ends in \".gz\" is assumed to be gzip compressed.  Note that, for the most part, this program does not understand coincidence information, and so if an injection or burst event is removed that participates in a coincidence, this program simply deletes the entire coincidence as well (before applying the --coinc-only cut)."
	)
	parser.add_option("--coinc-only", action = "store_true", help = "Discard events that are not participating in a coincident event.")
	parser.add_option("--comment", metavar = "text", default = "", help = "Set the comment string to be recorded in the process table for this job (default = \"\").")
	parser.add_option("--inj-made-only", action = "store_true", help = "Discard injections outside the search summary out segments.")
	parser.add_option("--min-amplitude", metavar = "value", help = "Discard events below the given amplitude.")
	parser.add_option("--max-amplitude", metavar = "value", help = "Discard events above the given amplitude.")
	parser.add_option("--min-bandwidth", metavar = "Hz", help = "Discard events narrower than the given bandwidth.")
	parser.add_option("--max-bandwidth", metavar = "Hz", help = "Discard events wider than the given bandwidth.")
	parser.add_option("--min-central-freq", metavar = "Hz", help = "Discard events with central frequency lower than that given.")
	parser.add_option("--max-central-freq", metavar = "Hz", help = "Discard events with central frequency higher than that given.")
	parser.add_option("--min-confidence", metavar = "value", help = "Discard events below the given confidence.")
	parser.add_option("--max-confidence", metavar = "value", help = "Discard events above the given confidence.")
	parser.add_option("--min-duration", metavar = "seconds", help = "Discard events shorter than the given duration.")
	parser.add_option("--max-duration", metavar = "seconds", help = "Discard events longer than the given duration.")
	parser.add_option("--min-fhigh", metavar = "Hz", help = "Discard events with highest frequency below the given frequency.")
	parser.add_option("--max-fhigh", metavar = "Hz", help = "Discard events with highest frequency above the given frequency.")
	parser.add_option("--min-flow", metavar = "Hz", help = "Discard events with lowest frequency below the given frequency.")
	parser.add_option("--max-flow", metavar = "Hz", help = "Discard events with loest frequency above the given frequency.")
	parser.add_option("--min-hrss", metavar = "value", help = "Discard events with h_rss below the given value.")
	parser.add_option("--max-hrss", metavar = "value", help = "Discard events with h_rss above the given value.")
	parser.add_option("--cut-instrument", metavar = "name", action = "append", default = [], help = "Discard events from given instrument.")
	parser.add_option("--min-peak-time", metavar = "seconds", help = "Discard events with peak time before the given GPS time.")
	parser.add_option("--max-peak-time", metavar = "seconds", help = "Discard events with peak time after the given GPS time.")
	parser.add_option("--min-start-time", metavar = "seconds", help = "Discard events starting before the given GPS time.")
	parser.add_option("--max-start-time", metavar = "seconds", help = "Discard events starting after the given GPS time.")
	parser.add_option("--min-stop-time", metavar = "seconds", help = "Discard events ending before the given GPS time.")
	parser.add_option("--max-stop-time", metavar = "seconds", help = "Discard events ending after the given GPS time.")
	parser.add_option("--min-snr", metavar = "value", help = "Discard events below the given SNR.")
	parser.add_option("--max-snr", metavar = "value", help = "Discard events above the given SNR.")
	parser.add_option("--program", metavar = "name", default = None, help = "Process events generated by the given program.")
	parser.add_option("--veto-segments", action = "store_true", help = "Veto events using the segment table contained in the input file.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	if options.inj_made_only and not options.program:
		raise ValueError, "must set --program when --inj-made-only is set"
	options.cut_instrument = set(options.cut_instrument)

	return options, (filenames or [None])


#
# =============================================================================
#
#                                 Preparation
#
# =============================================================================
#


class DocContents(object):
	def __init__(self, xmldoc, program = None):
		#
		# Find the out segments
		#

		self.outsegs = llwapp.segmentlistdict_fromsearchsummary(xmldoc, program)

		#
		# Find the sngl_burst table
		#

		self.snglbursttable = table.get_table(xmldoc, lsctables.SnglBurstTable.tableName)

		#
		# Get the list of process IDs we care about
		#

		self.process_ids = set(self.snglbursttable.getColumnByName("process_id"))
		if program is not None:
			self.process_ids &= table.get_table(xmldoc, lsctables.ProcessTable.tableName).get_ids_by_program(program)

		#
		# Find the sim_burst table, or make a fake one
		#

		try:
			self.simbursttable = table.get_table(xmldoc, lsctables.SimBurstTable.tableName)
		except:
			self.simbursttable = []

		#
		# Find the coinc tables, or make fake ones
		#

		try:
			self.coinctable = table.get_table(xmldoc, lsctables.CoincTable.tableName)
			self.coincmaptable = table.get_table(xmldoc, lsctables.CoincMapTable.tableName)
		except:
			self.coinctable = []
			self.coincmaptable = []
		self.make_coinceventids()

		#
		# Extract the to-be-vetoed segment list, or make a fake one
		#

		try:
			self.vetosegs = segments.segmentlist(row.get() for row in table.get_table(xmldoc, lsctables.SegmentTable.tableName) if row.get_active()).coalesce()
		except:
			self.vetosegs = segments.segmentlist()

	def make_coinceventids(self):
		if self.coincmaptable:
			self.coinceventids = set(ilwd.ILWDID(id) for id in self.coincmaptable.getColumnByName("event_id"))
		else:
			self.coinceventids = set()
		

	def is_coinc_event(self, event):
		return ilwd.ILWDID(event.event_id) in self.coinceventids


#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#


process_program_name = "ligolw_bucut"


def append_process(doc, options):
	process = llwapp.append_process(doc, program = process_program_name, version = __version__, cvs_repository = "lscsoft", cvs_entry_time = __date__, comment = options.comment)

	params = []
	if options.coinc_only:
		params += [("--coinc-only", "lstring", "")]
	if options.inj_made_only:
		params += [("--inj-made-only", "lstring", "")]
	if options.min_amplitude != None:
		options.min_amplitude = float(options.min_amplitude)
		params += [("--min-amplitude", "real_4", options.min_amplitude)]
	if options.max_amplitude != None:
		options.max_amplitude = float(options.max_amplitude)
		params += [("--max-amplitude", "real_4", options.max_amplitude)]
	if options.min_bandwidth != None:
		options.min_bandwidth = float(options.min_bandwidth)
		params += [("--min-bandwidth", "real_4", options.min_bandwidth)]
	if options.max_bandwidth != None:
		options.max_bandwidth = float(options.max_bandwidth)
		params += [("--max-bandwidth", "real_4", options.max_bandwidth)]
	if options.min_central_freq != None:
		options.min_central_freq = float(options.min_central_freq)
		params += [("--min-central-freq", "real_4", options.min_central_freq)]
	if options.max_central_freq != None:
		options.max_central_freq = float(options.max_central_freq)
		params += [("--max-central-freq", "real_4", options.max_central_freq)]
	if options.min_confidence != None:
		options.min_confidence = float(options.min_confidence)
		params += [("--min-confidence", "real_4", options.min_confidence)]
	if options.max_confidence != None:
		options.max_confidence = float(options.max_confidence)
		params += [("--max-confidence", "real_4", options.max_confidence)]
	if options.min_duration != None:
		options.min_duration = float(options.min_duration)
		params += [("--min-duration", "real_4", options.min_duration)]
	if options.max_duration != None:
		options.max_duration = float(options.max_duration)
		params += [("--max-duration", "real_4", options.max_duration)]
	if options.min_fhigh != None:
		options.min_fhigh = float(options.min_fhigh)
		params += [("--min-fhigh", "real_4", options.min_fhigh)]
	if options.max_fhigh != None:
		options.max_fhigh = float(options.max_fhigh)
		params += [("--max-fhigh", "real_4", options.max_fhigh)]
	if options.min_flow != None:
		options.min_flow = float(options.min_flow)
		params += [("--min-flow", "real_4", options.min_flow)]
	if options.max_flow != None:
		options.max_flow = float(options.max_flow)
		params += [("--max-flow", "real_4", options.max_flow)]
	if options.min_hrss != None:
		options.min_hrss = float(options.min_hrss)
		params += [("--min-hrss", "real_4", options.min_hrss)]
	if options.max_hrss != None:
		options.max_hrss = float(options.max_hrss)
		params += [("--max-hrss", "real_4", options.max_hrss)]
	for instrument in options.cut_instrument:
		params += [("--cut-instrument", "lstring", instrument)]
	if options.min_peak_time != None:
		options.min_peak_time = lal.LIGOTimeGPS(options.min_peak_time)
		params += [("--min-peak-time", "lstring", options.min_peak_time)]
	if options.max_peak_time != None:
		options.max_peak_time = lal.LIGOTimeGPS(options.max_peak_time)
		params += [("--max-peak-time", "lstring", options.max_peak_time)]
	if options.min_snr != None:
		options.min_snr = float(options.min_snr)
		params += [("--min-snr", "real_4", options.min_snr)]
	if options.max_snr != None:
		options.max_snr = float(options.max_snr)
		params += [("--max-snr", "real_4", options.max_snr)]
	if options.min_start_time != None:
		options.min_start_time = lal.LIGOTimeGPS(options.min_start_time)
		params += [("--min-start-time", "lstring", options.min_start_time)]
	if options.max_start_time != None:
		options.max_start_time = lal.LIGOTimeGPS(options.max_start_time)
		params += [("--max-start-time", "lstring", options.max_start_time)]
	if options.min_stop_time != None:
		options.min_stop_time = lal.LIGOTimeGPS(options.min_stop_time)
		params += [("--min-stop-time", "lstring", options.min_stop_time)]
	if options.max_stop_time != None:
		options.max_stop_time = lal.LIGOTimeGPS(options.max_stop_time)
		params += [("--max-stop-time", "lstring", options.max_stop_time)]
	if options.program:
		params += [("--program", "lstring", options.program)]
	if options.veto_segments:
		params += [("--veto-segments", "lstring", "")]
	llwapp.append_process_params(doc, process, params)

	return process, options


#
# =============================================================================
#
#                                     Cuts
#
# =============================================================================
#


def remove_events_by_segment(contents):
	ids = set()
	i = 0
	while i < len(contents.snglbursttable):
		if contents.vetosegs.intersects_segment(contents.snglbursttable[i].get_period()):
			ids.add(contents.snglbursttable[i].event_id)
			del contents.snglbursttable[i]
		else:
			i += 1
	return ids


def keep_this_sngl_burst(burst, options):
	"""
	Returns True if the sngl_burst row survives the cuts described by
	the attributes of the options object.
	"""
	if (options.min_amplitude != None) and (burst.amplitude < options.min_amplitude):
		return False
	if (options.max_amplitude != None) and (burst.amplitude > options.max_amplitude):
		return False
	if (options.min_bandwidth != None) and (burst.bandwidth < options.min_bandwidth):
		return False
	if (options.max_bandwidth != None) and (burst.bandwidth > options.max_bandwidth):
		return False
	if (options.min_central_freq != None) and (burst.central_freq < options.min_central_freq):
		return False
	if (options.max_central_freq != None) and (burst.central_freq > options.max_central_freq):
		return False
	if (options.min_confidence != None) and (burst.confidence < options.min_confidence):
		return False
	if (options.max_confidence != None) and (burst.confidence > options.max_confidence):
		return False
	if (options.min_duration != None) and (burst.duration < options.min_duration):
		return False
	if (options.max_duration != None) and (burst.duration > options.max_duration):
		return False
	if (options.min_fhigh != None) and (burst.fhigh < options.min_fhigh):
		return False
	if (options.max_fhigh != None) and (burst.fhigh > options.max_fhigh):
		return False
	if (options.min_flow != None) and (burst.flow < options.min_flow):
		return False
	if (options.max_flow != None) and (burst.flow > options.max_flow):
		return False
	if (options.min_hrss != None) and (burst.hrss < options.min_hrss):
		return False
	if (options.max_hrss != None) and (burst.hrss > options.max_hrss):
		return False
	if burst.ifo in options.cut_instrument:
		return False
	if (options.min_peak_time != None) and (burst.get_peak() < options.min_peak_time):
		return False
	if (options.max_peak_time != None) and (burst.get_peak() > options.max_peak_time):
		return False
	if (options.min_snr != None) and (burst.snr < options.min_snr):
		return False
	if (options.max_snr != None) and (burst.snr > options.max_snr):
		return False
	if (options.min_start_time != None) and (burst.get_start() < options.min_start_time):
		return False
	if (options.max_start_time != None) and (burst.get_start() > options.max_start_time):
		return False
	if (options.min_stop_time != None) and (burst.get_stop() < options.min_stop_time):
		return False
	if (options.max_stop_time != None) and (burst.get_stop() > options.max_stop_time):
		return False
	return True


def remove_events_by_parameters(contents, options):
	deleted_ids = set()
	for i in xrange(len(contents.snglbursttable) - 1, -1, -1):
		burst = contents.snglbursttable[i]
		if burst.process_id in contents.process_ids and not keep_this_sngl_burst(burst, options):
			ids.add(burst.event_id)
			del contents.snglbursttable[i]
	return deleted_ids


def remove_non_coincidences(contents):
	for i in xrange(len(contents.snglbursttable) - 1, -1, -1):
		burst = contents.snglbursttable[i]
		if burst.process_id in contents.process_ids and not contents.is_coinc_event(burst):
			del contents.snglbursttable[i]


def keep_this_injection(sim, outsegs):
	# FIXME: is this faster?
	#return True in (sim.get_peak(instrument) in seglist for instrument, seglist in outsegs.iteritems())
	for instrument, seglist in outsegs.iteritems():
		if sim.get_peak(instrument) in seglist:
			return True
	return False


def remove_injections_by_segment(contents):
	for i in xrange(len(contents.simbursttable) - 1, -1, -1):
		if not keep_this_injection(contents.simbursttable[i], contents.outsegs):
			del contents.simbursttable[i]


def clean_coinc_tables(contents, removed_ids):
	# remove dangling coinc_event_map rows
	removed_coincs = set()
	for i in xrange(len(contents.coincmaptable) - 1, -1, -1):
		if contents.coincmaptable[i].event_id in removed_ids:
			removed_coincs.add(contents.coincmaptable[i].coinc_event_id)
			del contents.coincmaptable[i]

	# remove broken coinc_event rows
	for i in xrange(len(contents.coinctable) - 1, -1, -1):
		if contents.coinctable[i].coinc_event_id in removed_coincs:
			del contents.coinctable[i]

	# remove dangling coinc_event_map rows
	for i in xrange(len(contents.coincmaptable) - 1, -1, -1):
		if contents.coincmaptable[i].coinc_event_id in removed_coincs:
			del contents.coincmaptable[i]

	contents.make_coinceventids()


#
# =============================================================================
#
#                                 Library API
#
# =============================================================================
#


def apply_filters(contents, options, verbose = False):
	removed_ids = set()
	if options.veto_segments:
		if verbose:
			print >>sys.stderr, "applying veto segment list ..."
		removed_ids |= remove_events_by_segment(contents)
	if verbose:
		print >>sys.stderr, "filtering sngl_burst rows by parameters ..."
	removed_ids |= remove_events_by_parameters(contents, options)
	if options.inj_made_only:
		if verbose:
			print >>sys.stderr, "removing injections that weren't performed ..."
		remove_injections_by_segment(contents)
	if verbose:
		print >>sys.stderr, "removing broken coincidences ..."
	clean_coinc_tables(contents, removed_ids)
	if options.coinc_only:
		if verbose:
			print >>sys.stderr, "removing non-coincident events ..."
		remove_non_coincidences(contents)


def ligolw_bucut(doc, options):
	contents = DocContents(doc, options.program)
	process, options = append_process(doc, options)

	apply_filters(contents, options, options.verbose)

	seg = contents.outsegs.extent_all()
	llwapp.append_search_summary(doc, process, inseg = seg, outseg = seg, nevents = len(contents.snglbursttable))
	llwapp.set_process_end_time(process)

	return doc


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


options, filenames = parse_command_line()


for filename in filenames:
	xmldoc = utils.load_filename(filename, options.verbose, gz = (filename or "stdin").endswith(".gz"))
	xmldoc = ligolw_bucut(xmldoc, options)
	utils.write_filename(xmldoc, filename, options.verbose, gz = (filename or "stdout").endswith(".gz"))
	xmldoc.unlink()
