#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

from optparse import OptionParser
import sys

from glue import lal
from glue import segments
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import ilwd
from glue.ligolw import utils
from pylal import llwapp

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version = "%prog CVS $Id$")
	parser.add_option("--coinc-discard", action = "store_true", help = "discard triggers participating in a coincident event")
	parser.add_option("--coinc-only", action = "store_true", help = "discard triggers that are not participating in a coincident event")
	parser.add_option("--comment", metavar = "text", default = "", help = "set comment string in process table")
	parser.add_option("--inj-made-only", action = "store_true", help = "discard injections outside the search summary out segments")
	parser.add_option("--inj-no-dups", action = "store_true", help = "discard duplicate injections")
	parser.add_option("--min-amplitude", metavar = "value", help = "discard triggers below the given amplitude")
	parser.add_option("--max-amplitude", metavar = "value", help = "discard triggers above the given amplitude")
	parser.add_option("--min-bandwidth", metavar = "Hz", help = "discard triggers narrower than the given bandwidth")
	parser.add_option("--max-bandwidth", metavar = "Hz", help = "discard triggers wider than the given bandwidth")
	parser.add_option("--min-central-freq", metavar = "Hz", help = "discard triggers with central frequency lower than that given")
	parser.add_option("--max-central-freq", metavar = "Hz", help = "discard triggers with central frequency higher than that given")
	parser.add_option("--min-confidence", metavar = "value", help = "discard triggers below the given confidence")
	parser.add_option("--max-confidence", metavar = "value", help = "discard triggers above the given confidence")
	parser.add_option("--min-duration", metavar = "seconds", help = "discard triggers shorter than the given duration")
	parser.add_option("--max-duration", metavar = "seconds", help = "discard triggers longer than the given duration")
	parser.add_option("--min-fhigh", metavar = "Hz", help = "discard triggers with highest frequency below the given frequency")
	parser.add_option("--max-fhigh", metavar = "Hz", help = "discard triggers with highest frequency above the given frequency")
	parser.add_option("--min-flow", metavar = "Hz", help = "discard triggers with lowest frequency below the given frequency")
	parser.add_option("--max-flow", metavar = "Hz", help = "discard triggers with loest frequency above the given frequency")
	parser.add_option("--min-hrss", metavar = "value", help = "discard triggers with h_rss below the given value")
	parser.add_option("--max-hrss", metavar = "value", help = "discard triggers with h_rss above the given value")
	parser.add_option("--cut-instrument", metavar = "name", action = "append", default = [], help = "discard triggers from given instrument")
	parser.add_option("--min-peak-time", metavar = "seconds", help = "discard triggers with peak time before the given GPS time")
	parser.add_option("--max-peak-time", metavar = "seconds", help = "discard triggers with peak time after the given GPS time")
	parser.add_option("--min-start-time", metavar = "seconds", help = "discard triggers starting before the given GPS time")
	parser.add_option("--max-start-time", metavar = "seconds", help = "discard triggers starting after the given GPS time")
	parser.add_option("--min-stop-time", metavar = "seconds", help = "discard triggers ending before the given GPS time")
	parser.add_option("--max-stop-time", metavar = "seconds", help = "discard triggers ending after the given GPS time")
	parser.add_option("--min-snr", metavar = "value", help = "discard triggers below the given SNR")
	parser.add_option("--max-snr", metavar = "value", help = "discard triggers above the given SNR")
	parser.add_option("--min-tfvolume", metavar = "value", help = "discard triggers with time-frequency volume below the given volume")
	parser.add_option("--max-tfvolume", metavar = "value", help = "discard triggers with time-frequency volume above the given volume")
	parser.add_option("--program", metavar = "name", default = None, help = "process triggers generated by the given program")
	parser.add_option("--veto-segments", action = "store_true", help = "veto events using the segment table contained in the input file")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	if options.coinc_discard and options.coinc_only:
		raise ValueError, "can't set both --coinc-discard and --coinc-only"
	if options.inj_made_only and not options.program:
		raise ValueError, "must set --program when --inj-made-only is set"

	return options, (filenames or [None])


#
# =============================================================================
#
#                                 Preparation
#
# =============================================================================
#

class DocContents(object):
	def __init__(self, xmldoc, program = None):
		self.snglbursttable = table.get_table(xmldoc, lsctables.SnglBurstTable.tableName)

		self.outsegs = llwapp.segmentlistdict_fromsearchsummary(xmldoc, program)
		self.outseg = self.outsegs.extent_all()

		try:
			self.simbursttable = table.get_table(xmldoc, lsctables.SimBurstTable.tableName)
		except:
			self.simbursttable = []
		try:
			self.coinctable = table.get_table(xmldoc, lsctables.CoincTable.tableName)
		except:
			self.coinctable = []
		try:
			self.coincmaptable = table.get_table(xmldoc, lsctables.CoincMapTable.tableName)
		except:
			self.coincmaptable = []
		self.make_coinceventids()

		try:
			self.vetosegs = segments.segmentlist([row.get() for row in table.get_table(xmldoc, lsctables.SegmentTable.tableName) if row.get_active()]).coalesce()
		except:
			self.vetosegs = segments.segmentlist()

	def make_coinceventids(self):
		if self.coincmaptable:
			self.coinceventids = map(ilwd.ILWDID, self.coincmaptable.getColumnByName("event_id"))
			self.coinceventids.sort()
		else:
			self.coinceventids = []
		

	def is_coinc_event(self, event):
		return llwapp.bisect_contains(self.coinceventids, ilwd.ILWDID(event.event_id))


#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#

def append_process(doc, options):
	process = llwapp.append_process(doc, program = "ligolw_bucut", version = __version__, cvs_repository = "lscsoft", cvs_entry_time = __date__, comment = options.comment)

	params = []
	if options.coinc_discard:
		params += [("--coinc-discard", "lstring", "")]
	if options.coinc_only:
		params += [("--coinc-only", "lstring", "")]
	if options.inj_made_only:
		params += [("--inj-made-only", "lstring", "")]
	if options.inj_no_dups:
		params += [("--inj-no-dups", "lstring", "")]
	if options.min_amplitude != None:
		options.min_amplitude = float(options.min_amplitude)
		params += [("--min-amplitude", "real_4", options.min_amplitude)]
	if options.max_amplitude != None:
		options.max_amplitude = float(options.max_amplitude)
		params += [("--max-amplitude", "real_4", options.max_amplitude)]
	if options.min_bandwidth != None:
		options.min_bandwidth = float(options.min_bandwidth)
		params += [("--min-bandwidth", "real_4", options.min_bandwidth)]
	if options.max_bandwidth != None:
		options.max_bandwidth = float(options.max_bandwidth)
		params += [("--max-bandwidth", "real_4", options.max_bandwidth)]
	if options.min_central_freq != None:
		options.min_central_freq = float(options.min_central_freq)
		params += [("--min-central-freq", "real_4", options.min_central_freq)]
	if options.max_central_freq != None:
		options.max_central_freq = float(options.max_central_freq)
		params += [("--max-central-freq", "real_4", options.max_central_freq)]
	if options.min_confidence != None:
		options.min_confidence = float(options.min_confidence)
		params += [("--min-confidence", "real_4", options.min_confidence)]
	if options.max_confidence != None:
		options.max_confidence = float(options.max_confidence)
		params += [("--max-confidence", "real_4", options.max_confidence)]
	if options.min_duration != None:
		options.min_duration = float(options.min_duration)
		params += [("--min-duration", "real_4", options.min_duration)]
	if options.max_duration != None:
		options.max_duration = float(options.max_duration)
		params += [("--max-duration", "real_4", options.max_duration)]
	if options.min_fhigh != None:
		options.min_fhigh = float(options.min_fhigh)
		params += [("--min-fhigh", "real_4", options.min_fhigh)]
	if options.max_fhigh != None:
		options.max_fhigh = float(options.max_fhigh)
		params += [("--max-fhigh", "real_4", options.max_fhigh)]
	if options.min_flow != None:
		options.min_flow = float(options.min_flow)
		params += [("--min-flow", "real_4", options.min_flow)]
	if options.max_flow != None:
		options.max_flow = float(options.max_flow)
		params += [("--max-flow", "real_4", options.max_flow)]
	if options.min_hrss != None:
		options.min_hrss = float(options.min_hrss)
		params += [("--min-hrss", "real_4", options.min_hrss)]
	if options.max_hrss != None:
		options.max_hrss = float(options.max_hrss)
		params += [("--max-hrss", "real_4", options.max_hrss)]
	for instrument in options.cut_instrument:
		params += [("--cut-instrument", "lstring", instrument)]
	if options.min_peak_time != None:
		options.min_peak_time = lal.LIGOTimeGPS(options.min_peak_time)
		params += [("--min-peak-time", "lstring", options.min_peak_time)]
	if options.max_peak_time != None:
		options.max_peak_time = lal.LIGOTimeGPS(options.max_peak_time)
		params += [("--max-peak-time", "lstring", options.max_peak_time)]
	if options.min_snr != None:
		options.min_snr = float(options.min_snr)
		params += [("--min-snr", "real_4", options.min_snr)]
	if options.max_snr != None:
		options.max_snr = float(options.max_snr)
		params += [("--max-snr", "real_4", options.max_snr)]
	if options.min_start_time != None:
		options.min_start_time = lal.LIGOTimeGPS(options.min_start_time)
		params += [("--min-start-time", "lstring", options.min_start_time)]
	if options.max_start_time != None:
		options.max_start_time = lal.LIGOTimeGPS(options.max_start_time)
		params += [("--max-start-time", "lstring", options.max_start_time)]
	if options.min_stop_time != None:
		options.min_stop_time = lal.LIGOTimeGPS(options.min_stop_time)
		params += [("--min-stop-time", "lstring", options.min_stop_time)]
	if options.max_stop_time != None:
		options.max_stop_time = lal.LIGOTimeGPS(options.max_stop_time)
		params += [("--max-stop-time", "lstring", options.max_stop_time)]
	if options.min_tfvolume != None:
		options.min_tfvolume = float(options.min_tfvolume)
		params += [("--min-tfvolume", "real_4", options.min_tfvolume)]
	if options.max_tfvolume != None:
		options.max_tfvolume = float(options.max_tfvolume)
		params += [("--max-tfvolume", "real_4", options.max_tfvolume)]
	if options.program:
		params += [("--program", "lstring", options.program)]
	if options.veto_segments:
		params += [("--veto-segments", "lstring", "")]
	llwapp.append_process_params(doc, process, params)

	return process, options


#
# =============================================================================
#
#                                     Cuts
#
# =============================================================================
#

def remove_events_by_segment(contents):
	ids = []
	i = 0
	while i < len(contents.snglbursttable):
		if contents.vetosegs.intersects_segment(contents.snglbursttable[i].get_period()):
			ids.append(contents.snglbursttable[i].event_id)
			del contents.snglbursttable[i]
		else:
			i += 1
	return ids


def keep_this_sngl_burst(burst, options):
	"""
	Returns True if the sngl_burst row survives the cuts described by
	the attributes of the options object.
	"""
	if (options.min_amplitude != None) and (burst.amplitude < options.min_amplitude):
		return False
	if (options.max_amplitude != None) and (burst.amplitude > options.max_amplitude):
		return False
	if (options.min_bandwidth != None) and (burst.bandwidth < options.min_bandwidth):
		return False
	if (options.max_bandwidth != None) and (burst.bandwidth > options.max_bandwidth):
		return False
	if (options.min_central_freq != None) and (burst.central_freq < options.min_central_freq):
		return False
	if (options.max_central_freq != None) and (burst.central_freq > options.max_central_freq):
		return False
	if (options.min_confidence != None) and (burst.confidence < options.min_confidence):
		return False
	if (options.max_confidence != None) and (burst.confidence > options.max_confidence):
		return False
	if (options.min_duration != None) and (burst.duration < options.min_duration):
		return False
	if (options.max_duration != None) and (burst.duration > options.max_duration):
		return False
	if (options.min_fhigh != None) and (burst.fhigh < options.min_fhigh):
		return False
	if (options.max_fhigh != None) and (burst.fhigh > options.max_fhigh):
		return False
	if (options.min_flow != None) and (burst.flow < options.min_flow):
		return False
	if (options.max_flow != None) and (burst.flow > options.max_flow):
		return False
	if (options.min_hrss != None) and (burst.hrss < options.min_hrss):
		return False
	if (options.max_hrss != None) and (burst.hrss > options.max_hrss):
		return False
	if burst.ifo in options.cut_instrument:
		return False
	if (options.min_peak_time != None) and (burst.get_peak() < options.min_peak_time):
		return False
	if (options.max_peak_time != None) and (burst.get_peak() > options.max_peak_time):
		return False
	if (options.min_snr != None) and (burst.snr < options.min_snr):
		return False
	if (options.max_snr != None) and (burst.snr > options.max_snr):
		return False
	if (options.min_start_time != None) and (burst.get_start() < options.min_start_time):
		return False
	if (options.max_start_time != None) and (burst.get_start() > options.max_start_time):
		return False
	if (options.min_stop_time != None) and (burst.get_stop() < options.min_stop_time):
		return False
	if (options.max_stop_time != None) and (burst.get_stop() > options.max_stop_time):
		return False
	if (options.min_tfvolume != None) and (burst.tfvolume < options.min_tfvolume):
		return False
	if (options.max_tfvolume != None) and (burst.tfvolume > options.max_tfvolume):
		return False
	return True


def remove_events_by_parameters(contents, options):
	ids = []
	i = 0
	while i < len(contents.snglbursttable):
		if keep_this_sngl_burst(contents.snglbursttable[i], options):
			i += 1
		else:
			ids.append(contents.snglbursttable[i].event_id)
			del contents.snglbursttable[i]
	return ids


def remove_coincidences(contents):
	if contents.coinceventids:
		i = 0
		while i < len(contents.snglbursttable):
			if contents.is_coinc_event(contents.snglbursttable[i]):
				del contents.snglbursttable[i]
			else:
				i += 1
		del contents.coinctable[:]
		del contents.coincmaptable[:]
		contents.coinceventids = []


def remove_non_coincidences(contents):
	i = 0
	while i < len(contents.snglbursttable):
		if not contents.is_coinc_event(contents.snglbursttable[i]):
			del contents.snglbursttable[i]
		else:
			i += 1


def keep_this_injection(sim, outsegs):
	for instrument, seglist in outsegs.iteritems():
		if sim.get_peak(instrument) in seglist:
			return True
	return False


def remove_injections_by_segment(contents):
	i = 0
	while i < len(contents.simbursttable):
		if not keep_this_injection(contents.simbursttable[i], contents.outsegs):
			del contents.simbursttable[i]
		else:
			i += 1


def remove_duplicate_injections(contents):
	# FIXME: this only works if binjfind has not yet been run (if no
	# cross-references exist to the injections)
	for a, sima in enumerate(contents.simbursttable):
		b = a + 1
		while b < len(contents.simbursttable):
			if not sima.cmp(contents.simbursttable[b]):
				del contents.simbursttable[b]
			else:
				b += 1


def clean_coinc_tables(contents, removed_ids):
	# FIXME:  this only works on the output of burca, not the output of
	# binjfind.  In the case of binjfind, deleting a trigger doesn't
	# neccessarily invalidate the coincidences in which it occurs since
	# the injection is still coincident with the remaining triggers.
	# If *all* of the triggers in an injection coincidence get deleted,
	# only then should the injection be marked as not found (by
	# deleting the coincidence).
	# remove dangling coinc_event_map rows
	removed_coincs = []
	i = 0
	while i < len(contents.coincmaptable):
		if llwapp.bisect_contains(removed_ids, contents.coincmaptable[i].event_id):
			removed_coincs.append(contents.coincmaptable[i].coinc_event_id)
			del contents.coincmaptable[i]
		else:
			i += 1
	removed_coincs.sort()

	# remove broken coinc_event rows
	i = 0
	while i < len(contents.coinctable):
		if llwapp.bisect_contains(removed_coincs, contents.coinctable[i].coinc_event_id):
			del contents.coinctable[i]
		else:
			i += 1

	# remove dangling coinc_event_map rows
	i = 0
	while i < len(contents.coincmaptable):
		if llwapp.bisect_contains(removed_coincs, contents.coincmaptable[i].coinc_event_id):
			del contents.coincmaptable[i]
		else:
			i += 1

	contents.make_coinceventids()


#
# =============================================================================
#
#                                 Library API
#
# =============================================================================
#

def apply_filters(contents, options, verbose = False):
	removed_ids = []
	if options.veto_segments:
		if verbose:
			print >>sys.stderr, "applying veto segment list..."
		removed_ids.extend(remove_events_by_segment(contents))
	if verbose:
		print >>sys.stderr, "filtering sngl_burst rows by parameters..."
	removed_ids.extend(remove_events_by_parameters(contents, options))
	if options.inj_made_only:
		if verbose:
			print >>sys.stderr, "removing injections that weren't performed..."
		remove_injections_by_segment(contents)
	if options.inj_no_dups:
		if verbose:
			print >>sys.stderr, "removing duplicate injections..."
		remove_duplicate_injections(contents)
	removed_ids.sort()
	if verbose:
		print >>sys.stderr, "removing broken coincidences..."
	clean_coinc_tables(contents, removed_ids)
	if options.coinc_discard:
		if verbose:
			print >>sys.stderr, "removing coincident triggers..."
		remove_coincidences(contents)
	elif options.coinc_only:
		if verbose:
			print >>sys.stderr, "removing non-coincident triggers..."
		remove_non_coincidences(contents)


def ligolw_bucut(doc, options):
	contents = DocContents(doc, options.program)
	process, options = append_process(doc, options)

	apply_filters(contents, options, options.verbose)

	llwapp.append_search_summary(doc, process, inseg = contents.outseg, outseg = contents.outseg, nevents = len(contents.snglbursttable))
	llwapp.set_process_end_time(process)

	return doc


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

options, filenames = parse_command_line()
for filename in filenames:
	xmldoc = utils.load_filename(filename, options.verbose, gz = filename[-3:] == ".gz")
	xmldoc = ligolw_bucut(xmldoc, options)
	utils.write_filename(xmldoc, filename, options.verbose, gz = filename[-3:] == ".gz")
	xmldoc.unlink()
