#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

from optparse import OptionParser
import os
import socket
import sys
import time

from glue.ligolw import ligolw
from glue.ligolw import metaio
from glue.ligolw import lsctables
from glue.ligolw import docutils
from pylal import SnglBurstUtils
from pylal.date import XLALUTCToGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

parser = OptionParser(version = "%prog CVS $Id$")
parser.add_option("--comment", metavar = "text", default = "", help = "set comment string in process table")
parser.add_option("-i", "--input", metavar = "filename", help = "read from filename (default = stdin)")
parser.add_option("-o", "--output", metavar = "filename", help = "write to filename (default = stdout)")
parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")

parser.add_option("--min-amplitude", metavar = "value", help = "discard triggers below the given amplitude")
parser.add_option("--max-amplitude", metavar = "value", help = "discard triggers above the given amplitude")
parser.add_option("--min-bandwidth", metavar = "Hz", help = "discard triggers narrower than the given bandwidth")
parser.add_option("--max-bandwidth", metavar = "Hz", help = "discard triggers wider than the given bandwidth")
parser.add_option("--min-central-freq", metavar = "Hz", help = "discard triggers with central frequency lower than that given")
parser.add_option("--max-central-freq", metavar = "Hz", help = "discard triggers with central frequency higher than that given")
parser.add_option("--min-confidence", metavar = "value", help = "discard triggers below the given confidence")
parser.add_option("--max-confidence", metavar = "value", help = "discard triggers above the given confidence")
parser.add_option("--min-duration", metavar = "seconds", help = "discard triggers shorter than the given duration")
parser.add_option("--max-duration", metavar = "seconds", help = "discard triggers longer than the given duration")
parser.add_option("--min-fhigh", metavar = "Hz", help = "discard triggers with highest frequency below the given frequency")
parser.add_option("--max-fhigh", metavar = "Hz", help = "discard triggers with highest frequency above the given frequency")
parser.add_option("--min-flow", metavar = "Hz", help = "discard triggers with lowest frequency below the given frequency")
parser.add_option("--max-flow", metavar = "Hz", help = "discard triggers with loest frequency above the given frequency")
parser.add_option("--min-hrss", metavar = "value", help = "discard triggers with h_rss below the given value")
parser.add_option("--max-hrss", metavar = "value", help = "discard triggers with h_rss above the given value")
parser.add_option("--cut-instrument", metavar = "name", action = "append", default = [], help = "discard triggers from given instrument")
parser.add_option("--min-peak-time", metavar = "seconds", help = "discard triggers with peak time before the given GPS time")
parser.add_option("--max-peak-time", metavar = "seconds", help = "discard triggers with peak time after the given GPS time")
parser.add_option("--min-start-time", metavar = "seconds", help = "discard triggers starting before the given GPS time")
parser.add_option("--max-start-time", metavar = "seconds", help = "discard triggers starting after the given GPS time")
parser.add_option("--min-stop-time", metavar = "seconds", help = "discard triggers ending before the given GPS time")
parser.add_option("--max-stop-time", metavar = "seconds", help = "discard triggers ending after the given GPS time")
parser.add_option("--min-snr", metavar = "value", help = "discard triggers below the given SNR")
parser.add_option("--max-snr", metavar = "value", help = "discard triggers above the given SNR")
parser.add_option("--min-tfvolume", metavar = "value", help = "discard triggers with time-frequency volume below the given volume")
parser.add_option("--max-tfvolume", metavar = "value", help = "discard triggers with time-frequency volume above the given volume")
options, args = parser.parse_args()
del parser, args


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

doc = ligolw.Document()
if options.input:
	ligolw.make_parser(lsctables.LIGOLWContentHandler(doc)).parse(file(options.input))
else:
	ligolw.make_parser(lsctables.LIGOLWContentHandler(doc)).parse(sys.stdin)


#
# =============================================================================
#
#                                 Preparation
#
# =============================================================================
#

proctable = metaio.getTablesByName(doc, lsctables.ProcessTable.tableName)
if len(proctable) != 1:
	print >>sys.stderr, "error: input must contain exactly 1 process table"
	sys.exit(1)
proctable = proctable[0]

procparamtable = metaio.getTablesByName(doc, lsctables.ProcessParamsTable.tableName)
if len(procparamtable) != 1:
	print >>sys.stderr, "error: input must contain exactly 1 process params table"
	sys.exit(1)
procparamtable = procparamtable[0]

searchsummtable = metaio.getTablesByName(doc, lsctables.SearchSummaryTable.tableName)
if len(searchsummtable) != 1:
	print >>sys.stderr, "error: input must contain exactly 1 search summary table"
	sys.exit(1)
searchsummtable = searchsummtable[0]

snglbursttables = metaio.getTablesByName(doc, lsctables.SnglBurstTable.tableName)


#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#

process = lsctables.Process()
process.program = "ligolw_bucut"
process.version = __version__
process.cvs_repository = "lscsoft"
process.cvs_entry_time = XLALUTCToGPS(time.strptime(__date__, "%Y/%m/%d %H:%M:%S")).seconds
process.comment = options.comment
process.is_online = 0
process.node = socket.gethostbyaddr(socket.gethostname())[0]
process.username = os.environ["LOGNAME"]
process.unix_procid = os.getpid()
process.start_time = XLALUTCToGPS(time.gmtime()).seconds
process.end_time = 0
process.jobid = 0
process.domain = ""
process.ifos = ""
process.process_id = docutils.NewILWDs(proctable, "process_id").next()

proctable.append(process)

def add_param(name, type, value):
	param = lsctables.ProcessParams()
	param.program = process.program
	param.process_id = process.process_id
	param.param = str(name)
	param.type = str(type)
	param.value = str(value)
	procparamtable.append(param)

if options.input != None:
	add_param("--input", "lstring", options.input)
if options.output != None:
	add_param("--output", "lstring", options.output)
if options.min_amplitude != None:
	options.min_amplitude = float(options.min_amplitude)
	add_param("--min-amplitude", "real_4", options.min_amplitude)
if options.max_amplitude != None:
	options.max_amplitude = float(options.max_amplitude)
	add_param("--max-amplitude", "real_4", options.max_amplitude)
if options.min_bandwidth != None:
	options.min_bandwidth = float(options.min_bandwidth)
	add_param("--min-bandwidth", "real_4", options.min_bandwidth)
if options.max_bandwidth != None:
	options.max_bandwidth = float(options.max_bandwidth)
	add_param("--max-bandwidth", "real_4", options.max_bandwidth)
if options.min_central_freq != None:
	options.min_central_freq = float(options.min_central_freq)
	add_param("--min-central-freq", "real_4", options.min_central_freq)
if options.max_central_freq != None:
	options.max_central_freq = float(options.max_central_freq)
	add_param("--max-central-freq", "real_4", options.max_central_freq)
if options.min_confidence != None:
	options.min_confidence = float(options.min_confidence)
	add_param("--min-confidence", "real_4", options.min_confidence)
if options.max_confidence != None:
	options.max_confidence = float(options.max_confidence)
	add_param("--max-confidence", "real_4", options.max_confidence)
if options.min_duration != None:
	options.min_duration = float(options.min_duration)
	add_param("--min-duration", "real_4", options.min_duration)
if options.max_duration != None:
	options.max_duration = float(options.max_duration)
	add_param("--max-duration", "real_4", options.max_duration)
if options.min_fhigh != None:
	options.min_fhigh = float(options.min_fhigh)
	add_param("--min-fhigh", "real_4", options.min_fhigh)
if options.max_fhigh != None:
	options.max_fhigh = float(options.max_fhigh)
	add_param("--max-fhigh", "real_4", options.max_fhigh)
if options.min_flow != None:
	options.min_flow = float(options.min_flow)
	add_param("--min-flow", "real_4", options.min_flow)
if options.max_flow != None:
	options.max_flow = float(options.max_flow)
	add_param("--max-flow", "real_4", options.max_flow)
if options.min_hrss != None:
	options.min_hrss = float(options.min_hrss)
	add_param("--min-hrss", "real_4", options.min_hrss)
if options.max_hrss != None:
	options.max_hrss = float(options.max_hrss)
	add_param("--max-hrss", "real_4", options.max_hrss)
for instrument in options.cut_instrument:
	add_param("--cut-instrument", "lstring", instrument)
if options.min_peak_time != None:
	options.min_peak_time = lal.LIGOTimeGPS(options.min_peak_time)
	add_param("--min-peak-time", "lstring", options.min_peak_time)
if options.max_peak_time != None:
	options.max_peak_time = lal.LIGOTimeGPS(options.max_peak_time)
	add_param("--max-peak-time", "lstring", options.max_peak_time)
if options.min_snr != None:
	options.min_snr = float(options.min_snr)
	add_param("--min-snr", "real_4", options.min_snr)
if options.max_snr != None:
	options.max_snr = float(options.max_snr)
	add_param("--max-snr", "real_4", options.max_snr)
if options.min_start_time != None:
	options.min_start_time = lal.LIGOTimeGPS(options.min_start_time)
	add_param("--min-start-time", "lstring", options.min_start_time)
if options.max_start_time != None:
	options.max_start_time = lal.LIGOTimeGPS(options.max_start_time)
	add_param("--max-start-time", "lstring", options.max_start_time)
if options.min_stop_time != None:
	options.min_stop_time = lal.LIGOTimeGPS(options.min_stop_time)
	add_param("--min-stop-time", "lstring", options.min_stop_time)
if options.max_stop_time != None:
	options.max_stop_time = lal.LIGOTimeGPS(options.max_stop_time)
	add_param("--max-stop-time", "lstring", options.max_stop_time)
if options.min_tfvolume != None:
	options.min_tfvolume = float(options.min_tfvolume)
	add_param("--min-tfvolume", "real_4", options.min_tfvolume)
if options.max_tfvolume != None:
	options.max_tfvolume = float(options.max_tfvolume)
	add_param("--max-tfvolume", "real_4", options.max_tfvolume)


#
# =============================================================================
#
#                                   Do Cuts
#
# =============================================================================
#

def keep_this_trigger(burst, options):
	if (options.min_amplitude != None) and (burst.amplitude < options.min_amplitude):
		return False
	if (options.max_amplitude != None) and (burst.amplitude > options.max_amplitude):
		return False
	if (options.min_bandwidth != None) and (burst.bandwidth < options.min_bandwidth):
		return False
	if (options.max_bandwidth != None) and (burst.bandwidth > options.max_bandwidth):
		return False
	if (options.min_central_freq != None) and (burst.central_freq < options.min_central_freq):
		return False
	if (options.max_central_freq != None) and (burst.central_freq > options.max_central_freq):
		return False
	if (options.min_confidence != None) and (burst.confidence < options.min_confidence):
		return False
	if (options.max_confidence != None) and (burst.confidence > options.max_confidence):
		return False
	if (options.min_duration != None) and (burst.duration < options.min_duration):
		return False
	if (options.max_duration != None) and (burst.duration > options.max_duration):
		return False
	if (options.min_fhigh != None) and (burst.fhigh < options.min_fhigh):
		return False
	if (options.max_fhigh != None) and (burst.fhigh > options.max_fhigh):
		return False
	if (options.min_flow != None) and (burst.flow < options.min_flow):
		return False
	if (options.max_flow != None) and (burst.flow > options.max_flow):
		return False
	if (options.min_hrss != None) and (burst.hrss < options.min_hrss):
		return False
	if (options.max_hrss != None) and (burst.hrss > options.max_hrss):
		return False
	if burst.ifo in options.cut_instrument:
		return False
	if (options.min_peak_time != None) and (burst.get_peak() < options.min_peak_time):
		return False
	if (options.max_peak_time != None) and (burst.get_peak() > options.max_peak_time):
		return False
	if (options.min_snr != None) and (burst.snr < options.min_snr):
		return False
	if (options.max_snr != None) and (burst.snr > options.max_snr):
		return False
	if (options.min_start_time != None) and (burst.get_start() < options.min_start_time):
		return False
	if (options.max_start_time != None) and (burst.get_start() > options.max_start_time):
		return False
	if (options.min_stop_time != None) and (burst.get_stop() < options.min_stop_time):
		return False
	if (options.max_stop_time != None) and (burst.get_stop() > options.max_stop_time):
		return False
	if (options.min_tfvolume != None) and (burst.tfvolume < options.min_tfvolume):
		return False
	if (options.max_tfvolume != None) and (burst.tfvolume > options.max_tfvolume):
		return False
	return True


nevents = 0
for table in snglbursttables:
	i = 0
	while i < len(table.rows):
		if keep_this_trigger(table.rows[i], options):
			i += 1
			nevents += 1
			continue
		del table.rows[i]


#
# =============================================================================
#
#                        Add Search Summary Information
#
# =============================================================================
#

searchsumm = lsctables.SearchSummary()
searchsumm.process_id = process.process_id
searchsumm.shared_object = "standalone"
searchsumm.lalwrapper_cvs_tag = ""
searchsumm.lal_cvs_tag = ""
searchsumm.comment = process.comment
searchsumm.ifos = process.ifos
searchsumm.set_in(searchsummtable.get_inlist().extent())
searchsumm.set_out(searchsummtable.get_outlist().extent())
searchsumm.nevents = nevents
searchsumm.nnodes = 1

searchsummtable.append(searchsumm)


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

process.end_time = XLALUTCToGPS(time.gmtime()).seconds

if options.output:
	doc.write(file(options.output, "w"))
else:
	doc.write(sys.stdout)
