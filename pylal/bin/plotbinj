#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import bisect
import math
from optparse import OptionParser
import matplotlib
matplotlib.use("Agg")
from matplotlib import figure
from matplotlib.backends.backend_agg import FigureCanvasAgg
import numarray
import sys
import urllib

from glue.lal import CacheEntry
from glue import segments
from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import docutils
from pylal import llwapp

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("-c", "--input-cache", metavar = "filename", default = [], action = "append", help = "read input file the files in this cache")
	parser.add_option("--made-only", action = "store_true", default = False, help = "plot only injections that were made")
	parser.add_option("-b", "--base", metavar = "base", default = "plotbinj_", help = "set the prefix for output filenames (default = plotbinj_)")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, urls = parser.parse_args()

	for cachename in options.input_cache:
		urls.extend([entry.url for entry in map(CacheEntry, file(cachename))])

	return options, (urls or [None])

try:
	options, urls = parse_command_line()
except ValueError, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

def ElementFilter(name, attrs):
	return lsctables.IsTableProperties(lsctables.SimBurstTable, name, attrs) or lsctables.IsTableProperties(lsctables.SearchSummaryTable, name, attrs) or lsctables.IsTableProperties(lsctables.SnglBurstTable, name, attrs) or lsctables.IsTableProperties(lsctables.CoincTable, name, attrs) or lsctables.IsTableProperties(lsctables.CoincMapTable, name, attrs)

def load_url(url, verbose = False):
	if verbose:
		if url:
			print >>sys.stderr, "reading %s..." % url
		else:
			print >>sys.stderr, "reading stdin..."
	doc = ligolw.Document()
	if url:
		ligolw.make_parser(docutils.PartialLIGOLWContentHandler(doc, ElementFilter)).parse(urllib.urlopen(url))
	else:
		ligolw.make_parser(docutils.PartialLIGOLWContentHandler(doc, ElementFilter)).parse(sys.stdin)
	return doc


#
# =============================================================================
#
#                            Document Comprehension
#
# =============================================================================
#

class DocContents(object):
	def __init__(self, doc, verbose = False):
		if verbose:
			print >>sys.stderr, "indexing..."

		#
		# Extract tables
		#

		self.simtable = llwapp.get_table(doc, lsctables.SimBurstTable.tableName)
		self.summarytable = llwapp.get_table(doc, lsctables.SearchSummaryTable.tableName)
		self.coinctable = llwapp.get_table(doc, lsctables.CoincTable.tableName)
		self.coincmaptable = llwapp.get_table(doc, lsctables.CoincMapTable.tableName)

		#
		# Sort table rows
		#

		# sim_burst by simulation_id
		self.simtable.rows.sort(lambda a, b: cmp(lsctables.ILWDID(a.simulation_id), lsctables.ILWDID(b.simulation_id)))

		# coinc_event_map by event_id
		self.coincmaptable.rows.sort(lambda a, b: cmp(lsctables.ILWDID(a.event_id), lsctables.ILWDID(b.event_id)))

		#
		# Construct ID look-up tables
		#

		self.simtableids = map(lsctables.ILWDID, self.simtable.getColumnByName("simulation_id"))
		self.coinctableids = map(lsctables.ILWDID, self.coinctable.getColumnByName("coinc_event_id"))
		self.coincmaptableids = map(lsctables.ILWDID, self.coincmaptable.getColumnByName("event_id"))

		#
		# Found and missed injection IDs
		#

		self.foundsimids = []
		self.missedsimids = []
		for id in self.simtableids:
			if llwapp.bisect_contains(self.coincmaptableids, id):
				self.foundsimids.append(id)
			else:
				self.missedsimids.append(id)
		self.foundsimids.sort()
		self.missedsimids.sort()


	def get_sim_by_id(self, id):
		return self.simtable.rows[bisect.bisect_left(self.simtableids, id)]


#
# =============================================================================
#
#                             Injection Iterators
#
# =============================================================================
#

def FoundInjectionIterator(doccontents):
	last = None
	for id in doccontents.foundsimids:
		if id != last:
			yield doccontents.get_sim_by_id(id)
		last = id

def MissedInjectionIterator(doccontents):
	for id in doccontents.missedsimids:
		yield doccontents.get_sim_by_id(id)


#
# =============================================================================
#
#                             Contour Plot Support
#
# =============================================================================
#

class MadeVsFound(object):
	def __init__(self, xmin, xmax, nx, ymin, ymax, ny):
		self.xmin = xmin
		self.xmax = xmax
		self.logxratio = math.log((xmax / xmin) ** (1.0 / (nx - 1.0)))
		self.xcoords = self.xmin * numarray.exp(numarray.array(range(nx)) * self.logxratio)

		self.ymin = ymin
		self.ymax = ymax
		self.logyratio = math.log((ymax / ymin) ** (1.0 / (ny - 1.0)))
		self.ycoords = self.ymin * numarray.exp(numarray.array(range(ny)) * self.logyratio)

		self.made = numarray.zeros((ny, nx), numarray.Float64)
		self.found = numarray.zeros((ny, nx), numarray.Float64)

	def incmade(self, x, y):
		if (self.xmin <= x <= self.xmax) and (self.ymin <= y <= self.ymax):
			i = int(math.log(y / self.ymin) / self.logyratio + 0.5)
			j = int(math.log(x / self.xmin) / self.logxratio + 0.5)
			self.made[i, j] += 1.0

	def incfound(self, x, y):
		if (self.xmin <= x <= self.xmax) and (self.ymin <= y <= self.ymax):
			i = int(math.log(y / self.ymin) / self.logyratio + 0.5)
			j = int(math.log(x / self.xmin) / self.logxratio + 0.5)
			self.found[i, j] += 1.0

	def normalize(self):
		self.made = numarray.where(self.made > 0, self.made, 1)


#
# =============================================================================
#
#                              Frequency vs. Time
#
# =============================================================================
#

class FreqVsTime(object):
	def __init__(self):
		self.name = "frequency vs. time"
		self.num_injections = 0
		self.seglist = segments.segmentlist()
		self.fig = figure.Figure()
		self.canvas = FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16, 8)
		self.axes = self.fig.gca()
		self.axes.semilogy()

		self.axes.grid(True)

		self.axes.set_xlabel("GPS Time (s)")
		self.axes.set_ylabel("Frequency (Hz)")

	def add_contents(self, doc):
		self.num_injections += len(doc.simtable)
		for row in doc.simtable.rows:
			self.axes.plot((float(row.get_geocent_peak()),), (row.freq,), "b+")
		if not options.made_only:
			for row in MissedInjectionIterator(doc):
				self.axes.plot((float(row.get_geocent_peak()),), (row.freq,), "rx")
		self.seglist |= doc.summarytable.get_outlist().coalesce()

	def finish(self):
		for seg in ~self.seglist & segments.segmentlist([segments.segment(self.axes.get_xlim())]):
			self.axes.axvspan(seg[0], seg[1], facecolor = "k", alpha = 0.2)
		self.axes.set_title("Injection Locations\n(%d Injections)" % self.num_injections)


#
# =============================================================================
#
#                           Amplitude vs. Frequency
#
# =============================================================================
#

class AmplVsFreq(object):
	def __init__(self, representation):
		self.name = "amplitude vs. frequency (%s)" % representation
		self.representation = representation
		self.num_injections = 0
		self.fig = figure.Figure()
		self.canvas = FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16, 8)
		self.axes = self.fig.gca()
		self.madevsfound = MadeVsFound(70.0, 2118.0, 64, 10**-22.2, 10**-18.0, 64)

		self.axes.loglog()
		self.axes.grid(True)

		self.axes.set_xlabel("Frequency (Hz)")
		self.axes.set_ylabel("h_rss")

	def add_contents(self, doc):
		self.num_injections += len(doc.simtable)
		if self.representation == "contour":
			for row in doc.simtable.rows:
				self.madevsfound.incmade(row.freq, row.hrss)
			if not options.made_only:
				for row in FoundInjectionIterator(doc):
					self.madevsfound.incfound(row.freq, row.hrss)
		elif self.representation == "scatter":
			for row in doc.simtable.rows:
				self.axes.plot((row.freq,), (row.hrss,), "b+")
			if not options.made_only:
				for row in MissedInjectionIterator(doc):
					self.axes.plot((row.freq,), (row.hrss,), "rx")

	def finish(self):
		if self.representation == "contour":
			self.madevsfound.normalize()
			if options.made_only:
				cset = self.axes.contour(self.madevsfound.xcoords, self.madevsfound.ycoords, self.madevsfound.made)
			else:
				cset = self.axes.contour(self.madevsfound.xcoords, self.madevsfound.ycoords, self.madevsfound.found / self.madevsfound.made, [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
		self.axes.set_title("Injection Amplitude vs. Frequency\n(%d Injections)" % self.num_injections)


#
# =============================================================================
#
#                                     Plot
#
# =============================================================================
#

plots = (FreqVsTime(), AmplVsFreq("scatter"), AmplVsFreq("contour"))

for n, url in enumerate(urls):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(urls)),
	try:
		doc = DocContents(load_url(url, options.verbose), options.verbose)
		for plot in plots:
			if options.verbose:
				print >>sys.stderr, "adding to %s..." % plot.name
			plot.add_contents(doc)
	except Exception, e:
		print >>sys.stderr, "error: %s" % str(e)
		sys.exit(1)

if options.verbose:
	print >>sys.stderr, "finishing..."
for plot in plots:
	plot.finish()


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

for n, plot in enumerate(plots):
	filename = "%s%d.%s" % (options.base, n, options.format)
	if options.verbose:
		print >>sys.stderr, "writing %s..." % filename
	plot.fig.savefig(filename)
