#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import bisect
import math
from optparse import OptionParser
import pylab
import sys
import urllib

from glue import lal
from glue import segments
from glue.ligolw import ligolw
from glue.ligolw import metaio
from glue.ligolw import lsctables
from glue.ligolw import docutils

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

parser = OptionParser(version="%prog CVS $Id$")
parser.add_option("--gps-start-time", metavar = "seconds", help = "set left edge of plot")
parser.add_option("--gps-end-time", metavar = "seconds", help = "set right edge of plot")
parser.add_option("-t", "--plot-type", metavar = "[freq_vs_time|ampl_vs_freq]", default = "freq_vs_time", help = "choose plot type")
parser.add_option("--representation", metavar = "[contour|scatter]", help = "choose plot type")
parser.add_option("-i", "--input", metavar = "filename", default = [], action = "append", help = "read input from this file")
parser.add_option("-c", "--cache", metavar = "filename", default = [], action = "append", help = "read input file the files in this cache")
parser.add_option("--made-only", action = "store_true", default = False, help = "plot only injections that were made")
parser.add_option("--found-only", action = "store_true", default = False, help = "plot only injections that were found")
parser.add_option("-o", "--output", metavar = "filename", help = "set output file name (required)")
parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
options = parser.parse_args()[0]
del parser

for name in options.cache:
	options.input.extend([entry.url for entry in map(lal.CacheEntry, file(name))])

if not options.input:
	print >>sys.stderr, "error: no input files specified"
	sys.exit(1)

if not options.output:
	print >>sys.stderr, "error: no output file specified"
	sys.exit(1)

if options.plot_type not in ["freq_vs_time", "ampl_vs_freq"]:
	print >>sys.stderr, "error: unrecognized plot type %s" % options.plot_type
	sys.exit(1)

if options.gps_start_time:
	options.gps_start_time = lal.LIGOTimeGPS(options.gps_start_time)
else:
	options.gps_start_time = -segments.infinity()
if options.gps_end_time:
	options.gps_end_time = lal.LIGOTimeGPS(options.gps_end_time)
else:
	options.gps_end_time = segments.infinity()
options.seg = segments.segmentlist([segments.segment(options.gps_start_time, options.gps_end_time)])

if options.made_only and options.found_only:
	print >>sys.stderr, "error: can't plot found only and made only"
	sys.exit(1)

if not options.representation:
	if options.plot_type == "freq_vs_time":
		options.representation = "scatter"
	else:
		options.representation = "contour"


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

def ElementFilter(name, attrs):
	return lsctables.IsTableProperties(lsctables.SimBurstTable, name, attrs) or lsctables.IsTableProperties(lsctables.SearchSummaryTable, name, attrs) or lsctables.IsTableProperties(lsctables.SnglBurstTable, name, attrs) or lsctables.IsTableProperties(lsctables.CoincTable, name, attrs) or lsctables.IsTableProperties(lsctables.CoincMapTable, name, attrs)

def LoadDocument(url):
	doc = ligolw.Document()
	handler = docutils.PartialLIGOLWContentHandler(doc, ElementFilter)
	try:
		ligolw.make_parser(handler).parse(urllib.urlopen(url))
	except Exception, e:
		print >>sys.stderr, "error: parsing contents of %s: %s" % (url, str(e))
		sys.exit(1)
	return doc


def GetTable(doc, Type):
	"""
	Find and return the table of the given type.
	"""
	tables = lsctables.getTablesByType(doc, Type)
	if len(tables) == 0:
		print >>sys.stderr, "warning: no %s tables found" % metaio.StripTableName(Type.tableName)
		return lsctables.New(Type)
	if len(tables) == 1:
		return tables[0]
	print >>sys.stderr, "error: files contain incompatible %s tables" % metaio.StripTableName(Type.tableName)
	sys.exit(1)


#
# =============================================================================
#
#                            Document Comprehension
#
# =============================================================================
#

class DocContents(object):
	def __init__(self, xmldoc):
		#
		# Extract tables
		#

		self.simtable = GetTable(xmldoc, lsctables.SimBurstTable)
		self.bursttable = GetTable(xmldoc, lsctables.SnglBurstTable)
		self.summarytable = GetTable(xmldoc, lsctables.SearchSummaryTable)
		self.coinctable = GetTable(xmldoc, lsctables.CoincTable)
		self.coincmaptable = GetTable(xmldoc, lsctables.CoincMapTable)

		#
		# Sort table rows
		#

		# sim_burst by simulation_id
		self.simtable.rows.sort(lambda a, b: cmp(lsctables.ILWDID(a.simulation_id), lsctables.ILWDID(b.simulation_id)))

		# sngl_burst by event_id
		self.bursttable.rows.sort(lambda a, b: cmp(lsctables.ILWDID(a.event_id), lsctables.ILWDID(b.event_id)))

		# coinc by coinc_event_id
		self.coinctable.rows.sort(lambda a, b: cmp(lsctables.ILWDID(a.coinc_event_id), lsctables.ILWDID(b.coinc_event_id)))

		# coinc_event_map by coinc_event_id
		self.coincmaptable.rows.sort(lambda a, b: cmp(lsctables.ILWDID(a.coinc_event_id), lsctables.ILWDID(b.coinc_event_id)))

		#
		# Construct ID look-up tables
		#

		self.simtableids = map(lsctables.ILWDID, self.simtable.getColumnByName("simulation_id"))
		self.bursttableids = map(lsctables.ILWDID, self.bursttable.getColumnByName("event_id"))
		self.coinctableids = map(lsctables.ILWDID, self.coinctable.getColumnByName("coinc_event_id"))
		self.coincmaptableids = map(lsctables.ILWDID, self.coincmaptable.getColumnByName("coinc_event_id"))


	def get_sim_by_id(self, id):
		return self.simtable.rows[bisect.bisect_left(self.simtableids, lsctables.ILWDID(id))]

	def get_burst_by_id(self, id):
		return self.bursttable.rows[bisect.bisect_left(self.bursttableids, lsctables.ILWDID(id))]

	def get_coincevents_by_id(self, id):
		result = []
		i = bisect.bisect_left(self.coincmaptableids, lsctables.ILWDID(id))
		while (i < len(self.coincmaptable.rows)) and (self.coincmaptable.rows[i].coinc_event_id == id):
			result.append(self.coincmaptable.rows[i])
			i += 1
		return result

	def get_sim_by_coincid(self, id):
		return [self.get_sim_by_id(row.event_id) for row in self.get_coincevents_by_id(id) if "sim_burst" in row.event_id]

	def get_burst_by_coincid(self, id):
		return [self.get_burst_by_id(row.event_id) for row in self.get_coincevents_by_id(id) if "sngl_burst" in row.event_id]


#
# =============================================================================
#
#                           Found Injection Iterator
#
# =============================================================================
#

class FoundIter(object):
	def __init__(self,  doc):
		self.doc = doc
		self.iditer = iter(doc.coinctable.getColumnByName("coinc_event_id"))

	def __iter__(self):
		return self

	def next(self):
		return self.doc.get_sim_by_coincid(self.iditer.next())[0]


#
# =============================================================================
#
#                             Contour Plot Support
#
# =============================================================================
#

class MadeVsFound(object):
	def __init__(self, xmin, xmax, nx, ymin, ymax, ny):
		self.xmin = xmin
		self.logxratio = math.log((xmax / xmin) ** (1.0 / (nx - 1.0)))
		self.xcoords = self.xmin * pylab.exp(pylab.array(range(nx)) * self.logxratio)

		self.ymin = ymin
		self.logyratio = math.log((ymax / ymin) ** (1.0 / (ny - 1.0)))
		self.ycoords = self.ymin * pylab.exp(pylab.array(range(ny)) * self.logyratio)

		self.made = pylab.zeros((ny, nx), pylab.Float64)
		self.found = pylab.zeros((ny, nx), pylab.Float64)

	def incmade(self, x, y):
		i = int(math.log(y / self.ymin) / self.logyratio + 0.5)
		j = int(math.log(x / self.xmin) / self.logxratio + 0.5)
		self.made[i, j] += 1.0

	def incfound(self, x, y):
		i = int(math.log(y / self.ymin) / self.logyratio + 0.5)
		j = int(math.log(x / self.xmin) / self.logxratio + 0.5)
		self.found[i, j] += 1.0

	def normalize(self):
		self.made = pylab.where(self.made > 0, self.made, 1)


#
# =============================================================================
#
#                              Frequency vs. Time
#
# =============================================================================
#

class FreqVsTime(object):
	def __init__(self):
		self.num_injections = 0
		self.min_t = segments.infinity()
		self.max_t = -segments.infinity()
		self.seglist = segments.segmentlist()
		self.fig = pylab.figure(1)
		self.fig.set_figsize_inches(16, 8)
		self.axes = pylab.gca()
		self.axes.semilogy()

		try:
			pylab.setp(self.axes, xlim = list(options.seg[0]))
		except AttributeError:
			# incase the user didn't select a segment
			pass
		pylab.grid(True)

		pylab.xlabel("GPS Time (s)")
		pylab.ylabel("Frequency (Hz)")

	def addto(self, doc):
		self.num_injections += len(doc.simtable)
		if not options.found_only:
			for row in doc.simtable.rows:
				t = float(row.get_geocent_peak())
				if t < self.min_t:
					self.min_t = t
				if t > self.max_t:
					self.max_t = t
				pylab.plot([t], [row.freq], "b+")
		if not options.made_only:
			for row in FoundIter(doc):
				pylab.plot([float(row.get_geocent_peak())], [row.freq], "rx")
		self.seglist |= doc.summarytable.get_inlist().coalesce()

	def finish(self):
		if not len(self.seglist):
			self.seglist = segments.segmentlist([segments.segment(self.min_t - 5.0, self.max_t + 5.0)])
		options.seg &= segments.segmentlist([self.seglist.extent()])

		for seg in ~self.seglist & options.seg:
			pylab.axvspan(seg[0], seg[1], facecolor = "k", alpha = 0.2)
		pylab.title("Injection Locations\n(%d Injections)" % self.num_injections)


#
# =============================================================================
#
#                           Amplitude vs. Frequency
#
# =============================================================================
#

class AmplVsFreq(object):
	def __init__(self):
		self.num_injections = 0
		self.fig = pylab.figure(1)
		self.fig.set_figsize_inches(16, 8)
		self.axes = pylab.gca()
		self.madevsfound = MadeVsFound(70.0, 2118.0, 32, 1e-22, 1e-19, 32)

		self.axes.loglog()
		#pylab.setp(self.axes, xlim = [70.0, 2118.0])
		#pylab.setp(self.axes, ylim = [1e-22, 1e-19])
		pylab.grid(True)

		pylab.xlabel("Frequency (Hz)")
		pylab.ylabel("h_rss")

	def addto(self, doc):
		self.num_injections += len(doc.simtable)
		if options.representation == "contour":
			if not options.found_only:
				for row in doc.simtable.rows:
					self.madevsfound.incmade(row.freq, row.hrss)
			if not options.made_only:
				for row in FoundIter(doc):
					self.madevsfound.incfound(row.freq, row.hrss)
		elif options.representation == "scatter":
			if not options.found_only:
				for row in doc.simtable.rows:
					pylab.plot([row.freq], [row.hrss], "b+")
			if not options.made_only:
				for row in FoundIter(doc):
					pylab.plot([row.freq], [row.hrss], "rx")

	def finish(self):
		if options.representation == "contour":
			self.madevsfound.normalize()
			if options.found_only:
				cset = pylab.contour(self.madevsfound.xcoords, self.madevsfound.ycoords, self.madevsfound.found)
			if options.made_only:
				cset = pylab.contour(self.madevsfound.xcoords, self.madevsfound.ycoords, self.madevsfound.made)
			else:
				cset = pylab.contour(self.madevsfound.xcoords, self.madevsfound.ycoords, self.madevsfound.found / self.madevsfound.made, [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
		pylab.title("Injection Amplitude vs. Frequency\n(%d Injections)" % self.num_injections)


#
# =============================================================================
#
#                                     Plot
#
# =============================================================================
#

if options.plot_type == "freq_vs_time":
	if options.representation == "contour":
		print >>sys.stderr, "contour plots of freq vs. time not supported"
		sys.exit(1)
	plot = FreqVsTime()
elif options.plot_type == "ampl_vs_freq":
	plot = AmplVsFreq()

for url in options.input:
	if options.verbose:
		print >>sys.stderr, url
	plot.addto(DocContents(LoadDocument(url)))

plot.finish()


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

pylab.savefig(options.output)
