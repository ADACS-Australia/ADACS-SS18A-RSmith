#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import math
import numpy
from optparse import OptionParser
try:
	import sqlite3
except ImportError:
	# pre 2.5.x
	from pysqlite2 import dbapi2 as sqlite3
import sys


from glue import segments
from glue.ligolw import dbtables
from glue.ligolw import utils
from pylal import rate
from pylal import SimBurstUtils
from pylal import SnglBurstUtils
from pylal.date import LIGOTimeGPS


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("--made-only", action = "store_true", default = False, help = "Plot only injections that were made.")
	parser.add_option("-b", "--base", metavar = "base", default = "plotbinj_", help = "Set the prefix for output filenames (default = \"plotbinj_\")")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "Set the output image format (default = \"png\")")
	parser.add_option("--hrss", metavar = "wave|det", default = "wave", help = "Select which h_rss will be shown on the plots.  \"wave\" = the h_rss of the wave, \"det\" = the h_rss in the detector (injected).")
	parser.add_option("-l", "--live-time-program", metavar = "program", default = "lalapps_power", help = "Set the name, as it appears in the process table, of the program whose search summary entries define the search live time (default = \"lalapps_power\").")
	parser.add_option("--plot", metavar = "number", action = "append", default = None, help = "Generate the given plot number.")
	parser.add_option("-t", "--tmp-space", metavar = "path", help = "Path to a directory suitable for use as a work area while manipulating the database file.  The database file will be worked on in this directory, and then moved to the final location when complete.  This option is intended to improve performance when running in a networked environment, where there might be a local disk with higher bandwidth than is available to the filesystem on which the final output will reside.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	if options.hrss not in ("wave", "det"):
		raise ValueError, "unrecognized --hrss %s" % options.hrss

	if options.plot:
		options.plot = map(int, options.plot)
	else:
		options.plot = range(10)


	return options, (filenames or [None])


#
# =============================================================================
#
#                              Frequency vs. Time
#
# =============================================================================
#


def missed_injections(contents, instrument):
	"""
	Iterate over missed injections.
	"""
	for values in contents.connection.cursor().execute("""
SELECT
	*
FROM
	sim_burst
WHERE
	NOT EXISTS (
		-- Find a link through the coinc_event_map table to a row
		-- in the sngl_burst table with the correct ifo value.
		SELECT
			*
		FROM
			coinc_event_map AS a
			JOIN coinc_event_map AS b ON (
				b.coinc_event_id == a.coinc_event_id
			)
			JOIN sngl_burst ON (
				b.table_name == 'sngl_burst'
				AND sngl_burst.event_id == b.event_id
			)
		WHERE
			a.table_name == 'sim_burst'
			AND a.event_id == sim_burst.simulation_id
			AND sngl_burst.ifo == ?
	)
	""", (instrument,)):
		yield contents.sim_burst_table._row_from_cols(values)


class FreqVsTime(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument):
		SnglBurstUtils.BurstPlot.__init__(self, "GPS Time (s)", "Frequency (Hz)")
		self.axes.semilogy()
		self.instrument = instrument
		self.num_injections = 0
		self.injected_x = []
		self.injected_y = []
		self.missed_x = []
		self.missed_y = []
		self.seglist = segments.segmentlist()

	def add_contents(self, contents):
		self.num_injections += len(contents.sim_burst_table)
		self.seglist |= contents.seglists[self.instrument]
		for sim in contents.sim_burst_table:
			self.injected_x.append(float(sim.get_geocent_peak()))
			self.injected_y.append(sim.freq)
		if contents.coinc_table is not None:
			for sim in missed_injections(contents, self.instrument):
				self.missed_x.append(float(sim.get_geocent_peak()))
				self.missed_y.append(sim.freq)

	def finish(self):
		self.axes.plot(self.injected_x, self.injected_y, "k+")
		if not options.made_only:
			self.axes.plot(self.missed_x, self.missed_y, "rx")
		for seg in ~self.seglist & segments.segmentlist([segments.segment(self.axes.get_xlim())]):
			self.axes.axvspan(float(seg[0]), float(seg[1]), facecolor = "k", alpha = 0.2)
		self.axes.set_ylim([min(self.injected_y), max(self.injected_y)])
		self.axes.set_title("Injection Locations\n(%d Injections)" % self.num_injections)


#
# =============================================================================
#
#                           Amplitude vs. Frequency
#
# =============================================================================
#


class HrssVsFreqScatter(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, hrss_func):
		SnglBurstUtils.BurstPlot.__init__(self, "Frequency (Hz)", r"$h_{\mathrm{rss}}$")
		self.axes.loglog()
		self.instrument = instrument
		self.hrss_func = hrss_func
		self.num_injections = 0
		self.injected_x = []
		self.injected_y = []
		self.missed_x = []
		self.missed_y = []

	def add_contents(self, contents):
		self.num_injections += len(contents.sim_burst_table)
		for sim in contents.sim_burst_table:
			self.injected_x.append(sim.freq)
			self.injected_y.append(self.hrss_func(sim, self.instrument))
		if contents.coinc_table is not None:
			for sim in missed_injections(contents, self.instrument):
				self.missed_x.append(sim.freq)
				self.missed_y.append(self.hrss_func(sim, self.instrument))

	def finish(self):
		self.axes.plot(self.injected_x, self.injected_y, "k+")
		if not options.made_only:
			self.axes.plot(self.missed_x, self.missed_y, "rx")
		self.axes.set_xlim([min(self.injected_x), max(self.injected_x)])
		self.axes.set_ylim([min(self.injected_y), max(self.injected_y)])
		self.axes.set_title("Injection Amplitude vs. Frequency\n(%d Injections)" % self.num_injections)


#
# =============================================================================
#
#                           Trigger Count Histogram
#
# =============================================================================
#


class TriggerCountHistogram(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument):
		SnglBurstUtils.BurstPlot.__init__(self, "Number of Triggers Coincident with Injection", "Count")
		self.axes.semilogy()
		self.instrument = instrument
		self.found = 0
		self.bins = []

	def add_contents(self, contents):
		for nevents, in contents.connection.cursor().execute("""
SELECT
	nevents
FROM
	coinc_event
WHERE
	coinc_def_id == ?
		""", (contents.sb_definer_id,)):
			self.found += 1
			while nevents + 1 >= len(self.bins):
				self.bins.append(0)
			self.bins[nevents] += 1

	def finish(self):
		self.axes.plot(range(len(self.bins)), self.bins, "ko-")
		self.axes.set_title("Triggers per Found Injection\n(%d Found Injections)" % self.found)


#
# =============================================================================
#
#                         Recovered vs. Injected h_rss
#
# =============================================================================
#


class RecoveredVsInjectedhrss(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, hrss_func):
		SnglBurstUtils.BurstPlot.__init__(self, r"Injected $h_{\mathrm{rss}}$", r"Recovered $h_{\mathrm{rss}}$")
		self.axes.loglog()
		self.fig.set_size_inches(8, 8)
		self.instrument = instrument
		self.hrss_func = hrss_func
		self.matches = 0
		self.x = []
		self.y = []
		self.c = []

	def add_contents(self, contents):
		for values in contents.connection.cursor().execute("""
SELECT
	sim_burst.*,
	sngl_burst.peak_frequency,
	sngl_burst.ms_hrss
FROM
	sim_burst
	JOIN coinc_event_map AS a ON (
		a.table_name == 'sim_burst'
		AND a.event_id == sim_burst.simulation_id
	)
	JOIN coinc_event_map AS b ON (
		a.coinc_event_id == b.coinc_event_id
	)
	JOIN sngl_burst ON (
		b.table_name == 'sngl_burst'
		AND b.event_id == sngl_burst.event_id
	)
WHERE
	sngl_burst.ifo == ?
		""", (self.instrument,)):
			sim = contents.sim_burst_table._row_from_cols(values)
			freq_rec, hrss_rec = values[-2:]
			self.matches += 1
			self.x.append(self.hrss_func(sim, self.instrument))
			self.y.append(hrss_rec)
			self.c.append(math.log(freq_rec))

	def finish(self):
		self.axes.scatter(self.x, self.y, c = self.c, s = 16)
		#xmin, xmax = self.axes.get_xlim()
		#ymin, ymax = self.axes.get_ylim()
		xmin, xmax = min(self.x), max(self.x)
		ymin, ymax = min(self.y), max(self.y)
		xmin = ymin = min(xmin, ymin)
		xmax = ymax = max(xmax, ymax)
		self.axes.plot([xmin, xmax], [ymin, ymax], "k-")
		self.axes.set_xlim([xmin, xmax])
		self.axes.set_ylim([ymin, ymax])
		self.axes.set_title(r"Recovered $h_{\mathrm{rss}}$ vs.\ Injected $h_{\mathrm{rss}}$ (%d Events Matching Injections)" % self.matches)


class RecoveredPerInjectedhrssVsFreq(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, hrss_func):
		SnglBurstUtils.BurstPlot.__init__(self, r"$f_{\mathrm{injected}}$ (Hz)", r"$\frac{\mathrm{Recovered}\ h_{\mathrm{rss}}}{\mathrm{Injected}\ h_{\mathrm{rss}}}$")
		self.axes.loglog()
		self.fig.set_size_inches(8, 8)
		self.instrument = instrument
		self.hrss_func = hrss_func
		self.matches = 0
		self.x = []
		self.y = []
		self.c = []

	def add_contents(self, contents):
		for values in contents.connection.cursor().execute("""
SELECT
	sim_burst.*,
	sngl_burst.peak_frequency,
	sngl_burst.ms_hrss
FROM
	sim_burst
	JOIN coinc_event_map AS a ON (
		a.table_name == 'sim_burst'
		AND a.event_id == sim_burst.simulation_id
	)
	JOIN coinc_event_map AS b ON (
		b.coinc_event_id == a.coinc_event_id
	)
	JOIN sngl_burst ON (
		b.table_name == 'sngl_burst'
		AND b.event_id == sngl_burst.event_id
	)
WHERE
	sngl_burst.ifo == ?
		""", (self.instrument,)):
			sim = contents.sim_burst_table._row_from_cols(values)
			freq_rec, hrss_rec = values[-2:]
			self.matches += 1
			self.x.append(sim.freq)
			self.y.append(hrss_rec / self.hrss_func(sim, self.instrument))
			self.c.append(math.log(freq_rec))

	def finish(self):
		self.axes.scatter(self.x, self.y, c = self.c, s = 16)
		self.axes.set_xlim([min(self.x), max(self.x)])
		self.axes.set_ylim([min(self.y), max(self.y)])
		self.axes.set_title(r"Ratio of Recovered to Injected $h_{\mathrm{rss}}$ vs.\ Frequency (%d Events Matching Injections)" % self.matches)


class RecoveredPerInjectedhrssVsBandwidth(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, hrss_func):
		SnglBurstUtils.BurstPlot.__init__(self, r"$\Delta f_{\mathrm{recovered}}$ (Hz)", r"$\frac{\mathrm{Recovered}\ h_{\mathrm{rss}}}{\mathrm{Injected}\ h_{\mathrm{rss}}}$")
		self.axes.loglog()
		self.fig.set_size_inches(8, 8)
		self.instrument = instrument
		self.hrss_func = hrss_func
		self.matches = 0
		self.x = []
		self.y = []
		self.c = []

	def add_contents(self, contents):
		for values in contents.connection.cursor().execute("""
SELECT
	sim_burst.*,
	sngl_burst.bandwidth,
	sngl_burst.peak_frequency,
	sngl_burst.ms_hrss
FROM
	sim_burst
	JOIN coinc_event_map AS a ON (
		a.table_name == 'sim_burst'
		AND a.event_id == sim_burst.simulation_id
	)
	JOIN coinc_event_map AS b ON (
		b.coinc_event_id == a.coinc_event_id
	)
	JOIN sngl_burst ON (
		b.table_name == 'sngl_burst'
		AND b.event_id == sngl_burst.event_id
	)
WHERE
	sngl_burst.ifo == ?
		""", (self.instrument,)):
			sim = contents.sim_burst_table._row_from_cols(values)
			bandwidth, freq_rec, hrss_rec = values[-3:]
			self.matches += 1
			self.x.append(bandwidth)
			self.y.append(hrss_rec / self.hrss_func(sim, self.instrument))
			self.c.append(math.log(freq_rec))

	def finish(self):
		self.axes.scatter(self.x, self.y, c = self.c, s = 16)
		self.axes.set_xlim([min(self.x), max(self.x)])
		self.axes.set_ylim([min(self.y), max(self.y)])
		self.axes.set_title(r"Ratio of Recovered to Injected $h_{\mathrm{rss}}$ vs.\ Recovered Bandwidth (%d Events Matching Injections)" % self.matches)


#
# =============================================================================
#
#                            Recovered Time Offset
#
# =============================================================================
#


class RecoveredTimeOffset(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, interval, width):
		SnglBurstUtils.BurstPlot.__init__(self, r"$t_{\mathrm{recovered}} - t_{\mathrm{injected}}$ (s)", "Triggers per Unit Offset")
		self.axes.semilogy()
		self.instrument = instrument
		self.found = 0
		self.offsets = rate.Rate(interval, width)
		self.coinc_offsets = rate.Rate(interval, width)

	def add_contents(self, contents):
		# this outer loop assumes each injection can only be found
		# in at most one coinc, otherwise the "found" count is
		# wrong.
		for values in contents.connection.cursor().execute("""
SELECT
	coinc_event.*,
	sim_burst.h_peak_time,
	sim_burst.h_peak_time_ns,
	sim_burst.l_peak_time,
	sim_burst.l_peak_time_ns
FROM
	coinc_event
	JOIN coinc_event_map ON (
		coinc_event_map.coinc_event_id == coinc_event.coinc_event_id
	)
	JOIN sim_burst ON (
		coinc_event_map.table_name == 'sim_burst'
		AND coinc_event_map.event_id == sim_burst.simulation_id
	)
WHERE
	coinc_def_id == ?
		""", (contents.sb_definer_id,)):
			coinc = contents.coinc_table._row_from_cols(values)
			sim_h_peak = LIGOTimeGPS(*values[-4:-2])
			sim_l_peak = LIGOTimeGPS(*values[-2:])
			if self.instrument in ("H1", "H2"):
				sim_peak = sim_h_peak
			elif self.instrument in ("L1",):
				sim_peak = sim_l_peak
			else:
				raise ValueError, self.instrument
			self.found += 1
			bursts = list(SnglBurstUtils.coinc_sngl_bursts(contents, coinc.coinc_event_id))
			coinc_dt = 0
			for burst in bursts:
				if burst.ifo == self.instrument:
					dt = burst.get_peak() - sim_peak
					try:
						self.offsets[dt] += 1.0
					except IndexError:
						# outside plot range
						pass
				if burst.ifo in ("H1", "H2"):
					coinc_dt += float(burst.get_peak() - sim_h_peak) * burst.snr
				elif burst.ifo in ("L1",):
					coinc_dt += float(burst.get_peak() - sim_l_peak) * burst.snr
				else:
					raise ValueError, burst.ifo
			coinc_dt /= sum([burst.snr for burst in bursts])
			try:
				self.coinc_offsets[coinc_dt] += 1.0
			except IndexError:
				# outside plot range
				pass

	def finish(self):
		self.axes.set_title("Trigger Peak Time - Injection Peak Time\n(%d Found Injections)" % self.found)
		self.axes.plot(self.offsets.xvals(), self.offsets.filter(), "k")
		self.axes.plot(self.coinc_offsets.xvals(), self.coinc_offsets.filter(), "r")
		self.axes.legend(["%s residuals" % self.instrument, "SNR-weighted mean of residuals in all instruments"], loc = "lower right")


#
# =============================================================================
#
#                          Recovered Frequency Offset
#
# =============================================================================
#


class RecoveredFrequencyOffset(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, interval, width):
		SnglBurstUtils.BurstPlot.__init__(self, r"$f_{\mathrm{recovered}} / f_{\mathrm{injected}}$", "Event Number Density")
		self.axes.loglog()
		self.instrument = instrument
		self.found = 0
		self.offsets = rate.Rate(interval, width)
		self.coinc_offsets = rate.Rate(interval, width)

	def add_contents(self, contents):
		# this outer loop assumes each injection can only be found
		# in at most one coinc, otherwise the "found" count is
		# wrong.
		for values in contents.connection.cursor().execute("""
SELECT
	coinc_event.*,
	sim_burst.freq
FROM
	coinc_event
	JOIN coinc_event_map ON (
		coinc_event_map.coinc_event_id == coinc_event.coinc_event_id
	)
	JOIN sim_burst ON (
		coinc_event_map.table_name == 'sim_burst'
		AND sim_burst.simulation_id == coinc_event_map.event_id
	)
WHERE
	coinc_event.coinc_def_id == ?
		""", (contents.sb_definer_id,)):
			coinc = contents.coinc_table._row_from_cols(values)
			sim_freq = values[-1]
			self.found += 1
			bursts = list(SnglBurstUtils.coinc_sngl_bursts(contents, coinc.coinc_event_id))
			for burst in bursts:
				if burst.ifo == self.instrument:
					df = math.log(burst.peak_frequency / sim_freq, 10)
					try:
						self.offsets[df] += 1.0
					except IndexError:
						# outside plot range
						pass
			# snr-weighted mean of peak frequencies
			coinc_freq = sum([burst.peak_frequency * burst.snr for burst in bursts]) / sum([burst.snr for burst in bursts])
			df = math.log(coinc_freq / sim_freq, 10)
			try:
				self.coinc_offsets[df] += 1.0
			except IndexError:
				# outside plot range
				pass

	def finish(self):
		self.axes.set_title("Trigger Peak Frequency / Injection Centre Frequency\n(%d Found Injections)" % self.found)
		self.axes.plot(10**self.offsets.xvals(), self.offsets.filter(), "k")
		self.axes.plot(10**self.coinc_offsets.xvals(), self.coinc_offsets.filter(), "r")
		self.axes.legend(["%s triggers" % self.instrument, "SNR-weighted mean of all matching triggers"], loc = "lower right")
		ymin, ymax = self.axes.get_ylim()
		if ymax / ymin > 1e6:
			ymin = ymax / 1e6
			self.axes.set_ylim((ymin, ymax))


#
# =============================================================================
#
#                       Recovered vs. Injected Frequency
#
# =============================================================================
#


class RecoveredVsInjectedFreq(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, hrss_func):
		SnglBurstUtils.BurstPlot.__init__(self, r"$f_{\mathrm{injected}}$ (Hz)", r"$f_{\mathrm{recovered}}$ (Hz)")
		self.axes.loglog()
		self.fig.set_size_inches(8, 8)
		self.instrument = instrument
		self.hrss_func = hrss_func
		self.matches = 0
		self.x = []
		self.y = []
		self.c = []

	def add_contents(self, contents):
		for values in contents.connection.cursor().execute("""
SELECT
	sim_burst.*,
	sngl_burst.peak_frequency,
	sngl_burst.ms_hrss
FROM
	sim_burst
	JOIN coinc_event_map AS a ON (
		a.table_name == 'sim_burst'
		AND a.event_id == sim_burst.simulation_id
	)
	JOIN coinc_event_map AS b ON (
		b.coinc_event_id == a.coinc_event_id
	)
	JOIN sngl_burst ON (
		b.table_name == 'sngl_burst'
		AND b.event_id == sngl_burst.event_id
	)
WHERE
	sngl_burst.ifo == ?
		""", (self.instrument,)):
			sim = contents.sim_burst_table._row_from_cols(values)
			freq_rec, hrss_rec = values[-2:]
			self.matches += 1
			self.x.append(sim.freq)
			self.y.append(freq_rec)
			self.c.append(math.log(hrss_rec / self.hrss_func(sim, self.instrument)))

	def finish(self):
		self.axes.scatter(self.x, self.y, c = self.c, s = 16)
		xmin, xmax = min(self.x), max(self.x)
		ymin, ymax = min(self.y), max(self.y)
		xmin = ymin = min(xmin, ymin)
		xmax = ymax = max(xmax, ymax)
		self.axes.plot([xmin, xmax], [ymin, ymax], "k-")
		self.axes.set_xlim([xmin, xmax])
		self.axes.set_ylim([ymin, ymax])
		self.axes.set_title(r"Recovered Frequency vs.\ Injected Frequency (%d Events Matching Injections)" % self.matches)


#
# =============================================================================
#
#                                     Plot
#
# =============================================================================
#


#
# How to create new plots
#


def new_plots(instrument, hrss_func, plots):
	l = (
		FreqVsTime(instrument),
		HrssVsFreqScatter(instrument, hrss_func),
		SimBurstUtils.Efficiency_hrss_vs_freq((instrument,), hrss_func, 0.1),
		TriggerCountHistogram(instrument),
		RecoveredVsInjectedhrss(instrument, hrss_func),
		RecoveredPerInjectedhrssVsFreq(instrument, hrss_func),
		RecoveredPerInjectedhrssVsBandwidth(instrument, hrss_func),
		RecoveredTimeOffset(instrument, segments.segment(-0.03, +0.03), 0.00015),
		RecoveredFrequencyOffset(instrument, segments.segment(-1.0, +1.0), .002),
		RecoveredVsInjectedFreq(instrument, hrss_func)
	)
	return [l[i] for i in plots]


#
# Parse command line
#


options, filenames = parse_command_line()


#
# Set hrss_func
#


if options.hrss == "wave":
	def hrss_func(sim, instrument):
		return sim.hrss
else:
	hrss_func = SimBurstUtils.hrss_in_instrument


#
# Process files
#


plots = {}
coincplots = (
	SimBurstUtils.Efficiency_hrss_vs_freq(("H1", "H2", "L1"), hrss_func, 0.1),
)
for n, filename in enumerate(utils.sort_files_by_size(filenames, options.verbose, reverse = True)):
	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename)
	working_filename = dbtables.get_connection_filename(filename, tmp_path = options.tmp_space, verbose = options.verbose)
	connection = sqlite3.connect(working_filename)
	dbtables.DBTable_set_connection(connection)
	database = SnglBurstUtils.CoincDatabase().summarize(options.live_time_program, options.verbose)
	for instrument in database.instruments:
		if instrument not in plots:
			plots[instrument] = new_plots(instrument, hrss_func, options.plot)
		for n, plot in zip(options.plot, plots[instrument]):
			if options.verbose:
				print >>sys.stderr, "adding to %s plot %d ..." % (instrument, n)
			plot.add_contents(database)
	for n, plot in enumerate(coincplots):
		if options.verbose:
			print >>sys.stderr, "adding to coinc plot %d ..." % n
		plot.add_contents(database)
	connection.close()
	dbtables.discard_connection_filename(filename, working_filename, verbose = options.verbose)


# compute the binning for the efficiency contour plots
def make_binning(plots):
	plots = [plot for instrument in plots.keys() for plot in plots[instrument] if isinstance(plot, SimBurstUtils.Efficiency_hrss_vs_freq)]
	if not plots:
		return None
	minx = min([min(plot.injected_x) for plot in plots])
	maxx = max([max(plot.injected_x) for plot in plots])
	miny = min([min(plot.injected_y) for plot in plots])
	maxy = max([max(plot.injected_y) for plot in plots])
	return rate.NDBins((rate.LogarithmicBins(minx, maxx, 256), rate.LogarithmicBins(miny, maxy, 256)))

binning = make_binning(plots)


# delete the plots as we go to save memory
efficiencies = []
for instrument in plots:
	n = 0
	format = "%%s%s_%%0%dd.%%s" % (instrument, int(math.log10(max(options.plot) or 1)) + 1)
	while len(plots[instrument]):
		plot = plots[instrument].pop(0)
		filename = format % (options.base, options.plot[n], options.format)
		if options.verbose:
			print >>sys.stderr, "finishing %s plot %d ..." % (instrument, options.plot[n])
		try:
			if isinstance(plot, SimBurstUtils.Efficiency_hrss_vs_freq):
				plot.finish(binning = binning)
				efficiencies.append(plot)
				fig = SimBurstUtils.plot_Efficiency_hrss_vs_freq(plot)
			else:
				plot.finish()
				fig = plot.fig
		except ValueError, e:
			print >>sys.stderr, "can't finish %s plot %d: %s" % (instrument, options.plot[n], str(e))
		else:
			if options.verbose:
				print >>sys.stderr, "writing %s ..." % filename
			fig.savefig(filename)
		n += 1


for n, plot in enumerate(coincplots):
	format = "%%s%s_%%0%dd.%%s" % ("coinc", int(math.log10(len(coincplots))) + 1)
	filename = format % (options.base, n, options.format)
	if options.verbose:
		print >>sys.stderr, "finishing coinc plot %d ..." % n
	try:
		plot.finish(binning = binning)
		fig = SimBurstUtils.plot_Efficiency_hrss_vs_freq(plot)
	except ValueError, e:
		print >>sys.stderr, "can't finish coinc plot %d: %s" % (n, str(e))
	else:
		if options.verbose:
			print >>sys.stderr, "writing %s ..." % filename
		fig.savefig(filename)


def plot_multi_Efficiency_hrss_vs_freq(efficiencies):
	plot = SnglBurstUtils.BurstPlot("Frequency (Hz)", r"$h_{\mathrm{rss}}$")
	plot.axes.loglog()

	e = efficiencies[0]
	xcoords, ycoords = e.efficiency.centres()
	zvals = e.efficiency.ratio()
	error = e.error
	for n, e in enumerate(efficiencies[1:]):
		error += e.error
		other_xcoords, other_ycoords = e.efficiency.centres()
		if (xcoords != other_xcoords).any() or (ycoords != other_ycoords).any():
			# binnings don't match, can't compute product of
			# efficiencies
			raise ValueError, "binning mismatch"
		zvals *= e.efficiency.ratio()
	error /= len(efficiencies)

	nfound = numpy.array([len(e.found_x) for e in efficiencies], dtype = "double")
	ninjected = numpy.array([len(e.injected_x) for e in efficiencies], dtype = "double")

	# the model for guessing the ninjected in the coincidence case is
	# to assume that the injections done in the instrument with the
	# most injections were done into all three with a probability given
	# by the ratio of the number actually injected into each instrument
	# to the number injected into the instrument with the most
	# injected, and then to assume that these are independent random
	# occurances and that to be done in coincidence an injection must
	# be done in all three instruments.

	ninjected_guess = (ninjected / ninjected.max()).prod() * ninjected.min()

	# the model for guessing the nfound in the coincidence case is to
	# assume that each injection is found or missed in each instrument
	# at random, and to be found in the coincidence case it must be
	# found in all three.

	nfound_guess = (nfound / ninjected).prod() * ninjected_guess

	ninjected_guess = int(round(ninjected_guess))
	nfound_guess = int(round(nfound_guess))

	instruments = [list(e.instruments) for e in efficiencies]
	[e.sort() for e in instruments]
	instruments = ["+".join(e) for e in instruments]
	instruments.sort()
	instruments = r" \& ".join(instruments)

	cset = plot.axes.contour(xcoords, ycoords, numpy.transpose(zvals), (.1, .2, .3, .4, .5, .6, .7, .8, .9))
	cset.clabel(inline = True, fontsize = 5, fmt = r"$%%g \pm %g$" % error, colors = "k")

	plot.axes.set_title(r"%s Estimated Injection Detection Efficiency ($\sim$%d of $\sim$%d Found)" % (instruments, nfound_guess, ninjected_guess))

	return plot.fig

if efficiencies:
	if options.verbose:
		print >>sys.stderr, "computing theoretical coincident detection efficiency ..."
	fig = plot_multi_Efficiency_hrss_vs_freq(efficiencies)
	filename = "%scoincidence.png" % options.base
	if options.verbose:
		print >>sys.stderr, "writing %s ..." % filename
	fig.savefig(filename)
