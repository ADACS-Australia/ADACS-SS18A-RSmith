#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import math
from optparse import OptionParser
import numarray
import sys

from glue import segments
from glue.ligolw import lsctables
from pylal import llwapp
from pylal import rate
from pylal import SnglBurstUtils
from pylal.date import LIGOTimeGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("--made-only", action = "store_true", default = False, help = "plot only injections that were made")
	parser.add_option("-b", "--base", metavar = "base", default = "plotbinj_", help = "set the prefix for output filenames (default = plotbinj_)")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	return options, (filenames or [None])

try:
	options, filenames = parse_command_line()
except ValueError, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

# load sngl_burst table's rows as a dictionary indexed by numeric event_id

def snglburst_init(self, attrs):
	lsctables.LSCTableUnique.__init__(self, attrs)
	self.rows = {}

def snglburst_append(self, row):
	self.rows[lsctables.ILWDID(row.event_id)] = row
	del row.event_id

# load sim_burst table's rows as a dictionary indexed by numeric
# simulation_id

def simburst_init(self, attrs):
	lsctables.LSCTableUnique.__init__(self, attrs)
	self.rows = {}

def simburst_append(self, row):
	self.rows[lsctables.ILWDID(row.simulation_id)] = row
	del row.simulation_id

# load the coinc_map table's rows as a dictionary indexed by numeric
# coinc_event_id, each value being a CoincMap object whose attributes are
# (at this stage) lists of the numeric IDs of the sim_burst, sngl_burst,
# and coinc_event entries to which this map references.

class CoincMap(object):
	__slots__ = ["sims", "bursts", "coincs"]

	def __init__(self):
		self.sims = []
		self.bursts = []
		self.coincs = []

def coinc_map_init(self, attrs):
	lsctables.LSCTableUnique.__init__(self, attrs)
	self.rows = {}

def coinc_map_append(self, row):
	id = lsctables.ILWDID(row.coinc_event_id)
	if id not in self.rows:
		self.rows[id] = CoincMap()
	if "sim_burst" in row.event_id:
		self.rows[id].sims.append(lsctables.ILWDID(row.event_id))
	elif "sngl_burst" in row.event_id:
		self.rows[id].bursts.append(lsctables.ILWDID(row.event_id))
	elif "coinc_event" in row.event_id:
		self.rows[id].coincs.append(lsctables.ILWDID(row.event_id))
	else:
		raise ValueError, "unrecognized coincident event ID: %s" % str(row.event_id)

# load the coinc_event table's rows as a list, parsing IDs to their numeric
# value

def coinc_append(self, row):
	row.coinc_event_id = lsctables.ILWDID(row.coinc_event_id)
	row.time_slide_id = lsctables.ILWDID(row.time_slide_id)
	self.rows.append(row)

# load the time_slide table's rows as a dictionary indexed by numeric
# time_slide_id

def timeslide_init(self, attrs):
	lsctables.LSCTableMulti.__init__(self, attrs)
	self.rows = {}

def timeslide_append(self, row):
	id = lsctables.ILWDID(row.time_slide_id)
	if id in self.rows:
		self.rows[id][row.instrument] = row.offset
	else:
		self.rows[id] = {row.instrument: row.offset}

# method and attribute overrides to put it all in place

lsctables.SnglBurstTable.loadcolumns = ["ifo", "confidence", "peak_time", "peak_time_ns", "event_id"]
lsctables.SnglBurstTable.__init__ = snglburst_init
lsctables.SnglBurstTable.append = snglburst_append
lsctables.SimBurstTable.loadcolumns = ["geocent_peak_time", "geocent_peak_time_ns", "h_peak_time", "h_peak_time_ns", "l_peak_time", "l_peak_time_ns", "freq", "hrss", "simulation_id"]
lsctables.SimBurstTable.__init__ = simburst_init
lsctables.SimBurstTable.append = simburst_append
lsctables.CoincTable.loadcolumns = ["coinc_event_id", "time_slide_id", "nevents"]
lsctables.CoincTable.append = coinc_append
lsctables.CoincMapTable.__init__ = coinc_map_init
lsctables.CoincMapTable.append = coinc_map_append
lsctables.TimeSlideTable.__init__ = timeslide_init
lsctables.TimeSlideTable.append = timeslide_append


#
# =============================================================================
#
#                            Document Comprehension
#
# =============================================================================
#

class DocContents(object):
	def __init__(self, xmldoc, live_time_program):
		#
		# Extract tables
		#

		self.sim_rows = llwapp.get_table(xmldoc, lsctables.SimBurstTable.tableName).rows
		try:
			burst_rows = llwapp.get_table(xmldoc, lsctables.SnglBurstTable.tableName).rows
			self.coinc_rows = llwapp.get_table(xmldoc, lsctables.CoincTable.tableName).rows
			coinc_map_rows = llwapp.get_table(xmldoc, lsctables.CoincMapTable.tableName).rows
			tisi_rows = llwapp.get_table(xmldoc, lsctables.TimeSlideTable.tableName).rows
		except:
			# file contains missing or incomplete coinc
			# information, rig for injection-only plots.
			print >>sys.stderr, "warning: no coincidence information"
			burst_rows = {}
			self.coinc_rows = []
			coinc_map_rows = {}
			tisi_rows = {}

		#
		# Extract segmentlist
		#

		try:
			self.seglists = llwapp.segmentlistdict_fromsearchsummary(xmldoc, live_time_program)
			self.instruments = self.seglists.keys()
		except:
			print >>sys.stderr, "warning: no search summary information"
			self.seglists = {}

		#
		# Replace numeric ID attributes of each coinc_event row
		# with references to the corresponding objects in the other
		# tables
		#

		i = 0
		while i < len(self.coinc_rows):
			coinc_map = coinc_map_rows[self.coinc_rows[i].coinc_event_id]
			if not coinc_map.sims:
				# not a sim_burst <--> anything coinc
				del self.coinc_rows[i]
				continue
			self.coinc_rows[i].coinc_event_id = coinc_map
			self.coinc_rows[i].time_slide_id = tisi_rows[self.coinc_rows[i].time_slide_id]
			# replace the numeric IDs in the CoincMap object
			# with references to the corresponding objects in
			# the respective tables
			coinc_map.sims = map(self.sim_rows.__getitem__, coinc_map.sims)
			coinc_map.bursts = map(burst_rows.__getitem__, coinc_map.bursts)
			# FIXME: commented out for speed;  uncomment when a
			# plot needs info about coincident injections.
			#coinc_map.coincs = map(lambda id: map(burst_rows.__getitem__, coinc_map_rows[id].bursts), coinc_map.coincs)
			i += 1

		#
		# Construct lists of the found and missed injections for
		# each instrument.
		#

		self.foundsims = {}
		self.missedsims = {}
		for instrument in self.instruments:
			self.foundsims[instrument] = []
			for coinc in self.coinc_rows:
				for burst in coinc.coinc_event_id.bursts:
					if burst.ifo == instrument:
						self.foundsims[instrument].extend(coinc.coinc_event_id.sims)
						break
			self.foundsims[instrument].sort()
			self.missedsims[instrument] = [sim for sim in self.sim_rows.itervalues() if not llwapp.bisect_contains(self.foundsims[instrument], sim) and sim.get_geocent_peak() in self.seglists[instrument]]
			self.missedsims[instrument].sort()


#
# =============================================================================
#
#                              Frequency vs. Time
#
# =============================================================================
#

class FreqVsTime(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument):
		SnglBurstUtils.BurstPlot.__init__(self, "GPS Time (s)", "Frequency (Hz)")
		self.axes.semilogy()
		self.instrument = instrument
		self.num_injections = 0
		self.injected_x = []
		self.injected_y = []
		self.missed_x = []
		self.missed_y = []
		self.seglist = segments.segmentlist()

	def add_contents(self, doc):
		self.num_injections += len(doc.sim_rows)
		self.seglist |= doc.seglists[self.instrument]
		for sim in doc.sim_rows.itervalues():
			self.injected_x.append(float(sim.get_geocent_peak()))
			self.injected_y.append(sim.freq)
		for sim in doc.missedsims[self.instrument]:
			self.missed_x.append(float(sim.get_geocent_peak()))
			self.missed_y.append(sim.freq)

	def finish(self):
		self.axes.plot(self.injected_x, self.injected_y, "k+")
		if not options.made_only:
			self.axes.plot(self.missed_x, self.missed_y, "rx")
		for seg in ~self.seglist & segments.segmentlist([segments.segment(self.axes.get_xlim())]):
			self.axes.axvspan(seg[0], seg[1], facecolor = "k", alpha = 0.2)
		self.axes.set_ylim([min(self.injected_y), max(self.injected_y)])
		self.axes.set_title("Injection Locations\n(%d Injections)" % self.num_injections)


#
# =============================================================================
#
#                           Amplitude vs. Frequency
#
# =============================================================================
#

class AmplVsFreqScatter(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument):
		SnglBurstUtils.BurstPlot.__init__(self, "Frequency (Hz)", r"$h_{\textrm{rss}}$")
		self.axes.loglog()
		self.instrument = instrument
		self.num_injections = 0
		self.injected_x = []
		self.injected_y = []
		self.missed_x = []
		self.missed_y = []

	def add_contents(self, doc):
		self.num_injections += len(doc.sim_rows)
		for sim in doc.sim_rows.itervalues():
			self.injected_x.append(sim.freq)
			self.injected_y.append(sim.hrss)
		for sim in doc.missedsims[self.instrument]:
			self.missed_x.append(sim.freq)
			self.missed_y.append(sim.hrss)

	def finish(self):
		self.axes.plot(self.injected_x, self.injected_y, "k+")
		if not options.made_only:
			self.axes.plot(self.missed_x, self.missed_y, "rx")
		self.axes.set_xlim([min(self.injected_x), max(self.injected_x)])
		self.axes.set_ylim([min(self.injected_y), max(self.injected_y)])
		self.axes.set_title("Injection Amplitude vs. Frequency\n(%d Injections)" % self.num_injections)


class AmplVsFreqContour(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, error):
		SnglBurstUtils.BurstPlot.__init__(self, "Frequency (Hz)", r"$h_{\textrm{rss}}$")
		self.axes.loglog()
		self.instrument = instrument
		self.error = error
		self.num_injections = 0
		self.injected_x = []
		self.injected_y = []
		self.found_x = []
		self.found_y = []

	def add_contents(self, doc):
		self.num_injections += len(doc.sim_rows)
		for sim in doc.sim_rows.itervalues():
			self.injected_x.append(sim.freq)
			self.injected_y.append(sim.hrss)
		for sim in doc.foundsims[self.instrument]:
			self.found_x.append(sim.freq)
			self.found_y.append(sim.hrss)

	def finish(self):
		efficiency = rate.BinnedRatios(rate.Bins(min(self.injected_x), max(self.injected_x), 1024, min(self.injected_y), max(self.injected_y), 512, spacing = ["log", "log"]))
		map(efficiency.incdenominator, zip(self.injected_x, self.injected_y))
		map(efficiency.incnumerator, zip(self.found_x, self.found_y))

		#bins_per_inj = efficiency.used() / float(self.num_injections)
		bins_per_inj = efficiency.numerator.shape[0] * efficiency.numerator.shape[1] / float(self.num_injections)
		window_size = (bins_per_inj / self.error**2)**0.5
		if window_size > 100:
			raise SnglBurstUtils.BurstPlotError, "smoothing filter too large (not enough injections)"
		efficiency.regularize()
		xcoords, ycoords = efficiency.centres()
		if options.made_only:
			zvals = efficiency.denominator
			rate.filter_array(zvals, rate.gaussian_window2d(window_size, window_size))
			cset = self.axes.contour(xcoords, ycoords, numarray.transpose(zvals))
		else:
			zvals = efficiency.ratio()
			rate.filter_array(zvals, rate.gaussian_window2d(window_size, window_size))
			cset = self.axes.contour(xcoords, ycoords, numarray.transpose(zvals), [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
		self.axes.set_title("Injection Detection Efficiency\n(%d Injections, Contours at 10%% Intervals, %g%% Uncertainty)" % (self.num_injections, 100 * self.error))


#
# =============================================================================
#
#                           Trigger Count Histogram
#
# =============================================================================
#

class TriggerCountHistogram(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument):
		SnglBurstUtils.BurstPlot.__init__(self, "Number of Triggers Coincident with Injection", "Count")
		self.axes.semilogy()
		self.instrument = instrument
		self.found = 0
		self.bins = []

	def add_count(self, n):
		while n + 1 >= len(self.bins):
			self.bins.append(0)
		self.bins[n] += 1

	def add_contents(self, doc):
		self.found += len(doc.coinc_rows)
		for row in doc.coinc_rows:
			self.add_count(row.nevents)

	def finish(self):
		self.axes.plot(range(len(self.bins)), self.bins, "ko-")
		self.axes.set_title("Triggers per Found Injection\n(%d Found Injections)" % self.found)


#
# =============================================================================
#
#                       Recovered vs. Injected Amplitude
#
# =============================================================================
#

class RecoveredVsInjectedAmplitude(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument):
		SnglBurstUtils.BurstPlot.__init__(self, r"Injected $h_{\textrm{rss}}$", "Recovered Confidence")
		self.axes.loglog()
		self.fig.set_figsize_inches(16, 16)
		self.instrument = instrument
		self.found = 0
		self.recovered = []
		self.injected = []

	def add_contents(self, doc):
		self.found += len(doc.coinc_rows)
		for coinc in doc.coinc_rows:
			coinc_map = coinc.coinc_event_id
			if coinc_map.coincs:
				# skip multi-instrument detections (must
				# also be a single-instrument detection)
				continue
			confidence = max([-burst.confidence for burst in coinc_map.bursts])
			self.injected.append(coinc_map.sims[0].hrss)
			self.recovered.append(confidence)

	def finish(self):
		self.axes.plot(self.injected, self.recovered, "k+")
		self.axes.set_title("Recovered Amplitude vs. Injected Amplitude\n(%d Found Injections)" % self.found)


#
# =============================================================================
#
#                            Recovered Time Offset
#
# =============================================================================
#

class RecoveredTimeOffset(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, interval, width):
		SnglBurstUtils.BurstPlot.__init__(self, "Offset (s)", "Triggers per Unit Offset")
		self.instrument = instrument
		self.found = 0
		self.offsets = rate.Rate(interval, width)
		self.best = rate.Rate(interval, width)

	def add_contents(self, doc):
		self.found += len(doc.coinc_rows)
		for coinc in doc.coinc_rows:
			coinc_map = coinc.coinc_event_id
			if coinc_map.coincs:
				# skip multi-instrument detections (not
				# what this plot is about)
				continue
			best_conf = 0.0
			best_dt = None
			for burst in coinc_map.bursts:
				dt = burst.get_peak() - coinc_map.sims[0].get_peak(burst.ifo)
				self.offsets[dt] = 1.0
				if math.fabs(burst.confidence) > best_conf:
					best_conf = math.fabs(burst.confidence)
					best_dt = dt
			if best_dt != None:
				self.best[best_dt] = 1.0

	def finish(self):
		self.axes.set_title("Trigger Peak Time - Injection Peak Time\n(%d Found Injections)" % self.found)
		self.axes.plot(self.offsets.xvals(), self.offsets.filtered(), "k")
		self.axes.plot(self.best.xvals(), self.best.filtered(), "r")


#
# =============================================================================
#
#                                     Plot
#
# =============================================================================
#

def new_plots(instrument):
	l = [
		FreqVsTime(instrument),
		AmplVsFreqScatter(instrument),
		AmplVsFreqContour(instrument, 0.1),
		TriggerCountHistogram(instrument),
		RecoveredVsInjectedAmplitude(instrument),
		RecoveredTimeOffset(instrument, segments.segment(-0.25, +0.25), 0.005)
	]
	return l

plots = {}
for n, filename in enumerate(llwapp.sort_files_by_size(filenames, options.verbose, reverse = True)):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	doc = llwapp.load_filename(filename, options.verbose)
	if options.verbose:
		print >>sys.stderr, "indexing..."
	contents = DocContents(doc, "power")
	doc.unlink()
	del doc
	for instrument in contents.instruments:
		if instrument not in plots:
			plots[instrument] = new_plots(instrument)
		for n, plot in enumerate(plots[instrument]):
			if options.verbose:
				print >>sys.stderr, "adding to %s plot %d..." % (instrument, n)
			plot.add_contents(contents)


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

# delete the plots as we go to save memory
for instrument in plots:
	n = 0
	format = "%%s%s_%%0%dd.%%s" % (instrument, int(math.log10(len(plots[instrument]))) + 1)
	while len(plots[instrument]):
		filename = format % (options.base, n, options.format)
		if options.verbose:
			print >>sys.stderr, "finishing %s plot %d..." % (instrument, n)
		try:
			plots[instrument][0].finish()
		except SnglBurstUtils.BurstPlotError, e:
			print >>sys.stderr, "can't finish %s plot %d: %s" % (instrument, n, str(e))
		else:
			if options.verbose:
				print >>sys.stderr, "writing %s..." % filename
			plots[instrument][0].fig.savefig(filename)
		del plots[instrument][0]
		n += 1
