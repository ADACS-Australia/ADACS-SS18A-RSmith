#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import math
from optparse import OptionParser
from pysqlite2 import dbapi2 as sqlite3
import sys


from glue import segments
from glue.ligolw import dbtables
from glue.ligolw import utils
from pylal import rate
from pylal import SimBurstUtils
from pylal import SnglBurstUtils


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("--made-only", action = "store_true", default = False, help = "plot only injections that were made")
	parser.add_option("-b", "--base", metavar = "base", default = "plotbinj_", help = "set the prefix for output filenames (default = plotbinj_)")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("-l", "--live-time-program", metavar = "program", default = "lalapps_power", help = "set the name, as it appears in the process table, of the program whose search summary entries define the search live time (default = lalapps_power)")
	parser.add_option("--plot", metavar = "number", action = "append", default = None, help = "generate the given plot number")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	if options.plot:
		options.plot = map(int, options.plot)
	else:
		options.plot = range(8)


	return options, (filenames or [None])


options, filenames = parse_command_line()


#
# =============================================================================
#
#                              Frequency vs. Time
#
# =============================================================================
#


class FreqVsTime(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument):
		SnglBurstUtils.BurstPlot.__init__(self, "GPS Time (s)", "Frequency (Hz)")
		self.axes.semilogy()
		self.instrument = instrument
		self.num_injections = 0
		self.injected_x = []
		self.injected_y = []
		self.missed_x = []
		self.missed_y = []
		self.seglist = segments.segmentlist()

	def add_contents(self, contents):
		self.num_injections += len(contents.sim_burst_table)
		self.seglist |= contents.seglists[self.instrument]
		for sim in contents.sim_burst_table:
			self.injected_x.append(float(sim.get_geocent_peak()))
			self.injected_y.append(sim.freq)
		if contents.coinc_table is not None:
			for sim in contents.missed_injections(self.instrument):
				self.missed_x.append(float(sim.get_geocent_peak()))
				self.missed_y.append(sim.freq)

	def finish(self):
		self.axes.plot(self.injected_x, self.injected_y, "k+")
		if not options.made_only:
			self.axes.plot(self.missed_x, self.missed_y, "ro")
		for seg in ~self.seglist & segments.segmentlist([segments.segment(self.axes.get_xlim())]):
			self.axes.axvspan(float(seg[0]), float(seg[1]), facecolor = "k", alpha = 0.2)
		self.axes.set_ylim([min(self.injected_y), max(self.injected_y)])
		self.axes.set_title("Injection Locations\n(%d Injections)" % self.num_injections)


#
# =============================================================================
#
#                           Amplitude vs. Frequency
#
# =============================================================================
#


class AmplVsFreqScatter(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument):
		SnglBurstUtils.BurstPlot.__init__(self, "Frequency (Hz)", r"$h_{\mathrm{rss}}$")
		self.axes.loglog()
		self.instrument = instrument
		self.num_injections = 0
		self.injected_x = []
		self.injected_y = []
		self.missed_x = []
		self.missed_y = []

	def add_contents(self, contents):
		self.num_injections += len(contents.sim_burst_table)
		for sim in contents.sim_burst_table:
			self.injected_x.append(sim.freq)
			self.injected_y.append(SimBurstUtils.hrss_in_instrument(sim, self.instrument))
		if contents.coinc_table is not None:
			for sim in contents.missed_injections(self.instrument):
				self.missed_x.append(sim.freq)
				self.missed_y.append(SimBurstUtils.hrss_in_instrument(sim, self.instrument))

	def finish(self):
		self.axes.plot(self.injected_x, self.injected_y, "k+")
		if not options.made_only:
			self.axes.plot(self.missed_x, self.missed_y, "ro")
		self.axes.set_xlim([min(self.injected_x), max(self.injected_x)])
		self.axes.set_ylim([min(self.injected_y), max(self.injected_y)])
		self.axes.set_title("Injection Amplitude vs. Frequency\n(%d Injections)" % self.num_injections)


#
# =============================================================================
#
#                           Trigger Count Histogram
#
# =============================================================================
#


class TriggerCountHistogram(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument):
		SnglBurstUtils.BurstPlot.__init__(self, "Number of Triggers Coincident with Injection", "Count")
		self.axes.semilogy()
		self.instrument = instrument
		self.found = 0
		self.bins = []

	def add_contents(self, contents):
		for nevents, in contents.connection.cursor().execute("""
SELECT nevents FROM
	coinc_event
WHERE
	coinc_def_id == ?
		""", (contents.sb_definer_id,)):
			self.found += 1
			while nevents + 1 >= len(self.bins):
				self.bins.append(0)
			self.bins[nevents] += 1

	def finish(self):
		self.axes.plot(range(len(self.bins)), self.bins, "ko-")
		self.axes.set_title("Triggers per Found Injection\n(%d Found Injections)" % self.found)


#
# =============================================================================
#
#                         Recovered vs. Injected h_rss
#
# =============================================================================
#


class RecoveredVsInjectedhrss(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument):
		SnglBurstUtils.BurstPlot.__init__(self, r"Injected $h_{\mathrm{rss}}$", r"Recovered $h_{\mathrm{rss}}$")
		self.axes.loglog()
		self.fig.set_size_inches(8, 8)
		self.instrument = instrument
		self.found = 0
		self.x = []
		self.y = []

	def add_contents(self, contents):
		for values in contents.connection.cursor().execute("""
SELECT sim_burst.*, sngl_burst.ms_hrss FROM
	sim_burst
	JOIN coinc_event_map AS a ON (
		a.table_name == 'sim_burst'
		AND a.event_id == sim_burst.simulation_id
	)
	JOIN coinc_event_map AS b ON (
		a.coinc_event_id == b.coinc_event_id
	)
	JOIN sngl_burst ON (
		b.table_name == 'sngl_burst'
		AND b.event_id == sngl_burst.event_id
	)
WHERE
	sngl_burst.ifo == ?
		""", (self.instrument,)):
			sim = contents.sim_burst_table._row_from_cols(values[:-1])
			recovered = values[-1]
			self.found += 1
			self.x.append(SimBurstUtils.hrss_in_instrument(sim, self.instrument))
			self.y.append(recovered)

	def finish(self):
		self.axes.plot(self.x, self.y, "k+")
		xmin, xmax = self.axes.get_xlim()
		ymin, ymax = self.axes.get_ylim()
		xmin = ymin = min(xmin, ymin)
		xmax = ymax = max(xmax, ymax)
		self.axes.set_xlim([xmin, xmax])
		self.axes.set_ylim([ymin, ymax])
		self.axes.plot([xmin, xmax], [ymin, ymax], "k-")
		self.axes.set_title(r"Recovered $h_{\mathrm{rss}}$ vs.\ Injected $h_{\mathrm{rss}}$ (%d Found Injections)" % self.found)


class RecoveredPerInjectedhrssVsFreq(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument):
		SnglBurstUtils.BurstPlot.__init__(self, r"$f_{\mathrm{injected}}$", r"$\frac{\mathrm{Recovered}\ h_{\mathrm{rss}}}{\mathrm{Injected}\ h_{\mathrm{rss}}}$")
		self.axes.loglog()
		self.fig.set_size_inches(8, 8)
		self.instrument = instrument
		self.found = 0
		self.x = []
		self.y = []

	def add_contents(self, contents):
		for values in contents.connection.cursor().execute("""
SELECT sim_burst.*, sngl_burst.ms_hrss FROM
	sim_burst
	JOIN coinc_event_map AS a ON (
		a.table_name == 'sim_burst'
		AND a.event_id == sim_burst.simulation_id
	)
	JOIN coinc_event_map AS b ON (
		b.coinc_event_id == a.coinc_event_id
	)
	JOIN sngl_burst ON (
		b.table_name == 'sngl_burst'
		AND b.event_id == sngl_burst.event_id
	)
WHERE
	sngl_burst.ifo == ?
		""", (self.instrument,)):
			sim = contents.sim_burst_table._row_from_cols(values[:-1])
			recovered = values[-1]
			self.found += 1
			self.x.append(sim.freq)
			self.y.append(recovered / SimBurstUtils.hrss_in_instrument(sim, self.instrument))

	def finish(self):
		self.axes.plot(self.x, self.y, "k+")
		self.axes.set_xlim([min(self.x), max(self.x)])
		self.axes.set_title(r"Ratio of Recovered to Injected $h_{\mathrm{rss}}$ vs.\ Frequency (%d Found Injections)" % self.found)


#
# =============================================================================
#
#                            Recovered Time Offset
#
# =============================================================================
#


class RecoveredTimeOffset(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, interval, width):
		SnglBurstUtils.BurstPlot.__init__(self, "Offset (s)", "Triggers per Unit Offset")
		self.instrument = instrument
		self.found = 0
		self.offsets = rate.Rate(interval, width)
		self.best = rate.Rate(interval, width)

	def add_contents(self, contents):
		for coinc in contents.coinc_select_by_def_id(contents.sb_definer_id):
			self.found += 1
			best_conf = 0.0
			best_dt = None
			sim = list(contents.coinc_sim_bursts(coinc))[0]
			for burst in contents.coinc_sngl_bursts(coinc):
				dt = burst.get_peak() - sim.get_peak(burst.ifo)
				try:
					self.offsets[dt] += 1.0
				except IndexError:
					# outside plot range
					pass
				if burst.confidence > best_conf:
					best_conf = burst.confidence
					best_dt = dt
			if best_dt is not None:
				try:
					self.best[best_dt] += 1.0
				except IndexError:
					# outside plot range
					pass

	def finish(self):
		self.axes.set_title("Trigger Peak Time - Injection Peak Time\n(%d Found Injections)" % self.found)
		self.axes.plot(self.offsets.xvals(), self.offsets.filter(), "k")
		self.axes.plot(self.best.xvals(), self.best.filter(), "r")
		self.axes.legend(["All matching triggers", "Highest confidence match"])


#
# =============================================================================
#
#                          Recovered Frequency Offset
#
# =============================================================================
#


class RecoveredFrequencyOffset(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, interval, width):
		SnglBurstUtils.BurstPlot.__init__(self, "Offset (Hz)", "Triggers per Unit Offset")
		self.instrument = instrument
		self.found = 0
		self.offsets = rate.Rate(interval, width)
		self.best = rate.Rate(interval, width)

	def add_contents(self, contents):
		for coinc in contents.coinc_select_by_def_id(contents.sb_definer_id):
			self.found += 1
			best_conf = 0.0
			best_df = None
			sim = list(contents.coinc_sim_bursts(coinc))[0]
			for burst in contents.coinc_sngl_bursts(coinc):
				df = burst.peak_frequency - sim.freq
				try:
					self.offsets[df] += 1.0
				except IndexError:
					# outside plot range
					pass
				if burst.confidence > best_conf:
					best_conf = burst.confidence
					best_df = df
			if best_df is not None:
				try:
					self.best[best_df] += 1.0
				except IndexError:
					# outside plot range
					pass

	def finish(self):
		self.axes.set_title("Trigger Peak Frequency - Injection Centre Frequency\n(%d Found Injections)" % self.found)
		self.axes.plot(self.offsets.xvals(), self.offsets.filter(), "k")
		self.axes.plot(self.best.xvals(), self.best.filter(), "r")
		self.axes.legend(["All matching triggers", "Highest confidence match"])


#
# =============================================================================
#
#                                     Plot
#
# =============================================================================
#


def new_plots(instrument, plots):
	l = [
		FreqVsTime(instrument),
		AmplVsFreqScatter(instrument),
		SimBurstUtils.Efficiency_hrss_vs_freq(instrument, 0.1),
		TriggerCountHistogram(instrument),
		RecoveredVsInjectedhrss(instrument),
		RecoveredPerInjectedhrssVsFreq(instrument),
		RecoveredTimeOffset(instrument, segments.segment(-0.06, +0.06), 0.0003),
		RecoveredFrequencyOffset(instrument, segments.segment(-50.0, +50.0), .5)
	]
	return [l[i] for i in plots]

plots = {}
for n, filename in enumerate(utils.sort_files_by_size(filenames, options.verbose, reverse = True)):
	if options.verbose:
		print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename)
	connection = sqlite3.connect(filename)
	dbtables.DBTable_set_connection(connection)
	database = SnglBurstUtils.CoincDatabase().summarize(dbtables.DBTable_get_xml(), options.live_time_program, options.verbose)
	for instrument in database.instruments:
		if instrument not in plots:
			plots[instrument] = new_plots(instrument, options.plot)
		for n, plot in zip(options.plot, plots[instrument]):
			if options.verbose:
				print >>sys.stderr, "adding to %s plot %d ..." % (instrument, n)
			plot.add_contents(database)
	connection.close()


# delete the plots as we go to save memory
for instrument in plots:
	n = 0
	format = "%%s%s_%%0%dd.%%s" % (instrument, int(math.log10(max(options.plot) or 1)) + 1)
	while len(plots[instrument]):
		filename = format % (options.base, options.plot[n], options.format)
		if options.verbose:
			print >>sys.stderr, "finishing %s plot %d ..." % (instrument, options.plot[n])
		try:
			plots[instrument][0].finish()
		except SnglBurstUtils.BurstPlotError, e:
			print >>sys.stderr, "can't finish %s plot %d: %s" % (instrument, options.plot[n], str(e))
		else:
			if options.verbose:
				print >>sys.stderr, "writing %s ..." % filename
			if isinstance(plots[instrument][0], SimBurstUtils.Efficiency_hrss_vs_freq):
				SimBurstUtils.plot_Efficiency_hrss_vs_freq(plots[instrument][0]).savefig(filename)
			else:
				plots[instrument][0].fig.savefig(filename)
		del plots[instrument][0]
		n += 1
