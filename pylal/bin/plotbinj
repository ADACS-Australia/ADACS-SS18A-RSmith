#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import math
from optparse import OptionParser
import matplotlib
matplotlib.use("Agg")
from matplotlib import figure
from matplotlib.backends.backend_agg import FigureCanvasAgg
import numarray
import sys

from glue import segments
from glue.ligolw import lsctables
from pylal import llwapp
from pylal import rate
from pylal.date import LIGOTimeGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("--made-only", action = "store_true", default = False, help = "plot only injections that were made")
	parser.add_option("-b", "--base", metavar = "base", default = "plotbinj_", help = "set the prefix for output filenames (default = plotbinj_)")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	return options, (filenames or [None])

try:
	options, filenames = parse_command_line()
except ValueError, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

class SnglBurst(object):
	__slots__ = ["ifo", "confidence", "peak_time", "peak_time_ns", "event_id"]

	def get_peak(self):
		return LIGOTimeGPS(self.peak_time, self.peak_time_ns)

def snglburst_init(self, attrs):
	lsctables.LSCTableUnique.__init__(self, attrs)
	self.rows = {}

def snglburst_append(self, row):
	self.rows[lsctables.ILWDID(row.event_id)] = row
	del row.event_id

def simburst_init(self, attrs):
	lsctables.LSCTableUnique.__init__(self, attrs)
	self.rows = {}

def simburst_append(self, row):
	self.rows[lsctables.ILWDID(row.simulation_id)] = row
	del row.simulation_id

def coinc_map_init(self, attrs):
	lsctables.LSCTableUnique.__init__(self, attrs)
	self.rows = {}

def coinc_map_append(self, row):
	id = lsctables.ILWDID(row.coinc_event_id)
	if id not in self.rows:
		self.rows[id] = ([], [])
	if "sim_burst" in row.event_id:
		self.rows[id][0].append(lsctables.ILWDID(row.event_id))
	else:
		# sngl_burst
		self.rows[id][1].append(lsctables.ILWDID(row.event_id))

lsctables.SnglBurstTable.RowType = SnglBurst
lsctables.SnglBurstTable.__init__ = snglburst_init
lsctables.SnglBurstTable.append = snglburst_append
lsctables.SimBurstTable.__init__ = simburst_init
lsctables.SimBurstTable.append = simburst_append
lsctables.CoincMapTable.__init__ = coinc_map_init
lsctables.CoincMapTable.append = coinc_map_append


#
# =============================================================================
#
#                            Document Comprehension
#
# =============================================================================
#

class DocContents(object):
	def __init__(self, xmldoc, live_time_program):
		#
		# Extract tables
		#

		self.bursttable = llwapp.get_table(xmldoc, lsctables.SnglBurstTable.tableName)
		self.simtable = llwapp.get_table(xmldoc, lsctables.SimBurstTable.tableName)
		self.coinctable = llwapp.get_table(xmldoc, lsctables.CoincTable.tableName)
		self.coincmaptable = llwapp.get_table(xmldoc, lsctables.CoincMapTable.tableName)

		#
		# Extract segmentlist
		#

		seglistdict = llwapp.get_seglistdict(xmldoc, live_time_program)
		self.seglist = seglistdict.intersect(seglistdict.keys())

		#
		# Found and missed injection IDs
		#

		foundsimids = [row[0][0] for row in self.coincmaptable.rows.itervalues()]
		foundsimids.sort()
		self.missedsims = [id for id in self.simtable.rows.iterkeys() if not llwapp.bisect_contains(foundsimids, id)]
		self.missedsims.sort()
		self.missedsims = map(self.simtable.rows.__getitem__, self.missedsims)

		#
		# Build coinc_event_map --> sngl_burst and sim_burst
		# references
		#

		for key, value in self.coincmaptable.rows.iteritems():
			self.coincmaptable.rows[key] = (map(self.simtable.rows.__getitem__, value[0]), map(self.bursttable.rows.__getitem__, value[1]))


#
# =============================================================================
#
#                              Frequency vs. Time
#
# =============================================================================
#

class FreqVsTime(object):
	def __init__(self):
		self.num_injections = 0
		self.injected_x = []
		self.injected_y = []
		self.missed_x = []
		self.missed_y = []
		self.seglist = segments.segmentlist()
		self.fig = figure.Figure()
		FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16, 8)
		self.axes = self.fig.gca()
		self.axes.semilogy()
		self.axes.grid(True)
		self.axes.set_xlabel("GPS Time (s)")
		self.axes.set_ylabel("Frequency (Hz)")

	def add_contents(self, doc):
		self.num_injections += len(doc.simtable)
		for sim in doc.simtable.rows.itervalues():
			self.injected_x.append(float(sim.get_geocent_peak()))
			self.injected_y.append(sim.freq)
		for sim in doc.missedsims:
			self.missed_x.append(float(sim.get_geocent_peak()))
			self.missed_y.append(sim.freq)
		self.seglist |= doc.seglist

	def finish(self):
		self.axes.plot(self.injected_x, self.injected_y, "k+")
		if not options.made_only:
			self.axes.plot(self.missed_x, self.missed_y, "rx")
		for seg in ~self.seglist & segments.segmentlist([segments.segment(self.axes.get_xlim())]):
			self.axes.axvspan(seg[0], seg[1], facecolor = "k", alpha = 0.2)
		self.axes.set_title("Injection Locations\n(%d Injections)" % self.num_injections)


#
# =============================================================================
#
#                           Amplitude vs. Frequency
#
# =============================================================================
#

class AmplVsFreqScatter(object):
	def __init__(self):
		self.num_injections = 0
		self.injected_x = []
		self.injected_y = []
		self.missed_x = []
		self.missed_y = []
		self.fig = figure.Figure()
		FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16, 8)
		self.axes = self.fig.gca()
		self.axes.loglog()
		self.axes.grid(True)
		self.axes.set_xlabel("Frequency (Hz)")
		self.axes.set_ylabel("h_rss")

	def add_contents(self, doc):
		self.num_injections += len(doc.simtable)
		for sim in doc.simtable.rows.itervalues():
			self.injected_x.append(sim.freq)
			self.injected_y.append(sim.hrss)
		for sim in doc.missedsims:
			self.missed_x.append(sim.freq)
			self.missed_y.append(sim.hrss)

	def finish(self):
		self.axes.plot(self.injected_x, self.injected_y, "k+")
		if not options.made_only:
			self.axes.plot(self.missed_x, self.missed_y, "rx")
		self.axes.set_title("Injection Amplitude vs. Frequency\n(%d Injections)" % self.num_injections)


class AmplVsFreqContour(object):
	def __init__(self):
		self.num_injections = 0
		self.fig = figure.Figure()
		FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16, 8)
		self.axes = self.fig.gca()
		self.madevsfound = rate.BinnedRatios(rate.Bins(70.0, 2118.0, 512, 10**-22.2, 10**-18.0, 512, spacing = ["log", "log"]))
		self.axes.loglog()
		self.axes.grid(True)
		self.axes.set_xlabel("Frequency (Hz)")
		self.axes.set_ylabel("h_rss")

	def add_contents(self, doc):
		self.num_injections += len(doc.simtable)
		for sim in doc.simtable.rows.itervalues():
			self.madevsfound.incdenominator((sim.freq, sim.hrss))
		for sims, bursts in doc.coincmaptable.rows.itervalues():
			self.madevsfound.incnumerator((sims[0].freq, sims[0].hrss))

	def finish(self):
		rate.filter_ratios(self.madevsfound, rate.gaussian_window2d(8, 8))
		self.madevsfound.regularize()
		xcoords, ycoords = self.madevsfound.centres()
		if options.made_only:
			cset = self.axes.contour(xcoords, ycoords, numarray.transpose(self.madevsfound.denominator))
		else:
			cset = self.axes.contour(xcoords, ycoords, numarray.transpose(self.madevsfound.ratio()), [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])
		self.axes.set_title("Injection Amplitude vs. Frequency\n(%d Injections)" % self.num_injections)


#
# =============================================================================
#
#                           Trigger Count Histogram
#
# =============================================================================
#

class TriggerCountHistogram(object):
	def __init__(self):
		self.found = 0
		self.bins = []
		self.fig = figure.Figure()
		FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16, 8)
		self.axes = self.fig.gca()
		self.axes.semilogy()
		self.axes.grid(True)
		self.axes.set_xlabel("Number of Triggers Coincident with Injection")
		self.axes.set_ylabel("Count")

	def add_count(self, n):
		while n + 1 >= len(self.bins):
			self.bins.append(0)
		self.bins[n] += 1

	def add_contents(self, doc):
		self.found += len(doc.coinctable)
		map(self.add_count, doc.coinctable.getColumnByName("nevents"))

	def finish(self):
		self.axes.plot(range(len(self.bins)), self.bins, "ko-")
		self.axes.set_title("Triggers per Found Injection\n(%d Found Injections)" % self.found)


#
# =============================================================================
#
#                       Recovered vs. Injected Amplitude
#
# =============================================================================
#

class RecoveredVsInjectedAmplitude(object):
	def __init__(self):
		self.found = 0
		self.recovered = []
		self.injected = []
		self.fig = figure.Figure()
		FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16, 16)
		self.axes = self.fig.gca()
		self.axes.loglog()
		self.axes.grid(True)
		self.axes.set_xlabel("Injected h_rss")
		self.axes.set_ylabel("Recovered Confidence")

	def add_contents(self, doc):
		self.found += len(doc.coinctable)
		for sims, bursts in doc.coincmaptable.rows.itervalues():
			confidence = max([math.fabs(burst.confidence) for burst in bursts])
			self.injected.append(sims[0].hrss)
			self.recovered.append(confidence)

	def finish(self):
		self.axes.plot(self.injected, self.recovered, "k+")
		self.axes.set_title("Recovered Amplitude vs. Injected Amplitude\n(%d Found Injections)" % self.found)


#
# =============================================================================
#
#                            Recovered Time Offset
#
# =============================================================================
#

class RecoveredTimeOffset(object):
	def __init__(self, interval, width):
		self.found = 0
		self.offsets = rate.Rate(interval, width)
		self.best = rate.Rate(interval, width)
		self.fig = figure.Figure()
		FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16, 8)
		self.axes = self.fig.gca()
		self.axes.grid(True)
		self.axes.set_xlabel("Offset (s)")
		self.axes.set_ylabel("Triggers per Unit Offset")

	def add_contents(self, doc):
		self.found += len(doc.coinctable)
		for sims, bursts in doc.coincmaptable.rows.itervalues():
			conf = 0.0
			for burst in bursts:
				dt = burst.get_peak() - sims[0].get_peak(burst.ifo)
				self.offsets[dt] = 1.0
				if math.fabs(burst.confidence) > conf:
					best_dt = dt
			self.best[dt] = 1.0

	def finish(self):
		self.axes.set_title("Trigger Peak Time - Injection Peak Time\n(%d Found Injections)" % self.found)
		self.offsets.filter()
		self.best.filter()
		self.axes.plot(self.offsets.xvals(), self.offsets.yvals(), "k")
		self.axes.plot(self.best.xvals(), self.best.yvals(), "r")


#
# =============================================================================
#
#                                     Plot
#
# =============================================================================
#

plots = [
	FreqVsTime(),
	AmplVsFreqScatter(),
	AmplVsFreqContour(),
	TriggerCountHistogram(),
	RecoveredVsInjectedAmplitude(),
	RecoveredTimeOffset(segments.segment(-0.25, +0.25), 0.005)
]

try:
	for n, filename in enumerate(llwapp.sort_files(filenames, options.verbose)):
		if options.verbose:
			print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
		doc = llwapp.load_filename(filename, options.verbose)
		if options.verbose:
			print >>sys.stderr, "indexing..."
		contents = DocContents(doc, "power")
		for n, plot in enumerate(plots):
			if options.verbose:
				print >>sys.stderr, "adding to %d..." % n
			plot.add_contents(contents)
		doc.unlink()
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

# delete the plots as we go to save memory
n = 0
format = "%%s%%0%dd.%%s" % (int(math.log10(len(plots))) + 1)
while len(plots):
	filename = format % (options.base, n, options.format)
	if options.verbose:
		print >>sys.stderr, "finishing plot %d..." % n
	plots[0].finish()
	if options.verbose:
		print >>sys.stderr, "writing %s..." % filename
	plots[0].fig.savefig(filename)
	del plots[0]
	n += 1
