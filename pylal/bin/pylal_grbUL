#!/usr/bin/env python
#
# Copyright (C) 2008  Nickolas Fotopoulos
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
"""
This code computes the probabilities that go into the distance upper limits
for the CBC external trigger search.

There is a lot of advanced indexing technique here.  Reference:
http://scipy.org/Cookbook/Indexing
"""

from __future__ import division

__author__ = "Nickolas Fotopoulos <nvf@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"
__Id__ = "$Id$"
__prog__ = "pylal_grbUL"
__title__ = "GRB interpretation"

import cPickle as pickle
import optparse
import sys

import numpy
from scipy import stats
import matplotlib
matplotlib.use("Agg")
import pylab
from pylal import InspiralUtils
from pylal import plotutils
from pylal import rate
from pylal import viz

# override pylab defaults, optimizing for web presentation
pylab.rcParams.update({
    "text.usetex": True,
    "text.verticalalignment": "center",
    "lines.linewidth": 2.5,
    "font.size": 16,
    "axes.titlesize": 20,
    "axes.labelsize": 16,
    "xtick.labelsize": 16,
    "ytick.labelsize": 16,
    "legend.fontsize": 16,
})

def get_level_crossings(xy_array, level, y_bins):
    """
    Return the linearly interpolated y values where the xy_array dips first
    dips below level, iterating upwards.
    """
    # sanity checks
    if xy_array.ndim != 2:
        raise ValueError, "require a two-dimensional xy_array"
    if xy_array.shape[1] != len(y_bins):
        raise ValueError, "xy_array y-dimension does not match y_bin length"

    def _first_below_val(column, target):
        """
        Return the index of the first entry that is less than target.
        If no entry is less than the target, return the length of the column.
        """
        for i, val in enumerate(column):
            if val < target:
                return i
        return len(column)

    def _interp_column(column, level, y_vals, min_y=0, max_y=None):
        """
        Return the linearly interpolated value of y where the column first
        dips below level.
        """
        if max_y is None:
            max_y = y_vals[-1]
        ind = _first_below_val(column, level)
        if ind == 0:
            return min_y
        elif ind == len(column):
            return max_y
        else:
            # interpolate between ind-1 and ind
            slope = (y_vals[ind] - y_vals[ind-1]) / \
                    (column[ind] - column[ind-1])
            return y_vals[ind-1] + (level - column[ind-1]) * slope

    y_vals = y_bins.centres()
    return numpy.array([_interp_column(col, level, y_vals, min_y=0,
                                       max_y=y_bins.max) \
                        for col in xy_array])

def parse_args():
    parser = optparse.OptionParser(version="%prog CVS $Id$ ")

    # input
    parser.add_option("--relic-onsource", help="output of pylal_relic "\
        "containing the onsource loudest coincs")
    parser.add_option("--relic-offsource", help="output of pylal_relic "\
        "containing the offsource loudest coincs")
    parser.add_option("--relic-injections", help="output of pylal_relic "\
        "containing the loudest injection coincs")
    parser.add_option("--grblikelihood-onsource",
        help="On-source output pickle from pylal_grblikelihood")
    parser.add_option("--grblikelihood-offsource",
        help="Off-source output pickle from pylal_grblikelihood")
    parser.add_option("--grblikelihood-injections",
        help="Injection output pickle from pylal_grblikelihood")

    # InspiralUtils compatibility
    parser.add_option("--gps-start-time", type="int",
        help="GPS start time of data analyzed")
    parser.add_option("--gps-end-time", type="int",
        help="GPS end time of data analyzed")
    parser.add_option("--ifo-tag", help="IFO coincidence time analyzed")
    parser.add_option("--user-tag", help="a tag to label your plots")
    parser.add_option("--output-path", help="root of the HTML output")
    parser.add_option("--enable-output", action="store_true",
        default=False, help="enable plots and HTML output")
    parser.add_option("--html-for-cbcweb", action="store_true",
        default=False, help="enable HTML output with the appropriate headers "
        "for the CBC website")
    parser.add_option("--show-plot", action="store_true", default=False,
        help="display the plots to screen if an X11 display is available")

    # Calibration uncertainty
    parser.add_option("--h1-calibration-uncertainty", metavar="FAC",
        type="float", default=0.,
        help="fractional uncertainty in the DC calibration of "
        "H1; rescale distances by (1 +/- max(FAC))*D")
    parser.add_option("--h2-calibration-uncertainty", metavar="FAC",
        type="float", default=0.,
        help="fractional uncertainty in the DC calibration of "
        "H2; rescale distances by (1 +/- max(FAC))*D")
    parser.add_option("--l1-calibration-uncertainty", metavar="FAC",
        type="float", default=0.,
        help="fractional uncertainty in the DC calibration of "
        "L1; rescale distances by (1 +/- max(FAC))*D")

    parser.add_option("--verbose", action="store_true", default=False,
        help="extra information to the console")

    return parser.parse_args()

################################################################################
# parse arguments
opts, args = parse_args()

##############################################################################
# HTML initialization
InspiralUtils.initialise(opts, __prog__, __version__)
html_footer = ""

##############################################################################
# Read input

if opts.verbose:
    print "Reading in bin definitions and loudest statistics..."
statistic, mc_bins, onsource_loudest_by_mc \
    = pickle.load(open(opts.relic_onsource))
statistic, mc_bins, offsource_loudest_by_trial_mc \
    = pickle.load(open(opts.relic_offsource))
statistic, mc_bins, m2_bins, D_bins, m2_D_by_inj, inj_loudest_by_inj_mc \
    = pickle.load(open(opts.relic_injections))
if statistic != "effective_snr":
    raise NotImplemented

log_pc0_by_mc, log_pch_by_mc_m2, actual_candidate_mask, log_L_by_m2 = \
    pickle.load(open(opts.grblikelihood_onsource))
offsource_pc0_by_trial_mc, offsource_pch_by_trial_mc_m2, \
    offsource_likelihood_by_trial_m2 = \
    pickle.load(open(opts.grblikelihood_offsource))
inj_likelihood_by_trial_m2, log_pc0_by_inj_mc, log_pch_by_inj_mc, \
    rho_by_inj_mc, trace_m2_bin = \
    pickle.load(open(opts.grblikelihood_injections))

m2_D_bins = rate.NDBins((m2_bins, D_bins))
num_sims_by_m2_D = rate.BinnedArray(m2_D_bins)
for m2_D in m2_D_by_inj:
    num_sims_by_m2_D[m2_D] += 1
num_sims_by_m2_D = num_sims_by_m2_D.array

##############################################################################
# Compute P(L > L_obs | h)

inj_louder_count_by_m2_D = numpy.zeros((len(m2_bins), len(D_bins)), dtype=int)
for inj_likelihood_by_m2, m2_D in zip(inj_likelihood_by_trial_m2, m2_D_by_inj):
    m2_ind, D_ind = m2_D_bins[m2_D]
    if inj_likelihood_by_m2[m2_ind] > log_L_by_m2[m2_ind]:
        inj_louder_count_by_m2_D[m2_ind, D_ind] += 1
pLh_by_m2_D = inj_louder_count_by_m2_D / (num_sims_by_m2_D + 1e-10)

##############################################################################
# Take MC errors into account
MC_sigma = numpy.sqrt(pLh_by_m2_D * (1 - pLh_by_m2_D) / num_sims_by_m2_D)

##############################################################################
# Take calibration systematics into account by rescaling D bins
# NB: Does not check what IFOs participated in the GRB search
calib_fac = 1 + max((opts.h1_calibration_uncertainty,
                     opts.h2_calibration_uncertainty,
                     opts.l1_calibration_uncertainty))
D_bins.min /= calib_fac
D_bins.max /= calib_fac
D_bins.delta /= calib_fac

################################################################################
# plots
fnameList = []
tagList = []

## upper limit contours (m2, D) image
text = "(m2, D) contours including MC error"

plot = plotutils.FillPlot(r"$m_2\ (M_\odot)$", r"$D\ \mathrm{(Mpc)}$",
    r"$D\textrm{ at which we see something louder in X\% of trials}$")

exclusion_x = m2_bins.lower()
zero = numpy.zeros(len(m2_bins), dtype=float)

for exclusion_level in (0.25, 0.5, 0.75, 0.9):
    num_sigmas = stats.norm.ppf(exclusion_level)
    exclusion_y = get_level_crossings(pLh_by_m2_D - num_sigmas * MC_sigma,
        exclusion_level, D_bins)
    tmpx, tmpy = viz.makesteps(exclusion_x, zero, exclusion_y)
    plot.add_content(tmpx, tmpy,
        label=str(int(exclusion_level * 100)) + r"\%")

plot.finalize()
plot.ax.set_ylim((0, D_bins.max))

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "exclusion_by_m2_D")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

#############################################################################
# Generate HTML and cache file
if opts.enable_output:
    html_filename = InspiralUtils.write_html_output(opts, sys.argv[1:],
        fnameList, tagList, comment=html_footer)
    InspiralUtils.write_cache_output(opts, html_filename, fnameList)

    if opts.html_for_cbcweb:
        html_filename_publish = InspiralUtils.write_html_output(opts,
            sys.argv[1:], fnameList, tagList, comment=html_footer, cbcweb=True)

if opts.show_plot:
    pylab.show()
