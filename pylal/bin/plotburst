#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import math
from optparse import OptionParser
import numarray
import sys

from glue import segments
from glue.ligolw import lsctables
from pylal import date
from pylal import llwapp
from pylal import rate
from pylal import SnglBurstUtils
from pylal import viz

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("-b", "--base", metavar = "base", default = "plotburst_", help = "set the prefix for output filenames (default = plotburst_)")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("--scalable-only", action = "store_true", help = "only generate plots that scale well with the number of triggers")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	return options, (filenames or [None])

try:
	options, filenames = parse_command_line()
except ValueError, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

class SnglBurst(object):
	__slots__ = ["ifo", "start_time", "start_time_ns", "duration", "central_freq", "bandwidth", "snr", "confidence", "peak_time", "peak_time_ns"]

	def get_start(self):
		return date.LIGOTimeGPS(self.start_time, self.start_time_ns)

	def get_peak(self):
		return date.LIGOTimeGPS(self.peak_time, self.peak_time_ns)

lsctables.SnglBurstTable.RowType = SnglBurst


#
# =============================================================================
#
#                            Document Comprehension
#
# =============================================================================
#

class DocContents(object):
	"""
	A wrapper interface to the XML document.
	"""
	def __init__(self, xmldoc, live_time_program):
		#
		# Extract segmentlist
		#

		self.seglists = llwapp.segmentlistdict_fromsearchsummary(xmldoc, live_time_program)
		self.ifos = self.seglists.keys()

		#
		# Extract columns
		#

		self.nevents = {}
		self.start_time = {}
		self.duration = {}
		self.peak_time = {}
		self.central_freq = {}
		self.bandwidth = {}
		self.lo_freq = {}
		self.snr = {}
		self.confidence = {}
		for ifo in self.ifos:
			self.nevents[ifo] = 0
			self.start_time[ifo] = []
			self.duration[ifo] = []
			self.peak_time[ifo] = []
			self.central_freq[ifo] = []
			self.bandwidth[ifo] = []
			self.lo_freq[ifo] = []
			self.snr[ifo] = []
			self.confidence[ifo] = []
		for event in llwapp.get_table(xmldoc, lsctables.SnglBurstTable.tableName):
			self.nevents[ifo] += 1
			self.start_time[event.ifo].append(event.get_start())
			self.duration[event.ifo].append(event.duration)
			self.peak_time[event.ifo].append(event.get_peak())
			self.central_freq[event.ifo].append(event.central_freq)
			self.bandwidth[event.ifo].append(event.bandwidth)
			self.lo_freq[event.ifo].append(event.central_freq - event.bandwidth / 2.0)
			self.snr[event.ifo].append(event.snr)
			self.confidence[event.ifo].append(event.confidence)


#
# =============================================================================
#
#                             Confidence vs. Time
#
# =============================================================================
#

class ConfidenceVsTime(SnglBurstUtils.BurstPlot):
	def __init__(self, ifo):
		SnglBurstUtils.BurstPlot.__init__(self, "GPS Time (s)", "Confidence")
		self.ifo = ifo
		self.x = []
		self.y = []
		self.seglist = segments.segmentlist()
		self.axes.semilogy()

	def add_contents(self, doc):
		self.nevents += doc.nevents[self.ifo]
		self.x.extend(doc.peak_time[self.ifo])
		self.y.extend(doc.confidence[self.ifo])
		try:
			self.seglist |= doc.seglists[self.ifo]
		except KeyError:
			pass

	def finish(self):
		self.axes.set_title("Trigger Confidence vs. Time\n(%d Triggers)" % self.nevents)
		self.axes.plot(self.x, self.y, "k+")
		for seg in ~self.seglist & segments.segmentlist([segments.segment(self.axes.get_xlim())]):
			self.axes.axvspan(seg[0], seg[1], facecolor = "k", alpha = 0.2)


#
# =============================================================================
#
#                       Confidence vs. Central Frequency
#
# =============================================================================
#

class ConfidenceVsFrequencyScatter(SnglBurstUtils.BurstPlot):
	def __init__(self, ifo):
		SnglBurstUtils.BurstPlot.__init__(self, "Central Frequency (Hz)", "Confidence")
		self.ifo = ifo
		self.x = []
		self.y = []
		self.axes.semilogy()

	def add_contents(self, doc):
		self.nevents += doc.nevents[self.ifo]
		self.x.extend(doc.central_freq[self.ifo])
		self.y.extend(doc.confidence[self.ifo])

	def finish(self):
		self.axes.set_title("Trigger Confidence vs. Central Frequency\n(%d Triggers)" % self.nevents)
		self.axes.plot(self.x, self.y, "k+")
		self.axes.set_xlim([min(self.x), max(self.x)])


#
# =============================================================================
#
#                          Rate vs. Central Frequency
#
# =============================================================================
#

class RateVsCentralFreq(SnglBurstUtils.BurstPlot):
	def __init__(self, ifo, interval, width):
		SnglBurstUtils.BurstPlot.__init__(self, "Central Frequency (Hz)", "Trigger Rate Spectral Density (triggers / s / Hz)")
		self.ifo = ifo
		self.rate = rate.Rate(interval, width)

	def add_contents(self, doc):
		self.nevents += doc.nevents[self.ifo]
		for f in doc.central_freq[self.ifo]:
			self.rate[f] = 1.0

	def finish(self):
		self.axes.set_title("Trigger Rate vs. Central Frequency\n(%d Triggers)" % self.nevents)
		self.rate.filter()
		xvals = self.rate.xvals()
		self.axes.plot(xvals, self.rate.yvals(), "k")
		self.axes.set_xlim([min(xvals), max(xvals)])


#
# =============================================================================
#
#                          Trigger Duration Histogram
#
# =============================================================================
#

class Durations(SnglBurstUtils.BurstPlot):
	def __init__(self, ifo):
		SnglBurstUtils.BurstPlot.__init__(self, "Duration (s)", "Trigger Count")
		self.ifo = ifo
		self.bins = {}

	def add_contents(self, doc):
		self.nevents += doc.nevents[self.ifo]
		for dt in doc.duration[self.ifo]:
			if dt in self.bins:
				self.bins[dt] += 1
			else:
				self.bins[dt] = 1

	def finish(self):
		self.axes.set_title("Trigger Durations\n(%d Triggers)" % self.nevents)
		data = zip(self.bins.keys(), self.bins.values())
		data.sort()
		self.axes.plot([d[0] for d in data], [d[1] for d in data], "ko-")


#
# =============================================================================
#
#                       Time Between Triggers Histogram
#
# =============================================================================
#

class Delays(SnglBurstUtils.BurstPlot):
	def __init__(self, ifo, width):
		SnglBurstUtils.BurstPlot.__init__(self, "Delay (s)", "Count / Delay")
		self.ifo = ifo
		self.data = {}
		self.width = width
		self.axes.semilogy()

	def add_contents(self, doc):
		self.nevents += doc.nevents[self.ifo]
		peaks = list(doc.peak_time[self.ifo])
		peaks.sort()
		for i in xrange(1, len(peaks)):
			dt = float(peaks[i] - peaks[i - 1])
			if dt in self.data:
				self.data[dt] += 1
			else:
				self.data[dt] = 1

	def finish(self):
		self.axes.set_title("Time Between Triggers\n(%d Triggers)" % self.nevents)
		data = zip(self.data.keys(), self.data.values())
		data.sort()
		self.axes.plot([d[0] for d in data], [d[1] for d in data], "ko-")

		max_delay = max(self.data.iterkeys())
		bins = rate.Rate(segments.segment(0, max_delay + 2), self.width)
		for key, value in self.data.iteritems():
			bins[key] = value
		bins.filter()
		self.axes.plot(bins.xvals(), bins.yvals(), "k")

		self.axes.set_xlim([0, max_delay + 2])
		self.axes.set_ylim([1e0, 1e7])


#
# =============================================================================
#
#                                 Rate vs. SNR
#
# =============================================================================
#

class RateVsSNR(SnglBurstUtils.BurstPlot):
	def __init__(self, ifo):
		SnglBurstUtils.BurstPlot.__init__(self, "SNR", "Trigger Rate (Hz)")
		self.ifo = ifo
		self.x = []
		self.seglist = segments.segmentlist()
		self.axes.loglog()

	def add_contents(self, doc):
		self.nevents += doc.nevents[self.ifo]
		self.x.extend(doc.snr[self.ifo])
		try:
			self.seglist |= doc.seglists[self.ifo]
		except KeyError:
			pass

	def finish(self):
		self.axes.set_title("Cummulative Trigger Rate vs. SNR\n(%d Triggers)" % self.nevents)
		self.x.sort()
		self.y = numarray.arange(len(self.x), 0.0, -1.0) / float(self.seglist.duration())
		self.axes.plot(self.x, self.y, "ko-")


#
# =============================================================================
#
#                             Rate vs. Confidence
#
# =============================================================================
#

class RateVsConfidence(SnglBurstUtils.BurstPlot):
	def __init__(self, ifo):
		SnglBurstUtils.BurstPlot.__init__(self, "Confidence", "Trigger Rate (Hz)")
		self.ifo = ifo
		self.x = []
		self.seglist = segments.segmentlist()
		self.axes.loglog()

	def add_contents(self, doc):
		self.nevents += doc.nevents[self.ifo]
		self.x.extend(doc.confidence[self.ifo])
		try:
			self.seglist |= doc.seglists[self.ifo]
		except KeyError:
			pass

	def finish(self):
		self.axes.set_title("Cummulative Trigger Rate vs. Confidence\n(%d Triggers)" % self.nevents)
		self.x.sort()
		self.y = numarray.arange(len(self.x), 0.0, -1.0) / float(self.seglist.duration())
		self.axes.plot(self.x, self.y, "ko-")


#
# =============================================================================
#
#                             Time-Frequency Plane
#
# =============================================================================
#

class TimeFrequencyPlane(SnglBurstUtils.BurstPlot):
	def __init__(self, ifo):
		SnglBurstUtils.BurstPlot.__init__(self, "GPS Time (s)", "Frequency (Hz)")
		self.ifo = ifo
		self.x = []
		self.seglist = segments.segmentlist()

	def add_contents(self, doc):
		self.nevents += doc.nevents[self.ifo]
		viz.tfplot(doc.start_time[self.ifo], doc.duration[self.ifo], doc.lo_freq[self.ifo], doc.bandwidth[self.ifo], numarray.log(numarray.array(doc.confidence[self.ifo])), axes = self.axes)
		try:
			self.seglist |= doc.seglists[self.ifo]
		except KeyError:
			pass

	def finish(self):
		self.axes.set_title("Time-Frequency Plane\n(%d Triggers)" % self.nevents)
		for seg in ~self.seglist & segments.segmentlist([segments.segment(self.axes.get_xlim())]):
			self.axes.axvspan(seg[0], seg[1], facecolor = "k", alpha = 0.2)


#
# =============================================================================
#
#                                     Plot
#
# =============================================================================
#

def new_plots(ifo, scalable_only = False):
	plots = [
		RateVsCentralFreq(ifo, segments.segment(70, 2118), 5),
		Durations(ifo),
		Delays(ifo, 0.125),
		RateVsSNR(ifo),
		RateVsConfidence(ifo),
	]
	if not scalable_only:
		plots += [
			ConfidenceVsTime(ifo),
			ConfidenceVsFrequencyScatter(ifo)
			#TimeFrequencyPlane(ifo)
		]
	return plots

plots = {}
for n, filename in enumerate(llwapp.sort_files_by_size(filenames, options.verbose, reverse = True)):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	doc = llwapp.load_filename(filename, options.verbose)
	if options.verbose:
		print >>sys.stderr, "indexing..."
	contents = DocContents(doc, "power")
	for ifo in contents.ifos:
		if ifo not in plots:
			plots[ifo] = new_plots(ifo, options.scalable_only)
		for n, plot in enumerate(plots[ifo]):
			if options.verbose:
				print >>sys.stderr, "adding to %s plot %d..." % (ifo, n)
			plot.add_contents(contents)
	doc.unlink()


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

# delete the plots as we go to save memory
for ifo in plots:
	n = 0
	format = "%%s%s_%%0%dd.%%s" % (ifo, int(math.log10(len(plots[ifo]))) + 1)
	while len(plots[ifo]):
		filename = format % (options.base, n, options.format)
		if options.verbose:
			print >>sys.stderr, "finishing plot %d..." % n
		plots[ifo][0].finish()
		if options.verbose:
			print >>sys.stderr, "writing %s..." % filename
		plots[ifo][0].fig.savefig(filename)
		del plots[ifo][0]
		n += 1
