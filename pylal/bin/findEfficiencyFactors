#!/usr/bin/python
__author__ = "Ruslan Vaulin <vaulin@gravity.phys.uwm.edu>"
__name__="findEfficiencyFactors"

#loading standard modules
from optparse import *
import glob
import sys
import cPickle
#loading modules used for input/output of data 
from glue import lal
from glue.ligolw import lsctables
from pylal import git_version
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils
from pylal import SimInspiralUtils
from pylal import InspiralUtils
from glue.ligolw import ligolw
from pylal import SearchSummaryUtils
from glue.ligolw import utils
from pylal import llwapp
from glue import segments
from pylal import date
from pylal.xlal.datatypes.ligotimegps import LIGOTimeGPS
from glue.ligolw.utils import segments as glsegments

################################################################################
# Main program
################################################################################
usage= """
usage: %prog [options]

This code calculates detection weighting factors for likelihood ratio.
"""
###############################################################################
# Options to read in Input
###############################################################################
def parse_command_line():

  """
  Parser function dedicated
  """

  parser = OptionParser(usage=usage, version=git_version.verbose_msg)
	
  parser.add_option("","--found-injection-glob",action="store",type="string",\
      default=None, metavar=" GLOB",help="GLOB thinca files with found injections to read" )
	
  parser.add_option("","--missed-injection-glob",action="store",type="string",\
      default=None, metavar=" GLOB",help="GLOB thinca files with missed injections to read" )

  parser.add_option("","--input-cache-file",action="store",type="string",\
      default=None, metavar="ZEROLAGCACHEFILE",help="name of the cache file including the path" )

  parser.add_option("","--found-injection-pattern",\
      default="", metavar="INJSPATTERN", help="the found injections files pattern the cache file, specified by --input-cache-file option, will be seived with.")

  parser.add_option("","--missed-injection-pattern",\
      default="", metavar="INJSPATTERN", help="the missed injections files pattern the cache file, specified by --input-cache-file option, will be seived with.")

# Options to select ifo types.

  parser.add_option("", "--h1-triggers",action="store_true", default=False,\
      help="input files contain triggers from H1")

  parser.add_option("", "--h2-triggers",action="store_true", default=False,\
      help="input files contain triggers from H2")

  parser.add_option("", "--l1-triggers",action="store_true", default=False,\
      help="input files contain triggers from L1")

  parser.add_option("", "--g1-triggers",action="store_true", default=False,\
      help="input files contain triggers from G1")

  parser.add_option("", "--v1-triggers",action="store_true", default=False,\
      help="input files contain triggers from V1")

  parser.add_option("","--statistic",action="store",default='snr',\
      type="string",\
      help="choice of statistic used in building coinc table, valid arguments are: snr (DEFAULT), snr_over_chi, s3_snr_chi_stat, effective_snr, bitten_l, bitten_lsq")
	  
  parser.add_option("","--veto-file",action="store",type="string",\
      default=None,metavar=" FNAME",\
      help="veto file for all IFOS (format ligolw_segments)")
	  
  parser.add_option("","--output-file",action="store",type="string",\
      default="stat", help="output file to store Detection Factors" )
	  
  parser.add_option("","--verbose", action="store_true",\
      default=False, help="print information" )

  (opts,args) = parser.parse_args()

  return opts, sys.argv[1:]
#####################################################################
opts, args = parse_command_line()

if not (opts.input_cache_file or (opts.found_injection_glob and opts.missed_injection_glob)):
  print >>sys.stderr, "Some of the options specifying the input files containing single inspiral tables are missing." 
  print >> sys.stderr, " Either (--input-cache-file option) or (--found-injection-glob and --missed-injection-glob options) must be given."
  sys.exit(1)
    
  
# constructing the list of the IFO's
analysis_ifo_list = [ifo for ifo in ("G1", "H1", "H2", "L1", "V1") \
            if getattr(opts, "%s_triggers" % ifo.lower())]

#Calculating statistic for coincidences
statistic = CoincInspiralUtils.coincStatistic(opts.statistic) 

# construct dictionary of types of triggers (IFO type, IFO time)
EFactors = {}
ifo_times = CoincInspiralUtils.get_ifo_combos(analysis_ifo_list)

for ifo_time in ifo_times:
  ifo_types = CoincInspiralUtils.get_ifo_combos(ifo_time)
  for ifo_type in ifo_types:
	EFactors["".join(ifo_type) + "_" + "".join(ifo_time)] = 0.0


# construct dictionary to hold numbers of found injections
Found_dic = {}
for ifo_time in ifo_times:
  ifo_types = CoincInspiralUtils.get_ifo_combos(ifo_time)
  for ifo_type in ifo_types:
	Found_dic["".join(ifo_type) + "_" + "".join(ifo_time)] = 0.0

# construct dictionary of normalization factors
Norm_Factors = {}
Norm_number_inj = {}
Missed_Factors ={}
sum_EFactors = {}
for ifo_time in ifo_times:
  Norm_Factors["".join(ifo_time)] = 0.0
  Norm_number_inj["".join(ifo_time)] = 0
  Missed_Factors["".join(ifo_time)] = 0.0
  sum_EFactors["".join(ifo_time)] = 0.0




number_found_injections = 0
number_missed_injections = 0

# contsructing lists of data files containing found and missed injections 
########################################################################################################	
if opts.input_cache_file:
  InspiralUtils.message(opts, "Reading input-cache-file ...")
  found_injfiles = []
  missed_injfiles = []
  SnglInspiralCache = lal.Cache.fromfile(open(opts.input_cache_file))
  found_injfiles = SnglInspiralCache.sieve(description = opts.found_injection_pattern, exact_match=True).checkfilesexist()[0].pfnlist()
  missed_injfiles = SnglInspiralCache.sieve(description = opts.missed_injection_pattern, exact_match=True).checkfilesexist()[0].pfnlist()
else:
  found_injfiles = []
  missed_injfiles = []
  found_injfiles = glob.glob(opts.found_injection_glob)
  missed_injfiles = glob.glob(opts.missed_injection_glob)
  
# check if file lists are not empty
if  not len(found_injfiles) > 0:
  print >>sys.stderr, "List of found injections files is empty: your sieve pattern may be wrong or files do not exist in the location given by the cache file"
  sys.exit(1) 
if  not len(missed_injfiles) > 0:
  print >>sys.stderr, "List of missed injections files is empty: your sieve pattern may be wrong or files do not exist in the location given by the cache file"
  sys.exit(1) 

########################
# read in the veto file

xmldoc = utils.load_filename(opts.veto_file, gz=opts.veto_file.endswith("gz"))
vetoes = glsegments.segmenttable_get_by_name(xmldoc, "vetoes")
vetoes.coalesce()



# looping over the files, sorting triggers according their IFO times and type, updating the Det_Factor dictionary
################################################################################################################# 



for (found_injfile, missed_injfile) in zip(found_injfiles, missed_injfiles):

  # read in found and missed injections
  InspiralUtils.message(opts,"Reading " + found_injfile)
  
  # read in SearchSummaryTable from input files
  tmp_doc = SearchSummaryUtils.ReadTablesFromFiles([found_injfile], [lsctables.SearchSummaryTable])
  SearchSummary_table = tmp_doc.childNodes[0]
  
  # get the start and end time of the science segment
  start_time = SearchSummary_table[0].in_start_time
  end_time = SearchSummary_table[0].in_end_time
   
  # get the ifos in play 
  ifos = SearchSummary_table[0].ifos
  
  # turn the ifo string into the list
  ifo_list = []
  for i in range(len(ifos)/2):
    ifo_list.append(ifos[2*i:(2*i+2)])
	
  # generate all possible ifo combinations	
  ifo_combos = CoincInspiralUtils.get_ifo_combos(ifo_list)
  
  # define ifo set
  ifos_set = set(ifo_list)
  
  # extract the veto time appropriate to this segment
  seg = segments.segmentlist([segments.segment(LIGOTimeGPS(start_time),LIGOTimeGPS(end_time))])
  tmp_vetoes = {}
  tmp_vetoes = vetoes.copy()
  for key in tmp_vetoes.keys():
	tmp_vetoes[key] &= seg

  # calculate the different times during this segment
  segs = segments.segmentlistdict()
  for ifo_combo in ifo_combos:
	segs[ifo_combo] = seg & (~tmp_vetoes).intersection(ifo_combo)
	if (ifos_set - set(ifo_combo)):
	  segs[ifo_combo] &= vetoes.intersection(ifos_set - set(ifo_combo))

  
  # read in injections sngl
  injectionTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles([found_injfile])
  
  # construct coincidence for injections  
  injectionCoincTriggers = CoincInspiralUtils.coincInspiralTable(injectionTriggers, statistic)
  
  if len(injectionCoincTriggers) > 0:
	# read in sim inspirals if the injection triggers were already clustered with COIRE
	found_simTriggers = SimInspiralUtils.ReadSimInspiralFromFiles([found_injfile])
	#add sim inspirals
	injectionCoincTriggers.add_sim_inspirals(found_simTriggers)
		
	for coinc in injectionCoincTriggers:
	  # get coinc's ifos
	  coinc_ifos, coinc_ifolist = coinc.get_ifos()
	  
	  # determine ifo time of the trigger
	  coinc_ifotime = ""
	  for ifo_combo in ifo_combos:
		flagVeto = True
		for ifo in coinc_ifolist:
		  if getattr(coinc,ifo).get_end() not in segs[ifo_combo]:
			flagVeto = False
			break
		if flagVeto:
		  coinc_ifotime = coinc_ifotime.join(ifo_combo)
		  print coinc.event_id, coinc_ifotime
		  
	  # check if we did not get to the border case	  
	  if not coinc_ifotime:
		#get ifo combos that may contain the current coincidence
		ifo_combos_for_this_event = []
		for ifo_combo in ifo_combos:
		  number_of_ifos = 0
		  for ifo in coinc_ifolist:
		    if ifo in ifo_combo:
			  number_of_ifos += 1
		  if number_of_ifos == len(coinc_ifolist):
		    ifo_combos_for_this_event.append(ifo_combo)
			
		# if number of potential ifo times is more than one check which one contains
		# at least one trigger of the coincidence	
		if len(ifo_combos_for_this_event) > 1:
		  # list of ifo times that contain at least one of the coincident triggers
		  ifo_times_for_coinc = []		  
		  for ifo_combo in ifo_combos_for_this_event:
			flagContain = False
			for ifo in coinc_ifolist:
			  if getattr(coinc,ifo).get_end() in segs[ifo_combo]:
				flagContain = True
			if flagContain:
			  ifo_times_for_coinc.append(ifo_combo)
			  
		  # choose the ifo time with the most detectors on
		  for ifo_combo in ifo_times_for_coinc:
			if (2*len(ifo_combo)) > len(coinc_ifotime):
			  coinc_ifotime = "".join(ifo_combo)
		  print coinc.event_id, coinc_ifotime
		  
		# otherwise just assign the only ifo time available 
		else:
		  coinc_ifotime = "".join(ifo_combos_for_this_event[0])
		  print coinc.event_id, coinc_ifotime
		  
	  # add it to the appropriate EFactor		
	  EFactors[coinc_ifos + "_" + coinc_ifotime] += coinc.sim.distance**3
	  Found_dic[coinc_ifos + "_" + coinc_ifotime] += 1
	  number_found_injections += 1
	  

		
  # read in sim inspirals with missed injections
  missed_simTriggers = SimInspiralUtils.ReadSimInspiralFromFiles([missed_injfile])


  if missed_simTriggers:
  
	# add missed injections to normalization factors
	for sim in missed_simTriggers:
	  
	  # check if injection is not vetoed
	  flagVetoed = False
	  number_vetoed_ifos = 0
	  for ifo in ifo_list:
		if sim.get_end(ifo[0]) in tmp_vetoes[ifo]:
		  number_vetoed_ifos += 1
	  if number_vetoed_ifos >= (len(ifo_list) - 1):
		flagVetoed = True
	  
	  if not flagVetoed:
	  
		# determine ifo time of the trigger
		sim_ifotime = ""
		for ifo_combo in ifo_combos:
		  flagVeto = True
		  for ifo in ifo_list:
			if sim.get_end(ifo[0]) not in segs[ifo_combo]:
			  flagVeto = False
			  break
		  if flagVeto:
			sim_ifotime = sim_ifotime.join(ifo_combo)
			print sim.simulation_id, sim_ifotime
			
		# check if we did not get to the border case	  
		if not sim_ifotime:
		
		  # if number of potential ifo times is more than one check which one contains
		  # at least one trigger of the coincidence	
		  # list of ifo times that contain at least one of the coincident triggers
		  ifo_times_for_sim = []		  
		  for ifo_combo in ifo_combos:
			flagContain = False
			for ifo in ifo_list:
			  if sim.get_end(ifo[0]) in segs[ifo_combo]:
				flagContain = True
			if flagContain:
			  ifo_times_for_sim.append(ifo_combo)
			  
		  # choose the ifo time with the most detectors on
		  for ifo_combo in ifo_times_for_sim:
			if (2*len(ifo_combo)) > len(sim_ifotime):
			  sim_ifotime = "".join(ifo_combo)
		  print sim.simulation_id, sim_ifotime
		  
		# add sim to appropriate Normalization Factor
		Norm_Factors[sim_ifotime] += sim.distance**3
		Norm_number_inj[sim_ifotime] += 1
	  
		Missed_Factors[sim_ifotime] += sim.distance**3
	  number_missed_injections += 1
	  
print "EFactors"	  
print EFactors

print "Norm Factors"
print Norm_Factors

print "Missed Factors"
print Missed_Factors

print "Norm_number_inj"
print Norm_number_inj



# include EFactors into Norm_Factors
for ifo_time in ifo_times:
  ifo_types = CoincInspiralUtils.get_ifo_combos(ifo_time)
  for ifo_type in ifo_types:
	Norm_Factors["".join(ifo_time)] += EFactors["".join(ifo_type) + "_" + "".join(ifo_time)]
	Norm_number_inj["".join(ifo_time)] += Found_dic["".join(ifo_type) + "_" + "".join(ifo_time)]

# set zeros in Norm Factors to ones

for ifo_time in ifo_times:

  if Norm_Factors["".join(ifo_time)] == 0.0:
	Norm_Factors["".join(ifo_time)] = 1.0
	
  if Norm_number_inj["".join(ifo_time)] == 0:
	Norm_number_inj["".join(ifo_time)] = 1


# Normalize EFactors 
for ifo_time in ifo_times:
  ifo_types = CoincInspiralUtils.get_ifo_combos(ifo_time)
  for ifo_type in ifo_types:
	EFactors["".join(ifo_type) + "_" + "".join(ifo_time)] = EFactors["".join(ifo_type) + "_" + "".join(ifo_time)] / Norm_Factors["".join(ifo_time)]
	sum_EFactors["".join(ifo_time)] += EFactors["".join(ifo_type) + "_" + "".join(ifo_time)]
	Found_dic["".join(ifo_type) + "_" + "".join(ifo_time)] = Found_dic["".join(ifo_type) + "_" + "".join(ifo_time)] / Norm_number_inj["".join(ifo_time)]
  Missed_Factors["".join(ifo_time)] = Missed_Factors["".join(ifo_time)] / Norm_Factors["".join(ifo_time)]


# generating the summary file
####################################################################################################

summary_file = open("summary.txt", "w")
summary_file.write("total number of found injections: " + str(number_found_injections) + "\n")
summary_file.write("number of missed injections: " + str(number_missed_injections) + "\n")
summary_file.write("Combined Efficiency Factors and Missed Factors for each ifo time should sum up to unity" + "\n")
for ifo_time in ifo_times:
  summary_file.write(str(sum_EFactors["".join(ifo_time)]) + " " + str(Missed_Factors["".join(ifo_time)]) +  "\n")
summary_file.write("Efficiency Factors: \n")
for ifo_time in ifo_times:
  ifo_types = CoincInspiralUtils.get_ifo_combos(ifo_time)
  for ifo_type in ifo_types:
	summary_file.write("".join(ifo_type) + "_" + "".join(ifo_time) + " " + str(EFactors["".join(ifo_type) + "_" + "".join(ifo_time)]) + "\n")
summary_file.write("Ratios of found injections: \n")
for ifo_time in ifo_times:
  ifo_types = CoincInspiralUtils.get_ifo_combos(ifo_time)
  for ifo_type in ifo_types:
	summary_file.write("".join(ifo_type) + "_" + "".join(ifo_time) + " " + str(Found_dic["".join(ifo_type) + "_" + "".join(ifo_time)]) + "\n")
summary_file.close()

#save EFactors into a file
####################################################################################################### 
 
InspiralUtils.message(opts,"saving EFactors into a file ...")

#open file
file = open(opts.output_file, "w")

#saving EFactors
cPickle.dump(EFactors, file)

#close file
file.close()







