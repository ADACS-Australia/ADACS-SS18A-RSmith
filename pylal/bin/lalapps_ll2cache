#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
Build a LAL cache from a list of LIGO LW XML files containing search
summary tables.
"""

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# Preamble.
#

import glob
from optparse import OptionParser
import os
import sys

from glue import lal
from glue import segments
from glue.ligolw import docutils
from glue.ligolw import ligolw
from glue.ligolw import lsctables


#
# Filter function for partial LIGO LW document loading.
#

def ElementFilter(name, attrs):
	"""
	Return True if name, attrs describes a search summary table or a
	process table.
	"""
	return lsctables.IsTableProperties(lsctables.SearchSummaryTable, name, attrs) or lsctables.IsTableProperties(lsctables.ProcessTable, name, attrs)


#
# Extract the value from a column in a table.
#

def column_value(table, column):
	"""
	Scan a column in a table element, checking that all rows have the
	same value, and return that value.
	"""

	if options.program:
		cache.segment = segments.segmentlist([row.get_out() for row in searchsumm if row.process_id.program == options.program]).extent()
	else:
		cache.segment = searchsumm.get_outlist().extent()

	if options.program:
		vals = [getattr(row, column) for row in table.rows if row.process_id.program == options.program]
	else:
		vals = table.getColumnByName(column)

	value = vals[0]
	for v in vals:
		if v != value:
			raise ValueError, "%s: not all rows have the same value for \"%s\"" % (table.tableName, column)
	return value


#
# Parse command line.
#

parser = OptionParser(version = "%prog CVS $Id$")
parser.add_option("--description", metavar = "DESCRIPTION", help = "set all descriptions to DESCRIPTION")
parser.add_option("--observatory", metavar = "OBSERVATORY", help = "set all observatories to OBSERVATORY")
parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
parser.add_option("-o", "--output", metavar = "filename", help = "set output file (default = stdout")
parser.add_option("-p", "--program" metavar = "name", help = "obtain start and durations from search summary entries corresponding to the given program (default = whatever is there)")
options, patterns = parser.parse_args()
del parser

if options.output:
	output = file(options.output)
else:
	output = sys.stdout


#
# Process files one-by-one.
#

for pattern in patterns:
	for name in glob.glob(pattern):
		# Load and merge search summary tables
		doc = ligolw.Document()
		ligolw.make_parser(docutils.PartialLIGOLWContentHandler(doc, SearchSummaryFilter)).parse(file(name))
		docutils.MergeCompatibleTables(doc)
		if len(doc.childNodes) != 1:
			raise Exception, "Missing or incompatible search summary tables in document %s" % name
		docutils.makeReference(doc)
		searchsumm = doc.childNodes[0]

		# initialize cache entry info
		cache = lal.CacheEntry()

		# extract segment
		if options.program:
			cache.segment = segments.segmentlist([row.get_out() for row in searchsumm if row.process_id.program == options.program]).extent()
		else:
			cache.segment = searchsumm.get_outlist().extent()

		# extract observatory
		if options.observatory:
			cache.observatory = options.observatory
		else:
			try:
				cache.observatory = column_value(searchsumm, "ifos")
			except ValueError, e:
				raise ValueError, "%s: %s" % (name, str(e))

		# extract description
		if options.description:
			cache.description = options.description
		else:
			try:
				cache.description = column_value(searchsumm, "comment")
			except ValueError:
				raise ValueError, "%s: %s" % (name, str(e))

		# set URL
		cache.url = "file://localhost" + os.path.abspath(name)

		# write cache entry
		print >>output, str(cache)
