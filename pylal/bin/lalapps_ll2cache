#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
Build a LAL cache from a list of LIGO LW XML files containing search
summary tables.
"""

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# Preamble.
#

import glob
from optparse import OptionParser
import os
import sys
from xml import sax

from glue import lal
from glue import segments
from glue.ligolw import docutils
from glue.ligolw import ligolw
from glue.ligolw import lsctables


#
# Filter function for partial LIGO LW document loading.
#

def SearchSummaryFilter(name, attrs):
	"""
	Return True if name, attrs describes a search summary table.
	"""
	return lsctables.IsTableProperties(lsctables.SearchSummaryTable, name, attrs)


#
# Extract the value from a column in a table.
#

def column_value(table, column):
	"""
	Scan a column in a table element, checking that all rows have the
	same value, and return that value.
	"""
	vals = table.getColumnByName(column)
	value = vals[0]
	for v in vals:
		if v != value:
			raise ValueError, "%s: not all rows have the same value for \"%s\"" % (table.tableName, column)
	return value


#
# Parse command line.
#

parser = OptionParser(version = "%prog CVS $Id$")
parser.add_option("--description", metavar = "DESCRIPTION", help = "set all descriptions to DESCRIPTION")
parser.add_option("--observatory", metavar = "OBSERVATORY", help = "set all observatories to OBSERVATORY")
parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
parser.add_option("-o", "--output", metavar = "FILENAME", help = "write output to FILENAME (default = stdout")
options, patterns = parser.parse_args()
del parser

if options.output:
	output = file(options.output)
else:
	output = sys.stdout


#
# Process files one-by-one.
#

for pattern in patterns:
	for name in glob.glob(pattern):
		# Load and merge search summary tables
		doc = ligolw.Document()
		sax.parse(file(name), docutils.PartialLIGOLWContentHandler(doc, SearchSummaryFilter))
		docutils.MergeCompatibleTables(doc)
		if len(doc.childNodes) != 1:
			raise Exception, "Missing or incompatible search summary tables in document %s" % name
		searchsumm = doc.childNodes[0]

		# initialize cache entry info
		cache = lal.CacheEntry()

		# extract segment
		cache.segment = searchsumm.get_outlist().extent()

		# extract observatory
		if options.observatory:
			cache.observatory = options.observatory
		else:
			try:
				cache.observatory = column_value(searchsumm, "ifos")
			except ValueError, e:
				raise ValueError, "%s: %s" % (name, str(e))

		# extract description
		if options.description:
			cache.description = options.description
		else:
			try:
				cache.description = column_value(searchsumm, "comment")
			except ValueError:
				raise ValueError, "%s: %s" % (name, str(e))

		# set URL
		cache.url = "file://localhost" + os.path.abspath(name)

		# write cache entry
		print >>output, str(cache)
