#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

from optparse import OptionParser
import math
import matplotlib.cm
import numarray
import sqlobject
import sys

from glue import segments
from glue.ligolw import table
from glue.ligolw import lsctables
from pylal import llwapp
from pylal import rate
from pylal import SnglBurstUtils
from pylal.date import LIGOTimeGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("-b", "--base", metavar = "base", default = "plotburca_", help = "set the prefix for output filenames (default = plotburca_)")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("-l", "--live-time-program", metavar = "program", default = "power", help = "set the name, as it appears in the process table, of the program whose search summary entries define the search live time (default = power)")
	parser.add_option("--plot", metavar = "number", action = "append", default = None, help = "only generate the given plot number")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	if options.plot:
		options.plot = map(int, options.plot)
	else:
		options.plot = [0, 1, 2, 3, 4, 5, 6]

	return options, (filenames or [None])


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

class SnglBurst(sqlobject.SQLObject):
	class sqlmeta:
		table = "sngl_burst"
		idName = "event_id"
	ifo = sqlobject.StringCol(length = 2)
	central_freq = sqlobject.FloatCol()
	confidence = sqlobject.FloatCol()
	peak_time = sqlobject.IntCol()
	peak_time_ns = sqlobject.IntCol()

	def get_peak(self):
		return LIGOTimeGPS(self.peak_time, self.peak_time_ns)


def sngl_burst_append(self, row):
	SnglBurst(
		id = lsctables.ILWDID(row.event_id),
		ifo = row.ifo,
		central_freq = row.central_freq,
		confidence = row.confidence,
		peak_time = row.peak_time,
		peak_time_ns = row.peak_time_ns
	)


class SimBurst(sqlobject.SQLObject):
	class sqlmeta:
		table = "sim_burst"
		idName = "simulation_id"
	geocent_peak_time = sqlobject.IntCol()
	geocent_peak_time_ns = sqlobject.IntCol()
	h_peak_time = sqlobject.IntCol()
	h_peak_time_ns = sqlobject.IntCol()
	l_peak_time = sqlobject.IntCol()
	l_peak_time_ns = sqlobject.IntCol()
	freq = sqlobject.FloatCol()
	hrss = sqlobject.FloatCol()


def sim_burst_append(self, row):
	SimBurst(
		id = lsctables.ILWDID(row.simulation_id),
		geocent_peak_time = row.geocent_peak_time,
		geocent_peak_time_ns = row.geocent_peak_time_ns,
		h_peak_time = row.h_peak_time,
		h_peak_time_ns = row.h_peak_time_ns,
		l_peak_time = row.l_peak_time,
		l_peak_time_ns = row.l_peak_time_ns,
		freq = row.freq,
		hrss = row.hrss
	)


class TimeSlide(sqlobject.SQLObject):
	class sqlmeta:
		table = "time_slide"
	process_id = sqlobject.IntCol()
	time_slide_id = sqlobject.IntCol()
	instrument = sqlobject.StringCol(length = 2)
	offset = sqlobject.FloatCol()

	def get_offsets(cls, id):
		offsets = {}
		for instrument, offset in cls._connection.queryAll("SELECT time_slide.instrument, time_slide.offset FROM time_slide WHERE time_slide.time_slide_id == %d" % id):
			offsets[instrument] = offset
		return offsets
	get_offsets = classmethod(get_offsets)

	def is_null(cls, id):
		return not cls._connection.queryOne("SELECT COUNT(*) FROM time_slide WHERE time_slide.time_slide_id == %d AND time_slide.offset != 0" % id)[0]
	is_null = classmethod(is_null)

	def all_offsets(cls):
		return [cls.get_offsets(id) for (id, ) in cls._connection.queryAll("SELECT DISTINCT time_slide.time_slide_id FROM time_slide")]
	all_offsets = classmethod(all_offsets)


def time_slide_append(self, row):
	TimeSlide(
		process_id = lsctables.ILWDID(row.process_id),
		time_slide_id = lsctables.ILWDID(row.time_slide_id),
		instrument = row.instrument,
		offset = row.offset
	)


class CoincDef(sqlobject.SQLObject):
	class sqlmeta:
		table = "coinc_definer"
	coinc_def_id = sqlobject.IntCol()
	table_name = sqlobject.StringCol()

	def get_table_names(cls, id):
		l = [table_name for (table_name, ) in cls._connection.queryAll("SELECT coinc_definer.table_name FROM coinc_definer WHERE coinc_definer.coinc_def_id = %d" % id)]
		l.sort()
		return l
	get_table_names = classmethod(get_table_names)

	def get_id(cls, table_names):
		table_names.sort()
		for id in [id for (id, ) in cls._connection.queryAll("SELECT DISTINCT coinc_definer.coinc_def_id FROM coinc_definer")]:
			if cls.get_table_names(id) == table_names:
				return id
		raise KeyError, table_names
	get_id = classmethod(get_id)


def coinc_def_append(self, row):
	CoincDef(
		coinc_def_id = lsctables.ILWDID(row.coinc_def_id),
		table_name = row.table_name
	)


class Coinc(sqlobject.SQLObject):
	class sqlmeta:
		table = "coinc_event"
		idName = "coinc_event_id"
	process_id = sqlobject.IntCol()
	coinc_def_id = sqlobject.IntCol()
	sngl_bursts = sqlobject.RelatedJoin("SnglBurst")
	sim_bursts = sqlobject.RelatedJoin("SimBurst")
	#coincs = sqlobject.RelatedJoin("Coinc")
	time_slide_id = sqlobject.IntCol()
	nevents = sqlobject.IntCol(default = 0)


def coinc_append(self, row):
	Coinc(
		id = lsctables.ILWDID(row.coinc_event_id),
		process_id = lsctables.ILWDID(row.process_id),
		coinc_def_id = lsctables.ILWDID(row.coinc_def_id),
		time_slide_id = lsctables.ILWDID(row.time_slide_id),
		nevents = row.nevents
	)


def coinc_map_append(self, row):
	coinc_event_id = lsctables.ILWDID(row.coinc_event_id)
	event_table = lsctables.ILWDTableName(row.event_id)
	event_id = lsctables.ILWDID(row.event_id)
	if not table.CompareTableNames(event_table, lsctables.SnglBurstTable.tableName):
		Coinc.get(coinc_event_id).addSnglBurst(SnglBurst.get(event_id))
	elif not table.CompareTableNames(event_table, lsctables.SimBurstTable.tableName):
		Coinc.get(coinc_event_id).addSimBurst(SimBurst.get(event_id))
	#elif not table.CompareTableNames(event_table, lsctables.CoincTable.tableName):
	#	Coinc.get(coinc_event_id).addCoinc(Coinc.get(event_id))
	else:
		raise TypeError, row.event_id


def InitBurstTableDatabase(connection):
	for cls in [SnglBurst, SimBurst, TimeSlide, CoincDef, Coinc]:
		cls._connection = connection
		cls.createTable()

	lsctables.SnglBurstTable.append = sngl_burst_append
	lsctables.SimBurstTable.append = sim_burst_append
	lsctables.TimeSlideTable.append = time_slide_append
	lsctables.CoincDefTable.append = coinc_def_append
	lsctables.CoincTable.append = coinc_append
	lsctables.CoincMapTable.append = coinc_map_append


def ResetBurstTables():
	for cls in [SnglBurst, SimBurst, TimeSlide, CoincDef, Coinc]:
		cls.clearTable()


#
# =============================================================================
#
#                            Document Comprehension
#
# =============================================================================
#

class DocContents(object):
	def __init__(self, xmldoc, live_time_program):
		self.seglists = llwapp.segmentlistdict_fromsearchsummary(xmldoc, live_time_program)


#
# =============================================================================
#
#                                Rate Contours
#
# =============================================================================
#

def time_slide_is_null(offsets):
	for offset in offsets.itervalues():
		if offset != 0:
			return False
	return True


class RateContours(SnglBurstUtils.BurstPlot):
	def __init__(self, x_instrument, y_instrument, min_delta_t, max_delta_t):
		SnglBurstUtils.BurstPlot.__init__(self, "%s Offset (s)" % x_instrument, "%s Offset (s)" % y_instrument)
		self.fig.set_figsize_inches(16,16)
		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.tisi_rows = None
		self.seglists = None
		self.bins = rate.BinnedRatios(rate.Bins(min_delta_t, max_delta_t, 81, min_delta_t, max_delta_t, 81))

	def add_contents(self, doc):
		if self.tisi_rows == None:
			self.tisi_rows = TimeSlide.all_offsets()
		if self.seglists == None:
			self.seglists = doc.seglists
		else:
			for instrument, seglist in doc.seglists.iteritems():
				self.seglists[instrument] |= seglist
		for row in Coinc.selectBy(coinc_def_id = CoincDef.get_id([lsctables.SnglBurstTable.tableName])):
			offsets = TimeSlide.get_offsets(row.time_slide_id)
			self.bins.incnumerator((offsets[self.x_instrument], offsets[self.y_instrument]))

	def finish(self):
		for row in self.tisi_rows:
			self.seglists.offsets.update(row)
			self.bins.incdenominator((row[self.x_instrument], row[self.y_instrument]), float(self.seglists.intersection(self.seglists.keys()).duration()))
		self.bins.logregularize()
		zvals = self.bins.ratio()
		rate.filter_array(zvals, rate.gaussian_window2d(8, 8))
		xcoords, ycoords = self.bins.centres()
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(zvals)))
		for offsets in self.tisi_rows:
			if time_slide_is_null(offsets):
				self.axes.plot((offsets[self.x_instrument],), (offsets[self.y_instrument],), "r+")
			else:
				self.axes.plot((offsets[self.x_instrument],), (offsets[self.y_instrument],), "k+")

		self.axes.set_xlim([self.bins.bins.min[0], self.bins.bins.max[0]])
		self.axes.set_ylim([self.bins.bins.min[1], self.bins.bins.max[1]])
		self.axes.set_title(r"Coincident Event Rate vs. Offset, Logarithmic Contours")


#
# =============================================================================
#
#                              Confidence Scatter
#
# =============================================================================
#

class ConfidenceContours(SnglBurstUtils.BurstPlot):
	def __init__(self, x_instrument, y_instrument, min_confidence, max_confidence):
		SnglBurstUtils.BurstPlot.__init__(self, "%s Confidence" % x_instrument, "%s Confidence" % y_instrument)
		self.fig.set_figsize_inches(16,16)
		self.axes.loglog()

		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.n_foreground = 0
		self.n_background = 0
		self.foreground_bins = rate.BinnedArray(rate.Bins(min_confidence, max_confidence, 1024, min_confidence, max_confidence, 1024, spacing = ["log", "log"]))
		self.background_bins = rate.BinnedArray(rate.Bins(min_confidence, max_confidence, 1024, min_confidence, max_confidence, 1024, spacing = ["log", "log"]))

	def add_contents(self, doc):
		for row in Coinc.selectBy(coinc_def_id = CoincDef.get_id([lsctables.SnglBurstTable.tableName])):
			if TimeSlide.is_null(row.time_slide_id):
				self.n_foreground += 1
				for burst in row.sngl_bursts:
					if burst.ifo == self.x_instrument:
						x = -burst.confidence
					elif burst.ifo == self.y_instrument:
						y = -burst.confidence
				self.foreground_bins[x, y] += 1
			else:
				self.n_background += 1
				for burst in row.sngl_bursts:
					if burst.ifo == self.x_instrument:
						x = -burst.confidence
					elif burst.ifo == self.y_instrument:
						y = -burst.confidence
				self.background_bins[x, y] += 1

	def finish(self):
		self.axes.set_title(r"Distribution of Coincident Event Confidence\\%d Foreground, %d Background Events, Logarithmic Contours" % (self.n_foreground, self.n_background))
		xcoords, ycoords = self.background_bins.centres()

		# prepare the data
		rate.filter_array(self.background_bins.array, rate.gaussian_window2d(8, 8))
		rate.filter_array(self.foreground_bins.array, rate.gaussian_window2d(8, 8))
		self.background_bins.logregularize()
		self.foreground_bins.logregularize()

		# plot background contours
		max_density = math.log(self.background_bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.background_bins.array)), [max_density - n for n in xrange(0, 10, 1)], cmap = matplotlib.cm.Greys)

		# plot foreground (zero-lag) contours
		max_density = math.log(self.foreground_bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.foreground_bins.array)), [max_density - n for n in xrange(0, 10, 1)], cmap = matplotlib.cm.Reds)

		self.axes.set_xlim([self.background_bins.bins.min[0], self.background_bins.bins.max[0]])
		self.axes.set_ylim([self.background_bins.bins.min[1], self.background_bins.bins.max[1]])


#
# =============================================================================
#
#                              Delta-t Histogram
#
# =============================================================================
#

class DeltaTHistogram(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, interval, width):
		SnglBurstUtils.BurstPlot.__init__(self, "Offset (s)", "Events per Unit Offset")
		self.instrument = instrument
		self.n_foreground = 0
		self.n_background = 0
		self.foreground = rate.Rate(interval, width)
		self.background = rate.Rate(interval, width)

	def add_contents(self, doc):
		for row in Coinc.select():
			offsets = TimeSlide.get_offsets(row.time_slide_id)
			if self.instrument not in offsets:
				continue
			# sum = len(bursts) * peak_time for this instrument
			# - sum of peak times of all instruments.  Dividing
			# this by len(bursts) gives the peak time for this
			# instrument - the average of all peak times.  I
			# compute this the way I do to avoid a (very
			# expensive!) LIGOTimeGPS division operation.
			sum = 0
			for burst in row.sngl_bursts:
				peak = burst.get_peak() + offsets[burst.ifo]
				if burst.ifo != self.instrument:
					sum -= peak
				else:
					sum += (len(row.sngl_bursts) - 1) * peak
			if TimeSlide.is_null(row.time_slide_id):
				self.n_foreground += 1
				self.foreground[float(sum) / len(row.sngl_bursts)] = 1.0
			else:
				self.n_background += 1
				self.background[float(sum) / len(row.sngl_bursts)] = 1.0

	def finish(self):
		self.axes.set_title(r"%s Peak Time Offset From Coincidence Mean\\%d Foreground, %d Background Events" % (self.instrument, self.n_foreground, self.n_background))
		self.axes.plot(self.background.xvals(), self.background.filtered(), "k")
		self.axes.plot(self.foreground.xvals(), self.foreground.filtered(), "r")


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

def new_plots(plots):
	deltat_seg = segments.segment(-0.3, +0.3)
	deltat_width = 0.03125
	l = [
		RateContours("H2", "H1", -100, +100),
		ConfidenceContours("H2", "H1", 30, 10**10),
		ConfidenceContours("H2", "L1", 30, 10**10),
		ConfidenceContours("L1", "H1", 30, 10**10),
		DeltaTHistogram("H1", deltat_seg, deltat_width),
		DeltaTHistogram("H2", deltat_seg, deltat_width),
		DeltaTHistogram("L1", deltat_seg, deltat_width)
	]
	return [l[i] for i in plots]

options, filenames = parse_command_line()

plots = new_plots(options.plot)

InitBurstTableDatabase(sqlobject.connectionForURI("sqlite:/:memory:"))

for n, filename in enumerate(llwapp.sort_files_by_size(filenames, options.verbose, reverse = True)):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	if filename[-3:] == ".gz":
		doc = llwapp.load_filename(filename, options.verbose, gz = True)
	else:
		doc = llwapp.load_filename(filename, options.verbose)
	if options.verbose:
		print >>sys.stderr, "indexing..."
	contents = DocContents(doc, options.live_time_program)
	doc.unlink()
	del doc
	for n, plot in enumerate(plots):
		if options.verbose:
			print >>sys.stderr, "adding to plot %d..." % options.plot[n]
		plot.add_contents(contents)
	ResetBurstTables()


# delete the plots as we go to save memory
n = 0
format = "%%s%%0%dd.%%s" % (int(math.log10(len(plots))) + 1)
while len(plots):
	filename = format % (options.base, options.plot[n], options.format)
	if options.verbose:
		print >>sys.stderr, "finishing plot %d..." % options.plot[n]
	plots[0].finish()
	if options.verbose:
		print >>sys.stderr, "writing %s..." % filename
	plots[0].fig.savefig(filename)
	del plots[0]
	n += 1
if options.verbose:
	print >>sys.stderr, "done."
