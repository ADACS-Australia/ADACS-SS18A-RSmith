#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import bisect
import gc
from optparse import OptionParser
import matplotlib
matplotlib.use("Agg")
from matplotlib import figure
from matplotlib.backends.backend_agg import FigureCanvasAgg
import numarray
import sys

from glue.lal import CacheEntry
from glue.ligolw import lsctables
from pylal import llwapp

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("-b", "--base", metavar = "base", default = "plotburca_", help = "set the prefix for output filenames (default = plotburca_)")
	parser.add_option("-c", "--input-cache", metavar = "filename", default = [], action = "append", help = "read input from the files in this cache")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("-x", "--x-instrument", metavar = "instrument", help = "set instrument for x axis")
	parser.add_option("-y", "--y-instrument", metavar = "instrument", help = "set instrument for y axis")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, urls = parser.parse_args()

	for cache in options.input_cache:
		urls.extend([entry.url for entry in map(CacheEntry, file(cache))])

	if not len(urls):
		raise ValueError, "no input files specified"

	return options, urls

try:
	options, urls = parse_command_line()
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

class SnglBurst(object):
	__slots__ = ["ifo", "confidence", "event_id"]

class Coinc(object):
	__slots__ = ["coinc_event_id", "time_slide_id"]

class TimeSlide(object):
	__slots__ = ["time_slide_id", "instrument", "offset"]

	def _get_key(self):
		return self.time_slide_id

	def _has_key(self, key):
		return self.time_slide_id == key

lsctables.SnglBurstTable.RowType = SnglBurst
lsctables.CoincTable.RowType = Coinc
lsctables.TimeSlideTable.RowType = TimeSlide


#
# =============================================================================
#
#                            Document Comprehension
#
# =============================================================================
#

class DocContents(object):
	def __init__(self, xmldoc):
		#
		# Extract tables
		#

		self.bursttable = llwapp.get_table(xmldoc, lsctables.SnglBurstTable.tableName)
		self.coinctable = llwapp.get_table(xmldoc, lsctables.CoincTable.tableName)
		self.coincmaptable = llwapp.get_table(xmldoc, lsctables.CoincMapTable.tableName)
		self.tisitable = llwapp.get_table(xmldoc, lsctables.TimeSlideTable.tableName)

		#
		# Find foreground time slide
		#

		self.foreground_tisi_id = None
		for self.foreground_tisi_id in self.tisitable.dict.keys():
			for offset in self.tisitable.get_offset_dict(self.foreground_tisi_id).values():
				if offset != 0.0:
					continue
			break

		#
		# Construct ID look-up tables
		#

		# sngl_burst by event_id
		self.bursttable.rows.sort(lambda a, b: cmp(lsctables.ILWDID(a.event_id), lsctables.ILWDID(b.event_id)))
		self.bursttableids = map(lsctables.ILWDID, self.bursttable.getColumnByName("event_id"))

		# coinc by coinc_event_id
		self.coinctable.rows.sort(lambda a, b: cmp(lsctables.ILWDID(a.coinc_event_id), lsctables.ILWDID(b.coinc_event_id)))
		self.coinctableids = map(lsctables.ILWDID, self.coinctable.getColumnByName("coinc_event_id"))

		# coinc_event_map by coinc_event_id
		self.coincmaptable.rows.sort(lambda a, b: cmp(lsctables.ILWDID(a.coinc_event_id), lsctables.ILWDID(b.coinc_event_id)))
		self.coincmaptableids = map(lsctables.ILWDID, self.coincmaptable.getColumnByName("coinc_event_id"))

		# time_slide by time_slide_id
		self.tisitable.rows.sort(lambda a, b: cmp(lsctables.ILWDID(a.time_slide_id), lsctables.ILWDID(b.time_slide_id)))
		self.tisitableids = map(lsctables.ILWDID, self.tisitable.getColumnByName("time_slide_id"))

	def get_burst_by_id(self, id):
		return self.bursttable.rows[bisect.bisect_left(self.bursttableids, lsctables.ILWDID(id))]

	def get_coincevents_by_id(self, id):
		return self.coincmaptable.rows[bisect.bisect_left(self.coincmaptableids, lsctables.ILWDID(id)) : bisect.bisect_right(self.coincmaptableids, lsctables.ILWDID(id))]

	def get_burst_by_coincid(self, id):
		return [self.get_burst_by_id(row.event_id) for row in self.get_coincevents_by_id(id) if "sngl_burst" in row.event_id]

	def get_tisi_by_id(self, id):
		return self.tisitable.rows[bisect.bisect_left(self.tisitableids, lsctables.ILWDID(id)) : bisect.bisect_right(self.tisitableids, lsctables.ILWDID(id))]


#
# =============================================================================
#
#                            Coincidence Iterators
#
# =============================================================================
#

class CoincEventIter(object):
	def __init__(self,  doc):
		self.doc = doc
		self.coinciter = iter(doc.coinctable)

	def __iter__(self):
		return self

	def next(self):
		coinc = self.coinciter.next()
		return coinc.time_slide_id == self.doc.foreground_tisi_id, self.doc.get_burst_by_coincid(coinc.coinc_event_id)


class CoincTisiIter(object):
	def __init__(self, doc):
		self.doc = doc
		self.iditer = iter(doc.coinctable.getColumnByName("time_slide_id"))

	def __iter__(self):
		return self

	def next(self):
		return self.doc.get_tisi_by_id(self.iditer.next())


#
# =============================================================================
#
#                             Contour Plot Support
#
# =============================================================================
#

class RatioBins(object):
	def __init__(self, xmin, xmax, nx, ymin, ymax, ny):
		self.xmin = xmin
		self.xmax = xmax
		self.dx = (xmax - xmin) / (nx - 1)
		self.xcoords = numarray.arange(xmin, xmax + self.dx, self.dx)

		self.ymin = ymin
		self.ymax = ymax
		self.dy = (ymax - ymin) / (ny - 1)
		self.ycoords = numarray.arange(ymin, ymax + self.dy, self.dy)

		self.numerator = numarray.zeros((ny, nx), numarray.Float64)
		self.denominator = numarray.zeros((ny, nx), numarray.Float64)

	def incnumerator(self, x, y):
		if (self.xmin <= x <= self.xmax) and (self.ymin <= y <= self.ymax):
			i = int((y - self.ymin) / self.dy + 0.5)
			j = int((x - self.xmin) / self.dx + 0.5)
			self.numerator[i, j] += 1.0

	def incdenominator(self, x, y):
		if (self.xmin <= x <= self.xmax) and (self.ymin <= y <= self.ymax):
			i = int((y - self.ymin) / self.dy + 0.5)
			j = int((x - self.xmin) / self.dx + 0.5)
			self.denominator[i, j] += 1.0

	def normalize(self):
		self.denominator = numarray.where(self.denominator > 0, self.denominator, 1)


#
# =============================================================================
#
#                                Rate Contours
#
# =============================================================================
#

class RateContours(object):
	def __init__(self, x_instrument, y_instrument):
		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.tisi_offsets_x = []
		self.tisi_offsets_y = []
		self.fig = figure.Figure()
		self.canvas = FigureCanvasAgg(self.fig)
		self.axes = self.fig.gca()
		self.bins = RatioBins(-100.0, 100.0, 11, -100.0, 100.0, 11)

		self.axes.grid(True)

		self.axes.set_xlabel("%s Offset (s)" % options.x_instrument)
		self.axes.set_ylabel("%s Offset (s)" % options.y_instrument)

	def addto(self, doc):
		if not self.tisi_offsets_x:
			for id in doc.tisitable.dict.keys():
				offsets = doc.tisitable.get_offset_dict(id)
				self.tisi_offsets_x.append(offsets[self.x_instrument])
				self.tisi_offsets_y.append(offsets[self.y_instrument])
		for offsets in CoincTisiIter(doc):
			x, y = None, None
			for row in offsets:
				if row.instrument == self.x_instrument:
					x = row.offset
				elif row.instrument == self.y_instrument:
					y = row.offset
			self.bins.incnumerator(x, y)

	def finish(self):
		self.axes.contour(self.bins.xcoords, self.bins.ycoords, self.bins.numerator)
		self.axes.plot(self.tisi_offsets_x, self.tisi_offsets_y, "k+")
		self.axes.set_title("Coincident Trigger Rate vs. Offset")


#
# =============================================================================
#
#                             Confidence Contours
#
# =============================================================================
#

class ConfidenceScatter(object):
	def __init__(self, x_instrument, y_instrument):
		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.n_foreground = 0
		self.n_background = 0
		self.foreground_x = []
		self.foreground_y = []
		self.background_x = []
		self.background_y = []
		self.fig = figure.Figure()
		self.canvas = FigureCanvasAgg(self.fig)
		self.axes = self.fig.gca()

		self.axes.loglog()
		self.axes.grid(True)

		self.axes.set_xlabel("%s Confidence" % x_instrument)
		self.axes.set_ylabel("%s COnfidence" % y_instrument)

	def addto(self, doc):
		for foreground, trigs in CoincEventIter(doc):
			if foreground:
				self.n_foreground += 1
				for trig in trigs:
					if trig.ifo == self.x_instrument:
						self.foreground_x.append(-trig.confidence)
					elif trig.ifo == self.y_instrument:
						self.foreground_y.append(-trig.confidence)
			else:
				self.n_background += 1
				for trig in trigs:
					if trig.ifo == self.x_instrument:
						self.background_x.append(-trig.confidence)
					elif trig.ifo == self.y_instrument:
						self.background_y.append(-trig.confidence)

	def finish(self):
		self.axes.set_title("Coincident Trigger Confidence")
		self.axes.plot(self.background_x, self.background_y, "k+")
		self.axes.plot(self.foreground_x, self.foreground_y, "rx")


#
# =============================================================================
#
#                                     Plot
#
# =============================================================================
#

plots = (RateContours(options.x_instrument, options.y_instrument), ConfidenceScatter("H2", "H1"), ConfidenceScatter("H2", "L1"), ConfidenceScatter("L1", "H1"))

try:
	for n, url in enumerate(urls):
		if options.verbose:
			print >>sys.stderr, "%d/%d: %s\nloading..." % (n + 1, len(urls), url)
		doc = llwapp.load_url(url)
		if options.verbose:
			print >>sys.stderr, "indexing..."
		contents = DocContents(doc)
		for n, plot in enumerate(plots):
			if options.verbose:
				print >>sys.stderr, "adding to plot %d..." % n
			plot.addto(contents)
		doc.unlink()
		gc.collect()
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)

if options.verbose:
	print >>sys.stderr, "finishing..."
for plot in plots:
	plot.finish()


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

for n, plot in enumerate(plots):
	filename = "%s%d.%s" % (options.base, n, options.format)
	if options.verbose:
		print >>sys.stderr, "writing %s..." % filename
	plot.fig.savefig(filename)
