#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

from optparse import OptionParser
import math
import matplotlib.cm
import numarray
import sys

from glue import segments
from glue.ligolw import table
from glue.ligolw import lsctables
from pylal import llwapp
from pylal import rate
from pylal import SnglBurstUtils
from pylal.date import LIGOTimeGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("-b", "--base", metavar = "base", default = "plotburca_", help = "set the prefix for output filenames (default = plotburca_)")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("-l", "--live-time-program", metavar = "program", default = "power", help = "set the name, as it appears in the process table, of the program whose search summary entries define the search live time (default = power)")
	parser.add_option("--plot", metavar = "number", action = "append", default = None, help = "generate the given plot number")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	if options.plot:
		options.plot = map(int, options.plot)
	else:
		options.plot = range(7)

	return options, (filenames or [None])


#
# =============================================================================
#
#                                Rate Contours
#
# =============================================================================
#

def time_slide_is_null(offsets):
	for offset in offsets.itervalues():
		if offset != 0:
			return False
	return True


class RateContours(SnglBurstUtils.BurstPlot):
	def __init__(self, x_instrument, y_instrument, min_delta_t, max_delta_t):
		SnglBurstUtils.BurstPlot.__init__(self, "%s Offset (s)" % x_instrument, "%s Offset (s)" % y_instrument)
		self.fig.set_figsize_inches(16,16)
		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.tisi_rows = None
		self.seglists = None
		self.bins = rate.BinnedRatios(rate.Bins(min_delta_t, max_delta_t, 81, min_delta_t, max_delta_t, 81))

	def add_contents(self, contents):
		if self.tisi_rows == None:
			self.tisi_rows = contents.TimeSlide.all_offsets()
		if self.seglists == None:
			self.seglists = contents.seglists
		else:
			for instrument, seglist in contents.seglists.iteritems():
				self.seglists[instrument] |= seglist
		for coinc in contents.Coinc.selectBy(coinc_def_id = contents.bb_definer_id):
			offsets = coinc.get_time_slide()
			self.bins.incnumerator((offsets[self.x_instrument], offsets[self.y_instrument]))

	def finish(self):
		for offsets in self.tisi_rows:
			self.seglists.offsets.update(offsets)
			self.bins.incdenominator((offsets[self.x_instrument], offsets[self.y_instrument]), float(self.seglists.intersection(self.seglists.keys()).duration()))
		self.bins.logregularize()
		zvals = self.bins.ratio()
		rate.filter_array(zvals, rate.gaussian_window2d(8, 8))
		xcoords, ycoords = self.bins.centres()
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(zvals)))
		for offsets in self.tisi_rows:
			if time_slide_is_null(offsets):
				self.axes.plot((offsets[self.x_instrument],), (offsets[self.y_instrument],), "r+")
			else:
				self.axes.plot((offsets[self.x_instrument],), (offsets[self.y_instrument],), "k+")

		self.axes.set_xlim([self.bins.bins.min[0], self.bins.bins.max[0]])
		self.axes.set_ylim([self.bins.bins.min[1], self.bins.bins.max[1]])
		self.axes.set_title(r"Coincident Event Rate vs. Offset (Logarithmic Rate Contours)")


#
# =============================================================================
#
#                              Confidence Scatter
#
# =============================================================================
#

class ConfidenceContours(SnglBurstUtils.BurstPlot):
	def __init__(self, x_instrument, y_instrument, min_confidence, max_confidence):
		SnglBurstUtils.BurstPlot.__init__(self, "%s Confidence" % x_instrument, "%s Confidence" % y_instrument)
		self.fig.set_figsize_inches(16,16)
		self.axes.loglog()

		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.coinc_injections_x = []
		self.coinc_injections_y = []
		self.n_foreground = 0
		self.n_background = 0
		self.n_injections = 0
		self.foreground_bins = rate.BinnedArray(rate.Bins(min_confidence, max_confidence, 1024, min_confidence, max_confidence, 1024, spacing = ["log", "log"]))
		self.background_bins = rate.BinnedArray(rate.Bins(min_confidence, max_confidence, 1024, min_confidence, max_confidence, 1024, spacing = ["log", "log"]))

	def add_contents(self, contents):
		for coinc in contents.Coinc.selectBy(coinc_def_id = contents.bb_definer_id):
			if coinc.is_zero_lag():
				self.n_foreground += 1
				x = y = None
				for burst in coinc.sngl_bursts:
					if burst.ifo == self.x_instrument:
						x = -burst.confidence
					elif burst.ifo == self.y_instrument:
						y = -burst.confidence
				self.foreground_bins[x, y] += 1
			else:
				self.n_background += 1
				x = y = None
				for burst in coinc.sngl_bursts:
					if burst.ifo == self.x_instrument:
						x = -burst.confidence
					elif burst.ifo == self.y_instrument:
						y = -burst.confidence
				self.background_bins[x, y] += 1
		for coinc in contents.Coinc.selectBy(coinc_def_id = contents.sc_definer_id):
			self.n_injections += 1
			for burst in coinc.sngl_bursts:
				if burst.ifo == self.x_instrument:
					self.coinc_injections_x.append(-burst.confidence)
				elif burst.ifo == self.y_instrument:
					self.coinc_injections_y.append(-burst.confidence)

	def finish(self):
		self.axes.set_title(r"Distribution of Coincident Event Confidence (%d Foreground, %d Background Events, %d Injections Found in Coincidence, Logarithmic Density Contours)" % (self.n_foreground, self.n_background, self.n_injections))
		xcoords, ycoords = self.background_bins.centres()

		# prepare the data
		rate.filter_array(self.background_bins.array, rate.gaussian_window2d(8, 8))
		rate.filter_array(self.foreground_bins.array, rate.gaussian_window2d(8, 8))
		self.background_bins.logregularize()
		self.foreground_bins.logregularize()

		# plot background contours
		max_density = math.log(self.background_bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.background_bins.array)), [max_density - n for n in xrange(0, 10, 1)], cmap = matplotlib.cm.Greys)

		# plot foreground (zero-lag) contours
		max_density = math.log(self.foreground_bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.foreground_bins.array)), [max_density - n for n in xrange(0, 10, 1)], cmap = matplotlib.cm.Reds)

		# mark injections
		self.axes.plot(self.coinc_injections_x, self.coinc_injections_y, "b+")

		# fix axes limits
		self.axes.set_xlim([self.background_bins.bins.min[0], self.background_bins.bins.max[0]])
		self.axes.set_ylim([self.background_bins.bins.min[1], self.background_bins.bins.max[1]])


#
# =============================================================================
#
#                              Delta-t Histogram
#
# =============================================================================
#

class DeltaTHistogram(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, interval, width):
		SnglBurstUtils.BurstPlot.__init__(self, "Offset (s)", "Events per Unit Offset")
		self.instrument = instrument
		self.n_foreground = 0
		self.n_background = 0
		self.foreground = rate.Rate(interval, width)
		self.background = rate.Rate(interval, width)

	def add_contents(self, contents):
		for coinc in contents.Coinc.selectBy(coinc_def_id = contents.bb_definer_id):
			offsets = coinc.get_time_slide()
			if self.instrument not in offsets:
				continue
			# sum = len(bursts) * peak_time for this instrument
			# - sum of peak times of all instruments.  Dividing
			# this by len(bursts) gives the peak time for this
			# instrument - the average of all peak times.  I
			# compute this the way I do to avoid a (very
			# expensive!) LIGOTimeGPS division operation.
			sum = 0
			bursts = list(coinc.sngl_bursts)
			for burst in bursts:
				peak = burst.get_peak() + offsets[burst.ifo]
				if burst.ifo != self.instrument:
					sum -= peak
				else:
					sum += (len(bursts) - 1) * peak
			if coinc.is_zero_lag():
				self.n_foreground += 1
				self.foreground[float(sum) / len(bursts)] = 1.0
			else:
				self.n_background += 1
				self.background[float(sum) / len(bursts)] = 1.0

	def finish(self):
		self.axes.set_title(r"%s Peak Time Offset From Coincidence Mean (%d Foreground, %d Background Events)" % (self.instrument, self.n_foreground, self.n_background))
		self.axes.plot(self.background.xvals(), self.background.filtered(), "k")
		self.axes.plot(self.foreground.xvals(), self.foreground.filtered(), "r")


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

def new_plots(plots):
	deltat_seg = segments.segment(-0.3, +0.3)
	deltat_width = 0.03125
	l = [
		RateContours("H2", "H1", -100, +100),
		ConfidenceContours("H2", "H1", 30, 10**10),
		ConfidenceContours("H2", "L1", 30, 10**10),
		ConfidenceContours("L1", "H1", 30, 10**10),
		DeltaTHistogram("H1", deltat_seg, deltat_width),
		DeltaTHistogram("H2", deltat_seg, deltat_width),
		DeltaTHistogram("L1", deltat_seg, deltat_width)
	]
	return [l[i] for i in plots]

options, filenames = parse_command_line()

plots = new_plots(options.plot)

database = SnglBurstUtils.CoincDatabase(SnglBurstUtils.CoincDatabaseConnection())

for n, filename in enumerate(llwapp.sort_files_by_size(filenames, options.verbose, reverse = True)):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	if filename[-3:] == ".gz":
		xmldoc = llwapp.load_filename(filename, options.verbose, gz = True)
	else:
		xmldoc = llwapp.load_filename(filename, options.verbose)
	database.summarize(xmldoc, options.live_time_program, options.verbose)
	xmldoc.unlink()
	del xmldoc
	for n, plot in zip(options.plot, plots):
		if options.verbose:
			print >>sys.stderr, "adding to burca plot %d..." % n
		plot.add_contents(database)
	database.clear()


# delete the plots as we go to save memory
n = 0
format = "%%s%%0%dd.%%s" % (int(math.log10(len(plots))) + 1)
while len(plots):
	filename = format % (options.base, options.plot[n], options.format)
	if options.verbose:
		print >>sys.stderr, "finishing plot %d..." % options.plot[n]
	plots[0].finish()
	if options.verbose:
		print >>sys.stderr, "writing %s..." % filename
	plots[0].fig.savefig(filename)
	del plots[0]
	n += 1
if options.verbose:
	print >>sys.stderr, "done."
