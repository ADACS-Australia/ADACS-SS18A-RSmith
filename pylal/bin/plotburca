#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

from optparse import OptionParser
import math
import matplotlib
matplotlib.use("Agg")
from matplotlib import figure
from matplotlib.backends.backend_agg import FigureCanvasAgg
import numarray
import sys

from glue import segments
from glue.ligolw import lsctables
from pylal import llwapp
from pylal import rate
from pylal.date import LIGOTimeGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("-b", "--base", metavar = "base", default = "plotburca_", help = "set the prefix for output filenames (default = plotburca_)")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("-l", "--live-time-program", metavar = "program", default = "power", help = "set the name, as it appears in the process table, of the program whose search summary entries define the search live time (default = power)")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	return options, (filenames or [None])


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

class SnglBurst(object):
	__slots__ = ["ifo", "central_freq", "confidence", "peak_time", "peak_time_ns", "event_id"]

	def get_peak(self):
		return LIGOTimeGPS(self.peak_time, self.peak_time_ns)

def snglburst_init(self, attrs):
	lsctables.LSCTableUnique.__init__(self, attrs)
	self.rows = {}

def snglburst_append(self, row):
	self.rows[lsctables.ILWDID(row.event_id)] = row
	del row.event_id

def coinc_init(self, attrs):
	lsctables.LSCTableUnique.__init__(self, attrs)
	self.rows = {}

def coinc_append(self, row):
	self.rows[lsctables.ILWDID(row.coinc_event_id)] = lsctables.ILWDID(row.time_slide_id)

def coinc_map_init(self, attrs):
	lsctables.LSCTableUnique.__init__(self, attrs)
	self.rows = {}

def coinc_map_append(self, row):
	id = lsctables.ILWDID(row.coinc_event_id)
	if id in self.rows:
		self.rows[id].append(lsctables.ILWDID(row.event_id))
	else:
		self.rows[id] = [lsctables.ILWDID(row.event_id)]

def timeslide_init(self, attrs):
	lsctables.LSCTableMulti.__init__(self, attrs)
	self.rows = {}

def timeslide_append(self, row):
	id = lsctables.ILWDID(row.time_slide_id)
	if id in self.rows:
		self.rows[id][row.instrument] = row.offset
	else:
		self.rows[id] = {row.instrument: row.offset}

lsctables.SnglBurstTable.RowType = SnglBurst
lsctables.SnglBurstTable.__init__ = snglburst_init
lsctables.SnglBurstTable.append = snglburst_append
lsctables.CoincTable.__init__ = coinc_init
lsctables.CoincTable.append = coinc_append
lsctables.CoincMapTable.__init__ = coinc_map_init
lsctables.CoincMapTable.append = coinc_map_append
lsctables.TimeSlideTable.__init__ = timeslide_init
lsctables.TimeSlideTable.append = timeslide_append


#
# =============================================================================
#
#                            Document Comprehension
#
# =============================================================================
#

class DocContents(object):
	def __init__(self, xmldoc, live_time_program):
		#
		# Extract tables
		#

		self.coinctable = llwapp.get_table(xmldoc, lsctables.CoincTable.tableName)
		self.coincmaptable = llwapp.get_table(xmldoc, lsctables.CoincMapTable.tableName)
		self.tisitable = llwapp.get_table(xmldoc, lsctables.TimeSlideTable.tableName)

		#
		# Extract segmentlist dictionary
		#

		self.seglistdict = llwapp.get_seglistdict(xmldoc, live_time_program)

		#
		# Find foreground time slide
		#

		self.foreground_tisi_id = None
		for self.foreground_tisi_id, offsetdict in self.tisitable.rows.iteritems():
			for offset in offsetdict.itervalues():
				if offset != 0.0:
					continue
			break

		#
		# Build coinc_event_map --> sngl_burst references
		#

		burstrows = llwapp.get_table(xmldoc, lsctables.SnglBurstTable.tableName).rows
		for key, value in self.coincmaptable.rows.iteritems():
			self.coincmaptable.rows[key] = map(burstrows.__getitem__, value)


#
# =============================================================================
#
#                            Coincidence Iterators
#
# =============================================================================
#

def CoincEventIter(doc):
	"""
	Generates a sequence of tuples, one for each coincidence in the
	data set.  The first element of each tuple is True or False
	indicating if the coincidence is a foreground event, the second
	element is the time slide dictionary at which the coincidence was
	found, and the third is a list of the sngl_burst events in the
	coincidence.
	"""
	for coinc_id, tisi_id in doc.coinctable.rows.iteritems():
		yield tisi_id == doc.foreground_tisi_id, doc.tisitable.rows[tisi_id], doc.coincmaptable.rows[coinc_id]


def CoincTisiIter(doc):
	"""
	Generates a sequence of time-slide dictionaries, one for each
	coincidence in the data set, indicating the time slide at which the
	corresponding coincidence was found.
	"""
	for tisi_id in doc.coinctable.rows.itervalues():
		yield doc.tisitable.rows[tisi_id]


#
# =============================================================================
#
#                                Rate Contours
#
# =============================================================================
#

class RateContours(object):
	def __init__(self, x_instrument, y_instrument):
		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.tisirows = None
		self.seglistdict = None
		self.fig = figure.Figure()
		FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16,16)
		self.axes = self.fig.gca()
		self.bins = rate.BinnedRatios(rate.Bins(-100.0, 100.0, 11, -100.0, 100.0, 11))
		self.axes.grid(True)
		self.axes.set_xlabel("%s Offset (s)" % x_instrument)
		self.axes.set_ylabel("%s Offset (s)" % y_instrument)

	def addto(self, doc):
		if self.tisirows == None:
			self.tisirows = doc.tisitable.rows.values()
		if self.seglistdict == None:
			self.seglistdict = doc.seglistdict
		else:
			for instrument, seglist in doc.seglistdict.iteritems():
				self.seglistdict[instrument] |= seglist
		for offsetdict in CoincTisiIter(doc):
			self.bins.incnumerator((offsetdict[self.x_instrument], offsetdict[self.y_instrument]))

	def finish(self):
		instruments = self.seglistdict.keys()
		for row in self.tisirows:
			self.seglistdict.set_offsets({self.x_instrument: row[self.x_instrument], self.y_instrument: row[self.y_instrument]})
			self.bins.incdenominator((row[self.x_instrument], row[self.y_instrument]), float(self.seglistdict.intersect(instruments).duration()))
		self.bins.normalize()
		xcoords, ycoords = self.bins.centres()
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.bins.numerator / self.bins.denominator)))
		for row in self.tisirows:
			self.axes.plot((row[self.x_instrument],), (row[self.y_instrument],), "k+")
		self.axes.set_title("Coincident Trigger Rate vs. Offset\n(Logarithmic Contours)")


#
# =============================================================================
#
#                              Confidence Scatter
#
# =============================================================================
#

class ConfidenceScatter(object):
	def __init__(self, x_instrument, y_instrument):
		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.n_foreground = 0
		self.n_background = 0
		self.foreground_x = []
		self.foreground_y = []
		self.background_x = []
		self.background_y = []
		self.fig = figure.Figure()
		FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16,16)
		self.axes = self.fig.gca()
		self.axes.loglog()
		self.axes.grid(True)
		self.axes.set_xlabel("%s Confidence" % x_instrument)
		self.axes.set_ylabel("%s Confidence" % y_instrument)

	def addto(self, doc):
		for foreground, tisi, trigs in CoincEventIter(doc):
			if foreground:
				self.n_foreground += 1
				for trig in trigs:
					if trig.ifo == self.x_instrument:
						self.foreground_x.append(-trig.confidence)
					elif trig.ifo == self.y_instrument:
						self.foreground_y.append(-trig.confidence)
			else:
				self.n_background += 1
				for trig in trigs:
					if trig.ifo == self.x_instrument:
						self.background_x.append(-trig.confidence)
					elif trig.ifo == self.y_instrument:
						self.background_y.append(-trig.confidence)

	def finish(self):
		self.axes.set_title("Coincident Trigger Confidence\n(%d Foreground, %d Background Triggers)" % (self.n_foreground, self.n_background))
		self.axes.plot(self.background_x, self.background_y, "k+")
		self.axes.plot(self.foreground_x, self.foreground_y, "rx")


#
# =============================================================================
#
#                              Delta-t Histogram
#
# =============================================================================
#

class DeltaTHistogram(object):
	def __init__(self, instrument, interval, width):
		self.instrument = instrument
		self.n_foreground = 0
		self.n_background = 0
		self.foreground = rate.Rate1D(interval, width)
		self.background = rate.Rate1D(interval, width)
		self.fig = figure.Figure()
		FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16,8)
		self.axes = self.fig.gca()
		self.axes.grid(True)
		self.axes.set_xlabel("Offset (s)")
		self.axes.set_ylabel("Triggers per Unit Offset")

	def addto(self, doc):
		for foreground, tisi, trigs in CoincEventIter(doc):
			n = len(trigs)
			mean = 0
			t = None
			for trig in trigs:
				peak = trig.get_peak() + tisi[trig.ifo]
				mean += peak / n
				if trig.ifo == self.instrument:
					t = peak
			if t != None:
				if foreground:
					self.n_foreground += 1
					self.foreground[t - mean] = 1.0
				else:
					self.n_background += 1
					self.background[t - mean] = 1.0

	def finish(self):
		self.axes.set_title("%s Peak Time Offset From Coincidence Mean\n(%d Foreground, %d Background Triggers)" % (self.instrument, self.n_foreground, self.n_background))
		self.background.convolve()
		self.foreground.convolve()
		self.axes.plot(self.background.xvals, self.background.yvals, "k")
		self.axes.plot(self.foreground.xvals, self.foreground.yvals, "r")


#
# =============================================================================
#
#                                     Plot
#
# =============================================================================
#

deltat_seg = segments.segment(-0.3, +0.3)
deltat_width = 0.03125

plots = [
	RateContours("H2", "H1"),
	ConfidenceScatter("H2", "H1"),
	ConfidenceScatter("H2", "L1"),
	ConfidenceScatter("L1", "H1"),
	DeltaTHistogram("H1", deltat_seg, deltat_width),
	DeltaTHistogram("H2", deltat_seg, deltat_width),
	DeltaTHistogram("L1", deltat_seg, deltat_width)
]

options, filenames = parse_command_line()
for n, filename in enumerate(llwapp.sort_files(filenames, options.verbose)):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	doc = llwapp.load_filename(filename, options.verbose)
	if options.verbose:
		print >>sys.stderr, "indexing..."
	contents = DocContents(doc, options.live_time_program)
	for n, plot in enumerate(plots):
		if options.verbose:
			print >>sys.stderr, "adding to plot %d..." % n
		plot.addto(contents)
	doc.unlink()


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

# delete the plots as we go to save memory
n = 0
format = "%%s%%0%dd.%%s" % (int(math.log10(len(plots))) + 1)
while len(plots):
	filename = format % (options.base, n, options.format)
	if options.verbose:
		print >>sys.stderr, "finishing plot %d..." % n
	plots[0].finish()
	if options.verbose:
		print >>sys.stderr, "writing %s..." % filename
	plots[0].fig.savefig(filename)
	del plots[0]
	n += 1
if options.verbose:
	print >>sys.stderr, "done."
