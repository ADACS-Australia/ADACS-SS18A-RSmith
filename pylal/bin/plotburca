#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

from optparse import OptionParser
import math
import matplotlib
matplotlib.use("Agg")
from matplotlib import figure
from matplotlib.backends.backend_agg import FigureCanvasAgg
import numarray
import sys

from glue import segments
from glue.ligolw import lsctables
from pylal import llwapp
from pylal import rate
from pylal.date import LIGOTimeGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("-b", "--base", metavar = "base", default = "plotburca_", help = "set the prefix for output filenames (default = plotburca_)")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("-l", "--live-time-program", metavar = "program", default = "power", help = "set the name, as it appears in the process table, of the program whose search summary entries define the search live time (default = power)")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	return options, (filenames or [None])


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

def snglburst_init(self, attrs):
	lsctables.LSCTableUnique.__init__(self, attrs)
	self.rows = {}

def snglburst_append(self, row):
	self.rows[lsctables.ILWDID(row.event_id)] = row
	del row.event_id

def coinc_def_init(self, attrs):
	lsctables.LSCTableMulti.__init__(self, attrs)
	self.rows = {}

def coinc_def_append(self, row):
	id = lsctables.ILWDID(row.coinc_def_id)
	if id in self.rows:
		self.rows[id].append(row.table_name)
		self.rows[id].sort()
	else:
		self.rows[id] = [row.table_name]

def coinc_map_init(self, attrs):
	lsctables.LSCTableUnique.__init__(self, attrs)
	self.rows = {}

def coinc_map_append(self, row):
	id = lsctables.ILWDID(row.coinc_event_id)
	if id in self.rows:
		self.rows[id].append(lsctables.ILWDID(row.event_id))
	else:
		self.rows[id] = [lsctables.ILWDID(row.event_id)]

def coinc_append(self, row):
	row.time_slide_id = lsctables.ILWDID(row.time_slide_id)
	row.coinc_def_id = lsctables.ILWDID(row.coinc_def_id)
	row.coinc_event_id = lsctables.ILWDID(row.coinc_event_id)
	self.rows.append(row)

def timeslide_init(self, attrs):
	lsctables.LSCTableMulti.__init__(self, attrs)
	self.rows = {}

def timeslide_append(self, row):
	id = lsctables.ILWDID(row.time_slide_id)
	if id in self.rows:
		self.rows[id][row.instrument] = row.offset
	else:
		self.rows[id] = {row.instrument: row.offset}

lsctables.SnglBurstTable.loadcolumns = ["ifo", "central_freq", "confidence", "peak_time", "peak_time_ns", "event_id"]
lsctables.SnglBurstTable.__init__ = snglburst_init
lsctables.SnglBurstTable.append = snglburst_append
lsctables.CoincDefTable.__init__ = coinc_def_init
lsctables.CoincDefTable.append = coinc_def_append
lsctables.CoincTable.append = coinc_append
lsctables.CoincMapTable.__init__ = coinc_map_init
lsctables.CoincMapTable.append = coinc_map_append
lsctables.TimeSlideTable.__init__ = timeslide_init
lsctables.TimeSlideTable.append = timeslide_append


#
# =============================================================================
#
#                            Document Comprehension
#
# =============================================================================
#

class DocContents(object):
	def __init__(self, xmldoc, live_time_program):
		#
		# Extract tables
		#

		self.coinc_rows = llwapp.get_table(xmldoc, lsctables.CoincTable.tableName).rows
		self.tisi_rows = llwapp.get_table(xmldoc, lsctables.TimeSlideTable.tableName).rows

		#
		# Extract segmentlist dictionary
		#

		self.seglistdict = llwapp.segmentlistdict_fromsearchsummary(xmldoc, live_time_program)

		#
		# Replace ID attributes of each coinc_event row with
		# references to the corresponding objects in the other
		# tables.
		#

		coinc_def_rows = llwapp.get_table(xmldoc, lsctables.CoincDefTable.tableName).rows
		coinc_map_rows = llwapp.get_table(xmldoc, lsctables.CoincMapTable.tableName).rows
		burst_rows = llwapp.get_table(xmldoc, lsctables.SnglBurstTable.tableName).rows
		for coinc_row in self.coinc_rows:
			coinc_row.time_slide_id = self.tisi_rows[coinc_row.time_slide_id]
			coinc_row.coinc_def_id = coinc_def_rows[coinc_row.coinc_def_id]
			coinc_row.coinc_event_id = map(burst_rows.__getitem__, coinc_map_rows[coinc_row.coinc_event_id])


#
# =============================================================================
#
#                            Coincidence Iterators
#
# =============================================================================
#

def time_slide_is_null(offsetdict):
	"""
	Test for all-zero time slide.
	"""
	for offset in offsetdict.itervalues():
		if offset:
			return False
	return True


def CoincEventIter(doc):
	"""
	Generates a sequence of tuples, one for each coincidence in the
	data set.  The first element of each tuple is True or False
	indicating if the coincidence is a foreground event, the second
	element is the time slide dictionary at which the coincidence was
	found, and the third is a list of the sngl_burst events in the
	coincidence.
	"""
	for row in doc.coinc_rows:
		yield time_slide_is_null(row.time_slide_id), row.time_slide_id, row.coinc_event_id


def CoincTisiIter(doc):
	"""
	Generates a sequence of time-slide dictionaries, one for each
	coincidence in the data set, indicating the time slide at which the
	corresponding coincidence was found.
	"""
	for row in doc.coinc_rows:
		yield row.time_slide_id


#
# =============================================================================
#
#                                Rate Contours
#
# =============================================================================
#

class RateContours(object):
	def __init__(self, x_instrument, y_instrument):
		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.tisi_rows = None
		self.seglistdict = None
		self.fig = figure.Figure()
		FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16,16)
		self.axes = self.fig.gca()
		self.bins = rate.BinnedRatios(rate.Bins(-100, 100, 81, -100, 100, 81))
		self.axes.grid(True)
		self.axes.set_xlabel("%s Offset (s)" % x_instrument)
		self.axes.set_ylabel("%s Offset (s)" % y_instrument)

	def addto(self, doc):
		if self.tisi_rows == None:
			self.tisi_rows = doc.tisi_rows.values()
		if self.seglistdict == None:
			self.seglistdict = doc.seglistdict
		else:
			for instrument, seglist in doc.seglistdict.iteritems():
				self.seglistdict[instrument] |= seglist
		for offsetdict in CoincTisiIter(doc):
			self.bins.incnumerator((offsetdict[self.x_instrument], offsetdict[self.y_instrument]))

	def finish(self):
		for row in self.tisi_rows:
			self.seglistdict.offsets.update(row)
			self.bins.incdenominator((row[self.x_instrument], row[self.y_instrument]), float(self.seglistdict.intersection(self.seglistdict.keys()).duration()))
		self.bins.logregularize()
		zvals = self.bins.ratio()
		rate.filter_array(zvals, rate.gaussian_window2d(8, 8))
		xcoords, ycoords = self.bins.centres()
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(zvals)))
		for row in self.tisi_rows:
			self.axes.plot((row[self.x_instrument],), (row[self.y_instrument],), "k+")
		self.axes.set_title("Coincident Trigger Rate vs. Offset\n(Logarithmic Contours)")


#
# =============================================================================
#
#                              Confidence Scatter
#
# =============================================================================
#

class ConfidenceScatter(object):
	def __init__(self, x_instrument, y_instrument):
		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.n_foreground = 0
		self.n_background = 0
		self.foreground_x = []
		self.foreground_y = []
		self.background_x = []
		self.background_y = []
		self.fig = figure.Figure()
		FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16,16)
		self.axes = self.fig.gca()
		self.axes.loglog()
		self.axes.grid(True)
		self.axes.set_xlabel("%s Confidence" % x_instrument)
		self.axes.set_ylabel("%s Confidence" % y_instrument)

	def addto(self, doc):
		for foreground, tisi, trigs in CoincEventIter(doc):
			if foreground:
				self.n_foreground += 1
				for trig in trigs:
					if trig.ifo == self.x_instrument:
						self.foreground_x.append(-trig.confidence)
					elif trig.ifo == self.y_instrument:
						self.foreground_y.append(-trig.confidence)
			else:
				self.n_background += 1
				for trig in trigs:
					if trig.ifo == self.x_instrument:
						self.background_x.append(-trig.confidence)
					elif trig.ifo == self.y_instrument:
						self.background_y.append(-trig.confidence)

	def finish(self):
		self.axes.set_title("Coincident Trigger Confidence\n(%d Foreground, %d Background Triggers)" % (self.n_foreground, self.n_background))

		#self.axes.plot(self.background_x, self.background_y, "k+")
		#self.axes.plot(self.foreground_x, self.foreground_y, "rx")

		bins = rate.BinnedArray(rate.Bins(min(self.background_x + self.foreground_x), max(self.background_x + self.foreground_x), 1024, min(self.background_y + self.foreground_y), max(self.background_y + self.foreground_y), 1024, spacing = ["log", "log"]))
		for coords in zip(self.background_x, self.background_y):
			bins[coords] += 1
		for coords in zip(self.foreground_x, self.foreground_y):
			bins[coords] += 1
		rate.filter_array(bins.array, rate.gaussian_window2d(8, 8))
		bins.logregularize()
		xcoords, ycoords = bins.centres()
		max_density = math.log(bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(bins.array)), [max_density - n for n in xrange(0, 10, 1)])


#
# =============================================================================
#
#                              Delta-t Histogram
#
# =============================================================================
#

class DeltaTHistogram(object):
	def __init__(self, instrument, interval, width):
		self.instrument = instrument
		self.n_foreground = 0
		self.n_background = 0
		self.foreground = rate.Rate(interval, width)
		self.background = rate.Rate(interval, width)
		self.fig = figure.Figure()
		FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16,8)
		self.axes = self.fig.gca()
		self.axes.grid(True)
		self.axes.set_xlabel("Offset (s)")
		self.axes.set_ylabel("Triggers per Unit Offset")

	def addto(self, doc):
		for foreground, tisi, trigs in CoincEventIter(doc):
			n = len(trigs)
			mean = 0
			t = None
			for trig in trigs:
				peak = trig.get_peak() + tisi[trig.ifo]
				mean += peak / n
				if trig.ifo == self.instrument:
					t = peak
			if t != None:
				if foreground:
					self.n_foreground += 1
					self.foreground[t - mean] = 1.0
				else:
					self.n_background += 1
					self.background[t - mean] = 1.0

	def finish(self):
		self.axes.set_title("%s Peak Time Offset From Coincidence Mean\n(%d Foreground, %d Background Triggers)" % (self.instrument, self.n_foreground, self.n_background))
		self.axes.plot(self.background.xvals(), self.background.filtered(), "k")
		self.axes.plot(self.foreground.xvals(), self.foreground.filtered(), "r")


#
# =============================================================================
#
#                                     Plot
#
# =============================================================================
#

deltat_seg = segments.segment(-0.3, +0.3)
deltat_width = 0.03125

plots = [
	RateContours("H2", "H1"),
	ConfidenceScatter("H2", "H1"),
	ConfidenceScatter("H2", "L1"),
	ConfidenceScatter("L1", "H1"),
	DeltaTHistogram("H1", deltat_seg, deltat_width),
	DeltaTHistogram("H2", deltat_seg, deltat_width),
	DeltaTHistogram("L1", deltat_seg, deltat_width)
]

options, filenames = parse_command_line()
for n, filename in enumerate(llwapp.sort_files_by_size(filenames, options.verbose, reverse = True)):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	doc = llwapp.load_filename(filename, options.verbose)
	if options.verbose:
		print >>sys.stderr, "indexing..."
	contents = DocContents(doc, options.live_time_program)
	doc.unlink()
	del doc
	for n, plot in enumerate(plots):
		if options.verbose:
			print >>sys.stderr, "adding to plot %d..." % n
		plot.addto(contents)


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

# delete the plots as we go to save memory
n = 0
format = "%%s%%0%dd.%%s" % (int(math.log10(len(plots))) + 1)
while len(plots):
	filename = format % (options.base, n, options.format)
	if options.verbose:
		print >>sys.stderr, "finishing plot %d..." % n
	plots[0].finish()
	if options.verbose:
		print >>sys.stderr, "writing %s..." % filename
	plots[0].fig.savefig(filename)
	del plots[0]
	n += 1
if options.verbose:
	print >>sys.stderr, "done."
