#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

from optparse import OptionParser
import math
import matplotlib.cm
import numarray
import sqlobject
import sys

from glue import segments
from glue.ligolw import table
from glue.ligolw import lsctables
from pylal import llwapp
from pylal import rate
from pylal import SnglBurstUtils
from pylal.date import LIGOTimeGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("-b", "--base", metavar = "base", default = "plotburca_", help = "set the prefix for output filenames (default = plotburca_)")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("-l", "--live-time-program", metavar = "program", default = "power", help = "set the name, as it appears in the process table, of the program whose search summary entries define the search live time (default = power)")
	parser.add_option("--plot", metavar = "number", action = "append", default = None, help = "only generate the given plot number")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	if options.plot:
		options.plot = map(int, options.plot)
	else:
		options.plot = [0, 1, 2, 3, 4, 5, 6]

	return options, (filenames or [None])


#
# =============================================================================
#
#                                   Database
#
# =============================================================================
#

sqlobject.sqlhub.processConnection = sqlobject.connectionForURI("sqlite:/:memory:")


class SnglBurst(sqlobject.SQLObject):
	class sqlmeta:
		idName = "event_id"
	ifo = sqlobject.StringCol(length = 2)
	central_freq = sqlobject.FloatCol()
	confidence = sqlobject.FloatCol()
	peak_time = sqlobject.IntCol()
	peak_time_ns = sqlobject.IntCol()

	def get_peak(self):
		return LIGOTimeGPS(self.peak_time, self.peak_time_ns)


class SimBurst(sqlobject.SQLObject):
	class sqlmeta:
		idName = "simulation_id"
	geocent_peak_time = sqlobject.IntCol()
	geocent_peak_time_ns = sqlobject.IntCol()
	h_peak_time = sqlobject.IntCol()
	h_peak_time_ns = sqlobject.IntCol()
	l_peak_time = sqlobject.IntCol()
	l_peak_time_ns = sqlobject.IntCol()
	freq = sqlobject.FloatCol()
	hrss = sqlobject.FloatCol()


class TimeSlide(sqlobject.SQLObject):
	class sqlmeta:
		idName = "time_slide_id"
	dict = sqlobject.PickleCol()

	def is_null(self):
		for offset in self.dict.itervalues():
			if offset != 0:
				return False
		return True


class Coinc(sqlobject.SQLObject):
	class sqlmeta:
		idName = "coinc_event_id"
	coinc_def_id = sqlobject.IntCol()
	time_slide = sqlobject.ForeignKey("TimeSlide")
	sngl_bursts = sqlobject.RelatedJoin("SnglBurst")
	sim_bursts = sqlobject.RelatedJoin("SimBurst")


SnglBurst.createTable()
SimBurst.createTable()
TimeSlide.createTable()
Coinc.createTable()


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

def sngl_burst_append(self, row):
	SnglBurst(
		id = lsctables.ILWDID(row.event_id),
		ifo = row.ifo,
		central_freq = row.central_freq,
		confidence = row.confidence,
		peak_time = row.peak_time,
		peak_time_ns = row.peak_time_ns
	)


def sim_burst_append(self, row):
	SimBurst(
		id = lsctables.ILWDID(row.simulation_id),
		geocent_peak_time = row.geocent_peak_time,
		geocent_peak_time_ns = row.geocent_peak_time_ns,
		h_peak_time = row.h_peak_time,
		h_peak_time_ns = row.h_peak_time_ns,
		l_peak_time = row.l_peak_time,
		l_peak_time_ns = row.l_peak_time_ns,
		freq = row.freq,
		hrss = row.hrss
	)


def time_slide_append(self, row):
	try:
		TimeSlide.get(lsctables.ILWDID(row.time_slide_id)).dict[row.instrument] = row.offset
	except sqlobject.main.SQLObjectNotFound:
		TimeSlide(id = lsctables.ILWDID(row.time_slide_id), dict = {row.instrument: row.offset})


def coinc_append(self, row):
	Coinc(
		id = lsctables.ILWDID(row.coinc_event_id),
		coinc_def_id = lsctables.ILWDID(row.coinc_def_id),
		time_slide = TimeSlide.get(lsctables.ILWDID(row.time_slide_id))
	)


def coinc_map_append(self, row):
	coinc_event_id = lsctables.ILWDID(row.coinc_event_id)
	event_table = lsctables.ILWDTableName(row.event_id)
	event_id = lsctables.ILWDID(row.event_id)
	if not table.CompareTableNames(event_table, lsctables.SnglBurstTable.tableName):
		Coinc.get(coinc_event_id).addSnglBurst(SnglBurst.get(event_id))
	elif not table.CompareTableNames(event_table, lsctables.SimBurstTable.tableName):
		Coinc.get(coinc_event_id).addSimBurst(SimBurst.get(event_id))
	else:
		raise TypeError, row.event_id


lsctables.SnglBurstTable.append = sngl_burst_append
lsctables.SimBurstTable.append = sim_burst_append
lsctables.TimeSlideTable.append = time_slide_append
lsctables.CoincTable.append = coinc_append
lsctables.CoincMapTable.append = coinc_map_append


#
# =============================================================================
#
#                            Document Comprehension
#
# =============================================================================
#

class DocContents(object):
	def __init__(self, xmldoc, live_time_program):
		self.seglists = llwapp.segmentlistdict_fromsearchsummary(xmldoc, live_time_program)


#
# =============================================================================
#
#                                Rate Contours
#
# =============================================================================
#

def time_slide_is_null(offsets):
	for offset in offsets.itervalues():
		if offset != 0:
			return False
	return True


class RateContours(SnglBurstUtils.BurstPlot):
	def __init__(self, x_instrument, y_instrument, min_delta_t, max_delta_t):
		SnglBurstUtils.BurstPlot.__init__(self, "%s Offset (s)" % x_instrument, "%s Offset (s)" % y_instrument)
		self.fig.set_figsize_inches(16,16)
		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.tisi_rows = None
		self.seglists = None
		self.bins = rate.BinnedRatios(rate.Bins(min_delta_t, max_delta_t, 81, min_delta_t, max_delta_t, 81))

	def add_contents(self, doc):
		if self.tisi_rows == None:
			self.tisi_rows = [row.dict for row in TimeSlide.select()]
		if self.seglists == None:
			self.seglists = doc.seglists
		else:
			for instrument, seglist in doc.seglists.iteritems():
				self.seglists[instrument] |= seglist
		for row in Coinc.select():
			offsetdict = row.time_slide.dict
			self.bins.incnumerator((offsetdict[self.x_instrument], offsetdict[self.y_instrument]))

	def finish(self):
		for row in self.tisi_rows:
			self.seglists.offsets.update(row)
			self.bins.incdenominator((row[self.x_instrument], row[self.y_instrument]), float(self.seglists.intersection(self.seglists.keys()).duration()))
		self.bins.logregularize()
		zvals = self.bins.ratio()
		rate.filter_array(zvals, rate.gaussian_window2d(8, 8))
		xcoords, ycoords = self.bins.centres()
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(zvals)))
		for tisi in self.tisi_rows:
			if time_slide_is_null(tisi):
				self.axes.plot((tisi[self.x_instrument],), (tisi[self.y_instrument],), "r+")
			else:
				self.axes.plot((tisi[self.x_instrument],), (tisi[self.y_instrument],), "k+")

		self.axes.set_xlim([self.bins.bins.min[0], self.bins.bins.max[0]])
		self.axes.set_ylim([self.bins.bins.min[1], self.bins.bins.max[1]])
		self.axes.set_title(r"Coincident Event Rate vs. Offset, Logarithmic Contours")


#
# =============================================================================
#
#                              Confidence Scatter
#
# =============================================================================
#

class ConfidenceContours(SnglBurstUtils.BurstPlot):
	def __init__(self, x_instrument, y_instrument, min_confidence, max_confidence):
		SnglBurstUtils.BurstPlot.__init__(self, "%s Confidence" % x_instrument, "%s Confidence" % y_instrument)
		self.fig.set_figsize_inches(16,16)
		self.axes.loglog()

		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.n_foreground = 0
		self.n_background = 0
		self.foreground_bins = rate.BinnedArray(rate.Bins(min_confidence, max_confidence, 1024, min_confidence, max_confidence, 1024, spacing = ["log", "log"]))
		self.background_bins = rate.BinnedArray(rate.Bins(min_confidence, max_confidence, 1024, min_confidence, max_confidence, 1024, spacing = ["log", "log"]))

	def add_contents(self, doc):
		for row in Coinc.select():
			if row.sim_bursts:
				continue
			if row.time_slide.is_null():
				self.n_foreground += 1
				for burst in row.sngl_bursts:
					if burst.ifo == self.x_instrument:
						x = -burst.confidence
					elif burst.ifo == self.y_instrument:
						y = -burst.confidence
				self.foreground_bins[x, y] += 1
			else:
				self.n_background += 1
				for burst in row.sngl_bursts:
					if burst.ifo == self.x_instrument:
						x = -burst.confidence
					elif burst.ifo == self.y_instrument:
						y = -burst.confidence
				self.background_bins[x, y] += 1

	def finish(self):
		self.axes.set_title(r"Distribution of Coincident Event Confidence\\%d Foreground, %d Background Events, Logarithmic Contours" % (self.n_foreground, self.n_background))
		xcoords, ycoords = self.background_bins.centres()

		# prepare the data
		rate.filter_array(self.background_bins.array, rate.gaussian_window2d(8, 8))
		rate.filter_array(self.foreground_bins.array, rate.gaussian_window2d(8, 8))
		self.background_bins.logregularize()
		self.foreground_bins.logregularize()

		# plot background contours
		max_density = math.log(self.background_bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.background_bins.array)), [max_density - n for n in xrange(0, 10, 1)], cmap = matplotlib.cm.Greys)

		# plot foreground (zero-lag) contours
		max_density = math.log(self.foreground_bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.foreground_bins.array)), [max_density - n for n in xrange(0, 10, 1)], cmap = matplotlib.cm.Reds)

		self.axes.set_xlim([self.background_bins.bins.min[0], self.background_bins.bins.max[0]])
		self.axes.set_ylim([self.background_bins.bins.min[1], self.background_bins.bins.max[1]])


#
# =============================================================================
#
#                              Delta-t Histogram
#
# =============================================================================
#

class DeltaTHistogram(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, interval, width):
		SnglBurstUtils.BurstPlot.__init__(self, "Offset (s)", "Events per Unit Offset")
		self.instrument = instrument
		self.n_foreground = 0
		self.n_background = 0
		self.foreground = rate.Rate(interval, width)
		self.background = rate.Rate(interval, width)

	def add_contents(self, doc):
		for row in Coinc.select():
			tisi = row.time_slide.dict
			if self.instrument not in tisi:
				continue
			# sum = len(bursts) * peak_time for this instrument
			# - sum of peak times of all instruments.  Dividing
			# this by len(bursts) gives the peak time for this
			# instrument - the average of all peak times.  I
			# compute this the way I do to avoid a (very
			# expensive!) LIGOTimeGPS division operation.
			sum = 0
			for burst in row.sngl_bursts:
				peak = burst.get_peak() + tisi[burst.ifo]
				if burst.ifo != self.instrument:
					sum -= peak
				else:
					sum += (len(row.sngl_bursts) - 1) * peak
			if row.time_slide.is_null():
				self.n_foreground += 1
				self.foreground[float(sum) / len(row.sngl_bursts)] = 1.0
			else:
				self.n_background += 1
				self.background[float(sum) / len(row.sngl_bursts)] = 1.0

	def finish(self):
		self.axes.set_title(r"%s Peak Time Offset From Coincidence Mean\\%d Foreground, %d Background Events" % (self.instrument, self.n_foreground, self.n_background))
		self.axes.plot(self.background.xvals(), self.background.filtered(), "k")
		self.axes.plot(self.foreground.xvals(), self.foreground.filtered(), "r")


#
# =============================================================================
#
#                                     Plot
#
# =============================================================================
#

def new_plots(plots):
	deltat_seg = segments.segment(-0.3, +0.3)
	deltat_width = 0.03125
	l = [
		RateContours("H2", "H1", -100, +100),
		ConfidenceContours("H2", "H1", 30, 10**10),
		ConfidenceContours("H2", "L1", 30, 10**10),
		ConfidenceContours("L1", "H1", 30, 10**10),
		DeltaTHistogram("H1", deltat_seg, deltat_width),
		DeltaTHistogram("H2", deltat_seg, deltat_width),
		DeltaTHistogram("L1", deltat_seg, deltat_width)
	]
	return [l[i] for i in plots]

options, filenames = parse_command_line()

plots = new_plots(options.plot)

for n, filename in enumerate(llwapp.sort_files_by_size(filenames, options.verbose, reverse = True)):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	if filename[-3:] == ".gz":
		doc = llwapp.load_filename(filename, options.verbose, gz = True)
	else:
		doc = llwapp.load_filename(filename, options.verbose)
	if options.verbose:
		print >>sys.stderr, "indexing..."
	contents = DocContents(doc, options.live_time_program)
	doc.unlink()
	del doc
	for n, plot in enumerate(plots):
		if options.verbose:
			print >>sys.stderr, "adding to plot %d..." % options.plot[n]
		plot.add_contents(contents)


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

# delete the plots as we go to save memory
n = 0
format = "%%s%%0%dd.%%s" % (int(math.log10(len(plots))) + 1)
while len(plots):
	filename = format % (options.base, options.plot[n], options.format)
	if options.verbose:
		print >>sys.stderr, "finishing plot %d..." % options.plot[n]
	plots[0].finish()
	if options.verbose:
		print >>sys.stderr, "writing %s..." % filename
	plots[0].fig.savefig(filename)
	del plots[0]
	n += 1
if options.verbose:
	print >>sys.stderr, "done."
