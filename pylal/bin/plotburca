#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import bisect
from optparse import OptionParser
import matplotlib
matplotlib.use("Agg")
from matplotlib import figure
from matplotlib.backends.backend_agg import FigureCanvasAgg
import numarray
import os
import stat
import sys

from glue.lal import CacheEntry
from glue.ligolw import lsctables
from pylal import llwapp

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("-b", "--base", metavar = "base", default = "plotburca_", help = "set the prefix for output filenames (default = plotburca_)")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	return options, (filenames or [None])


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

def sort_files(filenames, verbose = False):
	"""
	Sort the files from largest to smallest.
	"""
	if verbose:
		print >>sys.stderr, "sorting files from largest to smallest..."
	l = [(os.stat(name)[stat.ST_SIZE], name) for name in filenames]
	l.sort()
	l.reverse()
	return [pair[1] for pair in l]

class SnglBurst(object):
	__slots__ = ["ifo", "confidence", "event_id"]

class Coinc(object):
	__slots__ = ["coinc_event_id", "time_slide_id"]

class TimeSlide(object):
	__slots__ = ["time_slide_id", "instrument", "offset"]

	def _get_key(self):
		return self.time_slide_id

	def _has_key(self, key):
		return self.time_slide_id == key

def snglburst_init(self, attrs):
	lsctables.LSCTableUnique.__init__(self, attrs)
	self.rows = {}

def snglburst_append(self, row):
	self.rows[lsctables.ILWDID(row.event_id)] = row
	del row.event_id

def coinc_init(self, attrs):
	lsctables.LSCTableUnique.__init__(self, attrs)
	self.rows = {}

def coinc_append(self, row):
	self.rows[lsctables.ILWDID(row.coinc_event_id)] = lsctables.ILWDID(row.time_slide_id)

def coinc_map_append(self, row):
	row.coinc_event_id = lsctables.ILWDID(row.coinc_event_id)
	row.event_id = lsctables.ILWDID(row.event_id)
	lsctables.LSCTableUnique.append(self, row)

def timeslide_init(self, attrs):
	lsctables.LSCTableMulti.__init__(self, attrs)
	self.rows = {}

def timeslide_append(self, row):
	id = lsctables.ILWDID(row.time_slide_id)
	if id in self.rows:
		self.rows[id][row.instrument] = row.offset
	else:
		self.rows[id] = {row.instrument: row.offset}

lsctables.SnglBurstTable.RowType = SnglBurst
lsctables.SnglBurstTable.__init__ = snglburst_init
lsctables.SnglBurstTable.append = snglburst_append
lsctables.CoincTable.RowType = Coinc
lsctables.CoincTable.__init__ = coinc_init
lsctables.CoincTable.append = coinc_append
lsctables.CoincMapTable.append = coinc_map_append
lsctables.TimeSlideTable.RowType = TimeSlide
lsctables.TimeSlideTable.__init__ = timeslide_init
lsctables.TimeSlideTable.append = timeslide_append


#
# =============================================================================
#
#                            Document Comprehension
#
# =============================================================================
#

class DocContents(object):
	def __init__(self, xmldoc):
		#
		# Extract tables
		#

		self.bursttable = llwapp.get_table(xmldoc, lsctables.SnglBurstTable.tableName)
		self.coinctable = llwapp.get_table(xmldoc, lsctables.CoincTable.tableName)
		self.coincmaptable = llwapp.get_table(xmldoc, lsctables.CoincMapTable.tableName)
		self.tisitable = llwapp.get_table(xmldoc, lsctables.TimeSlideTable.tableName)

		#
		# Find foreground time slide
		#

		self.foreground_tisi_id = None
		for self.foreground_tisi_id, offsetdict in self.tisitable.rows.iteritems():
			for offset in offsetdict.itervalues():
				if offset != 0.0:
					continue
			break

		#
		# Construct ID look-up tables
		#

		# coinc_event_map by coinc_event_id
		self.coincmaptable.rows.sort(lambda a, b: cmp(a.coinc_event_id, b.coinc_event_id))
		self.coincmaptableids = list(self.coincmaptable.getColumnByName("coinc_event_id"))

	def get_burst_by_coincid(self, id):
		return [self.bursttable.rows[row.event_id] for row in self.coincmaptable.rows[bisect.bisect_left(self.coincmaptableids, id) : bisect.bisect_right(self.coincmaptableids, id)]]

	def get_tisi_by_id(self, id):
		return self.tisitable.rows[id]


#
# =============================================================================
#
#                            Coincidence Iterators
#
# =============================================================================
#

class CoincEventIter(object):
	def __init__(self,  doc):
		self.doc = doc
		self.iditer = doc.coinctable.rows.iterkeys()

	def __iter__(self):
		return self

	def next(self):
		id = self.iditer.next()
		return self.doc.coinctable.rows[id] == self.doc.foreground_tisi_id, self.doc.get_burst_by_coincid(id)


class CoincTisiIter(object):
	def __init__(self, doc):
		self.doc = doc
		self.iditer = doc.coinctable.rows.itervalues()

	def __iter__(self):
		return self

	def next(self):
		return self.doc.get_tisi_by_id(self.iditer.next())


#
# =============================================================================
#
#                             Contour Plot Support
#
# =============================================================================
#

class RatioBins(object):
	def __init__(self, xmin, xmax, nx, ymin, ymax, ny):
		self.xmin = xmin
		self.xmax = xmax
		self.dx = (xmax - xmin) / (nx - 1)
		self.xcoords = numarray.arange(xmin, xmax + self.dx, self.dx)

		self.ymin = ymin
		self.ymax = ymax
		self.dy = (ymax - ymin) / (ny - 1)
		self.ycoords = numarray.arange(ymin, ymax + self.dy, self.dy)

		self.numerator = numarray.zeros((ny, nx), numarray.Float64)
		self.denominator = numarray.zeros((ny, nx), numarray.Float64)

	def incnumerator(self, x, y):
		if (self.xmin <= x <= self.xmax) and (self.ymin <= y <= self.ymax):
			i = int((y - self.ymin) / self.dy + 0.5)
			j = int((x - self.xmin) / self.dx + 0.5)
			self.numerator[i, j] += 1.0

	def incdenominator(self, x, y):
		if (self.xmin <= x <= self.xmax) and (self.ymin <= y <= self.ymax):
			i = int((y - self.ymin) / self.dy + 0.5)
			j = int((x - self.xmin) / self.dx + 0.5)
			self.denominator[i, j] += 1.0

	def normalize(self):
		self.denominator = numarray.where(self.denominator > 0, self.denominator, 1)


#
# =============================================================================
#
#                                Rate Contours
#
# =============================================================================
#

class RateContours(object):
	def __init__(self, x_instrument, y_instrument):
		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.tisi_offsets_x = []
		self.tisi_offsets_y = []
		self.fig = figure.Figure()
		self.canvas = FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16,16)
		self.axes = self.fig.gca()
		self.bins = RatioBins(-100.0, 100.0, 11, -100.0, 100.0, 11)

		self.axes.grid(True)

		self.axes.set_xlabel("%s Offset (s)" % x_instrument)
		self.axes.set_ylabel("%s Offset (s)" % y_instrument)

	def addto(self, doc):
		if not self.tisi_offsets_x:
			for offsetdict in doc.tisitable.rows.itervalues():
				self.tisi_offsets_x.append(offsetdict[self.x_instrument])
				self.tisi_offsets_y.append(offsetdict[self.y_instrument])
		for offsetdict in CoincTisiIter(doc):
			self.bins.incnumerator(offsetdict[self.x_instrument], offsetdict[self.y_instrument])

	def finish(self):
		self.axes.contour(self.bins.xcoords, self.bins.ycoords, self.bins.numerator)
		self.axes.plot(self.tisi_offsets_x, self.tisi_offsets_y, "k+")
		self.axes.set_title("Coincident Trigger Rate vs. Offset")


#
# =============================================================================
#
#                             Confidence Contours
#
# =============================================================================
#

class ConfidenceScatter(object):
	def __init__(self, x_instrument, y_instrument):
		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.n_foreground = 0
		self.n_background = 0
		self.foreground_x = []
		self.foreground_y = []
		self.background_x = []
		self.background_y = []
		self.fig = figure.Figure()
		self.canvas = FigureCanvasAgg(self.fig)
		self.fig.set_figsize_inches(16,16)
		self.axes = self.fig.gca()

		self.axes.loglog()
		self.axes.grid(True)

		self.axes.set_xlabel("%s Confidence" % x_instrument)
		self.axes.set_ylabel("%s COnfidence" % y_instrument)

	def addto(self, doc):
		for foreground, trigs in CoincEventIter(doc):
			if foreground:
				self.n_foreground += 1
				for trig in trigs:
					if trig.ifo == self.x_instrument:
						self.foreground_x.append(-trig.confidence)
					elif trig.ifo == self.y_instrument:
						self.foreground_y.append(-trig.confidence)
			else:
				self.n_background += 1
				for trig in trigs:
					if trig.ifo == self.x_instrument:
						self.background_x.append(-trig.confidence)
					elif trig.ifo == self.y_instrument:
						self.background_y.append(-trig.confidence)

	def finish(self):
		self.axes.set_title("Coincident Trigger Confidence")
		self.axes.plot(self.background_x, self.background_y, "k+")
		self.axes.plot(self.foreground_x, self.foreground_y, "rx")


#
# =============================================================================
#
#                                     Plot
#
# =============================================================================
#

plots = (RateContours("H2", "H1"), ConfidenceScatter("H2", "H1"), ConfidenceScatter("H2", "L1"), ConfidenceScatter("L1", "H1"))

options, filenames = parse_command_line()
for n, filename in enumerate(sort_files(filenames, options.verbose)):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	doc = llwapp.load_filename(filename, options.verbose)
	if options.verbose:
		print >>sys.stderr, "indexing..."
	contents = DocContents(doc)
	for n, plot in enumerate(plots):
		if options.verbose:
			print >>sys.stderr, "adding to plot %d..." % n
		plot.addto(contents)
	doc.unlink()

if options.verbose:
	print >>sys.stderr, "finishing..."
for plot in plots:
	plot.finish()


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

for n, plot in enumerate(plots):
	filename = "%s%d.%s" % (options.base, n, options.format)
	if options.verbose:
		print >>sys.stderr, "writing %s..." % filename
	plot.fig.savefig(filename)
