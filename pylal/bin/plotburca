#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

from optparse import OptionParser
import math
import matplotlib.cm
import numarray
import os
from pysqlite2 import dbapi2 as sqlite3
import sys

from glue import segments
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from pylal import rate
from pylal import SnglBurstUtils
from pylal import date
from pylal.xlal import inject

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("-b", "--base", metavar = "base", default = "plotburca_", help = "set the prefix for output filenames (default = plotburca_)")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("-l", "--live-time-program", metavar = "program", default = "power", help = "set the name, as it appears in the process table, of the program whose search summary entries define the search live time (default = power)")
	parser.add_option("--plot", metavar = "number", action = "append", default = None, help = "generate the given plot number")
	parser.add_option("-s", "--skip", metavar = "number", default = 0, help = "skip this many files at the start of the list (default = 0)")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	if options.plot:
		options.plot = map(int, options.plot)
	else:
		options.plot = range(14)

	options.skip = int(options.skip)

	return options, (filenames or [None])


#
# =============================================================================
#
#                                Rate Contours
#
# =============================================================================
#

def time_slide_is_null(offsets):
	for offset in offsets.itervalues():
		if offset != 0:
			return False
	return True


class RateContours(SnglBurstUtils.BurstPlot):
	def __init__(self, x_instrument, y_instrument, min_delta_t, max_delta_t):
		SnglBurstUtils.BurstPlot.__init__(self, "%s Offset (s)" % x_instrument, "%s Offset (s)" % y_instrument)
		self.fig.set_figsize_inches(16,16)
		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.tisi_rows = None
		self.seglists = None
		self.bins = rate.BinnedRatios(rate.Bins(min_delta_t, max_delta_t, 81, min_delta_t, max_delta_t, 81))

	def add_contents(self, contents):
		if self.tisi_rows == None:
			self.tisi_rows = contents.time_slide_table.all_offsets()
		if self.seglists == None:
			self.seglists = contents.seglists
		else:
			for instrument, seglist in contents.seglists.iteritems():
				self.seglists[instrument] |= seglist
		for coinc in contents.coinc_table.selectByDefID(contents.bb_definer_id):
			offsets = coinc.get_time_slide()
			self.bins.incnumerator((offsets[self.x_instrument], offsets[self.y_instrument]))

	def finish(self):
		for offsets in self.tisi_rows:
			self.seglists.offsets.update(offsets)
			self.bins.incdenominator((offsets[self.x_instrument], offsets[self.y_instrument]), float(self.seglists.intersection(self.seglists.keys()).duration()))
		self.bins.logregularize()
		zvals = self.bins.ratio()
		rate.filter_array(zvals, rate.gaussian_window2d(8, 8))
		xcoords, ycoords = self.bins.centres()
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(zvals)))
		for offsets in self.tisi_rows:
			if time_slide_is_null(offsets):
				self.axes.plot((offsets[self.x_instrument],), (offsets[self.y_instrument],), "r+")
			else:
				self.axes.plot((offsets[self.x_instrument],), (offsets[self.y_instrument],), "k+")

		self.axes.set_xlim([self.bins.bins.min[0], self.bins.bins.max[0]])
		self.axes.set_ylim([self.bins.bins.min[1], self.bins.bins.max[1]])
		self.axes.set_title(r"Coincident Event Rate vs. Instrument Time Offset (Logarithmic Rate Contours)")


#
# =============================================================================
#
#                              Confidence Scatter
#
# =============================================================================
#


def magnitude_a(burst):
	return -burst.confidence


def magnitude_b(burst):
	# galactic core, J2000
	ra, dec = 2.0318570464121519, -0.50628171572274738
	gmst = date.XLALGreenwichMeanSiderealTime(date.LIGOTimeGPS(burst.peak_time, burst.peak_time_ns))
	fplus, fcross = inject.XLALComputeDetAMResponse(inject.cached_detector[burst.ifo].response(), ra, dec, 0.0, gmst)
	# power_per_dof = burst.snr / (2.0 * burst.tfvolume) + 1.0
	power_per_dof = (burst.snr + 2.0 * burst.tfvolume) / (2.0 * burst.bandwidth * burst.duration)
	return power_per_dof / (fplus**2.0 + fcross**2.0)


from pylal import itertools

def keep_1(coinc_bursts):
	# events are coincident iff their time-frequency tiles touch or
	# intersect
	return True

def keep_2(coinc_bursts):
	# events are coincident iff one time-frequency tile's centre
	# frequency and peak time are covered by the other time-frequency tile.
	for [a, b] in itertools.choices(coinc_bursts, 2):
		if a.get_peak() not in b.get_period() or b.get_peak() not in a.get_period() or a.central_freq not in b.get_band() or b.central_freq not in a.get_band():
			return False
	return True

def keep_3(coinc_bursts):
	# events are coincident iff their peak time and centre frequencies
	# equal
	for [a, b] in itertools.choices(coinc_bursts, 2):
		if a.get_peak() != b.get_peak() or a.central_freq != b.central_freq:
			return False
	return True


class ConfidenceContours(SnglBurstUtils.BurstPlot):
	def __init__(self, x_instrument, y_instrument, magnitude, desc, min_magnitude, max_magnitude):
		SnglBurstUtils.BurstPlot.__init__(self, "%s %s" % (x_instrument, desc), "%s %s" % (y_instrument, desc))
		self.fig.set_figsize_inches(16,16)
		self.axes.loglog()
		self.x_instrument = x_instrument
		self.y_instrument = y_instrument
		self.magnitude = magnitude
		self.foreground_x = []
		self.foreground_y = []
		self.n_foreground = 0
		self.n_background = 0
		self.n_injections = 0
		self.foreground_bins = rate.BinnedArray(rate.Bins(min_magnitude, max_magnitude, 1024, min_magnitude, max_magnitude, 1024, spacing = ["log", "log"]))
		self.background_bins = rate.BinnedArray(rate.Bins(min_magnitude, max_magnitude, 1024, min_magnitude, max_magnitude, 1024, spacing = ["log", "log"]))
		self.coinc_injection_bins = rate.BinnedArray(rate.Bins(min_magnitude, max_magnitude, 1024, min_magnitude, max_magnitude, 1024, spacing = ["log", "log"]))
		self.incomplete_coinc_injection_bins = rate.BinnedArray(rate.Bins(min_magnitude, max_magnitude, 1024, min_magnitude, max_magnitude, 1024, spacing = ["log", "log"]))

	def coords(self, coinc_bursts):
		x = y = None
		for burst in coinc_bursts:
			if burst.ifo == self.x_instrument:
				x = self.magnitude(burst)
			elif burst.ifo == self.y_instrument:
				y = self.magnitude(burst)
		return x, y

	def add_contents(self, contents):
		if self.x_instrument not in contents.instruments or self.y_instrument not in contents.instruments:
			# fast path: these are not the instruments we're
			# looking for
			return
		for coinc in contents.coinc_table.selectByDefID(contents.bb_definer_id):
			#if not keep_3(contents.coinc_sngl_bursts(coinc)):
			#	continue
			if coinc.is_zero_lag():
				self.n_foreground += 1
				x, y = self.coords(contents.coinc_sngl_bursts(coinc))
				try:
					self.foreground_bins[x, y] += 1
					#self.foreground_x.append(x)
					#self.foreground_y.append(y)
				except IndexError:
					# not on plot axes
					pass
			else:
				self.n_background += 1
				try:
					self.background_bins[self.coords(contents.coinc_sngl_bursts(coinc))] += 1
				except IndexError:
					# not on plot axes
					pass
		if contents.sc_definer_id:
			for coinc in contents.coinc_table.selectByDefID(contents.sc_definer_id):
				self.n_injections += 1
				for coinc in contents.coinc_coincs(coinc):
					try:
						self.coinc_injection_bins[self.coords(contents.coinc_sngl_bursts(coinc))] += 1
					except IndexError:
						# not on plot axes
						pass
		for coinc_event_id in contents.incomplete_injection_coinc_ids:
			try:
				self.incomplete_coinc_injection_bins[self.coords(contents.coinc_sngl_bursts(contents.coinc_table[coinc_event_id]))] += 1
			except IndexError:
				# not on plot axes
				pass

	def finish(self):
		self.axes.set_title(r"\begin{center}Distribution of Coincident Events (%d Foreground, %d Background Events, %d Injections Found in Coincidence, Logarithmic Density Contours)\end{center}" % (self.n_foreground, self.n_background, self.n_injections))
		xcoords, ycoords = self.background_bins.centres()

		# prepare the data
		rate.filter_array(self.foreground_bins.array, rate.gaussian_window2d(8, 8))
		rate.filter_array(self.background_bins.array, rate.gaussian_window2d(8, 8))
		rate.filter_array(self.coinc_injection_bins.array, rate.gaussian_window2d(8, 8))
		rate.filter_array(self.incomplete_coinc_injection_bins.array, rate.gaussian_window2d(8, 8))
		self.foreground_bins.logregularize()
		self.background_bins.logregularize()
		self.coinc_injection_bins.logregularize()
		self.incomplete_coinc_injection_bins.logregularize()

		# plot background contours
		max_density = math.log(self.background_bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.background_bins.array)), [max_density - n for n in xrange(0, 10, 1)], cmap = matplotlib.cm.Greys)

		# plot foreground (zero-lag) contours
		max_density = math.log(self.foreground_bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.foreground_bins.array)), [max_density - n for n in xrange(0, 10, 1)], cmap = matplotlib.cm.Reds)
		#self.axes.plot(self.foreground_x, self.foreground_y, "r+")

		# plot coincident injection contours
		max_density = math.log(self.coinc_injection_bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.coinc_injection_bins.array)), [max_density - n for n in xrange(0, 10, 1)], cmap = matplotlib.cm.Blues)

		# plot coincident injection contours
		max_density = math.log(self.incomplete_coinc_injection_bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.incomplete_coinc_injection_bins.array)), [max_density - n for n in xrange(0, 10, 1)], cmap = matplotlib.cm.Greens)

		# add diagonal line
		lower = max(self.background_bins.bins.min)
		upper = min(self.background_bins.bins.max)
		self.axes.plot([lower, upper], [lower, upper], "k:")

		# fix axes limits
		self.axes.set_xlim([self.background_bins.bins.min[0], self.background_bins.bins.max[0]])
		self.axes.set_ylim([self.background_bins.bins.min[1], self.background_bins.bins.max[1]])


class ConfidenceContourProjection(SnglBurstUtils.BurstPlot):
	def __init__(self, x, y, magnitude, max_magnitude):
		SnglBurstUtils.BurstPlot.__init__(self, "X", "Y")
		self.fig.set_figsize_inches(16,16)
		self.x = x
		self.y = y
		self.magnitude = magnitude
		self.n_foreground = 0
		self.n_background = 0
		self.n_injections = 0
		max_magnitude = math.log10(max_magnitude)
		self.foreground_bins = rate.BinnedArray(rate.Bins(-max_magnitude, max_magnitude, 1024, -max_magnitude, max_magnitude, 1024, spacing = ["lin", "lin"]))
		self.background_bins = rate.BinnedArray(rate.Bins(-max_magnitude, max_magnitude, 1024, -max_magnitude, max_magnitude, 1024, spacing = ["lin", "lin"]))
		self.coinc_injection_bins = rate.BinnedArray(rate.Bins(-max_magnitude, max_magnitude, 1024, -max_magnitude, max_magnitude, 1024, spacing = ["lin", "lin"]))
		self.incomplete_coinc_injection_bins = rate.BinnedArray(rate.Bins(-max_magnitude, max_magnitude, 1024, -max_magnitude, max_magnitude, 1024, spacing = ["lin", "lin"]))

	def coords(self, coinc_bursts):
		mag = numarray.zeros(3, "Float64")
		for burst in coinc_bursts:
			if burst.ifo == "H1":
				mag[0] = math.log10(self.magnitude(burst))
			elif burst.ifo == "H2":
				mag[1] = math.log10(self.magnitude(burst))
			elif burst.ifo == "L1":
				mag[2] = math.log10(self.magnitude(burst))
		return numarray.dot(mag, self.x), numarray.dot(mag, self.y)

	def add_contents(self, contents):
		for coinc in contents.coinc_table.selectByDefID(contents.bb_definer_id):
			#if not keep_3(contents.coinc_sngl_bursts(coinc)):
			#	continue
			if coinc.is_zero_lag():
				self.n_foreground += 1
				x, y = self.coords(contents.coinc_sngl_bursts(coinc))
				try:
					self.foreground_bins[x, y] += 1
					#self.foreground_x.append(x)
					#self.foreground_y.append(y)
				except IndexError:
					# not on plot axes
					pass
			else:
				self.n_background += 1
				try:
					self.background_bins[self.coords(contents.coinc_sngl_bursts(coinc))] += 1
				except IndexError:
					# not on plot axes
					pass
		if contents.sc_definer_id:
			for coinc in contents.coinc_table.selectByDefID(contents.sc_definer_id):
				self.n_injections += 1
				for coinc in contents.coinc_coincs(coinc):
					try:
						self.coinc_injection_bins[self.coords(contents.coinc_sngl_bursts(coinc))] += 1
					except IndexError:
						# not on plot axes
						pass
		for coinc_event_id in contents.incomplete_injection_coinc_ids:
			try:
				self.incomplete_coinc_injection_bins[self.coords(contents.coinc_sngl_bursts(contents.coinc_table[coinc_event_id]))] += 1
			except IndexError:
				# not on plot axes
				pass

	def finish(self):
		self.axes.set_title(r"\begin{center}Distribution of Coincident Events (%d Foreground, %d Background Events, %d Injections Found in Coincidence, Logarithmic Density Contours)\end{center}" % (self.n_foreground, self.n_background, self.n_injections))
		xcoords, ycoords = self.background_bins.centres()

		# prepare the data
		rate.filter_array(self.foreground_bins.array, rate.gaussian_window2d(8, 8))
		rate.filter_array(self.background_bins.array, rate.gaussian_window2d(8, 8))
		rate.filter_array(self.coinc_injection_bins.array, rate.gaussian_window2d(8, 8))
		rate.filter_array(self.incomplete_coinc_injection_bins.array, rate.gaussian_window2d(8, 8))
		self.foreground_bins.logregularize()
		self.background_bins.logregularize()
		self.coinc_injection_bins.logregularize()
		self.incomplete_coinc_injection_bins.logregularize()

		# plot background contours
		max_density = math.log(self.background_bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.background_bins.array)), [max_density - n for n in xrange(0, 10, 1)], cmap = matplotlib.cm.Greys)

		# plot foreground (zero-lag) contours
		max_density = math.log(self.foreground_bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.foreground_bins.array)), [max_density - n for n in xrange(0, 10, 1)], cmap = matplotlib.cm.Reds)
		#self.axes.plot(self.foreground_x, self.foreground_y, "r+")

		# plot coincident injection contours
		max_density = math.log(self.coinc_injection_bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.coinc_injection_bins.array)), [max_density - n for n in xrange(0, 10, 1)], cmap = matplotlib.cm.Blues)

		# plot coincident injection contours
		max_density = math.log(self.incomplete_coinc_injection_bins.array.max())
		self.axes.contour(xcoords, ycoords, numarray.transpose(numarray.log(self.incomplete_coinc_injection_bins.array)), [max_density - n for n in xrange(0, 10, 1)], cmap = matplotlib.cm.Greens)

		# fix axes limits
		self.axes.set_xlim([self.background_bins.bins.min[0], self.background_bins.bins.max[0]])
		self.axes.set_ylim([self.background_bins.bins.min[1], self.background_bins.bins.max[1]])


#
# =============================================================================
#
#                             Rate vs. Confidence
#
# =============================================================================
#

class RateVsConfidence(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument):
		SnglBurstUtils.BurstPlot.__init__(self, "%s Confidence" % instrument, "Coincident Event Rate (Hz)")
		self.instrument = instrument
		self.foreground = []
		self.background = []
		self.foreground_segs = segments.segmentlist()
		self.background_segs = segments.segmentlist()
		self.axes.loglog()

	def add_contents(self, contents):
		for time_slide_id in contents.time_slide_table.iterkeys():
			if contents.time_slide_table.is_null(time_slide_id):
				bins = self.foreground
				self.foreground_segs.append(contents.seglists[self.instrument])
			else:
				bins = self.background
				self.background_segs.append(contents.seglists[self.instrument])
			for coinc in contents.coinc_table.selectByTimeSlideID(time_slide_id):
				if coinc.coinc_def_id != contents.bb_definer_id:
					continue
				for burst in contents.coinc_sngl_bursts(coinc):
					if burst.ifo == self.instrument:
						bins.append(-burst.confidence)

	def finish(self):
		self.axes.set_title("Cummulative Coincident Event Rate vs. Confidence in %s" % self.instrument)
		self.background.sort()
		self.foreground.sort()
		background_y = numarray.arange(len(self.background), 0.0, -1.0, "Float64") / float(self.background_segs.duration())
		foreground_y = numarray.arange(len(self.foreground), 0.0, -1.0, "Float64") / float(self.foreground_segs.duration())
		self.axes.plot(self.background, background_y, "ko-")
		self.axes.plot(self.foreground, foreground_y, "ro-", markeredgecolor = "r")


#
# =============================================================================
#
#                              Delta-t Histogram
#
# =============================================================================
#

class DeltaTHistogram(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, interval, width):
		SnglBurstUtils.BurstPlot.__init__(self, "Offset (s)", "Events per Unit Offset")
		self.instrument = instrument
		self.n_foreground = 0
		self.n_background = 0
		self.foreground = rate.Rate(interval, width)
		self.background = rate.Rate(interval, width)

	def add_contents(self, contents):
		for coinc in contents.coinc_table.selectByDefID(contents.bb_definer_id):
			offsets = coinc.get_time_slide()
			if self.instrument not in offsets:
				continue
			# sum = len(bursts) * peak_time for this instrument
			# - sum of peak times of all instruments.  Dividing
			# this by len(bursts) gives the peak time for this
			# instrument - the average of all peak times.  I
			# compute this the way I do to avoid a (very
			# expensive!) LIGOTimeGPS division operation.
			sum = 0
			bursts = list(contents.coinc_sngl_bursts(coinc))
			for burst in bursts:
				peak = burst.get_peak() + offsets[burst.ifo]
				if burst.ifo != self.instrument:
					sum -= peak
				else:
					sum += (len(bursts) - 1) * peak
			if coinc.is_zero_lag():
				self.n_foreground += 1
				self.foreground[float(sum) / len(bursts)] = 1.0
			else:
				self.n_background += 1
				self.background[float(sum) / len(bursts)] = 1.0

	def finish(self):
		self.axes.set_title(r"%s Peak Time Offset From Coincidence Mean (%d Foreground, %d Background Events)" % (self.instrument, self.n_foreground, self.n_background))
		self.axes.plot(self.background.xvals(), self.background.filtered(), "k")
		self.axes.plot(self.foreground.xvals(), self.foreground.filtered(), "r")


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

inject.cached_detector.update({
	"H1": inject.cached_detector["LHO_4k"],
	"H2": inject.cached_detector["LHO_2k"],
	"L1": inject.cached_detector["LLO_4k"]
})

def new_plots(plots):
	deltat_seg = segments.segment(-0.3, +0.3)
	deltat_width = 0.03125
	l = [
		RateContours("H2", "H1", -100, +100),
		ConfidenceContours("H2", "H1", magnitude_a, "Confidence", 1, 10**10),
		ConfidenceContours("H2", "L1", magnitude_a, "Confidence", 1, 10**10),
		ConfidenceContours("L1", "H1", magnitude_a, "Confidence", 1, 10**10),
		ConfidenceContours("H2", "H1", magnitude_b, r"Power / D.o.F. / ($F_{+}^{2} + F_{\times}^{2}$)", 1, 10**10),
		ConfidenceContours("H2", "L1", magnitude_b, r"Power / D.o.F. / ($F_{+}^{2} + F_{\times}^{2}$)", 1, 10**10),
		ConfidenceContours("L1", "H1", magnitude_b, r"Power / D.o.F. / ($F_{+}^{2} + F_{\times}^{2}$)", 1, 10**10),
		ConfidenceContourProjection(numarray.array((-1/math.sqrt(2), +1/math.sqrt(2), 0), "Float64"), numarray.array((-1/math.sqrt(4), -1/math.sqrt(4), +1/math.sqrt(2)), "Float64"), magnitude_b, 10**5),
		RateVsConfidence("H1"),
		RateVsConfidence("H2"),
		RateVsConfidence("L1"),
		DeltaTHistogram("H1", deltat_seg, deltat_width),
		DeltaTHistogram("H2", deltat_seg, deltat_width),
		DeltaTHistogram("L1", deltat_seg, deltat_width),
		#ConfidenceContours(r"H1_DARM_ERR", r"H1_STRAIN", magnitude_a, "Confidence", 35, 10**10),
		#ConfidenceContours(r"H2_DARM_ERR", r"H2_STRAIN", magnitude_a, "Confidence", 35, 10**10),
		#ConfidenceContours(r"L1_DARM_ERR", r"L1_STRAIN", magnitude_a, "Confidence", 35, 10**10)
	]
	return [l[i] for i in plots]

options, filenames = parse_command_line()

plots = new_plots(options.plot)

for n, filename in enumerate(utils.sort_files_by_size(filenames, options.verbose, reverse = True)[options.skip:]):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames) - options.skip),
	database = SnglBurstUtils.CoincDatabase(sqlite3.connect(":memory:"))
	#database = SnglBurstUtils.CoincDatabase(sqlite3.connect("database.sqlite"))
	xmldoc = utils.load_filename(filename, options.verbose, gz = filename[-3:] == ".gz")
	database.summarize(xmldoc, options.live_time_program, options.verbose)
	for n, plot in zip(options.plot, plots):
		if options.verbose:
			print >>sys.stderr, "adding to burca plot %d..." % n
		plot.add_contents(database)
	xmldoc.unlink()
	#os.remove("database.sqlite")


# delete the plots as we go to save memory
n = 0
format = "%%s%%0%dd.%%s" % (int(math.log10(max(options.plot) - 1)) + 1)
while len(plots):
	filename = format % (options.base, options.plot[n], options.format)
	if options.verbose:
		print >>sys.stderr, "finishing plot %d..." % options.plot[n]
	plots[0].finish()
	if options.verbose:
		print >>sys.stderr, "writing %s..." % filename
	plots[0].fig.savefig(filename)
	del plots[0]
	n += 1
if options.verbose:
	print >>sys.stderr, "done."
