#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


"""
LIGO Light-Weight XML segment table manipulation.  At the moment, all this
can do is convert the output of segwizard to an XML file.
"""


from optparse import OptionParser
import sys


from glue import segments
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from pylal.date import LIGOTimeGPS
from pylal import llwapp


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog [options] [filename ...]",
		description = "Utility for manipulating segment lists in XML form.  At the moment, all this can do is convert segment lists in segwizard format to XML representations.  If a file name is given on the command line, then it is loaded, the segments are added to the segment tables therein, and the file overwritten with the new document.  If multiple file names are given, then the same transformation is performed to each one.  If no file names are given, then a new document is created and written to stdout.  If the --output option is set, then output is written to that file, instead."
	)
	parser.add_option("--comment", metavar = "text", help = "Set comment string in process and segment_definer tables (default = None).")
	parser.add_option("--name", metavar = "text", default = "", help = "When inserting new segments, set the name string in the definer table to this (default = \"\").")
	parser.add_option("-o", "--output", metavar = "filename", help = "Write output to this file (default = stdout).  If the file name ends in \".gz\", it will be gzip compressed.")
	parser.add_option("--insert-from-segwizard", metavar = "instrument=filename", default = [], action = "append", help = "Read list of active segments from segwizard file and insert into output.  Can be given more than once to specify multiple segwizard inputs, one each for different instruments.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	if filenames and len(filenames) > 1 and options.output:
		raise ValueError, "setting --output with multiple input files causes data loss"

	options.insert_from_segwizard = dict([argument.split("=") for argument in options.insert_from_segwizard])

	return options, (filenames or [None])



#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#


def append_process(xmldoc, options):
	process = llwapp.append_process(xmldoc, program = "ligolw_segments", version = __version__, cvs_repository = "lscsoft", cvs_entry_time = __date__, comment = options.comment)

	params = []
	if options.output is not None:
		params += [("--output", "lstring", options.output)]
	for item in options.insert_from_segwizard.iteritems():
		params += [("--insert-from-segwizard", "lstring", "=".join(item))]
	if options.name is not None:
		params += [("--name", "lstring", options.name)]
	if options.comment is not None:
		params += [("--comment", "lstring", options.comment)]
	llwapp.append_process_params(xmldoc, process, params)

	return process


#
# =============================================================================
#
#                                 Segment List
#
# =============================================================================
#


def segment_def(ifos, name, comment, tbl, process):
	row = lsctables.SegmentDef()
	row.process_id = process.process_id
	row.segment_def_id = tbl.get_next_id()
	row.ifos = ifos
	row.name = name
	row.comment = comment
	return row


def segment_table_rows(active, inactive, unknown, tbl, process):
	if active.intersects(inactive):
		raise ValueError, "active and inactive intersect"

	rows = []

	# "active" segments
	for seg in active:
		row = lsctables.Segment()
		row.process_id = process.process_id
		row.set(seg)
		row.active = 1
		rows.append(row)

	# "inactive" segments
	for seg in inactive:
		row = lsctables.Segment()
		row.process_id = process.process_id
		row.set(seg)
		row.active = 0
		rows.append(row)

	# "unknown" segments
	for seg in unknown:
		row = lsctables.Segment()
		row.process_id = process.process_id
		row.set(seg)
		row.active = None
		rows.append(row)

	# sort by time
	rows.sort(lambda a, b: cmp(a.get(), b.get()))

	# assign IDs
	for row in rows:
		row.segment_id = tbl.get_next_id()

	# done
	return rows


def seg_def_map(seg, seg_def, tbl, process):
	row = lsctables.SegmentDefMap()
	row.process_id = process.process_id
	row.segment_id = seg.segment_id
	row.segment_def_id = seg_def.segment_def_id
	row.seg_def_map_id = tbl.get_next_id()
	return row


#
# =============================================================================
#
#                                 Library API
#
# =============================================================================
#


class LigolwSegments(object):
	"""
	A high-level interface to the segments tables in a LIGO Light
	Weight XML document.
	"""
	def __init__(self, xmldoc, process):
		#
		# The row in the process table on which we will blame our
		# work
		#

		self.process = process

		#
		# Find tables, and synchronize ID generators
		#

		try:
			self.segment_def_table = table.get_table(xmldoc, lsctables.SegmentDefTable.tableName)
		except ValueError:
			self.segment_def_table = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.SegmentDefTable, ("process_id", "segment_def_id", "ifos", "name", "comment")))
		self.segment_def_table.sync_next_id()

		try:
			self.segment_table = table.get_table(xmldoc, lsctables.SegmentTable.tableName)
		except ValueError:
			self.segment_table = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.SegmentTable, ("process_id", "segment_id", "start_time", "start_time_ns", "end_time", "end_time_ns", "active")))
		self.segment_table.sync_next_id()

		try:
			self.segment_def_map_table = table.get_table(xmldoc, lsctables.SegmentDefMapTable.tableName)
		except ValueError:
			self.segment_def_map_table = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.SegmentDefMapTable, ("process_id", "segment_id", "segment_def_id", "seg_def_map_id")))
		self.segment_def_map_table.sync_next_id()


	def insert_from_segwizard(self, fileobj, instrument, name, comment):
		#
		# Create a segment definition for this list
		#

		segment_definition = segment_def(instrument, name, comment, self.segment_def_table, self.process)
		self.segment_def_table.append(segment_definition)

		#
		# Build and insert segments
		#

		active = segmentsUtils.fromsegwizard(fileobj, coltype = LIGOTimeGPS)
		inactive = segments.segmentlist()
		unknown = segments.segmentlist()
		for row in segment_table_rows(active, inactive, unknown, self.segment_table, self.process):
			self.segment_table.append(row)
			self.segment_def_map_table.append(seg_def_map(row, segment_definition, self.segment_def_map_table, self.process))


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# Parse command line.
#


options, filenames = parse_command_line()


#
# Iterate over files to process.  If list == [None], then create a new file
# and write to --output (or stdout if option not set).
#


for filename in filenames:
	#
	# Load document.
	#


	if filename is not None:
		xmldoc = utils.load_filename(filename, verbose = options.verbose, gz = filename.endswidth(".gz"))
	else:
		# create an empty one
		xmldoc = ligolw.Document()
		xmldoc.appendChild(ligolw.LIGO_LW())
		xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.ProcessTable))
		xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.ProcessParamsTable))


	#
	# Add ourselves to the process table.
	#


	process = append_process(xmldoc, options)


	#
	# Build the document interface
	#


	segments_tables = LigolwSegments(xmldoc, process)


	#
	# Insert segwizard format file contents
	#


	for instrument, filename in options.insert_from_segwizard.iteritems():
		if options.verbose:
			print >>sys.stderr, "reading '%s' for instrument '%s' ..." % (filename, instrument)

		segments_tables.insert_from_segwizard(file(filename), instrument, options.name, options.comment)


	#
	# Finalize process metadata.
	#


	llwapp.set_process_end_time(process)


	#
	# Write output.
	#


	if options.output:
		utils.write_filename(xmldoc, options.output, verbose = options.verbose, gz = options.output.endswith(".gz"))
	else:
		utils.write_filename(xmldoc, filename, verbose = options.verbose, gz = (filename or "stdout").endswith(".gz"))
