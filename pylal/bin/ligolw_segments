#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


"""
LIGO Light-Weight XML segment table manipulation.  At the moment, all this
can do is convert the output of segwizard to an XML file.
"""


from optparse import OptionParser
import sys


from glue import iterutils
from glue import segments
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from pylal.date import LIGOTimeGPS
from pylal import llwapp


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog [options] [filename ...]",
		description = "Utility for manipulating segment lists in XML form.  At the moment, all this can do is convert segment lists in segwizard format to XML representations.  If a file name is given on the command line, then it is loaded, the segments are added to the segment tables therein, and the file overwritten with the new document.  If multiple file names are given, then the same transformation is performed to each one.  If no file names are given, then a new document is created and written to stdout.  If the --output option is set, then output is written to that file, instead."
	)
	parser.add_option("--coalesce", action = "store_true", help = "Coalesce the segment lists (default = don't).")
	parser.add_option("--comment", metavar = "text", help = "Set comment string in process and segment_definer tables (default = None).")
	parser.add_option("--name", metavar = "text", help = "When inserting new segments, set the name string in the definer table to this (default = None).")
	parser.add_option("-o", "--output", metavar = "filename", help = "Write output to this file (default = stdout).  If the file name ends in \".gz\", it will be gzip compressed.")
	parser.add_option("--insert-from-segwizard", metavar = "instrument=filename", default = [], action = "append", help = "Read list of active segments from segwizard file and insert into output.  Can be given more than once to specify multiple segwizard inputs, one each for different instruments.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	if filenames and len(filenames) > 1 and options.output:
		raise ValueError, "setting --output with multiple input files causes data loss"

	options.insert_from_segwizard = dict([argument.split("=") for argument in options.insert_from_segwizard])

	return options, (filenames or [None])



#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#


def append_process(xmldoc, options):
	process = llwapp.append_process(xmldoc, program = "ligolw_segments", version = __version__, cvs_repository = "lscsoft", cvs_entry_time = __date__, comment = options.comment)

	params = []
	if options.output is not None:
		params += [("--output", "lstring", options.output)]
	for item in options.insert_from_segwizard.iteritems():
		params += [("--insert-from-segwizard", "lstring", "=".join(item))]
	if options.name is not None:
		params += [("--name", "lstring", options.name)]
	if options.comment is not None:
		params += [("--comment", "lstring", options.comment)]
	llwapp.append_process_params(xmldoc, process, params)

	return process


#
# =============================================================================
#
#                                 Segment List
#
# =============================================================================
#


def segment_def(instruments, name, comment, id, process):
	row = lsctables.SegmentDef()
	row.process_id = process.process_id
	row.segment_def_id = id
	instruments = list(instruments)
	instruments.sort()
	row.ifos = ",".join(instruments)
	row.name = name
	row.comment = comment
	return row


def seg_def_map(seg, seg_def, tbl, process):
	row = lsctables.SegmentDefMap()
	row.process_id = process.process_id
	row.segment_id = seg.segment_id
	row.segment_def_id = seg_def.segment_def_id
	row.seg_def_map_id = tbl.get_next_id()
	return row


class LigolwSegmentList(object):
	"""
	A description of a class of segments.
	"""
	def __init__(self, active = (), inactive = (), unknown = (), instruments = set(), name = None, comment = None):
		self.active = segments.segmentlist(active)
		self.inactive = segments.segmentlist(inactive)
		self.unknown = segments.segmentlist(unknown)
		self.instruments = instruments
		self.name = name
		self.comment = comment

	def sort(self, *args):
		self.active.sort(*args)
		self.inactive.sort(*args)
		self.unknown.sort(*args)

	def coalesce(self):
		self.active.coalesce()
		self.inactive.coalesce()
		self.unknown.coalesce()


	def rows(self, tbl, process):
		def seglist_iterator(seglist, activity):
			for seg in seglist:
				yield seg, activity

		self.sort()

		for seg, activity in iterutils.inorder((seglist_iterator(self.active, True), seglist_iterator(self.inactive, False), seglist_iterator(self.unknown, None))):
			row = lsctables.Segment()
			row.set(seg)
			row.set_active(activity)
			row.process_id = process.process_id
			row.segment_id = tbl.get_next_id()
			yield row


#
# =============================================================================
#
#                                 Library API
#
# =============================================================================
#


class LigolwSegments(object):
	"""
	A high-level interface to the segments tables in a LIGO Light
	Weight XML document.
	"""
	def __init__(self, xmldoc, process):
		#
		# The row in the process table on which we will blame our
		# work
		#

		self.process = process

		#
		# Find tables, and synchronize ID generators
		#

		try:
			self.segment_def_table = table.get_table(xmldoc, lsctables.SegmentDefTable.tableName)
		except ValueError:
			self.segment_def_table = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.SegmentDefTable, ("process_id", "segment_def_id", "ifos", "name", "comment")))
		self.segment_def_table.sync_next_id()

		try:
			self.segment_table = table.get_table(xmldoc, lsctables.SegmentTable.tableName)
		except ValueError:
			self.segment_table = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.SegmentTable, ("process_id", "segment_id", "start_time", "start_time_ns", "end_time", "end_time_ns", "active")))
		self.segment_table.sync_next_id()

		try:
			self.segment_def_map_table = table.get_table(xmldoc, lsctables.SegmentDefMapTable.tableName)
		except ValueError:
			self.segment_def_map_table = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.SegmentDefMapTable, ("process_id", "segment_id", "segment_def_id", "seg_def_map_id")))
		self.segment_def_map_table.sync_next_id()

		#
		# Transform segment tables into a collection of
		# LigolwSegmentList objects for more convenient
		# manipulation
		#

		# segment_def_id --> LigolwSegmentList object mapping
		self.segment_lists = {}
		for row in self.segment_def_table:
			if row.segment_def_id in self.segment_lists:
				raise ValueError, "segment_definer table contains duplicate segment_definer keys"
			self.segment_lists[row.segment_def_id] = LigolwSegmentList(instruments = row.get_ifos(), name = row.name, comment = row.comment)
		del self.segment_def_table[:]

		# segment_id --> LigolwSegmentList object mapping
		segment_def_map = {}
		for row in self.segment_def_map_table:
			if row.segment_id in segment_def_map:
				raise ValueError, "segment_def_map table contains duplicate segment keys"
			segment_def_map[row.segment_id] = self.segment_lists[row.segment_def_id]
		del self.segment_def_map_table[:]

		# populate LigolwSegmentList objects from segment table
		for row in self.segment_table:
			active = row.get_active()
			if active is True:
				segment_def_map[row.segment_id].active.append(row.get())
			elif row.active is False:
				segment_def_map[row.segment_id].inactive.append(row.get())
			elif row.active is None:
				segment_def_map[row.segment_id].unknown.append(row.get())
			else:
				raise ValueError, "execution should not get to this line of code"
		del self.segment_table[:]
		del segment_def_map

		#
		# Done
		#


	def coalesce(self):
		#
		# Coalesce the segment lists.
		#

		for ligolw_segment_list in self.segment_lists.values():
			ligolw_segment_list.coalesce()


	def finalize(self):
		#
		# Restore the LigolwSegmentList objects to the XML tables
		# in preparation for output
		#

		for segment_def_id, ligolw_segment_list in self.segment_lists.items():
			segment_definition = segment_def(ligolw_segment_list.instruments, ligolw_segment_list.name, ligolw_segment_list.comment, segment_def_id, self.process)
			self.segment_def_table.append(segment_definition)
			for row in ligolw_segment_list.rows(self.segment_table, self.process):
				self.segment_table.append(row)
				self.segment_def_map_table.append(seg_def_map(row, segment_definition, self.segment_def_map_table, self.process))
			del self.segment_lists[segment_def_id]


	def insert_from_segwizard(self, fileobj, instruments, name, comment):
		self.segment_lists[self.segment_def_table.get_next_id()] = LigolwSegmentList(active = segmentsUtils.fromsegwizard(fileobj, coltype = LIGOTimeGPS), instruments = instruments, name = name, comment = comment)


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# Parse command line.
#


options, filenames = parse_command_line()


#
# Iterate over files to process.  If list == [None], then create a new file
# and write to --output (or stdout if option not set).
#


for filename in filenames:
	#
	# Load document.
	#


	if filename is not None:
		xmldoc = utils.load_filename(filename, verbose = options.verbose, gz = filename.endswidth(".gz"))
	else:
		# create an empty one
		xmldoc = ligolw.Document()
		xmldoc.appendChild(ligolw.LIGO_LW())
		xmldoc.childNodes[-1].appendChild(lsctables.New(lsctables.ProcessTable))
		xmldoc.childNodes[-1].appendChild(lsctables.New(lsctables.ProcessParamsTable))


	#
	# Add ourselves to the process table.
	#


	process = append_process(xmldoc, options)


	#
	# Build the document interface
	#


	segments_tables = LigolwSegments(xmldoc, process)


	#
	# Insert segwizard format file contents
	#


	for instrument, filename in options.insert_from_segwizard.iteritems():
		if options.verbose:
			print >>sys.stderr, "reading \"%s\" for instrument \"%s\" (name %s) ..." % (filename, instrument, repr(options.name))

		segments_tables.insert_from_segwizard(file(filename), set([instrument]), options.name, options.comment)


	#
	# Restore segment tables.
	#

	if options.coalesce:
		if options.verbose:
			print >>sys.stderr, "coalescing ..."
		segments_tables.coalesce()
	if options.verbose:
		print >>sys.stderr, "reconstructing xml ..."
	segments_tables.finalize()


	#
	# Finalize process metadata.
	#


	llwapp.set_process_end_time(process)


	#
	# Write output.
	#


	if options.output:
		utils.write_filename(xmldoc, options.output, verbose = options.verbose, gz = options.output.endswith(".gz"))
	else:
		utils.write_filename(xmldoc, filename, verbose = options.verbose, gz = (filename or "stdout").endswith(".gz"))
