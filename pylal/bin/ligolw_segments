#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


"""
LIGO Light-Weight XML segment table manipulation.  At the moment, all this
can do is convert the output of segwizard to an XML file.
"""


from optparse import OptionParser
import sys


from glue import segments
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from pylal.date import LIGOTimeGPS
from pylal import llwapp


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$"
	)
	parser.add_option("--comment", metavar = "text", default = "", help = "Set comment string in process and segment_definer tables.")
	parser.add_option("-o", "--output", metavar = "filename", help = "Write output to this (default = stdout).  If the file name ends in \".gz\", it will be gzip compressed.")
	parser.add_option("--segwizard", metavar = "instrument=filename", default = [], action = "append", help = "Read list of active segments from segwizard file.  Can be given more than once to specify segment lists for multiple instruments.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	options.segwizard = dict([argument.split("=") for argument in options.segwizard])

	return options, (filenames or [None])


#
# =============================================================================
#
#                                 Preparation
#
# =============================================================================
#


def new_doc():
	xmldoc = ligolw.Document()
	xmldoc.appendChild(ligolw.LIGO_LW())
	xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.ProcessTable))
	xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.ProcessParamsTable))
	xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.SegmentDefTable, ["process_id", "segment_def_id", "ifos", "name", "comment"]))
	xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.SegmentTable, ["process_id", "segment_id", "start_time", "start_time_ns", "end_time", "end_time_ns", "active"]))
	xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.SegmentDefMapTable, ["process_id", "segment_id", "segment_def_id"]))

	return xmldoc


#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#


def append_process(xmldoc, options):
	process = llwapp.append_process(xmldoc, program = "ligolw_segments", version = __version__, cvs_repository = "lscsoft", cvs_entry_time = __date__, comment = options.comment)

	params = []
	if options.output != None:
		params += [("--output", "lstring", options.output)]
	for item in options.segwizard.iteritems():
		params += [("--segwizard", "lstring", "=".join(item))]
	llwapp.append_process_params(xmldoc, process, params)

	return process


#
# =============================================================================
#
#                                 Segment List
#
# =============================================================================
#


def segment_def(ifos, name, comment, ids, process):
	row = lsctables.SegmentDef()
	row.process_id = process.process_id
	row.segment_def_id = ids.next()
	row.ifos = ifos
	row.name = name
	row.comment = comment
	return row


def segment_table_rows(active, inactive, ids, process):
	if active.intersects(inactive):
		raise ValueError, "active and inactive intersect"

	extent = []
	try:
		extent.append(active.extent())
	except ValueError:
		# empty list
		pass
	try:
		extent.append(inactive.extent())
	except ValueError:
		# empty list
		pass
	extent = segments.segmentlist([segments.segmentlist(extent).extent()])

	undefined = ~(active | inactive)

	rows = []

	# "active" segments
	for seg in active:
		row = lsctables.Segment()
		row.process_id = process.process_id
		row.set(seg)
		row.active = 1
		rows.append(row)

	# "inactive" segments
	for seg in inactive:
		row = lsctables.Segment()
		row.process_id = process.process_id
		row.set(seg)
		row.active = -1
		rows.append(row)

	# undefined segments
	for seg in undefined & extent:
		row = lsctables.Segment()
		row.process_id = process.process_id
		row.set(seg)
		row.active = 0
		rows.append(row)

	# sort by time
	rows.sort(lambda a, b: cmp(a.get(), b.get()))

	# assign IDs
	for row in rows:
		row.segment_id = ids.next()

	# done
	return rows


def seg_def_map(seg, seg_def, process):
	row = lsctables.SegmentDefMap()
	row.process_id = process.process_id
	row.segment_id = seg.segment_id
	row.segment_def_id = seg_def.segment_def_id
	return row


#
# =============================================================================
#
#                                 Library API
#
# =============================================================================
#


def add_from_segwizard(segdeftable, segtable, segdefmaptable, filename, instrument, process):
	segdef = segment_def(instrument, "segwizard", options.comment, segdeftable.ids, process)
	segdeftable.append(segdef)
	active_segs = segmentsUtils.fromsegwizard(file(filename), coltype = LIGOTimeGPS).coalesce()
	inactive_segs = ~active_segs & segments.segmentlist([active_segs.extent()])
	for seg in segment_table_rows(active_segs, inactive_segs, segtable.ids, process):
		segtable.append(seg)
		segdefmaptable.append(seg_def_map(seg, segdef, process))


def ligolw_segments(xmldoc, options):
	segdeftable = table.get_table(xmldoc, lsctables.SegmentDefTable.tableName)
	segdeftable.sync_ids()

	segtable = table.get_table(xmldoc, lsctables.SegmentTable.tableName)
	segtable.sync_ids()

	segdefmaptable = table.get_table(xmldoc, lsctables.SegmentDefMapTable.tableName)

	process = append_process(xmldoc, options)

	for instrument, filename in options.segwizard.iteritems():
		if options.verbose:
			print >>sys.stderr, "reading %s ..." % filename
		add_from_segwizard(segdeftable, segtable, segdefmaptable, filename, instrument, process)

	llwapp.set_process_end_time(process)

	return xmldoc


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


options, filenames = parse_command_line()


utils.write_filename(ligolw_segments(new_doc(), options), options.output, verbose = options.verbose, gz = (options.output or "stdout")[-3:] == ".gz")
