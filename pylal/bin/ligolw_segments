#!/usr/bin/python
#
# Copyright (C) 2006  Kipp Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


"""
LIGO Light-Weight XML segment table manipulation.  At the moment, all this
can do is convert the output of segwizard to an XML file.
"""


from optparse import OptionParser
import sys


from glue import segments
from glue.lal import CacheEntry
from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import utils
from glue.ligolw.utils import segments as ligolw_segments
from glue.ligolw.utils import process as ligolw_process
from pylal import git_version
from pylal import llwapp


__author__ = "Kipp Cannon <kipp.cannon@ligo.org>"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "Name: %%prog\n%s" % git_version.verbose_msg,
		usage = "%prog [options] [url ...]",
		description = "Utility for manipulating segment lists in XML form.  At the moment, all this can do is convert segment lists in segwizard format to XML representations.  If a URL is given on the command line then it is loaded and its contents modified by this utility otherwise a new document is created.  The segments from the segwizard files are added to the segment tables in the document, and the document is written to the file identifed by the --output option if provided, otherwise to the original document if one was specified (it must be a local file in this case), otherwise to stdout.  To force output to stdout when reading from a URL use \"-\" as the output filename (use \"./-\") to write to a file literally named \"-\").  If multiple input URLs are given on the command line, then the same transformation is performed to each one."
	)
	parser.add_option("--coalesce", action = "store_true", help = "Coalesce the segment lists (default = don't).")
	parser.add_option("--comment", metavar = "text", help = "Set comment string in process and segment_definer tables (default = None).")
	parser.add_option("--name", metavar = "text", help = "When inserting new segments, set the name string in the definer table to this (default = None).")
	parser.add_option("-o", "--output", metavar = "filename", help = "Write output to this file (default = stdout).  If the file name ends in \".gz\", it will be gzip compressed.")
	parser.add_option("--insert-from-lal-cache", metavar = "filename", default = [], action = "append", help = "Read lists of active segments from a LAL cache file.  The description column is used to provide the segment list names.")
	parser.add_option("--insert-from-segwizard", metavar = "instrument=filename", default = [], action = "append", help = "Read list of active segments from segwizard file and insert into output.  Can be given more than once to specify multiple segwizard inputs, one each for different instruments.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, urls = parser.parse_args()

	if urls and len(urls) > 1 and options.output:
		raise ValueError, "setting --output with multiple input files causes data loss"

	options.insert_from_segwizard = dict([argument.split("=") for argument in options.insert_from_segwizard])

	return options, (urls or [None])


#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#


def append_process(xmldoc, options):
	process = llwapp.append_process(xmldoc, program = "ligolw_segments", version = __version__, cvs_repository = "lscsoft", cvs_entry_time = __date__, comment = options.comment)

	params = []
	if options.output is not None:
		params += [(u"--output", u"lstring", options.output)]
	for item in options.insert_from_segwizard.iteritems():
		params += [(u"--insert-from-segwizard", u"lstring", "=".join(item))]
	for filename in options.insert_from_lal_cache:
		params += [(u"--insert-from-lal-cache", u"lstring", filename)]
	if options.name is not None:
		params += [(u"--name", u"lstring", options.name)]
	if options.comment is not None:
		params += [(u"--comment", u"lstring", options.comment)]
	ligolw_process.append_process_params(xmldoc, process, params)

	return process


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# Parse command line.
#


options, urls = parse_command_line()


#
# Iterate over files to process.  If list == [None], then create a new file
# and write to --output (or stdout if option not set).
#


for url in urls:
	#
	# Load document.
	#


	if url is not None:
		xmldoc = utils.load_url(url, verbose = options.verbose, gz = url.endswith(".gz"))
	else:
		# create an empty one
		xmldoc = ligolw.Document()
		xmldoc.appendChild(ligolw.LIGO_LW())
		xmldoc.childNodes[-1].appendChild(lsctables.New(lsctables.ProcessTable))
		xmldoc.childNodes[-1].appendChild(lsctables.New(lsctables.ProcessParamsTable))


	#
	# Add ourselves to the process table.
	#


	process = append_process(xmldoc, options)


	#
	# Build the document interface
	#


	segments_tables = ligolw_segments.LigolwSegments(xmldoc)


	#
	# Insert segwizard format file contents
	#


	for instrument, filename in options.insert_from_segwizard.iteritems():
		if options.verbose:
			print >>sys.stderr, "reading \"%s\" for instrument \"%s\" (name %s) ..." % (filename, instrument, repr(options.name))

		ligolw_segments.insert_from_segwizard(segments_tables, file(filename), set([instrument]), options.name, options.comment)


	#
	# Insert LAL cache file contents
	#


	if options.insert_from_lal_cache:
		seglistdicts = dict()
		for filename in options.insert_from_lal_cache:
			if options.verbose:
				print >>sys.stderr, "reading \"%s\" ..." % filename
			for cacheentry in [CacheEntry(line, coltype = lsctables.LIGOTimeGPS) for line in file(filename)]:
				if cacheentry.description not in seglistdicts:
					seglistdicts[cacheentry.description] = segments.segmentlistdict()
				seglistdicts[cacheentry.description] |= cacheentry.to_segmentlistdict()
		for name, seglists in seglistdicts.items():
			ligolw_segments.insert_from_segmentlistdict(segments_tables, seglists, name, options.comment)
		del seglistdicts


	#
	# Restore segment tables.
	#


	if options.coalesce:
		if options.verbose:
			print >>sys.stderr, "coalescing ..."
		segments_tables.coalesce()
	if options.verbose:
		print >>sys.stderr, "merging equivalent lists ..."
	segments_tables.optimize()
	if options.verbose:
		print >>sys.stderr, "reconstructing xml ..."
	segments_tables.finalize(process)


	#
	# Finalize process metadata.
	#


	llwapp.set_process_end_time(process)


	#
	# Write output.
	#


	if options.output:
		if options.output == "-":
			utils.write_filename(xmldoc, None, verbose = options.verbose)
		else:
			utils.write_filename(xmldoc, options.output, verbose = options.verbose, gz = options.output.endswith(".gz"))
	else:
		utils.write_url(xmldoc, url, verbose = options.verbose, gz = (url or "stdout").endswith(".gz"))
