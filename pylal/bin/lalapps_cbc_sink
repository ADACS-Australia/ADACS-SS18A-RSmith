#!/usr/bin/python
import sys, os
from optparse import OptionParser
from pylal import rate
from pylal import SimInspiralUtils
from pylal import InspiralUtils
import scipy
import numpy
import matplotlib
matplotlib.use('Agg')
import pylab
from math import *
import sys
import glob
import copy
from glue.ligolw.utils import ligolw_add
from glue.ligolw import table
from glue.ligolw import array
from glue.ligolw import lsctables
from glue.ligolw.utils import print_tables
from glue.ligolw import ligolw, utils
from glue import lal
from glue import iterutils

from pylal import git_version
__author__ = "Stephen Privitera <sprivite@caltech.edu>"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date
__prog__ = "lalapps_cbc_sink"


# FIXME:  the latex rendering sucks :(
matplotlib.rcParams.update({"text.usetex": False})

def edges(bins):
  """Get the boundary points of a rate.NDBins object."""
  return tuple( numpy.concatenate((l,u[-1:])) for l,u in zip(bins.lower(),bins.upper()) )


def get_bins(file,bin_type):
	xmldoc = utils.load_filename(file, gz = (file or "stdin").endswith(".gz")).childNodes[0]
	m1bins = xmldoc.getChildrenByAttributes({"Name":"mass1_bins:%s" % bin_type})
	m2bins = xmldoc.getChildrenByAttributes({"Name":"mass2_bins:%s" % bin_type})
	if len(m1bins) == 1:
		m1bins = array.get_array(m1bins[0],u"array").array
	else:
		print >>sys.stderr,"XML must contain exactly 1 mass1 bin. Found %d."%len(m1bins)
		sys.exit(1)

	if len(m2bins) == 1:
		m2bins = array.get_array(m2bins[0],u"array").array
		bins = rate.NDBins((rate.IrregularBins(m1bins),rate.IrregularBins(m2bins)))
	elif len(m2bins) == 0:
		bins = rate.NDBins((rate.IrregularBins(m1bins),))
	else:
		print >>sys.stderr,"XML must contain less than 1 mass2 bin. Found %d."%len(m2bins)
		sys.exit(1)

	return bins


def get_data(file,tablename):
	"""Read in data produced by lalapps_cbc_svim"""

	xmldoc = utils.load_filename(file, gz = (file or "stdin").endswith(".gz"))
	xmldoc = xmldoc.childNodes[0]
	table_node = xmldoc.getChildrenByAttributes({"Name":"binned_array:%s" % tablename})
	if len(table_node) != 1:
		print >>sys.stderr,"XML must contain exactly 1 table %s. Found %d."% (tab,len(table_node))
		sys.exit(1)

	return array.get_array(table_node[0],u"array").array


def compute_posterior(vA, vA2, dvA):
	'''
	This function computes the posterior distribution on the rate parameter
	mu resulting from an experiment which was sensitive to a volume vA. This
	function implements the analytic marginalization over uncertainty in the
	efficiency at the loudest event if the input vA2 is nonzero (see Biswas,
	Creighton, Brady, Fairhurst, eqn 24). Where the sensitive volume is zero,
	the posterior is equal to the prior, which is taken to be a constant.
	'''
	length = 100000
	# The 90% UL will be a factor of a few divided by the observed volume
	# (see 17-19 in BCB) so taking max(mu) = 1000/max(vol) will safely capture
	# the entire posterior distribution for each mass bin.
	mu = numpy.arange(length) * 1000.0 / vA.array.max() / length
	post = numpy.zeros(vA.bins.shape + (len(mu),))

	for mbin in iterutils.MultiIter(*vA.bins.centres()):
		if vA[mbin] == 0:
			# we learned nothing from this experiment in this mass bin
			# so the posterior is equal to the prior
			post[vA.bins[mbin]] = (1./len(mu))*numpy.ones(len(mu), dtype="float")
		elif vA2[mbin] == 0:
			# we have perfectly measured our efficiency in this mass bin
			# so the posterior is given by eqn (14) in BCB
			post[vA.bins[mbin]] = vA[mbin]/(1.0+dvA[mbin]) *(1.0+mu*vA[mbin]*dvA[mbin])*numpy.exp(-mu*vA[mbin])
		else:
			# we have uncertainty in our efficiency in this mass bin and
			# want to marginalize it out using eqn (24) of BCB
			k = vA[mbin]**2/vA2[mbin]
			post[vA.bins[mbin]] = vA[mbin] / (1.0 + dvA[mbin]) *( (1.0 + mu*vA[mbin]/k)**(-k-1) + (mu*vA[mbin]*dvA[mbin]*(1.0 + 1.0/k)/(1.0 + mu*vA[mbin]/k)**(k+2)) )

		# NB: mu here is actually the rate R = mu/T as in eqn 9 of BCB and the
		# 4-volume vA is eps*T. In eqns 14,24 of BCB, only the product
		# mu*eps = R*vA matters, except in the overall normalization, which we
		# explicitly deal with here
		post[vA.bins[mbin]] /= post[vA.bins[mbin]].sum()

	return mu, post


def integrate_posterior(mu, post, bins, conf = 0.9):
	"""
        This function returns a BinnedArray which represents the conf
	percent upper limit on the merger rate mu as a function of mass.
	For each mass bin, this function computes the value mu_conf
	such that conf percent of the posterior probability distribution
	on mu is contained below mu_conf, i.e., such that

	   Prob(mu < mu_conf) = integral_0^{r_conf} post(mu) dmu = conf

        For conf = 0.9 and neglecting systematic errors, the upper limit
	is bounded by 2.303 < r_90 *vA[mbin] < 3.890 (see eqns 17-19 in
	BCB). This bound is useful as a code sanity check.
	"""
	mu_conf = rate.BinnedArray(bins)
	for mbin in iterutils.MultiIter(*bins.centres()):
		if numpy.min(post[bins[mbin]]) == numpy.max(post[bins[mbin]]):
			mu_conf[mbin] = float("inf") # if posterior is a constant, the UL is infinite
		else:
			cumpost = post[bins[mbin]].cumsum()/post[bins[mbin]].sum()
			val = [idx for idx in range(len(cumpost)) if cumpost[idx] >= conf][0]
			mu_conf[mbin] = mu[val]

	return mu_conf


def savefig_pylal(plot_description, open_box, inspiral_utils_opts, fnameList, tagList):
	name = InspiralUtils.set_figure_tag( plot_description, open_box = opts.open_box)
	fname = InspiralUtils.set_figure_name(inspiral_utils_opts, name)
	fname_thumb = InspiralUtils.savefig_pylal( filename=fname )
	fnameList.append(fname)
	tagList.append(name)


class UpperLimitTable(table.Table):
	tableName = "upper_limit:table"
	validcolumns = {"total_mass":"real_8","chirp_mass":"real_8","mass1":"real_8","mass2":"real_8", #FIXME add units?
			"range_in_Mpc":"real_8","lambda":"real_8","fractional_error":"real_8",
			"upper_limit":"real_8","upper_limit_including_errors":"real_8",
			"livetime":"real_8", # FIXME alan doesn't want this as a column
			"injections_found":"int_4s","injections_missed":"int_4s"}


def parse_command_line():
	parser = OptionParser(version = "Name: %%prog\n%s" % git_version.verbose_msg)

	# Note: an input cache is required
	parser.add_option("","--input-cache", help="input cache containing only the xml files you want to run on")
	parser.add_option("-f", "--output-format", action = "store", type = "string",
			  default = "html", metavar = "wiki, html, OR xml",
			  help = "Format of output summary table. Choices are 'wiki', 'html', or 'xml'. Default is html.")
	parser.add_option("--output-path", default = "./", action = "store",
			  help="Choose directory to save output files.")
	parser.add_option("--open-box", default = False, action = "store_true",
			  help="Turn flag on to indicate that input data describes zero-lag coincident events.")
	##########################

	opts, files = parser.parse_args()
	if opts.input_cache and files:
		print >>sys.stderr,"Please specify exactly one cache file, either as a program argument or"+\
		      "by specifying the --input-cache option"
		sys.exit(1)

	if files:
		if len(files) == 1:
			opts.input_cache = files[0]
		else:
			print >>sys.stderr,"Please specify exactly one cache file, either as a program argument or"+\
			      "by specifying the --input-cache option"
			sys.exit(1)

	opts.gps_extent =  lal.Cache.fromfile(open(opts.input_cache)).to_segmentlistdict().extent()
	opts.enable_output = True

	return opts


opts  = parse_command_line()

combined_ifos = opts.input_cache.split('-')[0] #FIXME super hack
for bin_type in ["Chirp_Mass","Total_Mass","Low_Mass","Mass1_Mass2"]:

   __prog__ = "lalapps_cbc_sink_by_"+bin_type.lower() # have you ever met a program with multiple identities?
   fnameList = []; tagList = []
   posteriors = []; posteriors_werrs = []
   total_vol = total_err = total_found = total_missed = total_lt = 0

   files = lal.Cache.fromfile(open(opts.input_cache)).sieve(description=bin_type)
   if len(files) == 0:
      continue

   for entry in files:

      # read in the data produced by lalapps_cbc_svim
      bins = get_bins(entry.path(),bin_type) # better use same binning in all files!!
      vA = rate.BinnedArray(bins,array=get_data(entry.path(),"SearchVolumeFirstMoment"))
      vA2 = rate.BinnedArray(bins,array=get_data(entry.path(),"SearchVolumeSecondMoment"))
      dvA = rate.BinnedArray(bins,array=get_data(entry.path(),"SearchVolumeDerivative"))
      distance = rate.BinnedArray(bins,array=get_data(entry.path(),"SearchVolumeDistance"))
      found = rate.BinnedArray(bins,array=get_data(entry.path(),"SearchVolumeFoundInjections"))
      missed = rate.BinnedArray(bins,array=get_data(entry.path(),"SearchVolumeMissedInjections"))
      ltA = rate.BinnedArray(bins,array=get_data(entry.path(),"SearchVolumeLiveTime"))

      # keep track of cumulative totals
      total_vol += vA.array
      total_err += vA2.array
      total_found += found.array
      total_missed += missed.array
      total_lt += ltA.array

      # get mass ranges
      mrange = [(min(b),max(b)) for b in edges(bins)]

      # compute posterior/upper limits neglecting uncertainties
      mu,post = compute_posterior(vA,rate.BinnedArray(bins),dvA)
      upper_limit = integrate_posterior(mu, post, bins, 0.90)
      posteriors.append(post)

      # compute posterior/upper limits marginalizing over uncertainties
      mu,post_werrs = compute_posterior(vA,vA2,dvA)
      upper_limit_werrs = integrate_posterior(mu, post_werrs, bins, 0.90)
      posteriors_werrs.append(post_werrs)

      # Initialize inspiral utility plotting helper
      opts.ifo_times = entry.observatory
      opts.gps_start_time = entry.segment[0]
      opts.gps_end_time = entry.segment[1]
      opts.user_tag = entry.path().split('/')[-1].split('-')[2] #FIXME this is a hack
      InspiralUtilsOpts = InspiralUtils.initialise(opts, __prog__, git_version.verbose_msg )

      # Make a table summarizing the results
      summary_file = open(opts.output_path+opts.ifo_times+'-'+opts.user_tag+'_'+bin_type+'_range_summary.'+opts.output_format,'w')
      summary_doc = ligolw.Document()
      summary_doc.appendChild(ligolw.LIGO_LW())
      ul_table = lsctables.New(UpperLimitTable)
      summary_doc.childNodes[0].appendChild(ul_table)

      for mtuple in iterutils.MultiIter(*bins.centres()):
         if found[mtuple]+missed[mtuple] == 0:
	    # no injections were performed in this mass bin so skip it
	    continue
         row = ul_table.RowType()
	 if bin_type == "Low_Mass":
	    if bins[mtuple] not in [bins[k] for k in [(1.35,1.35),(1.35,5.0),(5.0,5.0)]]:
	       # only print out the canonical lowmass bins 1.35-1.35 (BNS),
	       # 5-5 (BBH) and 1.35-5 (NSBH)
	       continue
	    row.mass1 = mtuple[0]
	    row.mass2 = mtuple[1]
	 if bin_type == "Mass1_Mass2":
	    row.mass1 = mtuple[0]
	    row.mass2 = mtuple[1]
	 if bin_type == "Total_Mass":
	    row.total_mass = mtuple[0]
	 if bin_type == "Chirp_Mass":
	    row.chirp_mass = mtuple[0]
	 row.range_in_Mpc = distance[mtuple]
	 row.livetime = ltA[mtuple] #FIXME alan doesnt like this
	 row.upper_limit = upper_limit[mtuple]
	 row.upper_limit_including_errors = upper_limit_werrs[mtuple]
	 row.fractional_error = vA2[mtuple]**0.5 / (vA[mtuple])
	 row.injections_found = found[mtuple]
	 row.injections_missed = missed[mtuple]
	 ul_table.append(row)

      columnList = ['range_in_Mpc','livetime','upper_limit','upper_limit_including_errors','fractional_error','injections_found','injections_missed']
      addCols = {"Mass1_Mass2":["mass1","mass2"],"Low_Mass":["mass1","mass2"],"Chirp_Mass":["chirp_mass"],"Total_Mass":["total_mass"]}
      columnList += addCols[bin_type]
      print_tables.print_tables(summary_doc,summary_file,opts.output_format,
				tableList=['upper_limit'],
				columnList = columnList )
      summary_file.close()

      # make plots

      #
      # posterior plots
      #
      for j,mbin in enumerate(iterutils.MultiIter(*bins.centres())):
         if bin_type == "Low_Mass" and bins[mbin] not in [bins[k] for k in [(1.35,1.35),(1.35,5.0),(5.0,5.0)]]:
	    continue # we only care about these three mass bins for the lowmass binning
         if bin_type != "Low_Mass" and j > 10: continue #let's not get ridiculous here
         if found[mbin] > 0:
	    pylab.semilogx(mu,post_werrs[bins[mbin]].cumsum(),label=','.join(["%.1f"%m for m in mbin])+"M$_{\odot}$")
      pylab.title(entry.observatory+ " Cumulative Posterior Rate Distributions",fontsize=14)
      pylab.legend(loc='upper left')
      pylab.ylabel("Cumulative Probability",fontsize=14)
      pylab.xlabel("Merger Rate (1/Mpc$^3$/yr)",fontsize=14)
      pylab.ylim([1e-2, 1])
      pylab.grid()
      pylab.xlim([1e-6, 1e-1]) #FIXME hardcoded rate limits are bad for advanced ligo
      savefig_pylal('posterior', opts.open_box, InspiralUtilsOpts,fnameList,tagList)
      pylab.clf()

      if len(bins) == 1:
         #
         # x-axis formatting
	 #
	 width = bins.upper()[0]-bins.lower()[0]
	 tick_locs = edges(bins)[0]
	 tick_strings = ["%.1f"% m for m in tick_locs]

         #
	 # distance plot in 1d
	 #
	 sec_in_yr = 3600*24*365.0
	 derr = ( vA2.array**0.5 *sec_in_yr / ltA.array / (4./3 *numpy.pi) )**(1./3)
	 pylab.bar(bins.lower()[0],distance.array,width,yerr=derr)
	 pylab.grid()
	 pylab.xticks(tick_locs,tick_strings)
	 pylab.xlim([numpy.min(bins.lower()[0])-numpy.min(width)/2,numpy.max(bins.upper()[0])+numpy.min(width)/2])
	 pylab.title(entry.observatory + " Search Range",fontsize=14)
	 pylab.xlabel(bin_type.replace('_',' ') + " (M$_{\odot}$)",fontsize=14)
	 pylab.ylabel("Range (Mpc)",fontsize=14)
	 savefig_pylal("distance", opts.open_box, InspiralUtilsOpts,fnameList,tagList)
	 pylab.clf()

	 #
	 # upper limit plot in 1d
	 #
	 fudge = 1e-7 #FIXME make sure this number is reasonable
	 pylab.bar(bins.lower()[0],pylab.log10(upper_limit.array + fudge),width,label="without systematic errors",color='k')
	 pylab.bar(bins.lower()[0],pylab.log10(upper_limit_werrs.array + fudge),width,label="with systematic errors",color='b')
	 pylab.grid()
	 pylab.legend()
	 pylab.xticks(tick_locs,tick_strings)
	 pylab.xlim([numpy.min(bins.lower()[0])-numpy.min(width)/2,numpy.max(bins.upper()[0])+numpy.min(width)/2])
	 pylab.ylim([-5,-1]) #FIXME are these numbers sensible?
	 pylab.title(entry.observatory + " 90% Upper Limit",fontsize=14)
	 pylab.xlabel(bin_type.replace('_',' ') + " (M$_{\odot}$)",fontsize=14)
	 pylab.ylabel("Rate Upper Limit (log$_{10}$mergers/Mpc$^3$/yr)",fontsize=14)
	 savefig_pylal('upper_limit_plot', opts.open_box, InspiralUtilsOpts,fnameList,tagList)
	 pylab.clf()

	 #
	 # lambda plot in 1d
	 #
	 fudge = 0.000000001
	 pylab.bar(bins.lower()[0],pylab.log10(dvA.array + fudge),width)
	 pylab.xticks(tick_locs,tick_strings)
	 pylab.grid()
	 pylab.xlim([numpy.min(bins.lower()[0])-numpy.min(width)/2,numpy.max(bins.upper()[0])+numpy.min(width)/2])
	 pylab.ylim([-9,-5]) #FIXME are these numbers sensible?
	 pylab.title(entry.observatory + " Likelihood Ratio of the Loudest Event",fontsize=14)
	 pylab.xlabel(bin_type.replace('_',' ') + " (M$_{\odot}$)",fontsize=14)
	 pylab.ylabel("Likelihood (log$_{10}$ $\Lambda$)",fontsize=14)
	 savefig_pylal('lambda', opts.open_box, InspiralUtilsOpts,fnameList,tagList)
	 pylab.clf()

      if bin_type == "Mass1_Mass2":
         xtick_locs = edges(bins)[0]
	 xtick_strings = ["%.1f"% m for m in xtick_locs]
         ytick_locs = edges(bins)[1]
	 ytick_strings = ["%.1f"% m for m in ytick_locs]

	 #
	 # log volume x time plot
	 #
	 vA.array[vA.array==0] = 0.0001 # give a little volume to empty bins to make log happy
	 pylab.pcolor(edges(bins)[0],edges(bins)[1], pylab.log10(vA.array), vmin=0, vmax=10)
	 pylab.colorbar()
	 pylab.xlim(mrange[0])
	 pylab.ylim(mrange[1])
	 pylab.xticks(xtick_locs,xtick_strings)
	 pylab.yticks(ytick_locs,ytick_strings)
	 pylab.grid()
	 pylab.title(entry.observatory + " Search Volume (log$_{10}$ Mpc$^3$ yr)",fontsize=14)
	 pylab.xlabel("Mass 1",fontsize=14)
	 pylab.ylabel("Mass 2",fontsize=14)
	 pylab.gca().set_aspect(1)
	 savefig_pylal('volume_time', opts.open_box, InspiralUtilsOpts,fnameList,tagList)
	 pylab.clf()

         #
	 # log distance plot
	 #
	 pylab.pcolor(edges(bins)[0],edges(bins)[1], pylab.log10(distance.array) , vmin=0, vmax=3)
	 pylab.colorbar()
	 pylab.xlim(mrange[0])
	 pylab.ylim(mrange[1])
	 pylab.xticks(xtick_locs,xtick_strings)
	 pylab.yticks(ytick_locs,ytick_strings)
	 pylab.grid()
	 pylab.title(entry.observatory + " Search Range (log$_{10} Mpc)",fontsize=14)
	 pylab.xlabel("Mass 1",fontsize=14)
	 pylab.ylabel("Mass 2",fontsize=14)
	 pylab.gca().set_aspect(1)
	 savefig_pylal('distance', opts.open_box, InspiralUtilsOpts,fnameList,tagList)
	 pylab.clf()

	 #
	 # volume error plot
	 #
	 vol_error = vA2.array**0.5 / vA.array
	 pylab.pcolor(edges(bins)[0],edges(bins)[1], vol_error, vmin=0, vmax=1)
	 pylab.colorbar()
	 pylab.xlim(mrange[0])
	 pylab.ylim(mrange[1])
	 pylab.xticks(xtick_locs,xtick_strings)
	 pylab.yticks(ytick_locs,ytick_strings)
	 pylab.grid()
	 pylab.title(entry.observatory + " Fractional Error on Search Volume (std/mean)",fontsize=14)
	 pylab.xlabel("Mass 1",fontsize=14)
	 pylab.ylabel("Mass 2",fontsize=14)
	 pylab.gca().set_aspect(1)
	 savefig_pylal('fractional_error', opts.open_box, InspiralUtilsOpts,fnameList,tagList)
	 pylab.clf()

	 #
	 # lambda plot
	 #
	 log_der = pylab.log10(dvA.array + 0.000000001)
	 pylab.pcolor(edges(bins)[0],edges(bins)[1], log_der, vmin=-9, vmax=-3) #FIXME hard limits
	 pylab.colorbar()
	 pylab.xlim(mrange[0])
	 pylab.ylim(mrange[1])
	 pylab.xticks(xtick_locs,xtick_strings)
	 pylab.yticks(ytick_locs,ytick_strings)
	 pylab.grid()
	 pylab.title(entry.observatory + " Likelihood Ratio (log$_{10} $\Lambda$)",fontsize=14)
	 pylab.xlabel("Mass 1",fontsize=14)
	 pylab.ylabel("Mass 2",fontsize=14)
	 pylab.gca().set_aspect(1)
	 savefig_pylal('lambda', opts.open_box, InspiralUtilsOpts,fnameList,tagList)
	 pylab.clf()

	 #
	 # upper limit plot
	 #
         fudge = 0.01 * min (upper_limit_werrs.array[upper_limit_werrs.array !=0])
	 log_ul = pylab.log10(upper_limit_werrs.array + fudge)
	 pylab.pcolor(edges(bins)[0],edges(bins)[1], log_ul, vmin=-7, vmax=0)
	 pylab.colorbar()
	 pylab.xlim(mrange[0])
	 pylab.ylim(mrange[1])
	 pylab.xticks(xtick_locs,xtick_strings)
	 pylab.yticks(ytick_locs,ytick_strings)
	 pylab.grid()
	 pylab.title(entry.observatory + " 90% Upper Limit (log$_{10}$ mergers/Mpc$^3$/yr)",fontsize=14)
	 pylab.xlabel("Mass 1",fontsize=14)
	 pylab.ylabel("Mass 2",fontsize=14)
	 pylab.gca().set_aspect(1)
	 savefig_pylal('upper_limit_plot', opts.open_box, InspiralUtilsOpts,fnameList,tagList)
	 pylab.clf()

      plothtml = InspiralUtils.write_html_output( InspiralUtilsOpts, [], fnameList,
						  tagList, add_box_flag = False ) #FIXME make sure it's ok to pass []
      InspiralUtils.write_cache_output( InspiralUtilsOpts, plothtml, fnameList )

   ###############################################################################
   # now write out the special combined case
   ###############################################################################

   # Initialize inspiral utility plotting helper
   __prog__ = "lalapps_cbc_combined_sink_"+bin_type
   opts.ifo_times = combined_ifos
   InspiralUtilsOpts = InspiralUtils.initialise( opts, __prog__, git_version.verbose_msg )
   fnameList = []; tagList = []

   # Compute combined upper limits (including errors)
   combined_post = numpy.ones(bins.shape+(len(mu),))
   combined_post_werrs = numpy.ones(bins.shape+(len(mu),))
   for mbin in iterutils.MultiIter(*bins.centres()):
      for post,post_werr in zip(posteriors,posteriors_werrs):
         # multiply individual posteriors to get combined posterior
         combined_post[bins[mbin]] *= post[bins[mbin]]
         combined_post_werrs[bins[mbin]] *= post_werr[bins[mbin]]

   combined_upper_limit = integrate_posterior(mu, combined_post, bins, 0.90)
   combined_upper_limit_werrs = integrate_posterior(mu, combined_post_werrs, bins, 0.90)

   #
   # combined posterior plot
   #
   for j,mbin in enumerate(iterutils.MultiIter(*bins.centres())):
      if bin_type == "Low_Mass" and bins[mbin] not in [bins[k] for k in [(1.35,1.35),(1.35,5.0),(5.0,5.0)]]:
         continue # we only care about these three mass bins for the lowmass binning
      if bin_type != "Low_Mass" and j > 10: continue #let's not get ridiculous here
      if combined_upper_limit[mbin] < float('inf'):
         pylab.semilogx(mu,combined_post[bins[mbin]].cumsum(),label=','.join(["%.1f"%m for m in mbin])+"M$_{\odot}$")
   pylab.title(combined_ifos+ " Combined Cumulative Posterior Rate Distributions",fontsize=14)
   pylab.legend(loc='upper left')
   pylab.ylabel("Cumulative Probability",fontsize=14)
   pylab.xlabel("Merger Rate (1/Mpc$^3$/yr)",fontsize=14)
   pylab.ylim([1e-2, 1])
   pylab.grid()
   pylab.xlim([1e-6, 1e-1]) #FIXME hardcoded rate limits are bad for advanced ligo
   savefig_pylal('combined_posterior', opts.open_box, InspiralUtilsOpts,fnameList,tagList)
   pylab.clf()

   #
   # combined upper limit plot
   #
   log_ul = pylab.log10(combined_upper_limit_werrs.array + 1e-7) #FIXME make sure 1e-7 is OK
   if len(bins) == 1:
      #FIXME hard limits at log(rate) of -7, 0
      pylab.bar(bins.lower()[0],pylab.log10(combined_upper_limit.array + fudge),width,label="without systematic errors",color='k')
      pylab.bar(bins.lower()[0],pylab.log10(combined_upper_limit_werrs.array + fudge),width,label="with systematic errors",color='b')
      pylab.title(combined_ifos + " Combined 90% Upper Limit",fontsize=14)
      pylab.legend()
      pylab.xticks(tick_locs,tick_strings)
      pylab.xlim([numpy.min(bins.lower()[0])-numpy.min(width)/2,numpy.max(bins.upper()[0])+numpy.min(width)/2])
      pylab.xlabel(bin_type.replace('_',' ') + " (M$_{\odot}$)",fontsize=14)
      pylab.ylabel("Upper Limit (log$_{10}$ 1/Mpc$^3$/yr)")
      pylab.grid()
      savefig_pylal('combined_upper_limit_plot', opts.open_box, InspiralUtilsOpts,fnameList,tagList)
      pylab.clf()

   if bin_type == "Mass1_Mass2":
      #FIXME hard limits at log(rate) of -7, 0
      pylab.pcolor(edges(bins)[0],edges(bins)[1], log_ul, vmin=-7.0, vmax=0)
      pylab.colorbar()
      pylab.xlim(mrange[0])
      pylab.ylim(mrange[1])
      pylab.xticks(xtick_locs,xtick_strings)
      pylab.yticks(ytick_locs,ytick_strings)
      pylab.grid()
      pylab.title("Combined 90% Upper Limit (log$_{10}$ 1/Mpc$^3$/yr)",fontsize=14)
      pylab.xlabel("Mass 1",fontsize=14)
      pylab.ylabel("Mass 2",fontsize=14)
      pylab.gca().set_aspect(1)
      savefig_pylal('combined_upper_limit_plot', opts.open_box, InspiralUtilsOpts,fnameList,tagList)
      pylab.clf()

   plothtml = InspiralUtils.write_html_output( InspiralUtilsOpts, [], fnameList,
					       tagList, add_box_flag = False ) #FIXME
   InspiralUtils.write_cache_output( InspiralUtilsOpts, plothtml, fnameList )

   #
   # write out combined statistics
   #
   summary_file = open(opts.output_path + combined_ifos + '-' + opts.user_tag +'_'+ bin_type+'_combined_upper_limit.'+opts.output_format,'w')
   summary_doc = ligolw.Document()
   summary_doc.appendChild(ligolw.LIGO_LW())
   ul_table = lsctables.New(UpperLimitTable)
   summary_doc.childNodes[0].appendChild(ul_table)

   for mbin in iterutils.MultiIter(*bins.centres()):
      if not total_found[bins[mbin]]+total_missed[bins[mbin]]:
         continue
      row = ul_table.RowType()
      if bin_type == "Low_Mass":
         if bins[mbin] not in [bins[k] for k in [(1.35,1.35),(1.35,5.0),(5.0,5.0)]]:
	    # only print out the canonical lowmass bins 1.35-1.35 (BNS),
	    # 5-5 (BBH) and 1.35-5 (NSBH)
	    continue
	 row.mass1 = mbin[0]
	 row.mass2 = mbin[1]
      if bin_type == "Mass1_Mass2":
         row.mass1 = mbin[0]
	 row.mass2 = mbin[1]
      if bin_type == "Total_Mass":
         row.total_mass = mbin[0]
      if bin_type == "Chirp_Mass":
         row.chirp_mass = mbin[0]
      row.range_in_Mpc = (total_vol[bins[mbin]]/total_lt[bins[mbin]] /(4*numpy.pi/3) )**(1./3)
      row.livetime = total_lt[bins[mbin]] #FIXME alan doesnt like this
      row.fractional_error = total_err[bins[mbin]]**0.5 / total_vol[bins[mbin]]
      row.injections_found = total_found[bins[mbin]]
      row.injections_missed = total_missed[bins[mbin]]
      row.upper_limit = combined_upper_limit[mbin]
      row.upper_limit_including_errors = combined_upper_limit_werrs[mbin]
      ul_table.append(row)

   columnList = ['range_in_Mpc','livetime','upper_limit','upper_limit_including_errors','fractional_error','injections_found','injections_missed']
   addCols = {"Mass1_Mass2":["mass1","mass2"],"Low_Mass":["mass1","mass2"],"Chirp_Mass":["chirp_mass"],"Total_Mass":["total_mass"]}
   columnList += addCols[bin_type]
   print_tables.print_tables(summary_doc,summary_file,opts.output_format,
			     tableList=['upper_limit'],
			     columnList = columnList)
   summary_file.close()


print >> sys.stderr, "ALL FINNISH!"
