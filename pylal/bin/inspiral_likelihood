#!/usr/bin/python

import sys
import exceptions 
from optparse import *
import glob
import re

from glue import lal
from glue.ligolw import lsctables
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils
from pylal import SimInspiralUtils
from pylal import inspiral_likelihood
from pylal.tools import XLALCalculateEThincaParameter

#from pylab import*
import glue.iterutils
import numpy
import cmath
numpy.seterr("raise")

################################################################################
# Main program.
################################################################################
usage= """
usage: %prog [options]

Calculates likelihood ratio and assigns rank based on it to each 
candidate event.
"""
###############################################################################
# Options for input
###############################################################################
parser = OptionParser( usage=usage, version="%prog CVS $Id$ " )
parser.add_option("","--candidate-events-glob",action="store",type="string",\
    default=None, metavar="CANDIDATEEVENTSGLOB",help="GLOB thinca (coire) files containing candidate events for which the likelihood is going to be calculated" )
parser.add_option("","--background-glob",action="store",type="string",\
    default=None, metavar="SLIDESGLOB",help="GLOB time slides thinca (coire) files that are going to be used to estimate the background" )
parser.add_option("","--found-injections-glob",action="store",type="string",\
    default=None, metavar="INJGLOB",help="GLOB thinca (coire) files with found software injections that are going to be used to estimate the foreground" )
parser.add_option("","--missed-injections-glob",action="store",type="string",\
    default=None, metavar="INJGLOB",help="GLOB thinca (coire) files with missed software injections that are going to be used to estimate the foreground" )
	
		
parser.add_option("-c","--candidate-events-cache-file",action="store",type="string",\
    default=None, metavar="CANDIDATEEVENTSCACHEFILE",help="name of the cache file (including the path) that points to thinca (coire) files containing candidate events for which the likelihood is going to be calculated " )
parser.add_option("","--background-cache-files",action="store",type="string",\
    default=None, help="names of the cache files (including the path) separated by commas that points to thinca (coire) files that are going to be used to estimate the background (timeslides) " )
parser.add_option("","--foreground-cache-files",action="store",type="string",\
    default=None, help="names of the cache files (including the path) separated by commas that points to thinca (coire) files that are going to be used to estimate the foregorund (injections) " )	
parser.add_option("","--candidate-events-pattern",\
    default="", metavar="CANDIDATEEVENTSPATTERN", help="the candidate events files pattern the corresponding cache file will be seived with.")
parser.add_option("","--background-pattern",\
    default="", metavar="BACKGROUNDPATTERN", help="the background events files pattern the corresponding cache file will be seived with.")
parser.add_option("","--found-injections-pattern",\
    default="", metavar="FOUNDINJECTIONSPATTERN", help="the found injections files pattern the corresponding cache file will be seived with.")
parser.add_option("","--missed-injections-pattern",\
    default="", metavar="MISSEDINJECTIONSPATTERN", help="the missed injections files pattern the corresponding cache file will be seived with.")
#################################################################################
# Options for output
##################################################################################
parser.add_option("","--output-file",action="store",type="string",\
	default=None, metavar="OUTPUTFILE",\
	help="Option that allows user to set the full name (including path) of the output file" )
parser.add_option("-u","--user-tag",action="store",type="string",\
	default="", metavar=" USERTAG",\
	help="The user tag used in the name of the name of the output file " )
parser.add_option("","--ifo-tag",action="store",type="string",\
	default="", metavar=" IFOTAG",\
	help="The ifo tag used in the name of the output file (e.g. SECOND_H1H2L1)")      
parser.add_option("","--gps-start-time",action="store", type="int", default=0, metavar="GPSSTARTTIME",\
	help="gps start time used in the name of the output file")
parser.add_option("","--gps-end-time",action="store", type= "int", default=0, metavar="GPSENDTIME",\
	help="gps end time used in the name of the output file")
parser.add_option("","--ifo-times",action="store",type="string",\
    default="", metavar="IFOS",\
	help="sets ifo times for which plots will be made (e.g. H1H2L1)" )
parser.add_option("-v","--verbose",action="store_true",\
	default=False,help="print information" )
####################################################################################	
# Options to select parameters for calculation of p(c|0), p(c|h) and likelihood ratio. 
####################################################################################
parser.add_option("","--calculate_DBR", action="store_true",\
    default = False, help="if given, Background Fraction and Detection Background Ratio (DBR) will be calculated,"\
	"otherwise they are set to zero for all events." )
	
parser.add_option("-S","--statistic",action="store",default='snr', type="string",\
    help="choice of statistic used in making plots, valid arguments are: snr (DEFAULT), snr_over_chi, s3_snr_chi_stat, effective_snr, bitten_l, bitten_lsq")

parser.add_option("","--eff-snr-epsilon",action="store",type="float",\
    default=0.2, help="allowed fractional error in effective snr" )
	
parser.add_option("","--eff-dist-epsilon",action="store",type="float",\
    default=0.2, help="allowed fractional error in rms effective distance" )
	
parser.add_option("","--mchirp-epsilon",action="store",type="float",\
    default=0.5, help="allowed fractional error in chirp mass" )
	
parser.add_option("","--eff-dist-theta-scale",action="store",type="float",\
    default=0.03490, help="allowed absolute error in effective distance theta angle in degrees")

parser.add_option("","--eff-dist-phi-scale",action="store",type="float",\
    default=0.17453, help="allowed absolute error in effective distance phi angle in degrees")
	
parser.add_option("","--mchirp-theta-scale",action="store",type="float",\
    default=0.03490, help="allowed absolute error in chirp mass theta angle in degrees")
  
parser.add_option("","--mchirp-phi-scale",action="store",type="float",\
    default=3.14159, help="allowed absolute error in chirp mass phi angle degrees")

parser.add_option("","--ethinca-scale",action="store",type="float",\
    default=0.1, help="allowed absolute error in e-thinca parameter")
	
parser.add_option("","--enable-eff-snr-dimension", action="store_true",\
    default = False, help="to include effective SNRs in the parameter space" )
	
parser.add_option("","--enable-eff-distance-dimension", action="store_true",\
    default = False, help="to include effective distances in the parameter space" )
	
parser.add_option("","--enable-mchirp-dimension", action="store_true",\
    default = False, help="to include chirp masses in the parameter space" )
	
parser.add_option("","--enable-ethinca-dimension", action="store_true",\
    default = False, help="to include e-thinca in the parameter space" )
		
parser.add_option("-N","--num-slides", action="store",type="int",\
    default = 0, metavar="numslides", help="number of time slides performed, must match the corresponding parameter from the .ini file" )

(opts,args) = parser.parse_args()

###############################################################################################


# read in the candidate events files
if opts.candidate_events_cache_file:
  CandidateEventsFiles = []
  CandidateEventsCache = lal.Cache.fromfile(open(opts.candidate_events_cache_file))
  CandidateEventsFiles = CandidateEventsCache.sieve(description = opts.candidate_events_pattern).checkfilesexist()[0].pfnlist()
elif opts.candidate_events_glob:
  CandidateEventsFiles = []
  CandidateEventsFiles = glob.glob(opts.candidate_events_glob)
else: 
  print >>sys.stderr, "either " + opts.candidate_events_cache_file + " or " + opts.candidate_events_glob + "must be given"
  sys.exit(1)  

if len(CandidateEventsFiles) < 1:
  print >>sys.stderr, "The list of CandidateEventsFiles is empty"
  sys.exit(1)




if opts.background_cache_files and opts.foreground_cache_files:
  BackgroundFiles = []
  FoundInjectionsFiles = []
  MissedInjectionsFiles = []
  BackgroundCacheFiles = opts.background_cache_files.split(",")
  ForegroundCacheFiles = opts.foreground_cache_files.split(",")
  for cachefile in BackgroundCacheFiles:  
    BackgroundCache = lal.Cache.fromfile(open(cachefile))
	#check that all files containing background events exist
    if len(BackgroundCache.sieve(description = opts.background_pattern).checkfilesexist()[1].pfnlist()):
	  print >> sys.stderr, " Not all files from " + cachefile + " containing background events were found."
	  print BackgroundCache.sieve(description = opts.background_pattern).checkfilesexist()[1].pfnlist()
	  sys.exit(1)   
    BackgroundFiles += BackgroundCache.sieve(description = opts.background_pattern).checkfilesexist()[0].pfnlist()
  for cachefile in ForegroundCacheFiles:  
    ForegroundCache = lal.Cache.fromfile(open(cachefile))
	#check that all files containing foreground events exist
    if len(ForegroundCache.sieve(description = opts.found_injections_pattern).checkfilesexist()[1].pfnlist()):
	  print >> sys.stderr, " Not all files from " + cachefile + " containing foreground events were found."
	  sys.exit(1)   
    FoundInjectionsFiles += ForegroundCache.sieve(description = opts.found_injections_pattern).checkfilesexist()[0].pfnlist()
    MissedInjectionsFiles += ForegroundCache.sieve(description = opts.missed_injections_pattern).checkfilesexist()[0].pfnlist() 	
elif opts.background_glob and opts.found_injections_glob and opts.missed_injections_glob:
  BackgroundFiles = []
  FoundInjectionsFiles = []
  MissedInjectionsFiles = []    
  BackgroundFiles = glob.glob(opts.background_glob)
  FoundInjectionsFiles = glob.glob(opts.found_injections_glob)
  MissedInjectionsFiles = glob.glob(opts.missed_injections_glob)
else:	
 print >>sys.stderr, "either " + opts.background_foreground_cache_file + " or " + opts.background_glob + " and " + opts.found_injections_glob + " and " + opts.missed_injections_glob + "must be given"
 sys.exit(1)
 
if len(BackgroundFiles) < 1:
  print >>sys.stderr, "The " + opts.background_foreground_cache_file  + "contains no time slides files "
  sys.exit(1)

if len(FoundInjectionsFiles) < 1:
  print >>sys.stderr, "The " + opts.background_foreground_cache_file  + "contains no found injections files "
  sys.exit(1)
  
if len(MissedInjectionsFiles) < 1:
  print >>sys.stderr, "The " + opts.background_foreground_cache_file  + "contains no missed injections files "
  sys.exit(1)

if not len(FoundInjectionsFiles) == len(MissedInjectionsFiles):
  print >>sys.stderr, " The number of found injections files does not match the number of missed injections files"
  sys.exit(1)
  
# check if number of slides is given
if opts.num_slides == 0:
  print >> sys.stderr, "--num_slides must be specified"
  sys.exit(1)
 
# check that statistic is OK:
if opts.statistic not in ('snr', 'snr_over_chi', 's3_snr_chi_stat', 'effective_snr', 'bitten_lsq', 'bitten_l'):
  print >>sys.stderr, "--statistic must be one of"  
  print >>sys.stderr, "(snr|snr_over_chi|s3_snr_chi_stat|effective_snr|bitten_l)"
  sys.exit(1)
  
statistic = CoincInspiralUtils.coincStatistic(opts.statistic) 

###############################################################################
# read in candidate events coincident triggers

CandidateEventsTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(CandidateEventsFiles, mangle_event_id=False)

# construct the candidate events coincs 
CandidateEventsCoincTriggers = CoincInspiralUtils.coincInspiralTable(CandidateEventsTriggers, statistic)

# read in time slides triggers 

#SlidesTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(BackgroundFiles, mangle_event_id=True)

# construct the time slides coincs
#SlidesCoincTriggers= \
#CoincInspiralUtils.coincInspiralTable(SlidesTriggers, statistic)


# read in found injections sngl and sim inspirals

#FoundInjectionsTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(FoundInjectionsFiles, mangle_event_id=True)

 #FoundSimTriggers = SimInspiralUtils.ReadSimInspiralFromFiles(FoundInjectionsFiles)   


#construct injection coincs and add sim inspirals

#FoundInjectionsCoincTriggers= \
#CoincInspiralUtils.coincInspiralTable(FoundInjectionsTriggers, statistic)

#FoundInjectionsCoincTriggers.add_sim_inspirals(FoundSimTriggers)

# read in missed injections sim inspirals

#MissedSimTriggers = SimInspiralUtils.ReadSimInspiralFromFiles(MissedInjectionsFiles)   


######################################
#Experimental area

#counter=0
#file=open('slidestriggers', 'w')
#for trigger in slidesCoincTriggers:
#  ifo, ifolist = trigger.get_ifos()
#  file.write(str(ifo) + '\n')
#  counter+=1
#print str(counter)
#file.close()

#for candidate in injectionTestCoincTriggers:
  #  ethinca=XLALCalculateEThincaParameter(candidate.H1, candidate.L1)
  #c_ifo, ifolist = candidate.get_ifos()
  #if c_ifo=='H1H2L1':
    #print candidate.event_id
    #simethinca = CoincInspiralUtils.simpleEThinca(candidate.H1, candidate.L1)
    #ethinca=XLALCalculateEThincaParameter(candidate.H1, candidate.L1)
    #print 'H1L1', ethinca, simethinca
    #simethinca = CoincInspiralUtils.simpleEThinca(candidate.H2, candidate.L1)
    #ethinca=XLALCalculateEThincaParameter(candidate.H2, candidate.L1)
    #print 'H2L1', ethinca, simethinca
    #simethinca = CoincInspiralUtils.simpleEThinca(candidate.H1, candidate.H2)
    #ethinca=XLALCalculateEThincaParameter(candidate.H1, candidate.H2)
    #print 'H1H2', ethinca, simethinca
 
  #  if simethinca > 100.0:
  #    CoincInspiralUtils.simpleEThinca(candidate.H1, candidate.L1)
  #    print simethinca

  #  d_tmp1=1.0 - simethinca**2
  #  d_tmp2=1.0 - simethinca**2/4.0
  #  d_tmp3=simethinca**2/4.0
  #print simethinca


############################################################################################################
# Likelihood calculation
###########################################################################################################
##########################################################################################
# calculate likelihood for candidate events 
#########################################################################################
# convert parameters given in degrees into radians
eff_dist_theta_scale = opts.eff_dist_theta_scale * cmath.pi/float(180)
eff_dist_phi_scale = opts.eff_dist_phi_scale * cmath.pi/float(180)
mchirp_theta_scale = opts.mchirp_theta_scale * cmath.pi/float(180)
mchirp_phi_scale = opts.mchirp_phi_scale * cmath.pi/float(180)   
# Calculate False Alarm Probability and Background Fraction
array_size = len(CandidateEventsCoincTriggers)
FAProduct = numpy.zeros(array_size) + 1.0
Ntotal_noise = 0
if opts.calculate_DBR:
  Nnoise_events_within_epsilon = numpy.zeros(array_size)
# loop over time slides files
for file in BackgroundFiles:
  # read in time slides triggers
  SlidesTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles([file], mangle_event_id=False)
  # construct the time slides coincs
  SlidesCoincTriggers = CoincInspiralUtils.coincInspiralTable(SlidesTriggers, statistic)
  if opts.calculate_DBR and SlidesCoincTriggers:
    Ntotal_noise += len(SlidesCoincTriggers)
  # False Alarm Probability for the current time slides file
  i = 0
  # looping over candidate events and calculating the false alarm probability
  for candidate in CandidateEventsCoincTriggers:
    c_ifos,ifolist=candidate.get_ifos()
    slides_array=numpy.zeros(2*opts.num_slides)
    slides_within_epsilon = SlidesCoincTriggers.getTriggersWithinEpsilonBox(candidate, opts.enable_eff_snr_dimension, opts.enable_mchirp_dimension, opts.enable_ethinca_dimension, opts.enable_eff_distance_dimension,\
    opts.eff_snr_epsilon, opts.eff_dist_epsilon, opts.mchirp_epsilon, eff_dist_theta_scale, eff_dist_phi_scale, mchirp_theta_scale, mchirp_phi_scale, opts.ethinca_scale)
    for slide in range(1, opts.num_slides + 1):
	  slideTriggers_forward = slides_within_epsilon.getslide(slide)
	  slideTriggers_backward = slides_within_epsilon.getslide(-slide)
	  if len(slideTriggers_forward) >= 1:
	    slides_array[slide - 1] = 1.0
	  if len(slideTriggers_backward) >= 1:
	    slides_array[opts.num_slides -1 + slide] = 1.0
    FAProb = sum(slides_array)/float(2*opts.num_slides)
    FAProduct[i] = FAProduct[i] * (1.0 - FAProb)
    if opts.calculate_DBR:
      # accumulating statistic for Background Fraction 
      Nnoise_events_within_epsilon[i] += len(SlidesCoincTriggers.getTriggersWithinEpsilonBox(candidate, opts.enable_eff_snr_dimension, opts.enable_mchirp_dimension, opts.enable_ethinca_dimension, opts.enable_eff_distance_dimension,\
	    opts.eff_snr_epsilon, opts.eff_dist_epsilon, opts.mchirp_epsilon, eff_dist_theta_scale, eff_dist_phi_scale, mchirp_theta_scale, mchirp_phi_scale, opts.ethinca_scale))
    i += 1
FalseAlarmProb = 1.0 - FAProduct 
if opts.calculate_DBR:  
  if Ntotal_noise > 0:
    BackgroundFraction = Nnoise_events_within_epsilon / float(Ntotal_noise)
  else:
    BackgroundFraction = numpy.zeros(array_size)
else:
  # if option --calculate-DBR is not given we set BackroundFraction to zero for all events
  BackgroundFraction = numpy.zeros(array_size) 
	 
# Calculate Detection Probability
Ntotal_found_injections = 0
N_injections_within_epsilon = numpy.zeros(array_size)
# loop over found injections files 	
for file in FoundInjectionsFiles:
  if opts.verbose:
    print file
  FoundInjectionsTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles([file], mangle_event_id=False)
  FoundInjectionsCoincTriggers = CoincInspiralUtils.coincInspiralTable(FoundInjectionsTriggers, statistic)
  if FoundInjectionsCoincTriggers:
    if opts.verbose:
      print len(FoundInjectionsCoincTriggers)
    Ntotal_found_injections += len(FoundInjectionsCoincTriggers)
  i = 0
  for candidate in CandidateEventsCoincTriggers:
    # accumulating statistic for Detection Probability
    N_injections_within_epsilon[i] += len(FoundInjectionsCoincTriggers.getTriggersWithinEpsilonBox(candidate, opts.enable_eff_snr_dimension, opts.enable_mchirp_dimension, opts.enable_ethinca_dimension, opts.enable_eff_distance_dimension,\
	  opts.eff_snr_epsilon, opts.eff_dist_epsilon, opts.mchirp_epsilon, eff_dist_theta_scale, eff_dist_phi_scale, mchirp_theta_scale, mchirp_phi_scale, opts.ethinca_scale))
    i += 1

Ntotal_missed_injections = 0
# loop over missed injections files
# Currently we assume that all missed injections were made at effective distance exceeding the horizon
# therefore we will disregard them. If this approximation turn out to be always valid, options related to 
# missed injections should be removed completely.
# For now we just comment out the section below  
#for file in MissedInjectionsFiles:
#  if opts.verbose:
#	print file
#  MissedSimTriggers = SimInspiralUtils.ReadSimInspiralFromFiles([file])
#  if MissedSimTriggers:
#    if opts.verbose:
#      print len(MissedSimTriggers)   
#    Ntotal_missed_injections += len(MissedSimTriggers)
	
DetectionProb = N_injections_within_epsilon / float(Ntotal_found_injections + Ntotal_missed_injections)
  
# Calculating likelihood ratio
for i in range(array_size):  
  if FalseAlarmProb[i] > 0:
    pass
  else:
	#Likelihood[i] = -1.0
	# below is a temporary fix for the case of vanishing false alarm probability
	FalseAlarmProb[i] = 1.0 / float(4.0*opts.num_slides)
	 
Likelihood = DetectionProb / FalseAlarmProb
   
# Calculating the ratio of DetectionProb to BackgroundFraction
if opts.calculate_DBR:
  for i in range(array_size):  
    if BackgroundFraction[i] > 0:
	  pass
    else:
	  #DetectionBackgroundRatio[i] = -1.0
	  # below is a temporary fix for the case of vanishing false alarm probability
	  BackgroundFraction[i] = 1.0 / float(2.0 * Ntotal_noise)
	
  DetectionBackgroundRatio= DetectionProb / BackgroundFraction
else:
  # if option --calculate-DBR is not given we set DetectionBackroundRatio to zero for all events 
  DetectionBackgroundRatio = numpy.zeros(array_size)

#populating InspiralLikelihoodTable
LikelihoodTable = lsctables.New(inspiral_likelihood.InspiralLikelihoodTable)
i = 0
for candidate in CandidateEventsCoincTriggers:
  inspLikelihood = inspiral_likelihood.InspiralLikelihood()
  c_ifos,ifolist = candidate.get_ifos()
  inspLikelihood.ifo = c_ifos
  inspLikelihood.event_id = candidate.event_id 	
  inspLikelihood.false_alarm_prob = FalseAlarmProb[i]
  inspLikelihood.detect_prob = DetectionProb[i]
  inspLikelihood.likelihood = Likelihood[i]
  inspLikelihood.bg_frac = BackgroundFraction[i]
  inspLikelihood.detect_bg_frac_ratio = DetectionBackgroundRatio[i]
  LikelihoodTable.append(inspLikelihood)
  i += 1
  
# writing InspiralLikelihoodTable into a file
# setting the name for the output file
if opts.output_file:
  output_file_name = opts.output_file
else:
  prefix, suffix = inspiral_likelihood.generate_prefix_and_suffix(ifo_times=opts.ifo_times, program_name="Likelihood", ifo_tag=opts.ifo_tag, user_tag=opts.user_tag, gps_start_time=opts.gps_start_time, gps_end_time=opts.gps_end_time)
  output_file_name = prefix + suffix + ".xml"
  
LikelihoodFile = open(output_file_name, "w")
LikelihoodTable.write(LikelihoodFile)
LikelihoodFile.close()

if opts.verbose:
  for row in LikelihoodTable:
    print row.ifo, row.event_id, row.false_alarm_prob, row.detect_prob, row.likelihood, row.bg_frac, row.detect_bg_frac_ratio
