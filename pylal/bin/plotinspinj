#!/usr/bin/python

# $Id$
__author__ = "Stephen Fairhurst <sfairhurs@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


import sys, os, re, exceptions, glob, optparse, itertools
from types import *

from glue import segmentsUtils
from glue.ligolw import ligolw, table as tab, lsctables, utils

from pylal import SnglInspiralUtils, SimInspiralUtils
from pylal.tools import XLALEThincaParameterForInjection as ethinca_param
from numpy import histogram

##############################################################################
usage = """usage: %prog [options] file1 (file2 file3)

Inspiral Injection Plotting Functions

Generate a set of summary plots from triggers and found injections stored as
sngl_inspiral and sim_inspiral table in LIGO lightweight format
respectively.  The routine expects that there are equal numbers of triggers
and injections stored in the files.  

The various plots can be turned on by selecting them.  For plots and
histograms, the AXIS can be specified.  This gives the Y-axis scale for plots and the width for the histograms.

Available plots:

1) Chirp mass accuracy can be plotted as:
  a) a function of the injected chirp mass, using --plot-mchirp
  b) a histogram, using --hist-mchirp
  c) a function of the injected effective distance, using --chirp-dist
  d) a function of the detected SNR, using --chirp-snr
The width of all these plots is set using --chirp-axis

2) Eta accuracy can be plotted as:
  a) a function of the injected eta, using --plot-eta
  b) a histogram, using --hist-eta
The width of all these plots is set using --eta-axis

3) End time accuracy can be plotted as:
  a) a function of the injected end time, using --plot-time
  b) a histogram, using --hist-time
  c) a function of the injected effective distance, using --time-dist
  d) a function of the detected SNR, using --time-snr
The width of all these plots is set using --time-axis

4) Effective distance accuracy can be plotted as:
  a) a function of the injected eta, using --plot-dist
  b) a histogram, using --hist-dist
The width of these plots is set using --dist-axis
  c) injected vs detected distance can be plotted using --dist-dist 

5) E-thinca parameter between a trigger and an injection can be plotted as:
  a) a function of the difference between a common parameter in the trigger and
     injections, using --ethinca-param-vs (ex: --ethinca-param-vs=end_time)
  b) histogram, using --hist-ethinca

"""
parser = optparse.OptionParser( usage=usage, version="%prog CVS $Id$")
    
parser.add_option("-m","--plot-mchirp",action="store_true",default=False,\
    help="plot the chirp mass accuracy" )
parser.add_option("-M","--hist-mchirp",action="store_true",default=False,\
    help="histogram of the chirp mass accuracy" )
parser.add_option("-o","--chirp-dist",action="store_true",default=False,\
    help="plot of chirp mass accuracy vs effective dist" )
parser.add_option("-q","--chirp-snr",action="store_true",default=False,\
    help="plot of chirp mass accuracy vs snr" )
parser.add_option("-C","--chirp-axis",action="store",type="float",\
    default=0, metavar=" M_SUN",help="width of chirp mass accuracy in plots" )
parser.add_option("","--mchirp-mchirp",action="store_true",default=False,\
    help="plot of injected vs recovered mchirp" )

parser.add_option("-e","--plot-eta",action="store_true",default=False,\
    help="plot the eta accuracy" )
parser.add_option("-E","--hist-eta",action="store_true",default=False,\
    help="histogram of the eta accuracy" ) 
parser.add_option("-a","--eta-snr",action="store_true",default=False,\
    help="plot of eta accuracy vs snr" )
parser.add_option("-F","--eta-axis",action="store",type="float",\
    default=0, metavar=" UNITS",help="width of eta accuracy in plots" )

parser.add_option("-t","--plot-time",action="store_true",default=False,\
    help="plot of the timing accuracy" )
parser.add_option("-T","--hist-time",action="store_true",default=False,\
    help="histogram of the timing accuracy" )
parser.add_option("-p","--time-dist",action="store_true",default=False,\
    help="plot of timing accuracy vs effective dist" )
parser.add_option("-r","--time-snr",action="store_true",default=False,\
    help="plot of timing accuracy vs snr" )
parser.add_option("-S","--time-axis",action="store",type="float",\
    default=0, metavar=" SEC",help="width of timing accuracy in plots" )

parser.add_option("-i","--plot-dist",action="store_true",default=False,\
    help="plot of the effective distance accuracy" )
parser.add_option("-I","--hist-dist",action="store_true",default=False,\
    help="histogram of the effective distance accuracy" )
parser.add_option("-k","--dist-dist",action="store_true",default=False,\
    help="plot of injected vs recovered distance" )
parser.add_option("-D","--dist-axis",action="store",type="float",\
    default=0,metavar=" FRAC_DIFF",help="width of distance accuracy in plots")

parser.add_option("", "--ethinca-vs-diff", dest="ethinca_vs_diff", \
    action='append', default=[], \
    help="plot maximum ethinca parameter for which "\
    "the trigger's ellipse encloses the true injection params "\
    "vs difference in given column between injection and trigger")
parser.add_option("", "--ethinca-vs-snr", action="store_true", \
    default=False, help="plot minimum ethinca parameter for which "\
    "the trigger's ellipse encloses the true injection params "\
    "vs the inverse of the snr of the trigger")

parser.add_option("", "--log-x", action="store_true", default=False,\
    help="plot the x-axis on a log scale (only implemented for ethinca "
    " plots)")
parser.add_option("", "--log-y", action="store_true", default=False,\
    help="plot the y-axis on a log scale (only implemented for ethinca "
    " plots)")
parser.add_option("", "--hist-ethinca", action="store_true", default=False,\
    help="histogram ethinca parameters between injections and recovered triggers")

parser.add_option("-c", "--coire-split", action="store_true", default=False,\
    help="split coired triggers into sire-like single ifo triggers")

parser.add_option("-1","--tag1",action="store",type="string",\
    default=None, metavar=" TAG",help="identifier for first input file" )
parser.add_option("-2","--tag2",action="store",type="string",\
    default=None, metavar=" TAG",help="identifier for second input file" )
parser.add_option("-3","--tag3",action="store",type="string",\
    default=None, metavar=" TAG",help="identifier for third input file" )
parser.add_option("-s","--show-plot",action="store_true",default=False,\
    help="display the figures on the terminal" )
parser.add_option("-n","--nbins",action="store",type="int",default=10,\
    metavar=" NBINS", help="number of bins for the histogram plots (default 10)" )
parser.add_option("-f","--figure-name",action="store",type="string",\
    default=None, metavar=" FNAME",\
    help="generate png figures with name FNAME-fig.png" ) 
parser.add_option("-x","--title-text",action="store",type="string",\
    default=None, metavar=" TEXT",\
    help="add TEXT at start of plot titles" ) 
parser.add_option("-V","--veto-file",action="store",type="string",\
    default=None,metavar=" FNAME",\
    help="read in segments from FNAME (assumed segwizard format)")

(opts,args) = parser.parse_args()

# check at least one trig file was specified
if not args:
  print >>sys.stderr, "a trig-file must be specified"
  print >>sys.stderr, "Enter 'plotinspinj --help' for usage"
  sys.exit(1)

injGlobs = args

tags = []
if opts.tag1:
  tags.append(opts.tag1)
  if opts.tag2:
    tags.append(opts.tag2)
    if opts.tag3:
      tags.append(opts.tag3)

# Do the pylab import in such a way that doesn't require an X display
# if show() won't be invoked.
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from pylal import viz
rc('text', usetex=True)

# get veto segment list
if opts.veto_file:
  seglist = segmentsUtils.fromsegwizard(file(opts.veto_file, 'r'))

# read in tables into dictionaries of paired sets
injSets = []

for injGlob in injGlobs:
  injDict = {}
  
  # read in triggers
  flist = glob.glob(injGlob)
  assert flist != [], "empty glob: \"%s\"" % injGlob
  injDict["sngl_inspiral"] = SnglInspiralUtils.ReadSnglInspiralFromFiles(flist)
  injDict["sim_inspiral"]  = SimInspiralUtils.ReadSimInspiralFromFiles(flist)
  
  # veto if supplied
  if opts.veto_file:
    injDict["sngl_inspiral"] = injDict["sngl_inspiral"].veto(seglist)
    injDict["sim_inspiral"] = injDict["sim_inspiral"].veto(seglist)
  
  # provide a matching sim_inspiral for each sngl_inspiral if requested
  if opts.coire_split:
    new_sim_table = tab.new_from_template(injDict["sim_inspiral"])
    
    # iterator over consecutive triggers with matching event_ids
    coincs = itertools.groupby(injDict["sngl_inspiral"],
                               lambda row: row.event_id)
    for coinc, inj in itertools.izip(coincs, injDict["sim_inspiral"]):
      # coinc is tuple of (key, iterator); count length of iterator
      num_coincs = reduce(lambda x,y: x + 1, coinc[1], 0)
      new_sim_table.extend([inj] * num_coincs)
    injDict['sim_inspiral'] = new_sim_table
  
  # test sire/coire sanity
  assert len(injDict['sngl_inspiral']) == len(injDict['sim_inspiral']), \
    "number of triggers and found injections must be equal"
  
  injSets.append(injDict)
  
# set lists of plot symbols
plot_symbols = ['rx','b+','ko','rx','b+','ko']
plot_colors = ['r', 'b', 'k', 'g', 'y']

# infinite sequence of integers, starting at 1
plot_num = itertools.count(1)
#####################################
# plot of injected vs detected mchirp
if opts.mchirp_mchirp:
  figure(plot_num.next())
  hold(True)
  sym=0
  for injSet in injSets:
    viz.plotval(injSet['sim_inspiral'], injSet['sngl_inspiral'],\
                'mchirp', 'lin', plot_symbols[sym] )
    sym+=1
  viz.labelval('mchirp', '$M_{\odot}$', [0,0,0,0],'Injected','Recovered',\
    tags,opts.title_text, opts.figure_name)

################################
# plot of mchirp error vs mchirp
if opts.plot_mchirp:
  figure(plot_num.next())
  hold(True)
  sym=0
  for injSet in injSets:
    viz.plotdiff(injSet['sim_inspiral'], injSet['sngl_inspiral'],\
                 'mchirp', 'linear', plot_symbols[sym])
    sym+=1
  viz.labeldiff('mchirp', '$M_{\odot}$', \
      [0,0,-opts.chirp_axis,opts.chirp_axis],\
      tags,opts.title_text, opts.figure_name)
  
###############################  
# histogram of chirp mass error
if opts.hist_mchirp:
  figure(plot_num.next())
  hold(True) 
  sym=0
  for injSet in injSets:
    viz.histdiff(injSet['sim_inspiral'], injSet['sngl_inspiral'], 'mchirp', \
                 'hist', sym, len(injSets), opts.nbins, \
                 [-opts.chirp_axis,opts.chirp_axis])
    sym+=1
  viz.labelhistdiff('mchirp', 'hist', '$M_{\odot}$', tags, opts.title_text,\
                    opts.figure_name)
  
 
################################
# plot of eta error vs eta
if opts.plot_eta:
  figure(plot_num.next())
  hold(True) 
  sym=0
  for injSet in injSets:
    viz.plotdiff(injSet['sim_inspiral'], injSet['sngl_inspiral'],\
                 'eta', 'linear', plot_symbols[sym])
    sym+=1
  viz.labeldiff('eta', None, [0,0,-opts.eta_axis,opts.eta_axis],\
    tags,opts.title_text, opts.figure_name) 
 
 
###############################  
# histogram of chirp mass error
if opts.hist_eta:
  figure(plot_num.next())
  hold(True)
  sym=0
  for injSet in injSets:
    viz.histdiff(injSet['sim_inspiral'], injSet['sngl_inspiral'], 'eta', \
                 'hist', sym, len(injSets), opts.nbins, \
                 [-opts.eta_axis,opts.eta_axis])
    sym+=1
  viz.labelhistdiff('eta', 'hist', None, tags, opts.title_text, \
                    opts.figure_name)


################################
# plot of timing error vs time
if opts.plot_time:
  figure(plot_num.next())
  hold(True) 
  sym=0
  for injSet in injSets:
    viz.plotdiff(injSet['sim_inspiral'], injSet['sngl_inspiral'],\
                 'end_time', 'linear', plot_symbols[sym] )
    sym+=1
  viz.labeldiff('end_time', 'days', [0,0,-opts.time_axis,opts.time_axis],\
    tags,opts.title_text, opts.figure_name) 


###############################  
# histogram of timing error
if opts.hist_time:
  figure(plot_num.next())
  hold(True) 
  sym=0
  for injSet in injSets:
    viz.histdiff(injSet['sim_inspiral'], injSet['sngl_inspiral'], 'end_time', \
                 'hist', sym, len(injSets), opts.nbins, \
                 [-opts.time_axis,opts.time_axis])
    sym+=1
  viz.labelhistdiff('end_time', 'hist', 'seconds', tags, opts.title_text, \
                    opts.figure_name)


################################
# plot of distance error vs dist
if opts.plot_dist:
  figure(plot_num.next())
  hold(True) 
  sym=0
  for injSet in injSets:
    viz.plotfracdiff(injSet['sim_inspiral'], injSet['sngl_inspiral'],\
                     'eff_dist', 'log', plot_symbols[sym] )
    sym+=1
  viz.labelfracdiff('eff_dist', 'Mpc', [0,0,-opts.dist_axis,opts.dist_axis],\
    tags,opts.title_text, opts.figure_name) 

###############################  
# histogram of dist error
if opts.hist_dist:
  figure(plot_num.next())
  hold(True)
  sym=0
  for injSet in injSets:
    viz.histdiff(injSet['sim_inspiral'], injSet['sngl_inspiral'], 'eff_dist', \
                 'frac_hist', sym, len(injSets), opts.nbins, 
                 [-opts.dist_axis,opts.dist_axis])
    sym+=1
  viz.labelhistdiff('eff_dist', 'frac_hist', 'Mpc', tags, opts.title_text, \
                    opts.figure_name)

#######################################
# plot of injected vs detected distamce    
if opts.dist_dist:  
  figure(plot_num.next())
  hold(True)
  sym=0
  for injSet in injSets:
    viz.plotval(injSet['sim_inspiral'], injSet['sngl_inspiral'],\
                'eff_dist', 'log', plot_symbols[sym] )
    sym+=1
  viz.labelval('eff_dist', 'Mpc', [0,0,0,0],'Injected','Recovered',\
    tags,opts.title_text, opts.figure_name) 

################################
# plot of mchirp error vs eff_dist
if opts.chirp_dist:
  figure(plot_num.next())
  hold(True) 
  sym=0
  for injSet in injSets:
    viz.plotdiffa_vs_b(injSet['sim_inspiral'], injSet['sngl_inspiral'],\
                 'mchirp', 'eff_dist', 'log', plot_symbols[sym])
    sym+=1
  viz.labeldiffa_vs_b('mchirp', 'eff_dist','$M_{\odot}','Mpc', \
    [0,0,-opts.chirp_axis,opts.chirp_axis], tags, opts.title_text,\
    opts.figure_name)

################################
# plot of mchirp error vs mchirp
if opts.time_dist:
  figure(plot_num.next())
  hold(True)
  sym=0
  for injSet in injSets:
    viz.plotdiffa_vs_b(injSet['sim_inspiral'], injSet['sngl_inspiral'],\
                 'end_time', 'eff_dist', 'log', plot_symbols[sym])
    sym+=1
  viz.labeldiffa_vs_b('end_time', 'eff_dist','$M_{\odot}$','Mpc', \
    [0,0,-opts.time_axis,opts.time_axis], tags, opts.title_text,\
    opts.figure_name)


################################
# plot of mchirp error vs snr
if opts.chirp_snr:
  figure(plot_num.next())
  hold(True)
  sym=0
  for injSet in injSets:
    viz.plotdiffa_vs_b(injSet['sngl_inspiral'], injSet['sim_inspiral'], \
                 'mchirp', 'snr', 'log', plot_symbols[sym])
    sym+=1
  viz.labeldiffa_vs_b('mchirp', 'snr','$M_{\odot}$',None, \
    [0,0,-opts.chirp_axis,opts.chirp_axis], tags, opts.title_text,\
    opts.figure_name)


################################
# plot of mchirp error vs snr
if opts.time_snr:
  figure(plot_num.next())
  hold(True)
  sym=0
  for injSet in injSets:
    viz.plotdiffa_vs_b(injSet['sngl_inspiral'], injSet['sim_inspiral'], \
                 'end_time', 'snr', 'log', plot_symbols[sym])
    sym+=1
  viz.labeldiffa_vs_b('end_time', 'snr','seconds',None, \
    [0,0,-opts.time_axis,opts.time_axis], tags, opts.title_text,\
    opts.figure_name)

################################
# plot of eta error vs snr
if opts.eta_snr:
  figure(plot_num.next())
  hold(True)
  sym=0
  for injSet in injSets:
    viz.plotdiffa_vs_b(injSet['sngl_inspiral'], injSet['sim_inspiral'], \
                 'eta', 'snr', 'log', plot_symbols[sym])
    sym+=1
  viz.labeldiffa_vs_b('eta', 'snr',None,None, \
    [0,0,-opts.eta_axis,opts.eta_axis], tags, opts.title_text,\
    opts.figure_name)

################################
# plot of ethinca parameter vs the difference between any parameter's
# injected and recovered values

for ethinca_vs_diff in opts.ethinca_vs_diff:
  fig = figure(plot_num.next())
  ax = fig.add_subplot(111)
  ax.grid(True)
  for injSet,symb in zip(injSets, plot_symbols):
    table1 = injSet['sim_inspiral']
    table2 = injSet['sngl_inspiral']
    
    # Print first row of table1
    # print [(k, table1[0].__getattribute__(k)) for k in table1.columnnames]
    
    # Print first row of table2
    # print [(k, table2[0].__getattribute__(k)) for k in table2.columnnames]
    
    [par1, par2, ifo] = viz.readcolfrom2tables(table1, table2, ethinca_vs_diff)
    
    diff_a = (par1 - par2)
    col_b = [ethinca_param(sim, sngl) for sim, sngl in zip(table1, table2)]
    
    ax.plot(diff_a, col_b, symb)
    
    if opts.log_x:
      ax.set_xscale('log')
    if opts.log_y:
      ax.set_yscale('log')
    
    ax.set_xlabel('$\delta (\mathrm{%s})$' \
      % ethinca_vs_diff.replace('_', r'\_'), size='x-large')
    ax.set_ylabel('ethinca-parameter', size='x-large')

    if opts.title_text is not None:
      ax.set_title(opts.title_text, size='x-large', weight='bold')
    
    if opts.figure_name:
      fig.savefig('%s_ethinca_vs_%s_accuracy.png' % \
        (opts.figure_name, ethinca_vs_diff))
    if not opts.show_plot:
      close()

# Plot of ethinca values vs snr
if opts.ethinca_vs_snr:
  fig = figure(plot_num.next())
  ax = fig.add_subplot(111)
  ax.grid(True)
  for injSet,symb in zip(injSets, plot_symbols):
    table1 = injSet['sim_inspiral']
    table2 = injSet['sngl_inspiral']

    # Print first row of table1
    # print [(k, table1[0].__getattribute__(k)) for k in table1.columnnames]

    # Print first row of table2
    # print [(k, table2[0].__getattribute__(k)) for k in table2.columnnames]

    col_a = viz.readcol(table2, 'snr')

    col_b = [ethinca_param(sim, sngl) for sim, sngl in zip(table1, table2)]

    ax.plot(col_a, col_b, symb)

    if opts.log_x:
      ax.set_xscale('log')
    if opts.log_y:
      ax.set_yscale('log')

    ax.set_xlabel('snr', size='x-large')
    ax.set_ylabel('ethinca-parameter', size='x-large')

    if opts.title_text is not None:
      ax.set_title(opts.title_text, size='x-large', weight='bold')

    if opts.figure_name:
      fig.savefig('%s_ethinca_vs_snr.png' % \
        (opts.figure_name))
    if not opts.show_plot:
      close()

# Histogram of ethinca values
if opts.hist_ethinca:
  fig = figure(plot_num.next())
  ax = fig.add_subplot(111)
  
  sim_tables = [x['sim_inspiral'] for x in injSets]
  sngl_tables = [x['sngl_inspiral'] for x in injSets]
  
  ethinca_list = [[ethinca_param(sim, sngl) \
                  for sim, sngl in zip(sim_table, sngl_table)] \
                  for sim_table, sngl_table in zip(sim_tables, sngl_tables)]
  
  # Histogram all datasets with the same bins
  ep_max = max([max(eps) for eps in ethinca_list])
  y_list, x_list = zip(*[histogram(eps, bins=opts.nbins, range=[0, ep_max]) \
                         for eps in ethinca_list])
  
  n = len(x_list)
  for i, x, y, color in zip(range(n), x_list, y_list, plot_colors):
    x += 0.1*i*ep_max/opts.nbins  # Introduce some stagger
    ax.bar(x, y, color=color, width=(1-0.1*n)*ep_max/opts.nbins)
  ax.set_ylabel("\#")
  ax.set_xlabel("E-thinca parameter")
  
  if opts.title_text is not None:
    ax.set_title(opts.title_text, size='x-large', weight='bold')
  
  if opts.figure_name:
    fig.savefig(opts.figure_name + "_inj-trig_ethinca_hist.png")
  if not opts.show_plot:
    close()

if opts.show_plot:
  show()
