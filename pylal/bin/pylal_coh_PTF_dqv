#!/usr/bin/env python

# Copyright (C) 2012 Duncan M. Macleod
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 
"""Veto triggers from a MultiInspiralTable based on data-quality vetoes
"""

# =============================================================================
# Preamble
# =============================================================================

# set float division
from __future__ import division

import re
import sys
import os
import optparse
import numpy
from time import time as time_now

from pylal import (git_version, MultiInspiralUtils, coh_PTF_pyutils)
from pylal.dq import dqSegmentUtils
from pylal.xlal.date import XLALGPSTimeNow

from glue.segments import segmentlist as SegmentList
from glue.ligolw import (ligolw, table, lsctables, utils as ligolw_utils)
from glue.ligolw.utils import process as ligolw_process
from glue.ligolw.utils import search_summary as ligolw_search_summary
lsctables.MultiInspiralTable.veto = coh_PTF_pyutils.veto
lsctables.MultiInspiralTable.vetoed = coh_PTF_pyutils.vetoed

# set up metadata
__author__ = "Duncan M. Macleod <duncan.macleod@ligo.org>"
__version__ = git_version.id
__date__ = git_version.date

PROFILE = False
VERBOSE = False


# print verbose messages
start = time_now()
elapsed_time = lambda: time_now()-start
def print_verbose(message, verbose=True, stream=sys.stdout, profile=True):
    """Print verbose messages to a file stream.

    @param message
        text to print
    @param verbose
        flag to print or not, default: False (don"t print)
    @param stream
        file object stream in which to print
    @param profile
        flag to print timestamp, default: False
    """
    if stream != sys.stderr:
        profile &= PROFILE
        verbose &= VERBOSE
    if profile and message.endswith("\n"):
        message = "%s (%.2f)\n" % (message.rstrip("\n"), elapsed_time())
    if verbose:
        stream.write(message)
        stream.flush()


# verify command lien thresholds
def parse_threshold(option, opt_str, value, parser):
    """Verify threshold argument is valid on callback.
    """
    if value <= 0:
        parser.error("%s must be positive" % opt_str)
    setattr(parser.values, option.dest, float(value))
    

# parse command line
def parse_command_line():
    """Parse command line arguments, and perform sanity checks.

    @returns commaned line (options, arguments) tuple
    """
    usage = "%prog [options] [file ...]"
    parser = optparse.OptionParser(usage=usage, description=__doc__[1:],\
                                   formatter=optparse.IndentedHelpFormatter(4))
    parser.add_option("-p", "--profile", action="store_true", default=False,
                      help="timestamp output, default: %default")
    parser.add_option("-v", "--verbose", action="store_true", default=False,\
                      help="show verbose output, default: %default")
    parser.add_option("-V", "--version", action="version",\
                      help="show program's version number and exit")
    parser.version =  __version__

    vetoopts = optparse.OptionGroup(parser, "Veto options")
    vetoopts.add_option("-s", "--segment-file", action="store",
                        type="string", default=[], metavar="FILE",
                        help=("path to SegWizard or XML file containing"
                              "data quality segments to apply. "
                              "Can be given multiple times."))
    parser.add_option_group(vetoopts)

    outopts = optparse.OptionGroup(parser, "Input options")
    outopts.add_option("-o", "--output-file", action="store",\
                      default=False, help="output xml file, default: stdout")
    parser.add_option_group(outopts)

    # parse args
    opts, args = parser.parse_args()

    # verify xmlfiles
    if len(args) > 1:
        raise parser.error("Please give only one input XML file (you gave %d)"
                           % len(args))
    if opts.segment_file:
        opts.segment_file = opts.segment_file.split(",")

    return opts,args[0]


# run from the command line
if __name__ == "__main__":
    # get command line args
    opts, xmlfile = parse_command_line()
    VERBOSE = opts.verbose
    PROFILE = opts.profile

    # generate output document
    outxml = ligolw.Document()
    outxml.appendChild(ligolw.LIGO_LW())

    # append our process
    process = ligolw_process.append_process(outxml, program=__file__,
                                            version=__version__)
    ligolw_process.append_process_params(outxml, process,
                                         [("", "lstring", xmlfile)])
    for key,val in vars(opts).iteritems():
        key = "--%s" % key.replace("_", "-")
        if key == "--segment-file":
            for fp in val:
                ligolw_process.append_process_params(outxml, process,
                                                     [(key, "lstring", fp)])
        elif val is not None:
            ligolw_process.append_process_params(outxml, process,
                                                 [(key, "lstring", val)])

    # open file
    print_verbose("Reading xml file...\n", profile=False)
    xmldoc = ligolw_utils.load_filename(xmlfile, gz=xmlfile.endswith(".gz"))
    # read SearchSummaryTable
    try:
        ss_table = table.get_table(xmldoc,
                                    lsctables.SearchSummaryTable.tableName)
        process.ifos = ss_table[0].ifos
        inseg = ss_table[0].get_in()
        outseg = ss_table[0].get_out()
    except ValueError:
        inseg = None
        outseg = None
    else:
        print_verbose("SearchSummaryTable read and copied.\n")
    # read SimInspiralTable
    try:
        sim_table = table.get_table(xmldoc,
                                    lsctables.SimInspiralTable.tableName)
    except ValueError:
        pass
    else:
        outxml.childNodes[-1].appendChild(sim_table)
        print_verbose("SimInspiralTable read and copied.\n")
    # read TimeSlideTable
    try:
        slide_table = table.get_table(xmldoc,
                                      lsctables.TimeSlideTable.tableName)
    except ValueError:
        slide_table = None
    else:
        outxml.childNodes[-1].appendChild(slide_table)
        print_verbose("TimeSlideTable read and copied.\n")
    # read MultiInspiralTable
    try:
        mi_table = table.get_table(xmldoc,
                                    lsctables.MultiInspiralTable.tableName)
    except ValueError:
        print_verbose("\nERROR: failed to load XML from %s.\n" % xmlfile,
                      stream=sys.stderr)
        raise
    else:
        keep = numpy.ones(len(mi_table)).astype(bool)
        nevents = keep.sum()
        print_verbose("MultiInspiralTable read, %d events found.\n" % nevents)

    # read segments
    veto_segments = SegmentList()
    for fp in opts.segment_file:
        with open(fp, "r") as f:
            if re.search("(xml|xml.gz)\Z", fp):
                veto_segments.extend(dqSegmentUtils.fromsegmentxml(f))
            else:
                veto_segments.extend(segmentsUtils.fromsegwizard(f))
    veto_segments.coalesce()
    print_verbose("Veto segments loaded. Deadtime: %.2f seconds\n"
                  % int(abs(veto_segments)))

    # apply veto
    nevents = len(mi_table)
    mi_table = mi_table.veto(veto_segments, slide_table)
    print_verbose("Vetoes killed %d events.\n" % (nevents - len(mi_table)))
    nevents = len(mi_table)
    outxml.childNodes[-1].appendChild(mi_table)

    # finalize and close
    outxml.childNodes[-1].appendChild(
        lsctables.New(lsctables.SearchSummaryTable))
    ligolw_search_summary.append_search_summary(outxml, process, inseg=inseg,
                                                outseg=outseg, nevents=nevents,
                                                comment=os.path.basename(
                                                            __file__))
    process.end_time = XLALGPSTimeNow().seconds
    ligolw_utils.write_filename(outxml, opts.output_file,
                                gz=opts.output_file.endswith(".gz"),
                                verbose=opts.verbose)
    print_verbose("Done.\n")

