#!/usr/bin/python

# $Id$
__author__ = "Stephen Fairhurst <sfairhur@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]
__name__="plotthinca"

import sys
import os
from optparse import *
import re
import exceptions
import glob
from types import *

from glue import lal
from glue import segments
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
import pylal.itertools
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils
from pylal import InspiralUtils


##############################################################################
usage = """
usage: %prog [options] 

Thinca Triggers Plotting Function

Generate a set of summary plots from a list of thinca files.  First, specify
which ifos the triggers come from using:
--g1-triggers, --h1-triggers, --h2-triggers, --l1-triggers.


The plots which can be generated are:

1)  A plot of the snr of coincident triggers (for each ifo) vs time.
    Generated by specifying: --snr-time

2)  Plots of snr vs snr for various ifo combinations.
    Generated by specifying: --snr-snr
    Note: specifying --snr-chi causes these to be plotted for snr/chi
    Note: specifying --s3-snr-chi-stat causes them to be plotted for
          stat = chisq * (snr^2 + 250) / snr^4.

These plots can be made with time slide triggers by specifying: 
  --slide-snr

3)  Plots of effective distance vs effective distance for various ifo comb.
    Generated by specifying: --dist-dist

These plots can be made with time slide triggers by specifying: 
  --slide-dist
  
4)  For each combination of two or more ifos, plot the number of triggers per 
    time slide.  Generated by specifying: --plot-slides

5)  For each combination of two or more ifos, make a histogram of the number 
    of triggers per time slide.  Generated by specifying: --hist-slides

The zero lag number of triggers can be added to the above by specifying:
  --add-zero-lag

If the zero lag data only contains playground, the number of triggers in the
  background can be scaled by a factor or 600/6370 by specifying
  --zero-lag-playground

6)  For each combination of two or more ifos, make a cumulative histogram of
    the number of events as a function of the combined snr.
    Generated by specifying: --snr-dist
"""

parser = OptionParser( usage=usage, version="%prog CVS $Id$ " )



# options related to input and output
parser.add_option("-g","--glob",action="store",type="string",\
    default=None, metavar=" GLOB",help="GLOB of thinca files to read" )
#parser.add_option("-I", "--input", help="read thinca filenames from cache input file")
parser.add_option("-I", "--cache-input", help="read thinca filenames from cache input file")

parser.add_option("-o","--off-source-glob",action="store",type="string",\
    default=None, metavar=" GLOB",help="GLOB off-source thinca files to read" )

parser.add_option("-V","--veto-file",action="store",type="string",\
    default=None,metavar=" FNAME",\
    help="discard triggers in segments from FNAME (segwizard format)")

parser.add_option("","--offsource-veto-file",action="store",type="string",\
    default=None,metavar=" FNAME",\
    help="discard off-source triggers in segments from FNAME (segwizard format)")

parser.add_option("-O","--enable-output",action="store_true",\
      default="false",  metavar="OUTPUT",\
      help="enable the generation of the html and cache documents")

parser.add_option("-u","--user-tag",action="store",type="string",\
      default=None, metavar=" USERTAG",\
      help="The user tag used in the name of the figures" )

parser.add_option("","--gps-start-time",action="store", type="int", metavar="GPSSTARTTIME",\
    help="gps start time used in the figure and output file names")

parser.add_option("","--gps-end-time",action="store", type= "int", metavar="GPSENDTIME",\
    help="gps end time used in the figure and output file names")

parser.add_option("-P","--output-path",action="store",\
      type="string",default="",  metavar="PATH",\
      help="path where the figures would be stored")

parser.add_option("","--ifo-times",action="store",type="string",\
    default=None,metavar="IFOS",\
    help="sets ifo times for which plots will be made (e.g. H1H2L1)" )

parser.add_option("","--cache-description", action="store",type="string",\
    default="COIRE_", metavar="CACHEDESCRIPTION", help="description pattern the cache entries will be sieved with" )

parser.add_option("","--add-description", action="store",type="string",\
    default="SLIDE", metavar="ADDDESCRIPTION", help="additional description pattern the cache entries will be sieved with" )

parser.add_option("","--match",action="store",type="string",\
    default=None,metavar="MATCH",\
    help="To sieve exactly according to a pattern, if its set True" )


parser.add_option("-s","--show-plot",action="store_true",default=False,\
    help="display the figures on the terminal" )

parser.add_option("-v","--verbose",action="store_true",\
      default=False,help="print information" )


#options that set parameters specific to the plots 

parser.add_option("-E","--ext-trig",action="store_true",default=False,\
    help="external trigger search, so should have off-source triggers" )

parser.add_option("-L","--cluster-window",action="store",type="int",default=0,\
    metavar=" SEC", help="length of time over which to cluster triggers" )
#parser.add_option("-f","--figure-name",action="store",type="string",\
#    default=None, metavar=" FNAME",\
#    help="generate png figures with name FNAME-fig.png" )

parser.add_option("-x","--min-snr",action="store",type="float",\
    default=0, metavar=" MIN_SNR",help="minimum value of snr on plot" )
parser.add_option("-X","--max-snr",action="store",type="float",\
    default=0, metavar=" MAX_SNR",help="maximum value of snr on plot" )
parser.add_option("-A","--g1-triggers",action="store_true",default=False,\
    help="input files contain triggers from G1" )
parser.add_option("-B","--h1-triggers",action="store_true",default=False,\
    help="input files contain triggers from H1" )
parser.add_option("-C","--h2-triggers",action="store_true",default=False,\
    help="input files contain triggers from H2" )
parser.add_option("-D","--l1-triggers",action="store_true",default=False,\
    help="input files contain triggers from L1" )
parser.add_option("-a","--snr-time",action="store_true",default=False,\
    help="plot the snr vs time of coinc triggers" )
parser.add_option("-b","--snr-snr",action="store_true",default=False,\
    help="make snr vs snr plots of coinc triggers" )
parser.add_option("-S","--statistic",action="store",default='snr',\
    type="string",\
    help="choice of statistic used in making plots, valid arguments are: "
          "snr (DEFAULT), snr_over_chi, s3_snr_chi_stat, effective_snr, bitten_l, bitten_lsq") 
parser.add_option("-F","--bittenl_a",action="store",type="float",default=None,\
    metavar=" BITTENL_A", help="parameter a for bitten-l statistic" ) 	 
parser.add_option("-G","--bittenl_b",action="store",type="float",default=None,\
    metavar=" BITTENL_B", help="parameter b for bitten-l statistic" )
parser.add_option("-d","--slide-snr",action="store_true",default=False,\
    help="make snr vs snr plots of time slide triggers" )
parser.add_option("-e","--dist-dist",action="store_true",default=False,\
    help="make dist vs dist plots of coinc triggers" )
parser.add_option("-l","--slide-dist",action="store_true",default=False,\
    help="make dist vs dist plots of time slide triggers" )
parser.add_option("-i","--hist-slides",action="store_true",default=False,\
    help="plot histograms of number of triggers in time slides")
parser.add_option("-j","--plot-slides",action="store_true",default=False,\
    help="plot of number of triggers vs slide number")

#parser.add_option("-P","--duration",action="store",default="",\
#    help="gps start tiem used in the figure and output file names")

parser.add_option("-z","--add-zero-lag",action="store_true",default=False,\
    help="add the zero lag info to slide plots")
parser.add_option("-Z","--zero-lag-playground",action="store_true",\
    default=False,\
    help="scale number of bkg triggers in slide plots by 600/6370")
parser.add_option("-k","--snr-dist",action="store_true",default=False,\
    help="plot distribution of combined statistic" )
parser.add_option("-K","--snr-hist",action="store_true",default=False,\
    help="plot histogram of combined statistic" )
parser.add_option("-m","--mass-dependent",action="store_true",default=False,\
    help="sort triggers by mass range" )
parser.add_option("-M","--mass-range",action="store",type="string",\
    metavar=" MASS_RANGE",default=None,help="sort triggers by mass range" )
parser.add_option("-n","--nbins",action="store",type="int",default=20,\
    metavar=" NBINS", help="number of bins for the histogram plots" )
parser.add_option("-N","--num-slides",action="store",type="int",default=0,\
    metavar=" NUM_SLIDES",help="number of time slides performed" )
parser.add_option("-t","--plot-type",action="store",type="string",\
    default="linear",metavar=" PLOT_TYPE", \
    help="make either linear or log plots" )

command_line = sys.argv[1:]

(opts,args) = parser.parse_args()

  # test the input options
if not opts.ifo_times:
  raise ValueError, "--ifo-times (which ifos were analysed) must be provided"

if opts.cache_input and opts.glob:
    raise ValueError, """ Use either the glob options(--glob OR the cachefile options (--cache-input), not both at the same time.
"""


if opts.plot_type not in ['log', 'linear']:
  print >>sys.stderr, "plot-type must be either \"log\" or \"linear\""
  sys.exit(1)

if not opts.glob and not opts.cache_input:
  print >>sys.stderr, "Must specify a --glob of files or --cache-input file to read"
  print >>sys.stderr, "Enter 'plotthinca --help' for usage"
  sys.exit(1)

if not opts.off_source_glob and opts.ext_trig:
  print >>sys.stderr, "Must specify a off source GLOB of files to read"
  print >>sys.stderr, "Enter 'plotthinca --help' for usage"
  sys.exit(1)

# if doing any slide plots:
if opts.hist_slides or opts.slide_snr:
  if not opts.num_slides:
    print >>sys.stderr, "--num-slides must be specified if"
    print >>sys.stderr, "--hist-slides or --slide-snr are"
    sys.exit(1)

# check that statistic is OK:
if (opts.statistic != 'snr') and (opts.statistic != 'snr_over_chi') \
    and (opts.statistic != 's3_snr_chi_stat') \
    and (opts.statistic != 'effective_snr')\
    and (opts.statistic != 'bitten_lsq')\
    and (opts.statistic != 'bitten_l'):
  print >>sys.stderr, "--statistic must be one of"
  print >>sys.stderr, "(snr|snr_over_chi|s3_snr_chi_stat|effective_snr|bitten_l)"
  sys.exit(1)

# check if bittenl-parameters has been specifiedv (or bitten_lsq), set snglStat 	 
snglStat=opts.statistic 	 
if 'bitten_l' in opts.statistic:
   snglStat='snr' 	 
   if (not opts.bittenl_a or not opts.bittenl_b): 	 
     print >>sys.stderr, "--bittenl_a and --bittenl_b must be specified" 	 
     sys.exit(1)
#####################################################################
# -- some initialisation
figure_number = 0  # used for the figure label (showplot)
output_cachefile_name = []   # use for the cache file

# Change to Agg back-end if show() will not be called thus avoiding display problem
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from pylal import viz
# -- set the proper color code
colors = InspiralUtils.colors
# Initialise
prefix, suffix = InspiralUtils.create_output_name(opts, __name__)

if opts.enable_output is True:
  # -- initialise the web page calling init_page
  page, extra = InspiralUtils.init_markup_page(opts)
  # -- set output_cache properly: make sure there is a slash
  if len(opts.output_path)>1 :
    opts.output_path = opts.output_path +'/'
  # -- filename
  html_filename = prefix[0:len(prefix)-1] + suffix +".html"
  html_file = file(opts.output_path + html_filename, "w")
####################################################################

statistic = CoincInspiralUtils.coincStatistic( opts.statistic, opts.bittenl_a, \
     opts.bittenl_b )
    
plotsymbols = ['r+','bx','ko','g1']
hanfordsym = ['b+','bx','r1']
addsym = ['k+','kx','k1']

xlow = 20
xhigh = 0
#f_name = opts.user_tag
if opts.cluster_window and f_name:
  f_name += '_clust_' + str(opts.cluster_window) + 'sec'

#######################################################
# determine IFOs and IFO combos in play

ifo_list = [ifo for ifo in ("G1", "H1", "H2", "L1") \
            if getattr(opts, "%s_triggers" % ifo.lower())]
ifo_non_h = [ifo for ifo in ifo_list if ifo[0] != "H"]

ifo_coincs = []
for num_ifos in range(2, len(ifo_list) + 1):
  ifo_coincs.extend(list(pylal.itertools.choices(ifo_list, num_ifos)))

#######################################################
# turn the mass range from a string to a list of floats

if opts.mass_range is not None:
  mass_range = [float(s) for s in opts.mass_range.split(",") if s != ""]

###################################
# glob the list of files to read in
if opts.glob is not None or opts.cache_input is not None:
  if opts.glob is not None:
    allfiles = []
    for gl in opts.glob.split(" "):
      allfiles.extend(glob.glob(gl))
    if len(allfiles) < 1:
      print >>sys.stderr, "The glob for " + opts.glob + " returned no files" 
      sys.exit(1)

    slidefiles = []
    coincfiles = []
    offsourcefiles = []

    for file in allfiles:
      if 'SLIDE' in file:
        slidefiles.append(file)
      else:
        coincfiles.append(file)

  elif opts.cache_input is not None:
    allfilesCache = lal.Cache.fromfile(open(opts.cache_input))    
    allfiles = []
    allfiles = allfilesCache.sieve(ifos=opts.ifo_times, exact_match=True).sieve(description = opts.cache_description, exact_match=opts.match).checkfilesexist()[0].pfnlist()
    if len(allfiles) < 1:
      print >>sys.stderr, "The file" + opts.cache_input + " contains no" + opts.cache_description + " files"
      sys.exit(1)

    offsourcefiles = []
    slidefiles = []
    coincfiles = []
    slidefiles = allfilesCache.sieve(ifos=opts.ifo_times, exact_match=True).sieve(description = (opts.cache_description + opts.add_description)).checkfilesexist()[0].pfnlist()

    for file in allfiles:
      if file not in slidefiles:
        coincfiles.append(file)

# Off Source Files
if opts.off_source_glob:  
  allfiles = []
  for gl in opts.off_source_glob.split(" "):
    allfiles.extend(glob.glob(gl))

  if len(allfiles) == 0:
    print >>sys.stderr, "The glob for " + opts.off_source_glob + \
        " returned no files"
    sys.exit(1)

  for file in allfiles: 
    offsourcefiles.append(file)

########################
# read in coinc triggers
inspTriggers = None
coincTriggers = None

if coincfiles:
  inspTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(coincfiles)
  
  # perform the veto
  if opts.veto_file:
    seglist = segmentsUtils.fromsegwizard(open(opts.veto_file, "r"))
    inspTriggers = inspTriggers.veto(seglist)
  
  # construct the coincs
  coincTriggers = \
      CoincInspiralUtils.coincInspiralTable(inspTriggers,statistic)

  # cluster them
  if opts.cluster_window:
    coincTriggers = coincTriggers.cluster(opts.cluster_window)

  if not opts.max_snr:
    if inspTriggers:
      xhigh = max( inspTriggers.get_column(snglStat) )
    else:
      xhigh = 50.0
  else:
    xhigh = opts.max_snr + 1

  if not opts.min_snr:
    if inspTriggers:
      xlow = min( inspTriggers.get_column(snglStat) )
    else:
      xlow = 1.0
  else:
    xlow = opts.min_snr
else:
  coincTriggers = None

if opts.mass_dependent:
  coincTriggersByMass = []
  for i in range(len(mass_range)-1):
    if coincTriggers:
      coincTriggersByMass.append( \
        coincTriggers.getChirpMass(mass_range[i],mass_range[i+1]) )
    else:
      coincTriggersByMass.append( coincTriggers )

########################
# read in off-source triggers
offsourceTriggers = None

if offsourcefiles:
  inspTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(offsourcefiles)
  # perform the veto
  if opts.offsource_veto_file:
    seglist = segmentsUtils.fromsegwizard(open(opts.offsource_veto_file, "r"))
    inspTriggers = inspTriggers.veto(seglist)
  elif opts.veto_file:
    seglist = segmentsUtils.fromsegwizard(open(opts.veto_file, "r"))
    inspTriggers = inspTriggers.veto(seglist)

  # construct the coincs
  offsourceTriggers = \
      CoincInspiralUtils.coincInspiralTable(inspTriggers,statistic)

  # cluster them
  if opts.cluster_window:
    offsourceTriggers = offsourceTriggers.cluster(opts.cluster_window)
else:
  offsourceTriggers = None

########################
# read in slide triggers
slideTriggers = []
if slidefiles:
  inspSlide = SnglInspiralUtils.ReadSnglInspiralFromFiles(slidefiles)
  # perform the veto
  if opts.veto_file:
    seglist = segmentsUtils.fromsegwizard(open(opts.veto_file, "r"))
    inspSlide = inspSlide.veto(seglist)
      
  slide_num = range(1 , opts.num_slides + 1)
  slide_num.extend(range(-opts.num_slides, 0))

  for slide in slide_num:
    this_slide = {}
    this_slide["slide_num"] = slide
    this_slide["sngl_trigs"] = inspSlide.getslide(slide)

    # make coincs
    this_slide["coinc_trigs"] = \
      CoincInspiralUtils.coincInspiralTable(this_slide["sngl_trigs"],statistic)

    # cluster triggers
    if opts.cluster_window:
      this_slide["coinc_trigs"] = \
        this_slide["coinc_trigs"].cluster(opts.cluster_window)  
    
    # add slide to list
    slideTriggers.append(this_slide)
    if opts.verbose:
      print (str(slide) + ' ' + str(len(this_slide["sngl_trigs"])))
  
  if inspSlide:
    slide_high = max( inspSlide.get_column(snglStat) )
    slide_low = min( inspSlide.get_column(snglStat) )
  else:
    slide_high = 50.0
    slide_low = 1.0

if opts.mass_dependent:
  slideTriggersByMass = []
  for i in range(len(mass_range)-1):
    slideTriggersByMass.append( [] )
    for j in range(len(slideTriggers)):
      tmp_this_slide = {}
      tmp_this_slide["slide_num"] = slideTriggers[j]["slide_num"]
      if slideTriggers[j]["coinc_trigs"]:
        tmp_this_slide["coinc_trigs"] = slideTriggers[j]["coinc_trigs"].getChirpMass(mass_range[i],mass_range[i+1])
      else:
        tmp_this_slide["coinc_trigs"] = slideTriggers[j]["coinc_trigs"]
      slideTriggersByMass[i].append( tmp_this_slide )

################################
# plot of h1 vs h2 stat

if opts.snr_snr or opts.slide_snr:
  if 'H1' in ifo_list and 'H2' in ifo_list:
    # create a text for the alt and title of html document
    text=" Plot of H1 vs H2 " + snglStat.replace("_"," ") + " statistic"
    figure(figure_number)
    figure_number += 1
    hold(True)
    if opts.slide_snr:
      for slide in slideTriggers:
        viz.plotcoincval(slide["coinc_trigs"], snglStat, 'H1', 'H2', \
          'k+',opts.plot_type)
    if opts.ext_trig:
      viz.plotcoincval(offsourceTriggers, snglStat, 'H1', 'H2', \
          'bo',opts.plot_type)
      # The color in 'bo' only applies to markerfacecolor, which plotcoincval
      # removes.  Must set the markeredgecolor on the last dataset in the
      # current axes.
      gca().get_lines()[-1].set_markeredgecolor('b')
    if opts.snr_snr:
      viz.plotcoincval(coincTriggers, snglStat, 'H1', 'H2', \
          'r+',opts.plot_type)
      # The color in 'r+' only applies to markerfacecolor, which plotcoincval
      # removes.  Must set the markeredgecolor on the last dataset in the
      # current axes.
      gca().get_lines()[-1].set_markeredgecolor('r')


    xlabel(snglStat.replace("_"," ") + ' H1', size='x-large')
    ylabel(snglStat.replace("_"," ") + ' H2', size='x-large')
    title('H1 vs H2 coincident event SNR')
    grid(True)
    if opts.min_snr:
      xlim(xmin=opts.min_snr)
      ylim(ymin=opts.min_snr)
    if opts.max_snr:
      xlim(xmax=opts.max_snr)
      ylim(ymax=opts.max_snr)
    else:
      viz.square_axis()
    if opts.enable_output is True:
      fname = prefix + "H1_vs_H2_" + snglStat  + suffix + ".png"
      savefig(opts.output_path  + fname)
      # -- create a link and image html tag
      page.a(extra.img(src=[opts.output_path +fname], width=400, \
      alt = text, border="2"), title=text, href=[opts.output_path + fname])

      # -- keep track of this filename
      output_cachefile_name.append(fname)


if (opts.snr_snr or opts.slide_snr) and opts.mass_dependent:
  for i in range(len(mass_range)-1):
    if 'H1' in ifo_list and 'H2' in ifo_list:
      figure(figure_number)
      figure_number += 1
      hold(True)
      if opts.slide_snr:
        for slide in slideTriggersByMass[i]:
          viz.plotcoincval(slide["coinc_trigs"], snglStat, 'H1', 'H2', \
            'k+',opts.plot_type)
      if opts.snr_snr:
        viz.plotcoincval(coincTriggersByMass[i], snglStat, 'H1', 'H2', \
            'r+',opts.plot_type)
        # The color in 'r+' only applies to markerfacecolor, which plotcoincval
        # removes.  Must set the markeredgecolor on the last dataset in the
        # current axes.
        gca().get_lines()[-1].set_markeredgecolor('r')

      xlabel(snglStat.replace("_"," ") + ' H1', size='x-large')
      ylabel(snglStat.replace("_"," ") + ' H2', size='x-large')
      title('H1 vs H2 coincident event SNR')
      grid(True)
      if opts.min_snr:
        xlim(xmin=opts.min_snr)
        ylim(ymin=opts.min_snr)
      if opts.max_snr:
        xlim(xmax=opts.max_snr)
        ylim(ymax=opts.max_snr)
      else:
        viz.square_axis()
      if opts.enable_output is True:
        text = "Plot of H1 vs H2 " + snglStat.replace("_"," ") + " for " + str(mass_range[i]) + str(mass_range[i+1]) +  " mass range"
        fname = prefix + "H1_vs_H2_" + snglStat +str(mass_range[i])\
          + "_" + str(mass_range[i+1]) + suffix + ".png"
        savefig(opts.output_path + fname)
        # -- create a link and image html tag
        page.a(extra.img(src=[opts.output_path +fname], width=400, \
        alt=text, border="2"), title=text, href=[opts.output_path + fname])
        # -- keep track of this filename
        output_cachefile_name.append(fname)
  
################################
# plot of hanford vs other snr

if opts.snr_snr or opts.slide_snr:
  if 'H1' in ifo_list or 'H2' in ifo_list:
    for ifo in ifo_non_h:
      figure(figure_number)
      figure_number += 1
      hold(True)
      if opts.slide_snr:
        for slide in slideTriggers:
          if 'H1' in ifo_list:
            viz.plotcoincval(slide["coinc_trigs"], snglStat, 'H1', ifo, \
              'kx', opts.plot_type)
          if 'H2' in ifo_list:
            viz.plotcoincval(slide["coinc_trigs"], snglStat, 'H2', ifo, \
              'k+', opts.plot_type)
          if 'H1' in ifo_list and 'H2' in ifo_list:
            viz.plotcoinchanford(slide["coinc_trigs"], snglStat, ifo, \
              'sqrtsqr', 'k1', opts.plot_type)
      
      if opts.snr_snr:
        sym = 0
        legend_text = []
        if 'H1' in ifo_list:
          viz.plotcoincval(coincTriggers, snglStat, 'H1', ifo, \
              hanfordsym[sym], opts.plot_type)
          legend_text.append('H1' + ifo)
          for add_ifo in ifo_non_h:
            if add_ifo != ifo:
              viz.plotcoincval(coincTriggers, snglStat, 'H1', ifo, \
                  addsym[sym], opts.plot_type, add_ifo)
              legend_text.append('H1' + ifo + '(also in ' + add_ifo + ')')
              
        if not opts.slide_snr: sym += 1
        if 'H2' in ifo_list:
          viz.plotcoincval(coincTriggers, snglStat, 'H2', ifo, \
              hanfordsym[sym], opts.plot_type)
          legend_text.append('H2' + ifo)
          for add_ifo in ifo_non_h:
            if add_ifo != ifo:
              viz.plotcoincval(coincTriggers, snglStat, 'H2', ifo, \
                  addsym[sym], opts.plot_type, add_ifo)
              legend_text.append('H2' + ifo + '(also in ' + add_ifo + ')')
              
        if not opts.slide_snr: sym += 1
        if 'H1' in ifo_list and 'H2' in ifo_list:       
          viz.plotcoinchanford(coincTriggers, snglStat, ifo, 'sqrtsqr', \
              hanfordsym[sym], opts.plot_type)
          legend_text.append('H1H2' + ifo)
          for add_ifo in ifo_non_h:
            if add_ifo != ifo:
              viz.plotcoinchanford(coincTriggers, snglStat, ifo, \
                  'sqrtsqr', addsym[sym],opts.plot_type, add_ifo)
              legend_text.append('H1H2' + ifo + '(also in ' + add_ifo + ')')


      if not opts.slide_snr:
        legend(legend_text,2)
      xlabel(snglStat.replace("_"," ") + ' Hanford', size='x-large')
      ylabel(snglStat.replace("_"," ") + ' '+ ifo, size='x-large')
      title('Hanford vs ' + ifo + ' coincident event SNR')
      grid(True)
      if opts.min_snr:
        xlim(xmin=opts.min_snr)
        ylim(ymin=opts.min_snr)
      if opts.max_snr:
        xlim(xmax=opts.max_snr)
        ylim(ymax=opts.max_snr)
      else:
        viz.square_axis()
      if opts.enable_output is True:
        fname = prefix + "H_vs_" + ifo +"_" +snglStat  + suffix + ".png"
        text = "Plot of Hanford vs " + ifo + " " + snglStat.replace("_"," ") + " statistic" 
        savefig(opts.output_path + fname)
        # -- create a link and image html tag
        page.a(extra.img(src=[opts.output_path +fname], width=400, \
        alt=text, border="2"), title=text, href=[opts.output_path + fname])
        # -- keep track of this filename
        output_cachefile_name.append(fname)
 

if (opts.snr_snr or opts.slide_snr) and opts.mass_dependent:
  for i in range(len(mass_range)-1):
    if 'H1' in ifo_list or 'H2' in ifo_list:
      for ifo in ifo_non_h:
        figure(figure_number)
        figure_number += 1
        hold(True)
        if opts.slide_snr:
          for slide in slideTriggersByMass[i]:
            if 'H1' in ifo_list:
              viz.plotcoincval(slide["coinc_trigs"], snglStat, 'H1', ifo, \
                'kx', opts.plot_type)
            if 'H2' in ifo_list:
              viz.plotcoincval(slide["coinc_trigs"], snglStat, 'H2', ifo, \
                'k+', opts.plot_type)
            if 'H1' in ifo_list and 'H2' in ifo_list:
              viz.plotcoinchanford(slide["coinc_trigs"], snglStat, ifo, \
                'sqrtsqr', 'k1', opts.plot_type)

        if opts.snr_snr:
          sym = 0
          legend_text = []
          if 'H1' in ifo_list:
            viz.plotcoincval(coincTriggersByMass[i], snglStat, 'H1', ifo, \
                hanfordsym[sym], opts.plot_type)
            legend_text.append('H1' + ifo)
            for add_ifo in ifo_non_h:
              if add_ifo != ifo:
                viz.plotcoincval(coincTriggersByMass[i], snglStat, 'H1', ifo, \
                    addsym[sym], opts.plot_type, add_ifo)
                legend_text.append('H1' + ifo + '(also in ' + add_ifo + ')')

          if not opts.slide_snr: sym += 1
          if 'H2' in ifo_list:
            viz.plotcoincval(coincTriggersByMass[i], snglStat, 'H2', ifo, \
                hanfordsym[sym], opts.plot_type)
            legend_text.append('H2' + ifo)
            for add_ifo in ifo_non_h:
              if add_ifo != ifo:
                viz.plotcoincval(coincTriggersByMass[i], snglStat, 'H2', ifo, \
                    addsym[sym], opts.plot_type, add_ifo)
                legend_text.append('H2' + ifo + '(also in ' + add_ifo + ')')

          if not opts.slide_snr: sym += 1
          if 'H1' in ifo_list and 'H2' in ifo_list:
            viz.plotcoinchanford(coincTriggersByMass[i], snglStat, ifo, \
                'sqrtsqr', hanfordsym[sym], opts.plot_type)
            legend_text.append('H1H2' + ifo)
            for add_ifo in ifo_non_h:
              if add_ifo != ifo:
                viz.plotcoinchanford(coincTriggersByMass[i], snglStat, ifo, \
                    'sqrtsqr', addsym[sym],opts.plot_type, add_ifo)
                legend_text.append('H1H2' + ifo + '(also in ' + add_ifo + ')')


        if not opts.slide_snr:
          legend(legend_text,2)
        xlabel(snglStat.replace("_"," ") + ' Hanford', size='x-large')
        ylabel(snglStat.replace("_"," ") + ' '+ ifo, size='x-large')
        title('Hanford vs ' + ifo + ' coincident event SNR \n' + \
          'mass range ' + str(mass_range[i]) + ' to ' + \
          str(mass_range[i+1]))
        grid(True)
        if opts.min_snr:
          xlim(xmin=opts.min_snr)
          ylim(ymin=opts.min_snr)
        if opts.max_snr:
          xlim(xmax=opts.max_snr)
          ylim(ymax=opts.max_snr)
        else:
          viz.square_axis()
        if opts.enable_output is True:
          text = "Plot of Hanford vs " + ifo + " " + snglStat.replace("_"," ") + " statistic" + " for " + str(mass_range[i]) + "-" + str(mass_range[i+1]) + " mass range"
          fname = prefix + "H_vs_" + ifo +"_"+ snglStat + "-"+\
              str(mass_range[i]) + "_" + str(mass_range[i+1]) + suffix+".png"
          savefig(opts.output_path + fname)          
          # -- create a link and image html tag
          page.a(extra.img(src=[opts.output_path +fname], width=400,\
          alt=text, border="2"), title=text, href=[opts.output_path + fname])
          # -- keep track of this filename
          output_cachefile_name.append(fname)

################################
# plot of non hanford snr

if opts.snr_snr or opts.slide_snr:
  if len(ifo_non_h) >= 2:
    figure(figure_number)
    figure_number += 1
    hold(True)
    if opts.slide_snr:
      for slide in slideTriggers:
        viz.plotcoincval(slide["coinc_trigs"], snglStat, ifo_non_h[0], 
            ifo_non_h[1], 'kx',opts.plot_type)
    if opts.snr_snr:
      viz.plotcoincval(coincTriggers, snglStat, ifo_non_h[0], 
          ifo_non_h[1], 'r+',opts.plot_type)
      # The color in 'r+' only applies to markerfacecolor, which plotcoincval
      # removes.  Must set the markeredgecolor on the last dataset in the
      # current axes.
      gca().get_lines()[-1].set_markeredgecolor('r')

    xlabel(snr + ' ' + ifo_non_h[0], size='x-large')
    ylabel(snr + ' ' + ifo_non_h[1], size='x-large')
    title(ifo_non_h[0] + ' vs ' + ifo_non_h[1] + ' coincident event SNR')
    grid(True)
    if opts.min_snr:
      xlim(xmin=opts.min_snr)
      ylim(ymin=opts.min_snr)
    if opts.max_snr:
      xlim(xmax=opts.max_snr)
      ylim(ymax=opts.max_snr)
    else:
      viz.square_axis()
    if opts.enable_output is True:
      fname = prefix + ifo_non_h[0] + "_vs_" + ifo_non_h[1] + "-"\
          + snglStat + suffix + ".png"
      savefig(opts.output_path + fname)
      text = "Plot of " + ifo_non_h[0] + " vs " +ifo_non_h[1] +  snglStat.replace("_"," ") + " statistic"
      # -- create a link and image html tag
      page.a(extra.img(src=[opts.output_path +fname], width=400,\
      alt=text, border="2"), title=text, href=[opts.output_path + fname])
      # -- keep track of this filename
      output_cachefile_name.append(fname)


if (opts.snr_snr or opts.slide_snr) and opts.mass_dependent:
  for i in range(len(mass_range)-1):
    if len(ifo_non_h) >= 2:
      figure(figure_number)
      figure_number += 1
      hold(True)
      if opts.slide_snr:
        for slide in slideTriggersByMass[i]:
          viz.plotcoincval(slide["coinc_trigs"], snglStat, ifo_non_h[0],
              ifo_non_h[1], 'kx',opts.plot_type)
      if opts.snr_snr:
        viz.plotcoincval(coincTriggersByMass[i], snglStat, ifo_non_h[0],
            ifo_non_h[1], 'r+',opts.plot_type)
        # The color in 'r+' only applies to markerfacecolor, which plotcoincval
        # removes.  Must set the markeredgecolor on the last dataset in the
        # current axes.
        gca().get_lines()[-1].set_markeredgecolor('r')

      xlabel(snr + ' ' + ifo_non_h[0], size='x-large')
      ylabel(snr + ' ' + ifo_non_h[1], size='x-large')
      title(ifo_non_h[0] + ' vs ' + ifo_non_h[1] + ' coincident event SNR \n' \
        + 'mass range ' + str(mass_range[i]) + ' to ' + str(mass_range[i+1]))
      grid(True)
      if opts.min_snr:
        xlim(xmin=opts.min_snr)
        ylim(ymin=opts.min_snr)
      if opts.max_snr:
        xlim(xmax=opts.max_snr)
        ylim(ymax=opts.max_snr)
      else:
        viz.square_axis()
      if opts.enable_output is True:
        fname = prefix + ifo_non_h[0] +"_vs_" +ifo_non_h[1] + "-"\
            +snglStat + str(mass_range[i]) + "_" + str(mass_range[i+1]) +\
             suffix +".png"
        savefig(opts.output_path + fname)
        text = "Plot of " + ifo_non_h[0] +" vs " + ifo_non_h[1] +  " " + snglStat.replace("_"," ") + " statistic" + " for " + str(mass_range[i]) + "-" + str(mass_range[i+1]) + " mass range"
        # -- create a link and image html tag
        page.a(extra.img(src=[opts.output_path +fname], width=400,\
          alt=text, border="2"), title=text, href=[opts.output_path + fname])
        # -- keep track of this filename
        output_cachefile_name.append(fname)


################################
# plot of h1 vs h2 eff dist
if opts.dist_dist:
  if 'H1' in ifo_list and 'H2' in ifo_list:
    figure(figure_number)
    figure_number += 1
    hold(True)
    if opts.slide_dist:
      for slide in slideTriggers:
        viz.plotcoincval(slide["coinc_trigs"], 'eff_distance', 'H1', 'H2', \
          'kx', opts.plot_type)
      
    if opts.ext_trig:
      viz.plotcoincval(offsourceTriggers, 'eff_distance', 'H1', 'H2', 'bo', \
          opts.plot_type)
      # The color in 'bo' only applies to markerfacecolor, which plotcoincval
      # removes.  Must set the markeredgecolor on the last dataset in the
      # current axes.
      gca().get_lines()[-1].set_markeredgecolor('b')

    if opts.dist_dist:
      viz.plotcoincval(coincTriggers, 'eff_distance', 'H1', 'H2', 'r+', \
          opts.plot_type)
      # The color in 'r+' only applies to markerfacecolor, which plotcoincval
      # removes.  Must set the markeredgecolor on the last dataset in the
      # current axes.
      gca().get_lines()[-1].set_markeredgecolor('r')

    xlabel('eff distance H1 (Mpc)', size='x-large')
    ylabel('eff distance H2 (Mpc)', size='x-large')
    title('H1 vs H2 coincident event effective distance')
    grid(True)
    if opts.min_snr:
      xlim(xmin=opts.min_snr)
      ylim(ymin=opts.min_snr)
    if opts.max_snr:
      xlim(xmax=opts.max_snr)
      ylim(ymax=opts.max_snr)
    else:
      viz.square_axis()
    if opts.enable_output is True:
      fname = prefix +  "H1_vs_H2_dist" + suffix + ".png"
      savefig(opts.output_path + fname)
      text = "Plot of H1 vs H2 effective dostance"
      # -- create a link and image html tag
      page.a(extra.img(src=[opts.output_path +fname], width=400,\
          alt=text, border="2"), title=text, href=[opts.output_path + fname])
      # -- keep track of this filename
      output_cachefile_name.append(fname)

if opts.dist_dist and opts.mass_dependent:
  for i in range(len(mass_range)-1):
    if 'H1' in ifo_list and 'H2' in ifo_list:
      figure(figure_number)
      figure_number += 1
      hold(True)
      if opts.slide_dist:
        for slide in slideTriggersByMass[i]:
          viz.plotcoincval(slide["coinc_trigs"], 'eff_distance', 'H1', 'H2', \
            'kx', opts.plot_type)

      if opts.dist_dist:
        viz.plotcoincval(coincTriggersByMass[i], 'eff_distance', 'H1', 'H2', \
            'r+', opts.plot_type)
        # The color in 'ro' only applies to markerfacecolor, which plotcoincval
        # removes.  Must set the markeredgecolor on the last dataset in the
        # current axes.
        gca().get_lines()[-1].set_markeredgecolor('r')

      xlabel('eff distance H1 (Mpc)', size='x-large')
      ylabel('eff distance H2 (Mpc)', size='x-large')
      title('H1 vs H2 coincident event effective distance \n' + \
        'mass range ' + str(mass_range[i]) + ' to ' + str(mass_range[i+1]))
      grid(True)
      if opts.min_snr:
        xlim(xmin=opts.min_snr)
        ylim(ymin=opts.min_snr)
      if opts.max_snr:
        xlim(xmax=opts.max_snr)
        ylim(ymax=opts.max_snr)
      else:
        viz.square_axis()
      if opts.enable_output is True:
        fname = prefix +  "H1_vs_H2_dist_"+str(mass_range[i])\
            +"_"+str(mass_range[i+1])+ suffix + ".png"
        savefig(opts.output_path + fname)
        text = "Plot of H1 vs H2 effective distance for " + str(mass_range[i]) + ' to ' + str(mass_range[i+1]) + " mass range"
        # -- create a link and image html tag
        page.a(extra.img(src=[opts.output_path +fname], width=400,\
          alt=text, border="2"), title=text, href=[opts.output_path + fname])
        # -- keep track of this filename
        output_cachefile_name.append(fname)
 


####################################
# plot of statistic vs time (for each ifo)
if opts.snr_time:
  figure(figure_number)
  figure_number += 1
  hold(True)
  sym = 0
  for ifo in ifo_list:
    ifoTrigs = coincTriggers.getsngls(ifo)
    if ifoTrigs:
      if opts.plot_type == 'linear':
        plot_type = 'linear'
      elif opts.plot_type == 'log':
        plot_type = 'logy'
      
      viz.plot_a_v_b(ifoTrigs, 'end_time', snglStat, plot_type, \
          plotsymbols[sym])
      legend(ifo_list,2)
      title( snglStat.replace("_"," ") + ' vs end time' )
      xlabel('end time (days into run)',size='x-large')
      ylabel(snglStat.replace("_"," "),size='x-large')
      grid(True)
      sym += 1
      if opts.min_snr:
        ylim(ymin=opts.min_snr)
      if opts.max_snr:
        ylim(ymax=opts.max_snr)
    
  if opts.enable_output is True:
    fname = prefix + snglStat + "_vs_time" + suffix + ".png"
    savefig(opts.output_path + fname)
    text = "Plot of " + snglStat.replace("_"," ") + " vs time for each of the IFOs"
    # -- create a link and image html tag
    page.a(extra.img(src=[opts.output_path +fname], width=400,\
      alt=text, border="2"), title=text, href=[opts.output_path + fname])  
    # -- keep track of this filename
    output_cachefile_name.append(fname)

if opts.snr_time and opts.mass_dependent:
  for i in range(len(mass_range)-1):
    figure(figure_number)
    figure_number += 1
    hold(True)
    sym = 0
    for ifo in ifo_list:
      ifoTrigs = coincTriggersByMass[i].getsngls(ifo)
      if ifoTrigs:
        if opts.plot_type == 'linear':
          plot_type = 'linear'
        elif opts.plot_type == 'log':
          plot_type = 'logy'

        viz.plot_a_v_b(ifoTrigs, 'end_time', snglStat, plot_type, \
            plotsymbols[sym])
        legend(ifo_list,2)
        title( snglStat.replace("_"," ") + ' vs end time \n' + \
          'mass range ' + str(mass_range[i]) + ' to ' + \
          str(mass_range[i+1]))
        xlabel('end time (days into run)',size='x-large')
        ylabel(snglStat.replace("_"," "),size='x-large')
        grid(True)
        sym += 1
        if opts.min_snr:
          ylim(ymin=opts.min_snr)
        if opts.max_snr:
          ylim(ymax=opts.max_snr)

    if opts.enable_output is True:
      fname = prefix + snglStat + "_vs_time-"+ str(mass_range[i]) +   "_" + str(mass_range[i+1]) + suffix + ".png"
      savefig(opts.output_path + fname)
      text = "Plot of " + snglStat.replace("_"," ") + " vs time for each of the IFOs in " + str(mass_range[i]) + ' to ' + str(mass_range[i+1]) + " mass range"
      # -- create a link and image html tag
      page.a(extra.img(src=[opts.output_path +fname], width=400,\
        alt=text, border="2"), title=text, href=[opts.output_path + fname])
      # -- keep track of this filename
      output_cachefile_name.append(fname)




################################################
# make plot/hist of number of triggers per slide
if opts.hist_slides or opts.plot_slides:
  if opts.add_zero_lag:
    coincTrigs = coincTriggers
  else:
    coincTrigs = None

  if opts.hist_slides:
    figure(figure_number)
    figure_number += 1
    viz.histslides(slideTriggers,coincTrigs,scalebkg=opts.zero_lag_playground)
    if opts.enable_output is True:
      fname = prefix + "hist_slide_trigs" + suffix + ".png"
      savefig(opts.output_path + fname)
      text = "Histogram of number of coincident triggers per time slide"
      # -- create a link and image html tag
      page.a(extra.img(src=[opts.output_path +fname], width=400, \
        alt=text, border="2"), title=text, href=[opts.output_path + fname])
      # -- keep track of this filename
      output_cachefile_name.append(fname)

  if opts.plot_slides:
    figure(figure_number)
    figure_number += 1
    viz.plotslides(slideTriggers,coincTrigs,scalebkg=opts.zero_lag_playground)
    if opts.enable_output is True:
      fname = prefix + "plot_slide_trigs" + suffix +".png"
      savefig(opts.output_path + fname)
      text = "Plot of number of coincident triggers per time slide"
      # -- create a link and image html tag
      page.a(extra.img(src=[opts.output_path +fname], width=400, \
        alt=text, border="2"), title=text, href=[opts.output_path + fname])
      # -- keep track of this filename
      output_cachefile_name.append(fname)


  for ifos in ifo_coincs:
    if opts.hist_slides:
      figure(figure_number)
      figure_number += 1
      viz.histslides(slideTriggers,coincTrigs,ifos)
      if opts.enable_output is True:
        fname = prefix
        ifo_concat = "" 
        for ifo in ifos:
          ifo_concat += ifo
        fname += ifo_concat + "_hist_slide_trigs"
        fname += suffix + ".png"
        savefig(opts.output_path + fname)
        text = "Histogram of " + ifo_concat + " triggers per time slide" 
        # -- create a link and image html tag
        page.a(extra.img(src=[opts.output_path +fname], width=400, \
          alt=text, border="2"), title=text, href=[opts.output_path + fname])
        # -- keep track of this filename
        output_cachefile_name.append(fname)

    if opts.plot_slides:
      figure(figure_number)
      figure_number += 1
      viz.plotslides(slideTriggers,coincTrigs,ifos)
      if opts.enable_output is True:
        fname = prefix
        ifo_concat = ""
        for ifo in ifos:
          ifo_concat += ifo
        fname += ifo_concat + "_plot_slide_trigs"
        fname += suffix +".png"
        savefig(opts.output_path + fname)
        text = "Plot of " + ifo_concat + " triggers per time slide"
        # -- create a link and image html tag
        page.a(extra.img(src=[opts.output_path +fname], width=400, \
          alt=text, border="2"), title=text, href=[opts.output_path + fname])
        # -- keep track of this filename
        output_cachefile_name.append(fname)

if (opts.hist_slides or opts.plot_slides) and opts.mass_dependent:
  for i in range(len(mass_range)-1):
    if opts.add_zero_lag:
      coincTrigs = coincTriggersByMass[i]
    else:
      coincTrigs = None
    
    if opts.hist_slides:
      figure(figure_number)
      figure_number += 1
      viz.histslides(slideTriggersByMass[i],coincTrigs, \
        scalebkg=opts.zero_lag_playground)
      if opts.enable_output is True:
        fname = prefix + "hist_slide_trigs" + \
            str(mass_range[i]) + "_" +  str(mass_range[i+1]) + \
            suffix + ".png"
        savefig(opts.output_path + fname)
        text = "Histogram of number of coincident triggers per time slide for " + str(mass_range[i]) + " to " +  str(mass_range[i+1]) + " mass range"
        # -- create a link and image html tag
        page.a(extra.img(src=[opts.output_path +fname], width=400, \
          alt=text, border="2"), title=text, href=[opts.output_path + fname])
        # -- keep track of this filename
        output_cachefile_name.append(fname)

      
    if opts.plot_slides:
      figure(figure_number)
      figure_number += 1
      viz.plotslides(slideTriggersByMass[i],coincTrigs, \
        scalebkg=opts.zero_lag_playground)
      if opts.enable_output is True:
        fname = prefix + "plot_slide_trigs" + \
            str(mass_range[i]) + "_" +     str(mass_range[i+1]) + \
            suffix + ".png"
        savefig(opts.output_path + fname)
        text = "Plot of number of coincident triggers per time slide for " + str(mass_range[i]) + " to " +  str(mass_range[i+1]) + " mass range"  
        # -- create a link and image html tag
        page.a(extra.img(src=[opts.output_path +fname], width=400, \
          alt=text, border="2"), title=text, href=[opts.output_path + fname])
        # -- keep track of this filename
        output_cachefile_name.append(fname)

    for ifos in ifo_coincs:
      if opts.hist_slides:
        figure(figure_number)
        figure_number += 1
        viz.histslides(slideTriggersByMass[i],coincTrigs,ifos)
        if opts.enable_output is True:
          fname = prefix
          ifo_concat = ""          
          for ifo in ifos:
            ifo_concat += ifo 
          fname += ifo_concat + "_hist_slide_trigs" + str(mass_range[i]) + suffix + ".png"
          savefig(opts.output_path + fname)
          text = "Histogram of " + ifo_concat + " triggers per time slide" +  str(mass_range[i]) + " to " +  str(mass_range[i+1]) + " mass range"
 
          # -- create a link and image html tag
          page.a(extra.img(src=[opts.output_path +fname], width=400, \
            alt=text, border="2"), title=text, href=[opts.output_path + fname])
          # -- keep track of this filename
          output_cachefile_name.append(fname)
          

      if opts.plot_slides:
        figure(figure_number)
        figure_number += 1
        viz.plotslides(slideTriggersByMass[i],coincTrigs,ifos)
        if opts.enable_output is True:
          fname = prefix
          ifo_concat = ""
          for ifo in ifos:
            ifo_concat += ifo
          fname += ifo_concat + "_plot_slide_trigs" + str(mass_range[i]) + "_" + \
            str(mass_range[i+1]) + suffix + ".png"
          savefig(opts.output_path + fname)
          text = "Plot of " + ifo_concat + " triggers per time slide" +  str(mass_range[i]) + " to " +  str(mass_range[i+1]) + " mass range"

          #  -- create a link and image html tag
          page.a(extra.img(src=[opts.output_path +fname], width=400, \
            alt=text, border="2"), title=text, href=[opts.output_path + fname])
          # -- keep track of this filename
          output_cachefile_name.append(fname)



################################################
# make histogram of stat distribution
if opts.snr_hist:
  figure(figure_number)
  figure_number += 1

  viz.histstat(coincTriggers, slideTriggers, None, opts.min_snr, \
      opts.max_snr, opts.nbins, statistic.name)
  xlim(xmin=opts.min_snr**2.0)
  xlim(xmax=opts.max_snr**2.0)
  grid(True)
  if opts.enable_output is True:
    fname = prefix + "hist_" + statistic.name + suffix +".png"
    savefig(opts.output_path + fname)
    text = "Histogram of " + statistic.name + " distribution"
    # -- create a link and image html tag
    page.a(extra.img(src=[opts.output_path +fname], width=400, \
        alt=text, border="2"), title=text, href=[opts.output_path + fname])

    # -- keep track of this filename
    output_cachefile_name.append(fname)
 
if opts.snr_dist:
  figure(figure_number) 
  figure_number += 1

  viz.cumhiststat(coincTriggers, slideTriggers, None, opts.min_snr, \
      opts.max_snr, opts.nbins, statistic.name)
  ylim(ymin=1.0e-02)
  ylim(ymax=20)
  grid(True)
  if opts.enable_output is True:  
    fname = prefix + "cum_hist_" + statistic.name + suffix + ".png"
    savefig(opts.output_path + fname)
    text = "Cumulative histogram of " + statistic.name + " distribution"
    # -- create a link and image html tag
    page.a(extra.img(src=[opts.output_path +fname], width=400, \
        alt=text, border="2"), title=text, href=[opts.output_path + fname])

    # -- keep track of this filename
    output_cachefile_name.append(fname)

  for ifos in ifo_coincs:
    figure(figure_number) 
    figure_number += 1
    viz.cumhiststat(coincTriggers, slideTriggers, ifos, opts.min_snr, \
        opts.max_snr, opts.nbins, statistic.name)
    if opts.enable_output is True:
      fname = prefix
      ifo_concat = "" 
      for ifo in ifos:
        ifo_concat += ifo
      fname += ifo_concat + "_cum_hist_" + statistic.name +suffix + ".png"
      savefig(opts.output_path + fname)
      text = "Cumulative histogram of " + statistic.name + " distribution for " + ifo_concat + " triggers"
      # -- create a link and image html tag
      page.a(extra.img(src=[opts.output_path +fname], width=400, \
        alt=text, border="2"), title=text, href=[opts.output_path + fname])

      # -- keep track of this filename
      output_cachefile_name.append(fname)


if opts.snr_dist and opts.mass_dependent:
  for i in range(len(mass_range)-1):
    figure(figure_number)
    figure_number += 1

    viz.cumhiststat(coincTriggersByMass[i], slideTriggersByMass[i], None, \
      opts.min_snr, opts.max_snr, opts.nbins, statistic.name)
    ylim(ymin=1.0e-01)
    ylim(ymax=20)
    if opts.enable_output is True:
      fname = prefix + "cum_hist_" + statistic.name + \
        str(mass_range[i]) + "_" + str(mass_range[i+1]) + suffix + ".png"
      savefig(opts.output_path + fname)
      text = "Cumulative histogram of " + statistic.name + " distribution for triggers in " + str(mass_range[i]) + " to " + str(mass_range[i+1]) +" mass range"
      # -- create a link and image html tag
      page.a(extra.img(src=[opts.output_path +fname], width=400, \
        alt=text, border="2"), title=text, href=[opts.output_path + fname])

      # -- keep track of this filename
      output_cachefile_name.append(fname)
 


    for ifos in ifo_coincs:
      figure(figure_number)
      figure_number += 1
      viz.cumhiststat(coincTriggersByMass[i], slideTriggersByMass[i], ifos, \
        opts.min_snr, opts.max_snr, opts.nbins, statistic.name)
      if opts.enable_output is True:
        fname = prefix
        ifo_concat = ""
        for ifo in ifos:
          ifo_concat+= ifo
        fname += ifo_concat + "_cum_hist_" + statistic.name + str(mass_range[i]) \
            + "_" + str(mass_range[i+1]) + suffix + ".png"
        savefig(opts.output_path + fname)
        text = "Cumulative histogram of " + statistic.name + " distribution of " + ifo_concat + " triggers in " + str(mass_range[i]) + " to " + str(mass_range[i+1]) +" mass range"
        # -- create a link and image html tag
        page.a(extra.img(src=[opts.output_path +fname], width=400, \
          alt=text, border="2"), title=text, href=[opts.output_path + fname])

        # -- keep track of this filename
        output_cachefile_name.append(fname)

# ============================================================================
# final step: html, cahe file generation
if opts.enable_output:
  text = InspiralUtils.writeProcessParams( __name__, __version__, command_line)
  page.add(text)
  html_file.write(page(False))
  html_file.close()

if opts.enable_output is True:
  output_cache_name = prefix[0:len(prefix)-1] + suffix +'.cache'
  this = open(opts.output_path + output_cache_name, 'w')
  if opts.enable_output is True:
    this.write(opts.output_path + html_filename + '\n')
  for fname in output_cachefile_name:
    this.write(fname + '\n')
  this.close()

# ============================================================================


if opts.show_plot:
  show()
