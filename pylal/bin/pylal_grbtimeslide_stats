#!/usr/bin/env python
"""
Determine the mean number of triggers per slide per fold_time-length segment
"""

from __future__ import division

import glob
import optparse
import sys

import numpy

from glue import lal
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils

# handle user input
parser = optparse.OptionParser(usage=__doc__, version="%prog CVS $Id$ ")
parser.add_option("-g", "--glob", action="append",
    help="glob of thinca slide files to read")
parser.add_option("-i", "--input", action="append",
    help="lal cache of thinca slide files to read")
parser.add_option("-o", "--outfile", default="stdout",
    help="write results to output file (default: stdout)")
parser.add_option("-V", "--veto-file",
    help="segwizard file with times to ignore")
parser.add_option("-t", "--fold-time", type="float",
    help="express result in terms of segments of length FOLD_TIME")
(opts,args) = parser.parse_args()

if opts.glob is None and opts.input is None:
    print >>sys.stderr, "A glob or input file is required"
    sys.exit(2)

if opts.outfile.lower() == "stdout":
    opts.outfile = sys.stdout
else:
    opts.outfile = open(opts.outfile, 'w')

# discover files containing coincs
if opts.glob is not None:
    filegroups = [glob.glob(g) for g in opts.glob]
    input_source = opts.glob
else:
    filegroups = [[lal.CacheEntry(line).path() for line in open(f)] \
        for f in opts.input]
    input_source = opts.input

# compute stats
dummy_stat = CoincInspiralUtils.coincStatistic('snr')
for input, files in zip(input_source, filegroups):
    # read triggers and segments
    triggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(files)
    segs = segmentsUtils.fromfilenames(files)
    
    # veto triggers
    if opts.veto_file is not None:
        veto_segs = segmentsUtils.fromsegwizard(open(opts.veto_file))
        triggers = triggers.veto(veto_segs)
        segs -= veto_segs
    
    # reconstruct coincidences
    coincTable = CoincInspiralUtils.coincInspiralTable(triggers, dummy_stat)
    
    # count coincs per slide
    lens = numpy.array([len(coincTable.getslide(x)) \
                        for x in range(-10,0)+range(1,11)])
    
    # count coincs per slide per fold time
    if opts.fold_time is not None:
        nsegs = abs(segs) / opts.fold_time
        lens = lens / nsegs  # in-place wouldn't upcast to float
    else:
        nsegs = 1.
    
    print >>opts.outfile, "Total number of slides: %d" % len(lens)
    print >>opts.outfile, "Total time analyzed: %f" % abs(segs)
    print >>opts.outfile, "Number of %f second segments per slide: %f" % (opts.fold_time, nsegs)
    print >>opts.outfile, "Mean coincidences per slide per segment: %f" % lens.mean()
    print >>opts.outfile, "Stdev of mean: %f" % (lens.std() / numpy.sqrt(nsegs))
