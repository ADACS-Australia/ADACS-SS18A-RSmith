#!/usr/bin/env python
#
# Copyright (C) 2007  Nickolas Fotopoulos
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
"""
Characterize a set of timeslide triggers.
"""

from __future__ import division

__author__ = "Nickolas Fotopoulos <nvf@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"
__Id__ = "$Id$"
__name__ = "pylal_grbtimeslide_stats"
__title__ = "GRB timeslide and trial statistics"


import glob
import optparse
import sys
itertools = __import__("itertools")  # system-wide itertools

import numpy
numpy.seterr(all="raise")

import matplotlib
matplotlib.use("Agg")
import pylab
pylab.rc("text", usetex=True)

from glue import lal
from glue import segmentsUtils
from glue import iterutils
from glue.segments import segment, segmentlist
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw.utils import ligolw_add
from pylal import CoincInspiralUtils
from pylal import InspiralUtils
from pylal import SearchSummaryUtils
from pylal import SnglInspiralUtils
from pylal import plotutils
from pylal import rate


##############################################################################
# utility functions

def get_num_slides(xmldoc):
    """
    Return the value of --num-slides found in the process_params table of
    xmldoc.  If no such entry is found, return 0.
    """
    # don't be too picky what program had --num-slides
    slide_params = [int(row.value) for row in table.get_table(xmldoc, lsctables.ProcessParamsTable.tableName) if (row.param == "--num-slides")] + [0]
    return max(slide_params)

def array_of_lists(shape):
    """
    Return a 2D array of empty lists given shape, a 2-tuple of dimensions.
    """
    if len(shape) != 2:
        raise ValueError, "array_of_lists only takes a 2-tuple shape argument"

    arr = numpy.empty(shape, dtype=object)
    for i in xrange(shape[0]):
        for j in xrange(shape[1]):
            arr[i, j] = []
    return arr

def get_loudest_stat(coinc_list):
    """
    Return the loudest statistic in coinc_list.  If coinc_list is empty,
    return 0.
    """
    return max([c.stat for c in coinc_list] + [0])

# some vectorized functions that act on arrays
_vec_len = numpy.frompyfunc(len, 1, 1)
def vec_len(arr):
    """
    Map the builtin len() to an array and return an output array of the same
    shape of type numpy.int32.
    """
    return _vec_len(arr).astype(numpy.int32)

_vec_get_loudest_stat = numpy.frompyfunc(get_loudest_stat, 1, 1)
def vec_get_loudest_stat(arr):
    """
    Map get_loudest_stat to an array and return an output array of the same
    shape of type numpy.float32.
    """
    return _vec_get_loudest_stat(arr).astype(numpy.float32)


##############################################################################
# handle user input

def comma_delimited(option, opt_str, value, parser, elem_type=str):
    """
    This callback function stores a comma-delimited string as a list during
    option parsing.  Cast elements of list to elem_type, specified via
    callback_kwargs (default: str).  Must specify type="string"!

    Example:
    parser.add_option("-n", "--names", action="callback", type="string",
        callback=comma_delimited, callback_kwargs={"elem_type":str})

    This would allow a user to provide "--names Joe,Bob,Sarah" and the
    developer to have opts.names == ["Joe", "Bob", "Sarah"].
    """
    setattr(parser.values, option.dest, map(elem_type, value.split(",")))

parser = optparse.OptionParser(version="%prog CVS $Id$ ")
parser.add_option("-g", "--glob",
    help="glob of zero-lag thinca or thinca slide files to read")
parser.add_option("-i", "--cache-file",
    help="lal cache of zero-lag thinca or thinca slide files to read")
parser.add_option("-p", "--coinc-pattern",
    help="sieve pattern for coincidences of interest (slide or zerolag)")
parser.add_option("-V", "--veto-files", action="callback", type="string",
    callback=comma_delimited, default=[],
    help="list of segwizard-formatted files containing segments to exclude")
parser.add_option("-t", "--fold-time", type="int",
    help="express result in terms of trials of length FOLD_TIME seconds")
parser.add_option("", "--coinc-statistic",
    help="coincidence statistic of interest (snr or effective_snr)")
parser.add_option("", "--hist-loudest", action="store_true", default=False,
    help="make a cumulative histogram that includes the loudest statistic "\
         "from each trial")
parser.add_option("--plot-num-coincs", action="store_true", default=False,
    help="plot the number of coincs vs trial number")
parser.add_option("--hist-num-coincs", action="store_true", default=False,
    help="histogram the number of coincs in each trial")
parser.add_option("", "--hist-trials", action="callback", type="string",
    callback=comma_delimited, callback_kwargs={"elem_type":int}, default=[],
    help="make a cumulative histogram of statistics for each of the given "\
         "trials (comma-delimited list)")
parser.add_option("", "--plot-prefix", help="prefix for plot filenames")
parser.add_option("", "--plot-slide-loudest", action="store_true",
    default=False, help="plot the loudest events in each slide vs slide number")
parser.add_option("", "--plot-trials-loudest", action="store_true",
    default=False, help="plot the loudest events in each zero-lag trial vs " \
    "trial number")
parser.add_option("", "--plot-trial-stat-autocorrelation",
    action="store_true", default=False, help="plot the auto-correlation of "\
    "loudest statistic vs trial number")
parser.add_option("", "--plot-trial-number-autocorrelation",
    action="store_true", default=False, help="plot the auto-correlation of "\
    "number of coincidences vs trial number")
parser.add_option("", "--show-plot", action="store_true", default=False,
    help="display plots to screen")
parser.add_option("-v", "--verbose", action="store_true", default=False,
    help="print extra information to stdout")

# InspiralUtils compatibility
parser.add_option("", "--gps-start-time", type="int",
    help="GPS start time of data analyzed")
parser.add_option("", "--gps-end-time", type="int",
    help="GPS end time of data analyzed")
parser.add_option("", "--ifo-tag", help="IFO coincidence time analyzed")
parser.add_option("", "--user-tag", help="a tag to label your plots")
parser.add_option("", "--output-path", help="root of the HTML output")
parser.add_option("", "--enable-output", action="store_true", default=False,
    help="enable plots and HTML output")
parser.add_option("", "--html-for-cbcweb", action="store_true", default=False,
    help="enable HTML output with the appropriate headers for the CBC website")

(opts, args) = parser.parse_args()

if not ((opts.glob is None) ^ (opts.cache_file is None)):
    print >>sys.stderr, "A glob or input file is required (but not both)"
    sys.exit(2)

if opts.fold_time is None:
    print >>sys.stderr, "A fold time is required."
    sys.exit(2)

if opts.coinc_statistic is None:
    print >>sys.stderr, "A coincidence statistic is required."
    sys.exit(2)

# discover files containing coincs
if opts.glob is not None:
    files = glob.glob(opts.glob)
    if len(files) == 0:
        raise ValueError, "no files match glob"
else:
    cache = lal.Cache.fromfile(open(opts.cache_file), coltype=int)
    cache = cache.sieve(description=opts.coinc_pattern)
    if len(cache) == 0:
        raise ValueError, "no files in cache match coinc pattern"
    present, missing = cache.checkfilesexist()
    files = present.pfnlist()

##############################################################################
# HTML initialization
InspiralUtils.initialise(opts, __name__, __version__)


##############################################################################
# segment computation

# get analyzed segments; if exttrig_analyze=offsource, then this is the two
# segments immediately adjacent to the on-source segment
seg_dict = SearchSummaryUtils.GetSegListFromSearchSummaries(files)
segs = seg_dict.union(seg_dict.iterkeys()).coalesce()
if abs(segs) % opts.fold_time != 0:
    raise ValueError, "The provided file's analysis segment is not divisible "\
        "by the fold time."
extent = segs.extent()

# generate bins for trials
num_trials = int(abs(extent)) // opts.fold_time
bins = rate.LinearBins(extent[0], extent[1], num_trials)

# incorporate veto file; in trial_veto_mask, True means vetoed.
trial_veto_mask = numpy.zeros(num_trials, dtype=numpy.bool8)
for veto_file in opts.veto_files:
    new_veto_segs = segmentsUtils.fromsegwizard(open(veto_file))
    for seg in new_veto_segs:
        # this awkward clause comes about because segment(a, b) ==> [a, b),
        # while naively doing slice(bins[seg[0]], bins[seg[1]] + 1) ==> [a, b].
        if (seg[1] - extent[0]) % opts.fold_time == 0:
            trial_veto_mask[bins[seg[0]]:bins[seg[1]]] = True
        else:
            trial_veto_mask[bins[seg[0]]:bins[seg[1]] + 1] = True

# count how many unvetoed trials we have
eff_num_trials = numpy.sum(~trial_veto_mask)

##############################################################################
# read triggers, veto them, and reconstruct coincidences
lsctables.SnglInspiralTable.next_id = lsctables.SnglInspiralID_old(0)
doc = ligolw_add.ligolw_add(ligolw.Document(), files, verbose=opts.verbose)

triggers = table.get_table(doc, lsctables.SnglInspiralTable.tableName)
iterutils.inplace_filter(lambda t: not trial_veto_mask[bins[t.end_time]],
                         triggers)

stat = CoincInspiralUtils.coincStatistic(opts.coinc_statistic)
coincTable = CoincInspiralUtils.coincInspiralTable(triggers, stat)

##############################################################################
# sort coincidences in each opts.fold_time second segment
num_slides = get_num_slides(doc)

# initialize an array of empty lists, into which we will sort our triggers
coincs = array_of_lists(shape=(2*num_slides + 1, num_trials))

# sort into (slide, segment) bins
for c in coincTable:
    # NB: c.slide_num indexing OK with current inspiral slide implementation
    coincs[c.slide_num, bins[getattr(c, c.get_ifos()[1][0]).end_time]]\
        .append(c)

# apply a vectorized len function to count how many coincs are in each bin
counts = vec_len(coincs)
total_counts = counts.sum()

##############################################################################
# output statistics
total_num_slides = 2 * num_slides or 1
norm = 1 / (total_num_slides * eff_num_trials)
mean = norm * total_counts
stdev = numpy.sqrt(norm * ((counts - mean)**2).sum())

info_text = ""
info_text += InspiralUtils.message(opts, "Total number of slides (pos + neg "\
    "or zerolag): %d" % total_num_slides)
info_text += InspiralUtils.message(opts, "Total time analyzed (s): %d of %d" % \
    (eff_num_trials * opts.fold_time, abs(extent)))
info_text += InspiralUtils.message(opts, "Number of %d second segments per "\
    "slide: %d" % (opts.fold_time, eff_num_trials))
info_text += InspiralUtils.message(opts, "Total number of coincidences: %d" % \
    total_counts)
info_text += InspiralUtils.message(opts, "Mean coincidences per trial: %f" % \
    mean)
info_text += InspiralUtils.message(opts, "Stdev of trials: %f" % stdev)

for i in range(min(10, counts.max() + 1)):
    prob = norm * ((counts == i) & ~trial_veto_mask).sum()
    info_text += InspiralUtils.message(opts, "p(%d|0): %f" % (i, prob))

##############################################################################
# plots
safe_stat = opts.coinc_statistic.replace("_", r"\_")
fnameList = []
tagList = []

# plot cumulative histogram of zero-lag trials' loudest event statistics
if opts.hist_loudest:
    text = "Cumulative histogram of zero-lag trials' loudest event statistics"

    # initialize plot
    plot = plotutils.CumulativeHistogramPlot(
            safe_stat,
            r"$\textrm{\# trials with %s}_\mathrm{loudest}^2 > \mathrm{%s}^2$" \
                % (safe_stat, safe_stat),
            r"$\textrm{Cumulative histogram of %s}^2\textrm{ "\
                r"of loudest events}$" % safe_stat)

    # prepare data
    zerolag_trials = coincs[0, :]
    data = vec_get_loudest_stat(zerolag_trials)
    data **= 2

    # finalize plot
    plot.add_content(data)
    plot.finalize(num_bins=50, normalization=1/eff_num_trials)

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts,
            "trial_loudest_%s_cum_hist" % opts.coinc_statistic)
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()

# plot cumulative histogram of specified trials' statistics
if len(opts.hist_trials) > 0:
    # sanity check
    for trial_num in opts.hist_trials:
        if trial_num < 0 or trial_num > num_trials:
            raise ValueError, "--hist-trials must provide numbers between 1 "\
            "and the number of trials"

    text = "Cumulative histogram of statistics"

    # initialize plot
    plot = plotutils.CumulativeHistogramPlot(
            r"$\textrm{%s}^2$" % safe_stat,
            r"$\textrm{\# coincs louder than %s}^2$" % safe_stat,
            r"$\textrm{Cumulative histogram of unclustered %s}^2$" % safe_stat)

    # prepare data of interest
    for trial_num in opts.hist_trials:
        trial = coincs[0, trial_num-1]
        data = [c.stat*c.stat for c in trial]
        plot.add_content(data, "trial %d" % trial_num)

    # prepare background
    data = [[c.stat*c.stat for c in coincs[0, i]] for i in \
            xrange(0, num_trials) if i+1 not in opts.hist_trials \
            and not trial_veto_mask[i]]
    plot.add_background(data, label=r"other\ trials")

    # finalize plot
    plot.finalize(num_bins=50)

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts,
            "trials_%s_cum_hist" % (opts.coinc_statistic))
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()

# plot loudest event statistic vs slide number
if opts.plot_slide_loudest:
    text = "Loudest event statistic vs slide number"

    # initialize plot
    plot = plotutils.VerticalBarPlot("slide number", safe_stat,
        "Loudest events in each slide")

    # prepare data
    x_data = numpy.arange(-num_slides, num_slides + 1)
    y_data = numpy.zeros(len(x_data), dtype=numpy.float32)
    for i, slide_num in enumerate(x_data):
        if not trial_veto_mask[i]:
            relevant_slides = coincTable.getslide(slide_num)
            y_data[i] = get_loudest_stat(relevant_slides)

    # complete plot
    plot.add_content(x_data, y_data)
    plot.finalize()

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts, "slide_loudest")
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()

# plot loudest event statistic vs trial number
if opts.plot_trials_loudest:
    text = "Loudest event statistic vs trial number"

    # initialize plot
    plot = plotutils.VerticalBarPlot("trial number", safe_stat,
        "Loudest events in each trial")

    # prepare data
    x_data = numpy.arange(num_trials)
    zerolag_trials = coincs[0, :]
    y_data = vec_get_loudest_stat(zerolag_trials)

    # sanity checks
    if sum(vec_len(zerolag_trials)) == 0:
        raise ValueError, "error: cannot obey --plot-trials-loudest, "\
            "as no zero-lag coincidences were found."
    assert len(zerolag_trials) == num_trials

    # complete plot
    plot.add_content(x_data, y_data)
    plot.finalize()

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts,
            "trial_loudest_%s" % opts.coinc_statistic)
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()

# plot the autocorrelation of the loudest event statistic vs trial number
if opts.plot_trial_stat_autocorrelation:
    text = "Autocorrelation of the loudest event statistic vs trial number"

    # initialize plot
    plot = plotutils.VerticalBarPlot(r"$\Delta(\textrm{trial number})$",
        "", r"Autocorrelation of loudest stat vs trial number")

    # prepare data
    x_data = numpy.arange(num_trials) - num_trials//2
    zerolag_trials = coincs[0, :]
    loudest = vec_get_loudest_stat(zerolag_trials)
    loudest -= loudest.mean()
    y_data = numpy.correlate(loudest, loudest, "same")

    # complete plot
    plot.add_content(x_data, y_data)
    plot.finalize()

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts,
            "trial_%s_autocorrelation" % opts.coinc_statistic)
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()

# plot the autocorrelation of the number of coincs vs trial number
if opts.plot_trial_number_autocorrelation:
    text = "autocorrelation of the number of coincs vs trial number"

    # initialize plot
    plot = plotutils.VerticalBarPlot(r"$\Delta(\textrm{trial number})$",
        "", r"Autocorrelation of \# coincs vs trial number")

    # prepare data
    x_data = numpy.arange(num_trials) - num_trials//2
    zerolag_trials = coincs[0, :]
    num_coincs = vec_len(zerolag_trials)
    num_coincs -= num_coincs.mean()
    y_data = numpy.correlate(num_coincs, num_coincs, "same")

    # complete plot
    plot.add_content(x_data, y_data)
    plot.finalize()

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts,
            "trial_number_autocorrelation")
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()

# plot the number of coincs in each trial
if opts.plot_num_coincs:
    text = "the number of coincs in each trial"

    # initialize plot
    plot = plotutils.VerticalBarPlot(r"trial \#", r"\# coincs",
        r"\# coincs in each trial")

    # prepare data
    x_data = numpy.arange(counts.size, dtype=numpy.int16) + 1
    plot.add_content(x_data, counts.flat)

    # complete plot
    plot.finalize()

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts,
            "plot_num_coincs")
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()


# plot a histogram of the number of coincs in each trial
if opts.hist_num_coincs:
    text = "histogram of number of coincs in each trial"

    # initialize plot
    plot = plotutils.VerticalBarPlot(r"\# coincs", r"\# trials",
        r"Histogram of \# coincs in each trial")

    # prepare data
    x_data = numpy.arange(counts.max(), dtype=int)
    y_data = [((counts == i) & ~trial_veto_mask).sum() for i in x_data]
    plot.add_content(x_data, y_data)

    # complete plot
    plot.finalize()

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts,
            "hist_num_coincs")
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()

#############################################################################
# Generate HTML and cache file
if opts.enable_output:
    html_filename = InspiralUtils.write_html_output(opts, sys.argv[1:],
        fnameList, tagList, comment=info_text)
    InspiralUtils.write_cache_output(opts, html_filename, fnameList)

    if opts.html_for_cbcweb:
        html_filename_publish = InspiralUtils.write_html_output(opts,
            sys.argv[1:], fnameList, tagList, comment=info_text, cbcweb=True)

if opts.show_plot:
    pylab.show()
