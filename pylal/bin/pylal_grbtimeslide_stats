#!/usr/bin/env python
#
# Copyright (C) 2007  Nickolas Fotopoulos
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
"""
Characterize a set of timeslide triggers.
"""

from __future__ import division

__author__ = "Nickolas Fotopoulos <nvf@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"
__Id__ = "$Id$"
__name__ = "pylal_grbtimeslide_stats"
__title__ = "GRB timeslide and trial statistics"


import glob
import optparse
import sys
itertools = __import__("itertools")  # system-wide itertools

import numpy
numpy.seterr(all="raise")

import matplotlib
matplotlib.use("Agg")
import pylab
pylab.rc("text", usetex=True)

from glue import iterutils
from glue import lal
from glue import segmentsUtils
from glue.segments import segment, segmentlist
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw.utils import ligolw_add
from pylal import CoincInspiralUtils
from pylal import InspiralUtils
from pylal import SearchSummaryUtils
from pylal import SnglInspiralUtils
from pylal import grbsummary
from pylal import plotutils
from pylal import rate


##############################################################################
# utility functions

def get_num_slides(xmldoc):
    """
    Return the value of --num-slides found in the process_params table of
    xmldoc.  If no such entry is found, return 0.
    """
    tbl_name = lsctables.ProcessParamsTable.tableName

    # don't be too picky what program had --num-slides
    for tbl in table.getTablesByName(xmldoc, tbl_name):
        for row in tbl:
           if row.param == "--num-slides":
               return int(row.value)
    return 0

def array_of_lists(shape):
    """
    Return an array of empty lists given shape, a tuple of dimensions.
    """
    size = numpy.prod(shape)
    arr = numpy.empty(size, dtype=object)
    for i in xrange(size):
        arr[i] = []
    return arr.reshape(shape)

def get_loudest_stat(coinc_list):
    """
    Return the loudest statistic in coinc_list.  If coinc_list is empty,
    return 0.
    """
    return max([c.stat for c in coinc_list] + [0])

# some vectorized functions that act on arrays
_vec_len = numpy.frompyfunc(len, 1, 1)
def vec_len(arr):
    """
    Map the builtin len() to an array and return an output array of the same
    shape of type numpy.int32.
    """
    return _vec_len(arr).astype(numpy.int32)

_vec_get_loudest_stat = numpy.frompyfunc(get_loudest_stat, 1, 1)
def vec_get_loudest_stat(arr):
    """
    Map get_loudest_stat to an array and return an output array of the same
    shape of type numpy.float32.
    """
    return _vec_get_loudest_stat(arr).astype(numpy.float32)


##############################################################################
# handle user input

def comma_delimited(option, opt_str, value, parser, elem_type=str):
    """
    This callback function stores a comma-delimited string as a list during
    option parsing.  Cast elements of list to elem_type, specified via
    callback_kwargs (default: str).  Must specify type="string"!

    Example:
    parser.add_option("-n", "--names", action="callback", type="string",
        callback=comma_delimited, callback_kwargs={"elem_type":str})

    This would allow a user to provide "--names Joe,Bob,Sarah" and the
    developer to have opts.names == ["Joe", "Bob", "Sarah"].
    """
    setattr(parser.values, option.dest, map(elem_type, value.split(",")))

parser = optparse.OptionParser(version="%prog CVS $Id$ ")
parser.add_option("-g", "--glob",
    help="glob of zero-lag thinca or thinca slide files to read")
parser.add_option("-i", "--cache-file",
    help="lal cache of zero-lag thinca or thinca slide files to read")
parser.add_option("-o", "--onsource-pattern",
    help="on-source coinc file; only used for segment information without "
         "--hist-onsource")
parser.add_option("-p", "--offsource-pattern",
    help="sieve pattern for coincidences of interest (slide or zerolag)")
parser.add_option("-V", "--veto-files", action="callback", type="string",
    callback=comma_delimited, default=[],
    help="list of segwizard-formatted files containing segments to exclude")
parser.add_option("-t", "--fold-time", type="int",
    help="express result in terms of trials of length FOLD_TIME seconds")
parser.add_option("--mc-boundaries", action="callback", type="string",
    callback=comma_delimited, default=[-numpy.inf, numpy.inf],
    callback_kwargs={"elem_type":float},
    help="comma-separated list of mchirp bin boundaries")
parser.add_option("", "--coinc-statistic",
    help="coincidence statistic of interest (snr or effective_snr)")
parser.add_option("", "--hist-loudest", action="store_true", default=False,
    help="make a cumulative histogram that includes the loudest statistic "\
         "from each trial")
parser.add_option("--plot-num-coincs", action="store_true", default=False,
    help="plot the number of coincs vs trial number")
parser.add_option("--hist-num-coincs", action="store_true", default=False,
    help="histogram the number of coincs in each trial")
parser.add_option("--hist-onsource", action="store_true", default=False,
    help="make a cumulative histogram of the on-source trial (If you want "\
    "this, make sure not to veto the on-source segment)")
parser.add_option("--hist-background", action="store_true", default=False,
    help="make a cumulative histogram of the background +/- 1 sigma, "\
    "including both off-source trials and time-slides.")
parser.add_option("", "--hist-trials", action="callback", type="string",
    callback=comma_delimited, callback_kwargs={"elem_type":int}, default=[],
    help="make a cumulative histogram of statistics for each of the given "\
         "trials (comma-delimited list)")
parser.add_option("", "--plot-prefix", help="prefix for plot filenames")
parser.add_option("", "--plot-slide-loudest", action="store_true",
    default=False, help="plot the loudest events in each slide vs slide number")
parser.add_option("", "--plot-trials-loudest", action="store_true",
    default=False, help="plot the loudest events in each zero-lag trial vs " \
    "trial number")
parser.add_option("", "--plot-trial-stat-autocorrelation",
    action="store_true", default=False, help="plot the auto-correlation of "\
    "loudest statistic vs trial number")
parser.add_option("", "--plot-trial-number-autocorrelation",
    action="store_true", default=False, help="plot the auto-correlation of "\
    "number of coincidences vs trial number")
parser.add_option("", "--show-plot", action="store_true", default=False,
    help="display plots to screen")
parser.add_option("-v", "--verbose", action="store_true", default=False,
    help="print extra information to stdout")

# InspiralUtils compatibility
parser.add_option("", "--gps-start-time", type="int",
    help="GPS start time of data analyzed")
parser.add_option("", "--gps-end-time", type="int",
    help="GPS end time of data analyzed")
parser.add_option("", "--ifo-tag", help="IFO coincidence time analyzed")
parser.add_option("", "--user-tag", help="a tag to label your plots")
parser.add_option("", "--output-path", help="root of the HTML output")
parser.add_option("", "--enable-output", action="store_true", default=False,
    help="enable plots and HTML output")
parser.add_option("", "--html-for-cbcweb", action="store_true", default=False,
    help="enable HTML output with the appropriate headers for the CBC website")

(opts, args) = parser.parse_args()

if not ((opts.glob is None) ^ (opts.cache_file is None)):
    print >>sys.stderr, "A glob or input file is required (but not both)"
    sys.exit(2)

if opts.fold_time is None:
    print >>sys.stderr, "A fold time is required."
    sys.exit(2)

if opts.coinc_statistic is None:
    print >>sys.stderr, "A coincidence statistic is required."
    sys.exit(2)

# turn a glob into a cache
if opts.glob is not None:
    tmp_files = glob.glob(opts.glob)
    if len(tmp_files) == 0:
        raise ValueError, "no files match glob"
    cache = Cache.fromfilenames(tmp_files, coltype=int)
else:
    cache = lal.Cache.fromfile(open(opts.cache_file))

##############################################################################
# HTML initialization
InspiralUtils.initialise(opts, __name__, __version__)

##############################################################################
# read in document
onsource_doc = grbsummary.load_cache(ligolw.Document(), cache,
    opts.onsource_pattern, exact_match=True, verbose=opts.verbose)
offsource_doc = grbsummary.load_cache(ligolw.Document(), cache,
    opts.offsource_pattern, exact_match=True, verbose=opts.verbose)

nominal_num_slides = get_num_slides(offsource_doc)
total_num_slides = 2 * nominal_num_slides or 1

##############################################################################
# segment computation
bins, trial_veto_mask, onsource_ind = \
    grbsummary.get_exttrig_trials(onsource_doc, offsource_doc, opts.veto_files)
num_trials = len(bins)

# derive a 2D trial mask for convenience
trial_veto_mask_2d = numpy.zeros((total_num_slides, num_trials),
                                 dtype=numpy.bool8)
trial_veto_mask_2d[0, trial_veto_mask] = True

# count how many unvetoed trials we have
eff_num_trials = numpy.sum(~trial_veto_mask)

##############################################################################
# make mchirp bins
mc_bins = rate.IrregularBins(opts.mc_boundaries)

##############################################################################
# read triggers, veto them, and reconstruct coincidences
triggers = table.get_table(offsource_doc, lsctables.SnglInspiralTable.tableName)

stat = CoincInspiralUtils.coincStatistic(opts.coinc_statistic)
coincTable = CoincInspiralUtils.coincInspiralTable(triggers, stat)

##############################################################################
# sort coincidences in each opts.fold_time second segment

# initialize an array of empty lists, into which we will sort our triggers
coincs = array_of_lists(shape=(total_num_slides, num_trials))

# sort into (slide, segment) bins
for c in coincTable:
    # NB: c.slide_num indexing OK with current inspiral slide implementation
    coincs[c.slide_num, bins[getattr(c, c.get_ifos()[1][0]).end_time]]\
        .append(c)

# apply a vectorized len function to count how many coincs are in each bin
counts = vec_len(coincs)
total_counts = counts[~trial_veto_mask_2d].sum()

##############################################################################
# output statistics
norm = 1 / (total_num_slides * eff_num_trials)
mean = norm * total_counts
stdev = numpy.sqrt(norm * ((counts[~trial_veto_mask_2d] - mean)**2).sum())

info_text = ""
info_text += InspiralUtils.message(opts, "Total number of slides (pos + neg "\
    "or zerolag): %d" % total_num_slides)
info_text += InspiralUtils.message(opts, "Total time analyzed (s): %d of %d" % \
    (eff_num_trials * opts.fold_time, bins.max - bins.min))
info_text += InspiralUtils.message(opts, "Number of %d second segments per "\
    "slide: %d" % (opts.fold_time, eff_num_trials))
info_text += InspiralUtils.message(opts, "Total number of coincidences: %d" % \
    total_counts)
info_text += InspiralUtils.message(opts, "Mean coincidences per trial: %f" % \
    mean)
info_text += InspiralUtils.message(opts, "Stdev of trials: %f" % stdev)

for i in range(min(10, counts.max() + 1)):
    prob = norm * (counts[~trial_veto_mask_2d] == i).sum()
    info_text += InspiralUtils.message(opts, "p(%d|0): %f" % (i, prob))

##############################################################################
# prepare loudest event statistics (squared) for plots
trial_numbers = numpy.arange(num_trials, dtype=int) + 1
slide_numbers = numpy.arange(-nominal_num_slides, nominal_num_slides + 1)
loudest_sq = vec_get_loudest_stat(coincs)**2

##############################################################################
# plots
safe_stat = opts.coinc_statistic.replace("_", r"\_")
fnameList = []
tagList = []

# plot cumulative histogram of zero-lag trials' loudest event statistics
if opts.hist_loudest:
    text = "Cumulative histogram of zero-lag trials' loudest event statistics"

    # initialize plot
    plot = plotutils.CumulativeHistogramPlot(
            r"$\textrm{%s}^2$" % safe_stat,
            r"$\textrm{\# trials with %s}_\mathrm{loudest}^2 > \mathrm{%s}^2$" \
                % (safe_stat, safe_stat),
            r"$\textrm{Cumulative histogram of %s}^2\textrm{ "\
                r"of loudest events}$" % safe_stat)

    # finalize plot
    plot.add_content(loudest_sq[0, ~trial_veto_mask])
    plot.finalize(num_bins=50, normalization=1/eff_num_trials)

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts,
            "trial_loudest_%s_cum_hist" % opts.coinc_statistic)
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()

# plot cumulative histogram of specified trials' loudest statistics
if opts.hist_onsource or opts.hist_background or len(opts.hist_trials) > 0:
    # sanity check
    for trial_num in opts.hist_trials:
        if trial_num < 0 or trial_num > num_trials:
            raise ValueError, "--hist-trials must provide numbers between 1 "\
            "and the number of trials"

    text = "Cumulative histogram of statistics"

    # initialize plot
    plot = plotutils.CumulativeHistogramPlot(
            r"$\textrm{%s}^2$" % safe_stat,
            r"$\textrm{\# loudest events louder than %s}^2$" % safe_stat,
            r"$\textrm{Cumulative histogram of loudest %s}^2$" % safe_stat)

    # add on-source
    if opts.hist_onsource:
        plot.add_content([loudest_sq[0, num_trials // 2]], "on-source trial")

    # add hist_trials (assume zero lag)
    for trial_num in opts.hist_trials:
        plot.add_content([loudest_sq[0, trial_num - 1]], "trial %d" % trial_num)

    # create a mask so that we know to veto hist_trials trials from the bg
    hist_trials_mask = numpy.zeros(num_trials, dtype=numpy.bool8)
    hist_trials_mask[opts.hist_trials] = True

    # add background
    if opts.hist_background:
        bg_slice = numpy.ones(loudest_sq.shape, dtype=numpy.bool8)
        # only mask zero-lag trials
        bg_slice[0, trial_veto_mask | hist_trials_mask] = False
        # add_background expects a list of trials, but loudest_sq[bg_slice] is
        # a one-dimensional array.  The [:, None] construct separates each
        # element into a separate trial.
        plot.add_background(loudest_sq[bg_slice][:, None],
                            label=r"off-source\ trials")

    # finalize plot
    plot.finalize(num_bins=50)
    plot.ax.set_ylim(ymax=1.2)

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts,
            "trials_%s_cum_hist" % (opts.coinc_statistic))
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()

# plot loudest event statistic vs trial number
if opts.plot_trials_loudest:
    text = "Loudest event statistic vs trial number"

    # initialize plot
    plot = plotutils.BarPlot("trial number", safe_stat,
        "Loudest events in each trial")

    # prepare data
    x_data = trial_numbers[~trial_veto_mask]
    y_data = vec_get_loudest_stat(coincs[0, ~trial_veto_mask])

    # complete plot
    plot.add_content(x_data, y_data)
    plot.finalize()

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts,
            "trial_loudest_%s" % opts.coinc_statistic)
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()

# plot the autocorrelation of the loudest event statistic vs trial number
if opts.plot_trial_stat_autocorrelation:
    text = "Autocorrelation of the loudest event statistic vs trial number"

    # initialize plot
    plot = plotutils.BarPlot(r"$\Delta(\textrm{trial number})$",
        "", r"Autocorrelation of loudest stat vs trial number")

    # prepare data
    x_data = numpy.arange(num_trials) - num_trials//2
    zerolag_trials = coincs[0, :]
    loudest = vec_get_loudest_stat(zerolag_trials)
    loudest -= loudest.mean()
    y_data = numpy.correlate(loudest, loudest, "same")

    # complete plot
    plot.add_content(x_data, y_data)
    plot.finalize()

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts,
            "trial_%s_autocorrelation" % opts.coinc_statistic)
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()

# plot the autocorrelation of the number of coincs vs trial number
if opts.plot_trial_number_autocorrelation:
    text = "autocorrelation of the number of coincs vs trial number"

    # initialize plot
    plot = plotutils.BarPlot(r"$\Delta(\textrm{trial number})$",
        "", r"Autocorrelation of \# coincs vs trial number")

    # prepare data
    x_data = numpy.arange(num_trials)[~trial_veto_mask] - num_trials//2
    zerolag_trials = coincs[0, ~trial_veto_mask]
    num_coincs = vec_len(zerolag_trials)
    num_coincs -= num_coincs.mean()
    y_data = numpy.correlate(num_coincs, num_coincs, "same")

    # complete plot
    plot.add_content(x_data, y_data)
    plot.finalize()

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts,
            "trial_number_autocorrelation")
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()

# plot the number of coincs in each trial
if opts.plot_num_coincs:
    text = "the number of coincs in each trial"

    # initialize plot
    plot = plotutils.BarPlot(r"trial \#", r"\# coincs",
        r"\# coincs in each trial")

    # prepare data
    x_data = trial_numbers[~trial_veto_mask]
    plot.add_content(x_data, counts[0, ~trial_veto_mask])

    # complete plot
    plot.finalize()

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts,
            "plot_num_coincs")
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()


# plot a histogram of the number of coincs in each trial
if opts.hist_num_coincs:
    text = "histogram of number of coincs in each trial"

    # initialize plot
    plot = plotutils.BarPlot(r"\# coincs", r"\# trials",
        r"Histogram of \# coincs in each trial")

    # prepare data
    x_data = numpy.arange(counts.max(), dtype=int)
    y_data = [(counts[~trial_veto_mask_2d] == i).sum() for i in x_data]
    plot.add_content(x_data, y_data)

    # complete plot
    plot.finalize()

    # output it as appropriate
    if opts.enable_output:
        fname = InspiralUtils.set_figure_name(opts,
            "hist_num_coincs")
        fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
        fnameList.append(fname)
        tagList.append(text)
    if not opts.show_plot:
        plot.close()

#############################################################################
# Generate HTML and cache file
if opts.enable_output:
    html_filename = InspiralUtils.write_html_output(opts, sys.argv[1:],
        fnameList, tagList, comment=info_text)
    InspiralUtils.write_cache_output(opts, html_filename, fnameList)

    if opts.html_for_cbcweb:
        html_filename_publish = InspiralUtils.write_html_output(opts,
            sys.argv[1:], fnameList, tagList, comment=info_text, cbcweb=True)

if opts.show_plot:
    pylab.show()
