#!/usr/bin/env python
"""
Determine the mean number of triggers per slide per fold_time-length segment
"""

from __future__ import division

import glob
import optparse
import sys

import numpy

from glue import lal
from glue import segmentsUtils
from glue.segments import segment, segmentlist
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils

# handle user input
parser = optparse.OptionParser(usage=__doc__, version="%prog CVS $Id$ ")
parser.add_option("-g", "--glob", action="append",
    help="glob of zero-lag thinca or thinca slide files to read")
parser.add_option("-i", "--input", action="append",
    help="lal cache of zero-lag thinca or thinca slide files to read")
parser.add_option("-o", "--outfile", default="stdout",
    help="write results to output file (default: stdout)")
parser.add_option("-V", "--veto-file",
    help="segwizard file with times to ignore")
parser.add_option("-t", "--fold-time", type="float",
    help="express result in terms of segments of length FOLD_TIME")
parser.add_option("-p", "--padding-seconds", type="int", default=0,
    help="number of seconds to trim from beginning and end of off-source seg (default=0)")
(opts,args) = parser.parse_args()

if opts.glob is None and opts.input is None:
    print >>sys.stderr, "A glob or input file is required"
    sys.exit(2)

if opts.outfile.lower() == "stdout":
    opts.outfile = sys.stdout
else:
    opts.outfile = open(opts.outfile, 'w')

# discover files containing coincs
if opts.glob is not None:
    filegroups = [glob.glob(g) for g in opts.glob]
    input_source = opts.glob
else:
    filegroups = [[lal.CacheEntry(line).path() for line in open(f)] \
        for f in opts.input]
    input_source = opts.input

# compute stats
dummy_stat = CoincInspiralUtils.coincStatistic('snr')
for input, files in zip(input_source, filegroups):
    # read triggers and segments
    triggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(files)
    segs = segmentsUtils.fromfilenames(files)
    
    # trim padding
    segs &= segmentlist([segs.extent().contract(opts.padding_seconds)])
    
    # veto triggers
    if opts.veto_file is not None:
        veto_segs = segmentsUtils.fromsegwizard(open(opts.veto_file))
        triggers = triggers.veto(veto_segs)
        segs -= veto_segs
        
        # re-quantize on fold_time
        t = opts.fold_time
        segs = segmentlist([segment(a, a + ((b-a)//t)*t) for a,b in segs])
    
    print veto_segs
    print segs
    
    # reconstruct coincidences
    coincTable = CoincInspiralUtils.coincInspiralTable(triggers, dummy_stat)
    
    # count coincs per slide
    counts = numpy.array([len(coincTable.getslide(x)) \
                        for x in coincTable.get_slide_numbers()])
    
    # count coincs per slide per fold time
    if opts.fold_time is not None:
        nsegs = abs(segs) / opts.fold_time
    else:
        nsegs = 1.
    
    print >>opts.outfile, "Total number of slides: %d" % len(counts)
    print >>opts.outfile, "Total time analyzed: %f" % abs(segs)
    print >>opts.outfile, "Number of %f second segments per slide: %f" % (opts.fold_time, nsegs)
    print >>opts.outfile, "Total number of coincidences: %d" % counts.sum()
    print >>opts.outfile, "Mean coincidences per slide per segment: %f" % (counts.mean() / nsegs)
    print >>opts.outfile, "Stdev of trials: %f" % (counts.std() / nsegs)
