#!/usr/bin/python

# $Id$
__author__ = "Stephen Fairhurst <fairhurst_s@ligo.caltech.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]

import sys
import os
from optparse import *
import re
import exceptions
import glob
from types import *

from pylab import *
from pylal import viz
from pylal import SimInspiralUtils
from pylal import SnglInspiralUtils
from pylal import CoincInspiralUtils


##############################################################################
def coinctest(coinc_table, ifo_list, col_name, window):
  """
  function to test for coincidence between entries in a coinc inspiral table
  and remove entries from the coinc list which fail coincidence.  The coinc
  table should contain only coincidences from the ifos given in ifo_list.

  @param coinc_table: coinc inspiral table
  @param ifo_list: list of ifos to test
  @col_name: name of column to use for coincidence test
  @window: size of coincidence window
  """
  [val1, val2, ifo] = viz.readcolfrom2tables(coinc_table.getsngls(ifo_list[0]),
      coinc_table.getsngls(ifo_list[1]),col_name)
  diff = val1 - val2
  event_nums = range(len(coinc_table))
  event_nums.reverse()
  for i in event_nums:
    if diff[i] < window[0] or diff[i] > window[1]:
      coinc_table.pop(i)

######################################################################
# function to histogram the difference between values of 'col_name' in
# two tables, table1 and table2
def histcoincdiff(coinc_table, ifo_list, col_name, hist_width, nbins=None):
  """
  function to plot a histogram of the difference of the value of col_name
  in the coinc_table for the ifos in ifo_list.  
  
  @param coinc_table: coinc inspiral table
  @param ifo_list: list of ifos to test
  @param col_name: name of column to plot
  @param hist_width: the width of the histogram
  @param nbins: number of bins to plot in histogram (default = 10)
  """
  [val1, val2, ifo] = viz.readcolfrom2tables(coinc_table.getsngls(ifo_list[0]),
      coinc_table.getsngls(ifo_list[1]),col_name)
  diff = val1 - val2
  if not nbins:
    nbins = 10
  bins = []
  for i in range(nbins):
    bins.append(hist_width[0] + i * (hist_width[1] - hist_width[0])/nbins)
  figure(100)
  out = hist(diff,bins)
  close(100)
  height = out[0]
  bins = out[1]
  return [bins,height]

######################################################################
# function to calculate probability that we get this number of events
# or more given background.
def probbg(number,bg,thresh):
  """
  function to determine probability of obtaining number or more given
  a background bg.

  @ param number: number of events measured
  @ param bg: background 
  """

  prob_bg = 1
  for n in range(number):
    fact = 1
    for int in range(n): fact *= (int+1)
    prob_bg -= exp( -bg ) * pow( bg, n ) / fact

    if prob_bg < thresh:
      return prob_bg

  return prob_bg


######################################################################
# function to histogram the difference between values of 'col_name' in
# two tables, table1 and table2
def revisewindow(bins,foreground,background,uniform_bg,conf):
  """
  function to determine a revised window for the parameter.

  @param bins: the bin boundaries
  @param foreground: the number of foreground entries in each bin
  @param background: the number of background entries in each bin
  """
  bin_width = bins[1] - bins[0]
  bin_num = range(len(bins))
  uniform_bg /= len(bins)
  low_window = bins[0] + bin_width * len(bins)
  high_window = bins[0]
  
  prob_bg = 1
  for i in bin_num:
    # set background to be max of background and uniform_bg
    this_bg = max(background[i],uniform_bg)
    prob_last_bg = prob_bg
    prob_bg = 1
    
    if foreground[i] > 0:
      # stop if 
      # less than (1 - conf) chance of getting this fg
      prob_bg = probbg(foreground[i],this_bg,(1-conf)) 

      if prob_bg * prob_last_bg < (1 - conf):
        low_window = bins[i]
        if prob_last_bg < 1:
          low_window -= bin_width
        break

  bin_num.reverse()
  prob_bg = 1
  for i in bin_num:
    # set background to be max of background and uniform_bg
    this_bg = max(background[i],uniform_bg)
    prob_last_bg = prob_bg
    prob_bg = 1

    if foreground[i] > 0:
      # stop if 
      # less than (1 - conf) chance of getting this fg
      prob_bg = probbg(foreground[i],this_bg,(1-conf)) 

      if prob_bg * prob_last_bg < (1 - conf):
        high_window = bins[i] + bin_width
        if prob_last_bg < 1:
          high_window += bin_width
        break
  
  if low_window > high_window:
    print >>sys.stderr, "The forground is below background everywhere"
    print >>sys.stderr, "Check your background glob and the values"
    print >>sys.stderr, "given for --normalized-trigger-rate"
    sys.exit(1)

  return [low_window,high_window]

######################################################################
# function to histogram the difference between values of 'col_name' in
# two tables, table1 and table2
def makeplot(coincDict,ifo_list,col_name,width,uniform_bg=None,nbins=None):
  """
  make the plot we want

  @param coincDict: dictionary containing the data
  @param col_name: name of column to use
  @param width:    width of the histogram
  @param uniform_bg: estimate of the expected background
  @param nbins: number of bins in histogram
  """
  hold(True) 
  sym=0
  if not nbins: nbins = 20
  viz.histdiff(coincDict['fg'].getsngls(ifo_list[1]), \
      coincDict['fg'].getsngls(ifo_list[0]), col_name,'hist',sym,2,\
      nbins,width)
  sym+=1
  if len(coincDict['bg']):
    viz.histdiff(coincDict['bg'].getsngls(ifo_list[1]), \
        coincDict['bg'].getsngls(ifo_list[0]), col_name,'hist',sym,2,\
        nbins,width) 
  if uniform_bg: plot(width, [uniform_bg/nbins])  
 

##############################################################################
usage = """usage: %prog [options] 

Program for automatically determining coincidence windows.  Here, we make use
of triggers surviving after the coincidence step of the pipeline.  This then
allows us to directly compare the values recorded in two different
instruments.  This is especially useful for timing (where there may be a
systematic offset) and quantities such as psi0/psi3 which don't match to the
injected waveform.  

Work as follows:

1) Choose 2 ifos (A and B). 

2) Run coincidence between injections in A and injections in B, with wide
   windows.

3) Keep all triggers near injections in A and B (this is just to cut down on
   the number of triggers processed), eg by running SIRE with window of 100ms.

4) Run coincidence between no-injections in A and injections in B, with the
   same windows as (3). 

5) Run coincidence between injections in A and no-injections in B, with the
   same windows as (3).
   
6) Keep all coincident triggers from (4) and (5) which are near to injection 
   times.

7) Pass in the output of (3) as --glob-found and (6) as --glob-bg.
"""

parser = OptionParser( usage = usage, version= "%prog CVS $Id$")
parser.add_option("-a","--ifo",action="append",type="string",\
    dest="ifo_list", metavar=" IFO", help="add IFO to list of ifos" )
parser.add_option("-r","--normalized-trigger-rate",action="append",\
    type="float",dest="rate_list",metavar=" RATE",\
    help="RATE of triggers for each ifo per unit parameter space volume")
parser.add_option("-g","--glob-found",action="store",type="string",\
    default=None, metavar=" GLOB",\
    help="GLOB of found injections" )
parser.add_option("-G","--glob-bg",action="store",type="string",\
    default=None, metavar=" GLOB",
    help="GLOB of background found injections, optional" )
parser.add_option("-c","--coincidence-column",action="append", type="string",\
    dest="coinc_cols",metavar=" COL",
    help="add COL to list of cols for which to determine coincidence window")
parser.add_option("-C","--background-confidence",action="store", \
    type="float",dest="conf",metavar=" CONF",\
    help="confidence, CONF, that the triggers are not due to background")
parser.add_option("-f","--figure-name",action="store",type="string",\
    default=None, metavar=" FNAME",\
    help="generate png figures with name FNAME-fig.png" )
parser.add_option("-s","--show-plot",action="store_true",default=False,\
    help="display the figures on the terminal" )
parser.add_option("-n","--nbins",action="store",type="int",default=20,\
    metavar=" NBINS", help="number of bins for the histogram plots" )
parser.add_option("-S","--max-step",action="store",type="float",default=1./3,\
    metavar=" MAXSTEP",\
    help="maximum fractional step made when revising the coincidence window" )
(opts,args) = parser.parse_args()


if not opts.glob_found:
  print >>sys.stderr, "Must specify a GLOB of found files"
  print >>sys.stderr, "Enter 'plotcoincwindow --help' for usage"
  sys.exit(1)

if not opts.glob_bg:
  print >>sys.stderr, "Recommended to specify a GLOB of bg files. But optional"
  print >>sys.stderr, "Enter 'plotcoincwindow --help' for usage"
  #sys.exit(1)

if not opts.ifo_list or len(opts.ifo_list) != 2:
  print >>sys.stderr, "Must specify two ifos using --ifo"
  sys.exit(1)

  
if not opts.rate_list or len(opts.rate_list) != 2:
  print >>sys.stderr, "Must specify trigger rates for ifos using"
  print >>sys.stderr, "--normalized-trigger-rate"
  sys.exit(1)

if not opts.coinc_cols:
  print >>sys.stderr, "Must specify at least one column for coincidence"
  print >>sys.stderr, "Use --coincidence-column to do so"
  sys.exit(1)

if not opts.conf:
  print >>sys.stderr, "Must specify a confidence, using --background-confidence"
  sys.exit(1)

if opts.conf >= 1 or opts.conf < 0:
  print >>sys.stderr, "Must specify a background confidence, between 0 and 1"
  sys.exit(1)


# glob for files
files = {}
files['fg'] = glob.glob(opts.glob_found)
if opts.glob_bg:
  files['bg'] = glob.glob(opts.glob_bg)


# read in the foreground and background triggers
snglDict = {}
coincDict = {}
availTrigs=['fg']
if opts.glob_bg:
  availTrigs=['fg','bg']
  
for trigs in availTrigs:
  snglDict[trigs] = {}
  snglDict[trigs] = SnglInspiralUtils.ReadSnglInspiralFromFiles(files[trigs])
  coincDict[trigs] = CoincInspiralUtils.coincInspiralTable(snglDict[trigs],\
      CoincInspiralUtils.coincStatistic("snr")) 
  coincDict[trigs] = coincDict[trigs].coincinclude(opts.ifo_list) 
  coincDict[trigs] = coincDict[trigs].cluster(10) 

if not opts.glob_bg:
  snglDict['bg'] = SnglInspiralUtils.ReadSnglInspiralFromFiles([])
  coincDict['bg'] = CoincInspiralUtils.coincInspiralTable()

# set number of events
nevents = len(coincDict['fg'])

# find the initial coincidence windows (1.2 times the furthest outlier)
# and remove all background outside this
window = {}
fig_num = 0

for col_name in opts.coinc_cols:
  [val_a, val_b, ifo ] = viz.readcolfrom2tables(
      coincDict['fg'].getsngls(opts.ifo_list[0]), 
      coincDict['fg'].getsngls(opts.ifo_list[1]), col_name)
  window[col_name] = [1.2 * min(val_a - val_b), 1.2 * max(val_a - val_b)]

revision_number = 0
revision = True
min_col = None
while revision == True:
  # calculate the expected background
  uniform_bg = sum(opts.rate_list) * nevents
  for col_name in opts.coinc_cols:
    uniform_bg *= (window[col_name][1] - window[col_name][0])

  # remove any fg or bg outside our windows
  for col_name in opts.coinc_cols:
    coinctest(coincDict['fg'], opts.ifo_list, col_name,window[col_name])
    if len(coincDict['bg']):
      coinctest(coincDict['bg'], opts.ifo_list, col_name, window[col_name])
  
  # make plots of foregroun and background
  for col_name in opts.coinc_cols:    
    fig_num +=1
    figure(fig_num)
    makeplot(coincDict,opts.ifo_list,col_name,window[col_name],\
        uniform_bg,opts.nbins)
    ylim(0,10)
    title(col_name, size='x-large')
    
    if opts.figure_name:
      output_name = opts.figure_name + '_' + col_name + '_revised_' + \
          str(revision_number) + '.png'
      savefig(output_name)
    if not opts.show_plot:
      close()

  # work out the revised windows
  new_window = {}
  win_ratio = {}
  for col_name in opts.coinc_cols:
    [bins,fg] = histcoincdiff(coincDict['fg'],opts.ifo_list,col_name, \
        window[col_name],opts.nbins)
    if len(coincDict['bg']):
      [bins,bg] = histcoincdiff(coincDict['bg'],opts.ifo_list,col_name, \
          window[col_name],opts.nbins)
    else:
      bg = zeros(len(bins))
    new_window[col_name] = revisewindow(bins,fg,bg,uniform_bg,opts.conf)
    win_ratio[col_name] = (new_window[col_name][1] - new_window[col_name][0]) \
        / (window[col_name][1] - window[col_name][0]) 
  sys.stdout.flush()
  min_ratio = 1
  for col_name, col_ratio in win_ratio.iteritems():
    if col_ratio < min_ratio:
      min_ratio = col_ratio
      min_col = col_name
  if min_ratio == 1:
    revision = False
  revision_number += 1

  # only reduce the window by 1/3 in any step
  if win_ratio[min_col] < (1 - opts.max_step):
    scale_factor = opts.max_step / ( 1 - win_ratio[min_col] )
    window[min_col][0] = window[min_col][0] + \
        scale_factor * (new_window[min_col][0] - window[min_col][0])
    window[min_col][1] = window[min_col][1] + \
        scale_factor * (new_window[min_col][1] - window[min_col][1])
  else:
    window[min_col] = new_window[min_col]

  # print min_col

print window
if opts.show_plot:
  show()
