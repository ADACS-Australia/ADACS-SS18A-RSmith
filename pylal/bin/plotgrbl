#!/usr/bin/env python
#
# Copyright (C) 2008  Nickolas Fotopoulos
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
"""
This code computes the probabilities that go into the distance upper limits
for the CBC external trigger search.

There is a lot of advanced indexing technique here.  Reference:
http://scipy.org/Cookbook/Indexing
"""

from __future__ import division

__author__ = "Nickolas Fotopoulos <nvf@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"
__Id__ = "$Id$"
__prog__ = "plotgrbl"
__title__ = "GRB likelihood diagnostics"

import cPickle as pickle
import optparse
import sys

import numpy
numpy.seterr(all="raise")  # throw an exception on any funny business
from scipy import stats
import matplotlib
matplotlib.use("Agg")
import pylab

from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import table
from glue.ligolw import utils
from pylal import CoincInspiralUtils
from pylal import grbsummary
from pylal import InspiralUtils
from pylal import plotutils
from pylal import rate
from pylal import viz

# override pylab defaults, optimizing for web presentation
pylab.rcParams.update({
    "text.usetex": True,
    "text.verticalalignment": "center",
    "lines.linewidth": 2.5,
    "font.size": 16,
    "axes.titlesize": 20,
    "axes.labelsize": 16,
    "xtick.labelsize": 16,
    "ytick.labelsize": 16,
    "legend.fontsize": 16,
})

class always_equal(object):
    def __eq__(self, other):
        return True

def make_html_table(two_dim_seq, header_row=None):
    """
    Given a sequence of sequences (2-D array works), make an HTML table out
    of it.  If header_row is provided, make it the table header.
    """
    last_len = always_equal()
    html = ["<table  border=\"1\" cellspacing=\"0\">"]
    if header_row is not None:
        html.append("  <tr><th>" + "</th><th>".join(map(str, header_row)) \
            + "</th></tr>")
        last_len = len(header_row)
    for row in two_dim_seq:
        if len(row) != last_len:
            raise ValueError, "header and row lengths must all be consistent."
        last_len = len(row)
        html.append("  <tr><td>" + "</td><td>".join(map(str, row)) \
            + "</td></tr>")
    html.append("</table><br>")
    return "\n".join(html)


def parse_args():
    parser = optparse.OptionParser(version="%prog CVS $Id$ ")

    # input
    parser.add_option("--relic-onsource", help="output of pylal_relic "\
        "containing the onsource loudest coincs")
    parser.add_option("--relic-offsource", help="output of pylal_relic "\
        "containing the offsource loudest coincs")
    parser.add_option("--relic-injections", help="output of pylal_relic "\
        "containing the loudest injection coincs")
    parser.add_option("--grblikelihood-onsource",
        help="On-source output pickle from pylal_grblikelihood")
    parser.add_option("--grblikelihood-offsource",
        help="Off-source output pickle from pylal_grblikelihood")
    parser.add_option("--grblikelihood-injections",
        help="Injection output pickle from pylal_grblikelihood")

    # InspiralUtils compatibility
    parser.add_option("--gps-start-time", type="int",
        help="GPS start time of data analyzed")
    parser.add_option("--gps-end-time", type="int",
        help="GPS end time of data analyzed")
    parser.add_option("--ifo-tag", help="IFO coincidence time analyzed")
    parser.add_option("--user-tag", help="a tag to label your plots")
    parser.add_option("--output-path", help="root of the HTML output")
    parser.add_option("--enable-output", action="store_true",
        default=False, help="enable plots and HTML output")
    parser.add_option("--html-for-cbcweb", action="store_true",
        default=False, help="enable HTML output with the appropriate headers "
        "for the CBC website")
    parser.add_option("--show-plot", action="store_true", default=False,
        help="display the plots to screen if an X11 display is available")

    parser.add_option("--verbose", action="store_true", default=False,
        help="extra information to the console")

    return parser.parse_args()


################################################################################
# parse arguments
opts, args = parse_args()

##############################################################################
# HTML initialization
InspiralUtils.initialise(opts, __prog__, __version__)
html_footer = ""

##############################################################################
# Read input

if opts.verbose:
    print "Reading in bin definitions and loudest statistics..."
statistic, mc_bins, onsource_loudest_by_mc \
    = pickle.load(open(opts.relic_onsource))
statistic, mc_bins, offsource_loudest_by_trial_mc \
    = pickle.load(open(opts.relic_offsource))
statistic, mc_bins, m2_bins, D_bins, m2_D_by_inj, inj_loudest_by_inj_mc \
    = pickle.load(open(opts.relic_injections))
if statistic != "effective_snr":
    raise NotImplemented

log_pc0_by_mc, log_pch_by_mc_m2, actual_candidate_mask, log_L_by_m2 = \
    pickle.load(open(opts.grblikelihood_onsource))
offsource_pc0_by_trial_mc, offsource_pch_by_trial_mc_m2, \
    offsource_likelihood_by_trial_m2 = \
    pickle.load(open(opts.grblikelihood_offsource))
inj_likelihood_by_trial_m2, log_pc0_by_inj_mc, log_pch_by_inj_mc, \
    rho_by_inj_mc, trace_m2_bin = \
    pickle.load(open(opts.grblikelihood_injections))

m2_D_bins = rate.NDBins((m2_bins, D_bins))
num_sims_by_m2_D = rate.BinnedArray(m2_D_bins)
for m2_D in m2_D_by_inj:
    num_sims_by_m2_D[m2_D] += 1
num_sims_by_m2_D = num_sims_by_m2_D.array

num_offsource_trials = offsource_loudest_by_trial_mc.shape[0]
num_inj = inj_likelihood_by_trial_m2.shape[0]
if inj_loudest_by_inj_mc.shape[0] != num_inj:
    raise ValueError, "relic injections do not match grblikelihood injections"

# get non-extrapolated P(rho > rho* | 0)
raw_pc0_by_mc = \
    (offsource_loudest_by_trial_mc > onsource_loudest_by_mc[None, :])\
    .sum(axis=0) / num_offsource_trials

log_L_by_mc_m2 = log_pch_by_mc_m2 - log_pc0_by_mc[:, None]
log_L_by_inj_mc = log_pch_by_inj_mc - log_pc0_by_inj_mc

##############################################################################
# Compute P(L > L_obs | 0)

# in each m2 bin, find what fraction of trials are louder than the on-source
pL0_by_m2 = \
    (offsource_likelihood_by_trial_m2 > log_L_by_m2[None, :])\
    .sum(axis=0, dtype=float) / num_offsource_trials

# find the fraction of trials whose max L is greater than the on-source max L
log_L_max = log_L_by_m2.max()
pLmax0 = (offsource_likelihood_by_trial_m2.max(axis=1) > log_L_max)\
    .sum(dtype=float) / num_offsource_trials

# for diagnostics, find P(L > L_* | 0) for various L_*
L_star_by_m2_trial = offsource_likelihood_by_trial_m2.T.copy()
L_star_by_m2_trial.sort(axis=1)
L_star_by_m2_trial[L_star_by_m2_trial < 0.] = 0.
offsource_pL0_by_trial = numpy.arange(num_offsource_trials, dtype=float)[::-1] \
    / num_offsource_trials

L_max_star = offsource_likelihood_by_trial_m2.max(axis=1)
L_max_star.sort()
P_L_max_star = numpy.arange(num_offsource_trials, dtype=float)[::-1] \
    / num_offsource_trials
L_max_star[L_max_star < 0.] = 0


##############################################################################
# Compute P(L > L_obs | h)

inj_louder_count_by_m2_D = numpy.zeros((len(m2_bins), len(D_bins)), dtype=int)
for inj_likelihood_by_m2, m2_D in zip(inj_likelihood_by_trial_m2, m2_D_by_inj):
    m2_ind, D_ind = m2_D_bins[m2_D]
    if inj_likelihood_by_m2[m2_ind] > log_L_by_m2[m2_ind]:
        inj_louder_count_by_m2_D[m2_ind, D_ind] += 1
pLh_by_m2_D = inj_louder_count_by_m2_D / (num_sims_by_m2_D + 1e-10)


##############################################################################
# print summary of loudest events
if opts.verbose:
    print "Computation complete.  Writing summary page and plots..."

relic_onsource_xml = opts.relic_onsource.replace(".pickle", ".xml")
html_footer += "Loudest on-source coincidences [<a href=\"" \
    + relic_onsource_xml + "\">XML</a>]:<br><br>\n"

if not numpy.any(actual_candidate_mask):
    html_footer += "No on-source coincidences found.\n"
else:
    # make overall statement
    html_footer += "<em>&rho;</em><sup>2</sup><sub style='margin-left: "\
        "-1ex;'><em>L</em>,max,obs</sub> = %.2g<br>\n" % log_L_max
    html_footer += "P(<em>&rho;</em><sup>2</sup><sub style='margin-left: "\
        "-1ex;'><em>L</em>,max</sub> &gt; <em>&rho;</em><sup>2</sup><sub "\
        "style='margin-left: -1ex;'><em>L</em>,max,obs</sub> | 0) "\
        "= %.2g<br><br>\n" % pLmax0

    # parse coincs
    coinc_stat = CoincInspiralUtils.coincStatistic(statistic)
    onsource_doc = utils.load_filename(relic_onsource_xml)
    onsource_trigs = table.get_table(onsource_doc,
        lsctables.SnglInspiralTable.tableName)
    onsource_coincs = CoincInspiralUtils.coincInspiralTable(onsource_trigs,
        coinc_stat)
    if len(onsource_coincs) > len(mc_bins):
        raise ValueError, "more on-source coincs than mchirp bins"

    # print per-mchirp info
    ifos = set()
    for coinc in onsource_coincs:
        ifos.update(coinc.get_ifos()[1])
    ifos = list(ifos)
    ifos.sort()
    columns = ["mc_bin", "event_id"] \
        + ["<em>&rho;</em><sub>eff,%s</sub>" % ifo for ifo in ifos] \
        + ["combined <em>&rho;</em><sub>eff</sub>", "mchirp",
        "<em>P</em>(<em>&rho;</em><sub>eff</sub> &gt; <em>&rho;</em>"\
        "<sub>eff,obs</sub> | 0)"]
    rows = []
    for low, hi, pc0 in \
        zip(mc_bins.lower(), mc_bins.upper(), raw_pc0_by_mc):
        row = ["[%.2f, %.2f)" % (low, hi)]
        mc_coincs = onsource_coincs.getChirpMass(low, hi)
        if len(mc_coincs) == 0:
            row += ["&mdash;"] * (len(columns) - len(row))
        elif len(mc_coincs) == 1:
            c = mc_coincs[0]
            # XXX: hardcoded effective SNR
            row += [c.event_id] \
                + ["%.4g" % trig.get_effective_snr() for trig in c] \
                + ["%.4g" % c.stat, "%.4g" % grbsummary.get_mean_mchirp(c),
                   "%.4g" % pc0]
        rows.append(row)
    html_footer += make_html_table(rows, columns)

    # print per-m2 info
    temp_log_L_by_mc_m2 = log_pch_by_mc_m2 - log_pc0_by_mc[:, None]
    temp_log_L_by_mc_m2[~actual_candidate_mask, :] = 0
    mc_ind_by_m2 = temp_log_L_by_mc_m2.argmax(axis=0)
    mc_ranges = zip(mc_bins.lower(), mc_bins.upper())
    m2_ranges = zip(m2_bins.lower(), m2_bins.upper())
    columns = ["m2_bin", "event_id", "<em>&rho;</em><sup>2</sup><sub "\
        "style='margin-left: -1ex;'><em>L</em></sub>",
        "<em>P</em>(<em>&rho;</em><sup>2</sup><sub style='margin-left: "\
        "-1ex;'><em>L</em></sub>(<em>m</em><sub>2</sub>) &gt; "\
        "<em>&rho;</em><sup>2</sup><sub style='margin-left: -1ex;'>"\
        "<em>L</em>,obs</sub>(<em>m</em><sub>2</sub>) | 0)"]
    rows = []
    for m2_range, mc_ind, log_L, pL0 in zip(m2_ranges, mc_ind_by_m2,
        log_L_by_m2, pL0_by_m2):
        row = ["[%.2f, %.2f)" % m2_range]
        m2_coincs = onsource_coincs.getChirpMass(*mc_ranges[mc_ind])
        if len(m2_coincs) == 0:
            row.append("&mdash;")
        elif len(m2_coincs) == 1:
            row.append(m2_coincs[0].event_id)
        else:
            raise ValueError, "there should be exactly one or zero coincs"
        row.extend(["%.4g" % log_L, "%.4g" % pL0])
        rows.append(row)
    html_footer += make_html_table(rows, columns)


################################################################################
# plots
fnameList = []
tagList = []

c_in_E = r"\textrm{any candidate in } \mathcal{E}(c_0)"
mc_latex = r"\langle \hat{M}_\mathrm{chirp} \rangle"
mc_ranges = zip(mc_bins.lower(), mc_bins.upper())

if actual_candidate_mask.any():
    observation = r"\rho_L^2(m_2) > \rho_{L,\mathrm{obs}}^2(m_2)"
else:
    observation = r"\textrm{any candidates}"

## Significance
text = "Significance"

thresh_05 = L_max_star[int(0.95 * len(L_max_star))]
thresh_01 = L_max_star[int(0.99 * len(L_max_star))]

plot = plotutils.SimplePlot(r"$m_2\ (M_\odot)$", r"$\rho_\mathrm{L}^2 (m_2)$",
    "Significance")
if actual_candidate_mask.any():
    plot.add_content(m2_bins.centres(), log_L_by_m2)
else:
    # get plot limits to autoscale the way we want
    plot.add_content(m2_bins.centres(), numpy.ones(len(m2_bins)),
        visible=False)
plot.finalize()
plot.ax.set_ylim(ymin=-0.5)

if not actual_candidate_mask.any():
    plot.ax.text(m2_bins.centres()[len(m2_bins)//2], 0.0,
        "No candidates found.", horizontalalignment="center",
        fontsize="x-large")

# add thresholds
xlims = tuple(plot.ax.get_xlim())
plot.ax.plot(xlims, (thresh_05, thresh_05), linestyle="--")
plot.ax.text(xlims[1], thresh_05, r"5\% false alarm",
    horizontalalignment="right", verticalalignment="bottom")
plot.ax.plot(xlims, (thresh_01, thresh_01), linestyle="--")
plot.ax.text(xlims[1], thresh_01, r"1\% false alarm",
    horizontalalignment="right", verticalalignment="bottom")
plot.ax.set_xlim(xlims)

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "max_log_L_by_mc_m2")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

## P(L_max > L_max^* | 0) vs L_max^*
text = "P(L_max > L_max^*| 0) vs ln L_max^*"

plot = plotutils.SimplePlot(\
    r"${\rho_{L\mathrm{,max}}^*}^2$",
    r"$P(\rho_{L\mathrm{,max}}^2 > {\rho_{L\mathrm{,max}}^*}^2 \,|\,0)$",
    r"$\textrm{Background distribution of } \rho_{L\mathrm{,max}}^2$")
plot.add_content(L_max_star, P_L_max_star,  marker=".", linestyle="None")
plot.finalize()
plot.ax.set_xscale("log")

# pLmax0
if actual_candidate_mask.any():
    xlims = tuple(plot.ax.get_xlim())
    plot.ax.plot((log_L_max, log_L_max), (0, 1), "k--")
    plot.ax.set_xlim(xlims)
    plot.ax.set_ylim((0, 1))

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "P_L_max_by_L")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()


## mchirp vs loudest stat horizontal bar graph
text = "mchirp vs loudest statistic"

plot = plotutils.NumberVsBinBarPlot(statistic.replace("_", r"\_"),
    "$" + mc_latex + "$", "Loudest statistics by template bank mchirp")
plot.add_content(mc_bins, onsource_loudest_by_mc)
plot.finalize(orientation="horizontal")

# add p(c|0) on top as text
for mc, snr, have_candidate, pc0 in \
    zip(mc_bins.centres(), onsource_loudest_by_mc, actual_candidate_mask,
        raw_pc0_by_mc):
    if have_candidate:
        plot.ax.text(snr + 0.2, mc, r"$P(" + c_in_E + r"\,|\,0) = %.3f$" \
            % pc0, verticalalignment="center")
    else:
        plot.ax.text(10, mc, r"$P(\textrm{any candidate}\,|\,0) = %.3f$" \
            % pc0, horizontalalignment="center", verticalalignment="center")

if plot.ax.get_xlim()[1] < 20:
    plot.ax.set_xlim(xmax=20)

plot.ax.set_ylim((mc_bins.min, mc_bins.max))

# add mchirp dividers
for divider in mc_bins.boundaries:
    plot.ax.plot(plot.ax.get_xlim(), (divider, divider),
        "k--", label="_nolegend_")

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "loudest_stats_by_mchirp")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

## L(c|h) vs m2
# TODO: before and after MC and calibration systematics
text = "ln L(c(mc)|h(m2))"

# get likelihoods at extrapolation points
# XXX: 0.1 is a magic number; we start extrapolating at p(c|0) = 0.1
extrap_ind = offsource_loudest_by_trial_mc.argsort(axis=0)\
    [-int(0.1 * num_offsource_trials), ...]
extrap_snr_by_mc = \
    offsource_loudest_by_trial_mc[extrap_ind, range(len(mc_bins))]

plot = plotutils.SimplePlot(\
    r"$m_2\ (M_\odot)$",
    r"$\rho_L^2(m_2)$",
    r"Significance of candidates in different mchirp regions")
for mc_range, mc_log_L_by_m2, is_candidate, color in \
    zip(mc_ranges, log_L_by_mc_m2,
    actual_candidate_mask, plotutils.default_colors()):
    if is_candidate:
        linestyle = "-"
    else:
        linestyle = "--"
    plot.add_content(m2_bins.centres(), mc_log_L_by_m2, linestyle=linestyle,
                     color=color,
                     label=r"$" + mc_latex + r"\in [%4.2f, %4.2f)$" % mc_range)
plot.finalize(loc=4)
plot.ax.set_ylim(ymin=-0.5)

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "log_L_by_mc_m2")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

## p(c|h) vs rho for each mc bin
text = "ln P(c|h) vs rho for each mc bin for m2 = " \
    + str(m2_bins.centres()[trace_m2_bin])

plot = plotutils.SimplePlot(r"$\rho_\mathrm{eff}$", "",
    r"$\ln P(" + c_in_E + r"\,|\,h)\textrm{ vs stat for some } "\
    r"m_2\ (%s\,M_\odot)$" % str(m2_bins.centres()[trace_m2_bin]))
for mc_ind, mc_range in enumerate(mc_ranges):
    x_data = rho_by_inj_mc[:, mc_ind]
    y_data = log_pch_by_inj_mc[:, mc_ind]
    plot.add_content(x_data, y_data, marker=".", linestyle="None",
        label="$" + mc_latex + r"\in [%4.2f, %4.2f)$" % mc_range)

plot.finalize(loc=1)

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "log_pch_vs_rho")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

## p(c|0) vs rho for each mc bin
text = "ln P(c|0) vs rho for each mc bin for m2 = " \
    + str(m2_bins.centres()[trace_m2_bin])

plot = plotutils.SimplePlot(r"$\rho_\mathrm{eff}$", "",
    r"$\ln P(" + c_in_E + r"\,|\,0)\textrm{ vs stat for some }m_2\ "\
    r"(%s\,M_\odot)$" % str(m2_bins.centres()[trace_m2_bin]))
for mc_range, rho_by_inj, log_pc0_by_inj \
    in zip(mc_ranges, rho_by_inj_mc.T, log_pc0_by_inj_mc.T):
    plot.add_content(rho_by_inj, log_pc0_by_inj, marker=".", linestyle="None",
        label="$" + mc_latex + r"\in [%4.2f, %4.2f)$" % mc_range)
plot.finalize(loc=3)

# add SNRs at which we begin extrapolating
ylims = tuple(plot.ax.get_ylim())
for extrap_snr, color in zip(extrap_snr_by_mc, plotutils.default_colors()):
    plot.ax.plot((extrap_snr, extrap_snr), ylims,
        color + "--", label="_nolegend_")
plot.ax.set_ylim(ylims)

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "log_pc0_vs_rho")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
# save a zoomed version, too
plot.ax.set_xlim((4, 10))
plot.ax.set_ylim((-3, 0.2))
if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "log_pc0_vs_rho_zoom")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

## L vs rho for each mc bin
text = "ln L vs rho for each mc bin for m2 = " + str(m2_bins.centres()[trace_m2_bin])

plot = plotutils.SimplePlot(r"$\rho_\mathrm{eff}$", "",
    r"$\rho_L^2\textrm{ vs stat for some }m_2\ (%s\,M_\odot)$" \
    % str(m2_bins.centres()[trace_m2_bin]))
for mc_ind, mc_range in enumerate(mc_ranges):
    x_data = rho_by_inj_mc[:, mc_ind]
    y_data = log_L_by_inj_mc[:, mc_ind]
    plot.add_content(x_data, y_data, marker=".", linestyle="None",
        label="$" + mc_latex + r"\in [%4.2f, %4.2f)$" % mc_range)
plot.finalize(loc=2)

# add SNRs at which we begin extrapolating
ylims = tuple(plot.ax.get_ylim())
for extrap_snr, color in zip(extrap_snr_by_mc, plotutils.default_colors()):
    plot.ax.plot((extrap_snr, extrap_snr), ylims,
        color + "--", label="_nolegend_")
plot.ax.set_ylim(ylims)

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "log_L_vs_rho")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
# save a zoomed version, too
plot.ax.set_xlim((4, 10))
plot.ax.set_ylim((-0.2, 3))
if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "log_L_vs_rho_zoom")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

## p(c|h) from max L mchirp bins vs (m2, D) image
text = "p(observation|h(m2, D)) after 90% MC errors"

num_sigmas = stats.norm.ppf(0.9)
MC_sigma = numpy.sqrt(pLh_by_m2_D * (1 - pLh_by_m2_D) / num_sims_by_m2_D)

plot = plotutils.ImagePlot(r"$m_2\ (M_\odot)$", r"$D\ \mathrm{(Mpc)}$",
    r"$P(" + observation + r"\,|\,h(m_2, D)) "
    r"\textrm{ w/ 90\% MC error}$")
plot.add_content(pLh_by_m2_D.T - num_sigmas * MC_sigma.T, m2_bins, D_bins)
plot.finalize()

# XXX: Hack around an apparent matplotlib API backwards-incompatibility
# When all clusters have 0.90 or higher, remove the try-except.
try:
  image = [c for c in plot.ax.get_children() \
           if isinstance(c, matplotlib.image.AxesImage)][0]
  image.set_clim((0, 1))
except AttributeError:
  pass

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "pLh_afterMCerr_by_m2_D")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

## p(c|h) from max L mchirp bins vs (m2, D) image
text = "p(observation|h(m2, D)) before MC errors"

plot = plotutils.ImagePlot(r"$m_2\ (M_\odot)$", r"$D\ \mathrm{(Mpc)}$",
    r"$P(" + observation + r"\,|\,h(m_2, D))$")
plot.add_content(pLh_by_m2_D.T, m2_bins, D_bins)
plot.finalize()

# XXX: Hack around an apparent matplotlib API backwards-incompatibility
# When all clusters have 0.90 or higher, remove the try-except.
try:
  image = [c for c in plot.ax.get_children() \
           if isinstance(c, matplotlib.image.AxesImage)][0]
  image.set_clim((0, 1))
except AttributeError:
  pass

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "pLh_by_m2_D")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

## P(L > L_0 | 0) vs m2
text = "lim_{D->inf} P(observation| h(m2, D)) vs m_2"

orig_size = pylab.rcParams["axes.titlesize"]
pylab.rcParams["axes.titlesize"] = orig_size * 0.9
plot = plotutils.SimplePlot(\
    r"$m_2\ (M_\odot)$",
    r"$P(" + observation + r"\,|\,0)$",
    r"\[P(" + observation + r"\,|\,0) \left(= \lim_{D\rightarrow\infty} P(" \
    + observation + r"\,|\,h(m_2, D))\right)\]")
plot.add_content(m2_bins.centres(), pL0_by_m2)
plot.finalize(loc=4)
plot.ax.set_ylim((0, 1))
pylab.rcParams["axes.titlesize"] = orig_size

# the title is stupidly huge; shrink plot to fit it
plot.ax.set_position((0.12, 0.1, 0.8, 0.78))

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "pL0_by_m2")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

## P(L > L_* | 0) vs L_*
text = "P(L(m_2) > L_*(m_2) | 0) vs ln L_*"

plot = plotutils.SimplePlot(\
    r"${\rho_L^*}^2$",
    r"$P(\rho_L^2(m_2) > \rho_{L,*}^2\,|\,0)$",
    r"\[P(\rho_L^2(m_2) > \rho_{L,*}^2\,|\,0) "\
    r"\left(= \lim_{D\rightarrow\infty} P(\rho_L^2(m_2) > \rho_{L,*}^2 "\
    r"\,|\,h(m_2, D))\right)\]")

m2_ranges = zip(m2_bins.lower(), m2_bins.upper())
for m2_range, Lstar_by_trial in \
    zip(m2_ranges, L_star_by_m2_trial):
    plot.add_content(Lstar_by_trial, offsource_pL0_by_trial,
                     label=r"$m_2 \in [%4.1f, %4.1f) M_\odot$" % m2_range)
plot.finalize(loc=4)
plot.ax.set_yscale("log")
plot.ax.set_xlim(xmin=0)

# the title is stupidly huge; shrink plot to fit it
plot.ax.set_position((0.12, 0.1, 0.8, 0.78))

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "pL0_by_L")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()

## injection count vs (m2, D) image
text = "Injection count"

plot = plotutils.ImagePlot("$m_2\ (M_\odot)$", "$D\ \mathrm{(Mpc)}$",
    r"Injections made")
plot.add_content(num_sims_by_m2_D.T, m2_bins, D_bins)
plot.finalize()

if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "injection_count_by_m2_D")
    fname_thumb = InspiralUtils.savefig_pylal(fname, fig=plot.fig)
    fnameList.append(fname)
    tagList.append(text)
if not opts.show_plot:
    plot.close()


#############################################################################
# Generate HTML and cache file
if opts.enable_output:
    html_filename = InspiralUtils.write_html_output(opts, sys.argv[1:],
        fnameList, tagList, comment=html_footer)
    InspiralUtils.write_cache_output(opts, html_filename, fnameList)

    if opts.html_for_cbcweb:
        html_filename_publish = InspiralUtils.write_html_output(opts,
            sys.argv[1:], fnameList, tagList, comment=html_footer, cbcweb=True)

if opts.show_plot:
    pylab.show()
