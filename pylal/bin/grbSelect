#!/usr/bin/python

__Id__ = "$Id$"
__author__ = "Alexander Dietz <Alexander.Dietz@astro.cf.ac.uk>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]
__name__ = "grbSelect"
__title__ = "grb selection tool"


import os
import sys
from optparse import *
from numpy import *

### Speed hacks
import glue.segments, glue.__segments
glue.segments.segment = glue.__segments.segment
glue.segments.segmentlist = glue.__segments.segmentlist
glue.segments.PosInfinity = glue.__segments.PosInfinity
glue.segments.NegInfinity = glue.__segments.NegInfinity
### End speed hacks

from glue.ligolw import ligolw
from glue.ligolw import utils
from glue.ligolw import table
from glue.ligolw import lsctables
from glue import segments
from glue import segmentsUtils
from pylal import antenna
from pylal import date
from pylal import grbsummary
from pylal import CoincInspiralUtils

import matplotlib
matplotlib.use('Agg')
from pylal.plotsegments import PlotSegmentsPlot

##############################################
## global variables
##############################################

ifoList=['H1','H2','L1','G1','V1']


##############################################
usage = """
usage: %prog [options]

GRB selection script.

Selects specified GRBs from the basic list and generates a xml-file and/or a html-file.

Needs the following files:
listGRB.xml
S5[IFO]_selectedsegs.txt #for all five IFOs, in directory specified by --segments

Optional but useful files:
[ifo]cat1.list          # for all five IFOs. Contain the category1-veto segment lists, in same directory

Example call:

grbSelect \
  --onsource-left 120 \
  --onsource-right 20 \
  --input listGRB.xml \
  --segments Segments \
  --algorithm unsymmetric \
  --type short \
  --ifo-times H1H2 \
  --select sub \
  --num-offsource 50 \
  --output-html S5_any_yr12.html\
  --output-xml S5_any_yr12.xml \
  --stats \
  --gps-start-time 815011213 \
  --gps-end-time 847555570
"""

htmlHeader='''
<table border="1" cellpadding="2" cellspacing="2">
  <tbody>
<tr>
      <td style="vertical-align: top; background-color: rgb(255, 153, 0);"><span style="color: rgb(51, 51, 255); font-weight: bold;">Nr</span><br>

      </td>
      <td style="vertical-align: top; font-weight: bold; font-style: italic; color: rgb(51, 51, 255); background-color: rgb(255, 153, 0);">GRB</td>
      <td style="vertical-align: top; color: rgb(51, 51, 255); font-weight: bold; font-style: italic; background-color: rgb(255, 153, 0);">GPS<br>

      </td>

      <td style="vertical-align: top; font-weight: bold; font-style: italic; color: rgb(51, 51, 255); background-color: rgb(255, 153, 0);">Date<br>
      </td>

      <td style="vertical-align: top; font-style: italic; color: rgb(51, 51, 255); font-weight: bold; background-color: rgb(255, 153, 0);">redshift<br>

      </td>
      <td style="vertical-align: top; font-weight: bold; background-color: rgb(255, 153, 0);"><span style="color: rgb(51, 51, 255);">duration [s]</span><br>
      </td>
      <td style="vertical-align: top; font-weight: bold; font-style: italic; color: rgb(51, 51, 255); background-color: rgb(255, 153, 0);">RA<br>
      </td>
      <td style="vertical-align: top; font-weight: bold; font-style: italic; color: rgb(51, 51, 255); background-color: rgb(255, 153, 0);">DEC<br>

      </td>
 <td style="vertical-align: top; font-weight: bold; font-style: italic; color: rgb(51, 51, 255); background-color: rgb(255, 153, 0);">H1<br>
      </td>
 <td style="vertical-align: top; font-weight: bold; font-style: italic; color: rgb(51, 51, 255); background-color: rgb(255, 153, 0);">H2<br>
      </td>
 <td style="vertical-align: top; font-weight: bold; font-style: italic; color: rgb(51, 51, 255); background-color: rgb(255, 153, 0);">L1<br>
      </td>

 <td style="vertical-align: top; font-weight: bold; font-style: italic; color: rgb(51, 51, 255); background-color: rgb(255, 153, 0);">G1<br>
      </td>
 <td style="vertical-align: top; font-weight: bold; font-style: italic; color: rgb(51, 51, 255); background-color: rgb(255, 153, 0);">V1<br>
      </td>'''

##############################################
def parse_command_line():

  parser = OptionParser( usage=usage, \
      version="%prog CVS\n" + 
      "$Id$\n" + 
      "Name: $\n") 
  parser.add_option("-i","--input",action="store",type="string",\
      default=None, metavar=" INPUT",\
      help="XML input file containing the list of GRBs to read" )
  parser.add_option("-S","--segments",action="store",\
      type="string",  metavar=" SEGMENTS",\
      help="directory containing the segment files in format: S5[IFO]_selectedsegs.txt")
  parser.add_option("","--l1-vetosegs",action="store",\
      type="string",  metavar="L1-VETOSEGS", default = None,\
      help="specifies veto segments for L1")
  parser.add_option("","--h1-vetosegs",action="store",\
      type="string",  metavar="H1-VETOSEGS", default = None,\
      help="specifies veto segments for H1")
  parser.add_option("","--h2-vetosegs",action="store",\
      type="string",  metavar="H2-VETOSEGS", default = None,\
      help="specifies veto segments for H2")
  parser.add_option("","--g1-vetosegs",action="store",\
      type="string",  metavar="G1-VETOSEGS", default = None,\
      help="specifies veto segments for G1")
  parser.add_option("","--v1-vetosegs",action="store",\
      type="string",  metavar="V1-VETOSEGS", default = None,\
      help="specifies veto segments for V1")
  parser.add_option("-H","--output-html",action="store",type="string",\
      default=None, metavar=" OUTPUT_HTML",\
      help="Output file for html output" )
  parser.add_option("-o","--output-xml",action="store",type="string",\
      help="Output file for xml")
  parser.add_option("-a","--stats",action="store_true",\
      default=False, metavar=" STATS",\
      help="Printing statistical informations to screen (using all GRBs in list)" )
  parser.add_option("-t","--grb-type",action="store",\
      type="string",default="",  metavar=" SELECT_TYPE",\
      help="Selection of the type (short, long, all)")
  parser.add_option("","--gps-start-time",action="store",\
      type="int",  metavar="GPSSTARTTIME",\
      help="gps start time (for selection purposes)")
  parser.add_option("","--gps-end-time",action="store",\
      type="int",  metavar=" GPSENDTIME",\
      help="gps end time (for selection purposes)")
  parser.add_option("-T","--ifo-times",action="store",\
      type="string",  metavar=" IFOTIMES",\
      help="ifo times e.g H1H2, H1L1, H1H2L1, etc., all (all GRBs), "\
                    "any (any GRB with data from >=2 detectors only)")
  parser.add_option("-e","--match-exact",action="store",\
      type="string",  metavar=" MATCH_EXACT",\
      help="if set to 'true' it will select only GRB's which"\
                    "matches the ifo_times exactly. "\
                    "Otherwise if set to 'false'")
  parser.add_option("-E","--exclude-ifos",action="store",\
      type="string",  \
      help="sets an IFO to be excluded")
  parser.add_option("-l","--onsource-left",action="store",\
      type="int",  default=0, metavar=" ONSOURCE_LEFT",\
      help="onsource time left of the trigger")
  parser.add_option("-r","--onsource-right",action="store",\
      type="int",  default=0, metavar=" ONSOURCE_LEFT",\
      help="onsource time right of the trigger")
  parser.add_option("-n","--num-trials",action="store",\
      type="int",  default=-1, metavar=" NUM_TRIALS",\
      help="number of offsource segments required")
  parser.add_option("-p", "--padding-time", type="int", default=0,
      help="padding time on each side of an analysis segment")   
  parser.add_option("-s", "--symmetric", action="store_true", default=False,
       help="restrict the off-source trials to be arranged"\
            " symmetrically about the on-source segment "\
            "(default: asymmetrical distribution allowed)")
  parser.add_option("-O", "--plot-offset", type="int", default=0,
      help="offset-time added to the plots")   
  parser.add_option("","--plot-segments",action="store_true",\
      default=False,help=" plot the segments" )
  parser.add_option("-v","--verbose",action="store_true",\
      default=False,help="print information" )

  (opts,args) = parser.parse_args()

  
  # test the input options
  if opts.onsource_right==0 or opts.onsource_left==0 :
    print >> sys.stderr, "left and right onsource segment must be specified"
    print >> sys.stderr, "use --onsource-left and --onsource-right"
    sys.exit(1)

  if not opts.input:    
    print >> sys.stderr, "Must specify XML input file with --input"
    sys.exit(1)

  if not opts.segments:       
    print >> sys.stderr, "Must specify segments directory with --segments"
    sys.exit(1)

  if not opts.grb_type:
    print >> sys.stderr,"Must select type, either short, long or all"
    sys.exit(1)

  if not opts.ifo_times:
    print >> sys.stderr,"Must specify ifo-times, either the IFOs or 'all'"
    sys.exit(1)
    
  if opts.ifo_times!='all' and opts.ifo_times!='any':
    if opts.match_exact!='true' and  opts.match_exact!='false':
      print >> sys.stderr,"Must specify 'true' or 'false' for --match-exact"
      sys.exit(1)

  if opts.match_exact=='true':
    opts.match = True
  else:
    opts.match = False

  if opts.num_trials<0:  
    print >> sys.stderr,"Number of offcource segments must e >=0"
    sys.exit(1)         

  return opts, sys.argv[1:]

##############################################
def checkSelection( grb, opts):
  """
  Checks if the GRB lies in thme tie specified, and if the type is correct
  """

  if opts.gps_start_time:
    if grb.start_time<opts.gps_start_time:
      return False

  if opts.gps_end_time:
    if grb.start_time>opts.gps_end_time:
      return False

  if opts.grb_type!="all":
    if opts.grb_type!=grb.event_type:
      return False

  return True

##############################################
def checkIFO( ifo_times, grb_list, match):
  """
  Check if the ifos in both lists are the same, regardless of their order.
  """

  # return True if a special flag is selected
  if ifo_times=='any' or ifo_times=='all':
    return False

  # decompose both strings
  list = []
  for i in range(len(ifo_times)/2):
    list.append(ifo_times[2*i:2*i+2])

  # convert to sets
  ifosRequested = set( list )
  ifosValid = set( grb_list )

  # now do the logic
  if match:
    if ifosValid==ifosRequested:
      return True
    else:
      return False

  else:
    if ifosRequested<=ifosValid:
      return True
    else:
      return False
  
##############################################################################
def applyDataQuality(segments, vetofile):
  """
  Applying the veto-segments specified in 'vetofile'
  to 'segments'
  """
  
  # read it back in and apply
  try:
    veto_segs = segmentsUtils.fromsegwizard(open(vetofile))
    segments -= veto_segs
  except:
    print "Unable to read veto segments from file  %s" % \
          (vetofile)


##############################################################################
def addColumnEntry( row, text, bold = False, link = None):
  """
  Add another column to the row in html format.
  """

  if bold:
    text='<b>'+text+'</b>'
  if link:
    text='<a href="'+link+'">'+text+'</a>'
    
  row+='<td>'+text+'</td>'

  return row
    

##############################################
## Main Program
##############################################

# get the command arguments
opts, name =  parse_command_line()

# create a set of excluded ifos
ifos_excluded = []
if opts.exclude_ifos:
  ifos_excluded = [opts.exclude_ifos[2*i:2*i+2] \
                   for i in range(len(opts.exclude_ifos)/2)]

# and adjust the ifoList
ifoList = [ifo for ifo in ['H1','H2','L1','G1','V1'] \
           if ifo not in ifos_excluded]

 
# read the table
doc = utils.load_filename( opts.input )
table = table.get_table(doc, lsctables.ExtTriggersTable.tableName)


# defined some useless variables
vectorDur = []
vectorZ   = []
vectorTime= []
numberShort = 0
numberLong  = 0
numberShortZ= 0
numberLongZ = 0
numberTotal = 0

# loop over all GRBs in the list
for grb in table:
  if grb.event_type=='short':
    numberShort+=1
    if grb.event_z>0:
      numberShortZ+=1
  elif grb.event_type=='long':    
    numberLong+=1
    if grb.event_z>0:
      numberLongZ+=1
  else:
    print "unknown type: ", grb.event_type


  if grb.event_z>0:
    vectorZ.append( grb.event_z)
  if float(grb.event_epoch)>0:
    vectorDur.append( float(grb.event_epoch) )

  numberTotal+=1
  vectorTime.append( grb.start_time)
  


if opts.stats:
  print "Total number of GRBs in the list: ", numberTotal
  print "Number of short: %d (%d), number of long: %d (%d)" %\
        (numberShort, numberShortZ, numberLong, numberLongZ )
  
  print "shortest: %f  longest: %f" % (min(vectorDur),max(vectorDur))
  print "closest: %f  farthest: %f" % (min(vectorZ),max(vectorZ))


################################
## create table for html (enote)
################################
  
# calculate onsource times
onSourceLeft = opts.onsource_left
onSourceRight = opts.onsource_right
onSourceLength = onSourceLeft+onSourceRight


# open the html output file if requested
if opts.output_html:
  htmlfile=open(opts.output_html, 'w')
  htmlfile.write(htmlHeader)


# prepare the xml output file if requested
if opts.output_xml:
  xmldoc = ligolw.Document()
  xmldoc.appendChild(ligolw.LIGO_LW())
  tbl = lsctables.New(lsctables.ExtTriggersTable)
  xmldoc.childNodes[-1].appendChild(tbl)
    
## create HTML table of all GRB's
month=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug',\
       'Sep','Oct','Nov','Dec']


############################################################
# handle the segment lists
segdict = segments.segmentlistdict()
for ifo in ifoList:

  # read the segment lists
  filename = opts.segments+'/S5%s_selectedsegs.txt' % ifo
  segdict[ifo] = segmentsUtils.fromsegwizard(open(filename))
  
  # apply category-1 vetoes in any case
  applyDataQuality(segdict[ifo], opts.segments+"/"+ifo + \
                   "_cat1_vetoed_segments.txt")

  # check for a veto file
  if getattr( opts, ifo.lower()+'_vetosegs'):
      
    applyDataQuality(segdict[ifo], ifo.lower()+'_vetosegs') 
    print "Veto-file specified for IFO %s" % ifo

# sort the triggers first
index = argsort( vectorTime )


##########################################################
# loop over all GRBs in the list

# just some counters
color=1
number=1
numberSelected=0

if opts.plot_segments and not os.path.isdir("plotsegments"):
  os.mkdir("plotsegments")

# loop over all GRBs
for ind in index:
  grb = table[ind]
  
  # check if this GRB is selected
  if not checkSelection( grb, opts):
    continue

  # create te on-source segment
  onSource =  segments.segment( grb.start_time-onSourceLeft,
                                grb.start_time+onSourceRight )
  offSourceLength =   (1+opts.num_trials)*abs(onSource)+\
           2*opts.padding_time

    
  # calculate the antenna factor
  antennaFactor = {}
  for ifo in ifoList:
    if onSource in segdict[ifo]:
      
      # compute the antenna factor for this time and position on the sky
      f_plus, f_cross, f_ave, f_q = antenna.response( grb.start_time,
                                                      grb.event_ra,\
                                                      grb.event_dec, \
                                                      0.0, 0.0, 'degree',
                                                      ifo )
      antennaFactor[ifo]=f_q

    
  # set the background color
  line=''
  if color==1:
    line ='<tr style="background-color: rgb(153, 255, 255);">'
  else:
    line = '<tr style="background-color: rgb(204, 255, 255);">'
    
  if grb.event_type == 'short':
    line = '<tr style="background-color: rgb(255, 200, 200);">'
    
  # set the number and the GCN link
  line = addColumnEntry( line , '%d' % number)
  line = addColumnEntry( line ,grb.event_number_grb, \
                         link ="http://gcn.gsfc.nasa.gov/gcn3/%d.gcn3"% \
                         grb.event_number_gcn )

  # set the time
  line = addColumnEntry( line , '%d' %  grb.start_time)
  gps = date.LIGOTimeGPS(grb.start_time )
  d = date.XLALGPSToUTC(gps)
  line = addColumnEntry( line ,'%s %02d %d %02d:%02d:%02d' %\
                         (month[d[1]-1], d[2], d[0], d[3], d[4], d[5]))

  # put in the redshift
  if grb.event_z>0:
    if int(grb.notice_time)>0:
      line = addColumnEntry( line , '%.3f' % grb.event_z, \
                             link ="http://gcn.gsfc.nasa.gov/gcn3/%d.gcn3"% \
                             int(grb.notice_time) )
    else:
      line = addColumnEntry( line , '%.3f' % grb.event_z )      
  else:
    line = addColumnEntry( line , 'n/a' )

  # put in the duration
  if float(grb.event_epoch)>0:
    if int(grb.email_time)>0:
      line = addColumnEntry( line , '%.3f' % float(grb.event_epoch), \
                             link ="http://gcn.gsfc.nasa.gov/gcn3/%d.gcn3"% \
                             int(grb.email_time) )
    else:
      line = addColumnEntry( line , '%.3f' % float(grb.event_epoch) ) 
  else:
    if int(grb.email_time)>0:
      line = addColumnEntry( line , 'n/a' , link = "http://gcn.gsfc.nasa.gov/gcn3/%d.gcn3"% \
                             int(grb.email_time) )
    else:
      line = addColumnEntry( line , 'n/a' )      

  # position
  line = addColumnEntry( line , '%.2f' % grb.event_ra )
  line = addColumnEntry( line , '%.2f' % grb.event_dec )  


  # find the analysable IFO for this GRB with Nick's function
  offSourceSegment, grb_ifolist = \
                    grbsummary.multi_ifo_compute_offsource_segment(\
      segdict, onSource, padding_time=opts.padding_time , \
      min_trials=opts.num_trials, max_trials=opts.num_trials,
      symmetric=opts.symmetric)
  grb_ifolist.sort()

  # check the length of the segment:
  if offSourceSegment:
    if abs(offSourceSegment)!=offSourceLength:
      offSourceSegment=None
      grb_ifolist=[]

  # create the segment plot
  link=None
  if opts.plot_segments:

    filePrefix = grb_ifolist
    if offSourceSegment is None:
      offSourceSegment = \
        segments.segment(onSource[0] - opts.num_trials*onSourceLength,
                         onSource[1] + opts.num_trials*onSourceLength)
      filePrefix='None'
    effective_window = segments.segmentlist([offSourceSegment]).protract(opts.plot_offset)
    effective_segdict = segdict.map(lambda sl: sl & effective_window)
    plot = PlotSegmentsPlot(grb.start_time)
    plot.add_contents(effective_segdict)
    plot.set_window(offSourceSegment, opts.plot_offset)
    plot.highlight_segment( onSource )
    plot.finalize()
    filename = "".join(filePrefix) + "-PLOTSEGMENT_" + grb.event_number_grb
    filename = "-".join((filename, str(offSourceSegment[0]),
                         str(abs(offSourceSegment))))
    filename += ".png"
    plot.ax.set_title('Segments for GRB '+grb.event_number_grb)
    plot.savefig("plotsegments/"+filename)
    plot.close()
    link = "plotsegments/"+filename


  # put together the last columns in the html entry
  for ifo in ifoList:
    if onSource in segdict[ifo]:
      if ifo in grb_ifolist:
        line = addColumnEntry( line , '%.2f' % antennaFactor[ifo], bold=True, link=link  )
      else:
        line = addColumnEntry( line , '%.2f' % antennaFactor[ifo], link=link  )        
    else:
      line = addColumnEntry( line , 'N/A', link=link)
  
  # Now finally check if we got the IFO times that was requested
  if opts.ifo_times=='all' or \
         (opts.ifo_times=='any' and len(grb_ifolist)>=2) or \
         checkIFO(opts.ifo_times, grb_ifolist, opts.match):

    ifoCombo = "".join(grb_ifolist)
    print "selected GRB %s: %s %s " % \
          (grb.event_number_grb, opts.ifo_times, \
           ifoCombo)
    
    # increase counters
    numberSelected+=1
    color*=-1
    number+=1
    
    # append to html table
    if opts.output_html:
      htmlfile.write(line+'</tr>\n')

    # append to xml file
    if opts.output_xml:
      tbl.append(grb)

  # double check to see if the individual IFO are contained in the segments
  # and if the duration is correct
  for ifo in grb_ifolist:
    if offSourceSegment not in segdict[ifo]:     
      print "ERROR: offsourcesegment is not contained in segment of IFO ", ifo,\
        "for GRB", grb.event_number_grb
      sys.exit(1)

######################################################################
# close-out the files
if opts.output_html:
  htmlfile.close()
if opts.output_xml:
  utils.write_filename(xmldoc, opts.output_xml )


print "%d GRBs were selected " % numberSelected

    
