#!/usr/bin/python
#
# Copyright (C) 2009  Steve Fairhurst & John Veitch, based on glitch-page.sh by Duncan
# Brown, ligolw_glitch_page.py by Larne Pekowsky
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#

from optparse import OptionParser
import sys
import os
import subprocess

from pylal import SnglInspiralUtils
from pylal import SimInspiralUtils
from glue import segments
from glue import segmentsUtils
from glue.segmentdb import segmentdb_utils

# =============================================================================

def readInjLog(fname):
    """
    read the injection log, and keep those rows corresponding to
    successful injections
    """
    f = open(fname,'r')
    injections = f.readlines()
    f.close()
    injections.pop(0)
    inj_times = []
    for line in injections:
        details = line.strip().split('\t')
        if details[3].strip() == 'Successful':
            # injection performed successfully, so we want to record it
            inj_times.append(int(details[0]))
    return inj_times

# =============================================================================


def get_xml_files(filenames,time,ifo):
	# Decide on the xml files to read
    xml_files = []

    for fname in filenames:
        tm, dur = fname.split('-')[-2:]
        tm      = int(tm)
        dur     = int(dur[:-4])
	if time >= tm and time <= (tm + dur) and ifo in fname:
        	xml_files.append(fname)
    return xml_files
# =============================================================================

def check_ifo_result(ifo,time,filenames,successful_inj):
	"""
	Return indicator of status for this injection
	"""
	if(successful_inj.has_key(ifo)) and (successful_inj[ifo] is not None):
	        if time in successful_inj[ifo]:
			injected=1
		else: injected = 0
	else: injected=0
	if(injected==0):
		return (0,0,0)
	xml_files = get_xml_files(filenames,time,ifo)
	if not xml_files:
		analysed=0
		found=0
	else: analysed=1
	if analysed:
		triggers =  SnglInspiralUtils.ReadSnglInspiralFromFiles(xml_files)
		if triggers:
			inj_time = segments.segment(time - 0.1, time + 0.1)
                	triggers = triggers.vetoed(inj_time)
                	triggers = triggers.ifocut(ifo)
        	if triggers and len(triggers): found=1
		else: found=0
	return (injected,analysed,found)

def get_ifo_result_string(key):
	"""
	Generate the HTML table element for a particular IFO and time
	"""
	(injected,analysed,found)=key
	if not injected: return "<td bgcolor=#ddffdd>Not performed</td>"
 	if not analysed: return "<td bgcolor=#ff9900>Not analysed</td>"
	if not found: return "<td bgcolor=#ff2222>Missed</td>"
	else: return "<td bgcolor=#22ff22>Found</td>"	

def chirp_dist(inj,ifo):
	return inj.get_eff_dist(ifo[0])*(2.8*.25**(3.0/5.0)/inj.mchirp)**(5.0/6.0)

# =============================================================================
def list_results(ifo, time, segment_url, filenames, successful_inj, outfile):
    """
    Generate HTML for each MBTA trigger in the given ifo 'close to'
    the given time 
    """
    dq_flags = ''
    flags    = {}

    # Check whether the injection was performed
    if (successful_inj.has_key(ifo) ) and (successful_inj[ifo] is not None):
        if time not in successful_inj[ifo]:
            print >>outfile,'  <tr valign="top" bgcolor="ddffdd"><td>%s</td><td colspan="10">Injection Not Performed</td><td></td></tr>' % ifo
            return

    # Get associated DQ flags
    if segment_url:
        pipe = os.popen('ligolw_dq_query --segment=%s --include-segments %s --in-segments-only --report %d' % (segment_url, ifo, time))
    else:
        pipe = []

    for line in pipe:
        flag, beforet, timet, aftert = filter(lambda x: x != '', line.split())
    
        ifo, name, version = flag.split(':')
        flags[name] = (beforet, timet, aftert)

    if not pipe == []:
        pipe.close()
    
    ifo_status = ''

    # Handle the ones that sould be displayed in bold without
    # DMT- 
    for flag_name in ['Light','Up','Calibrated','Science','Injection']:
        flag = 'DMT-' + flag_name.upper()

        if flag in flags:
            ifo_status += flag_name + ','
            del flags[flag]

    if len(ifo_status) > 0:
        ifo_status = ifo_status[:-1]


    flags[ifo_status] = True


    for name, value in flags.items():
        if not name.startswith('DMT'):
            dq_flags += '<b>%s</b><br>' % name
        else:
            dq_flags += '%s %s %s<br>' % (name, value[0], value[2])
    xml_files=get_xml_files(filenames,time,ifo)

    # read triggers
    if not xml_files:
        print >>outfile, '  <tr valign="top" bgcolor="ff9900"><td>%s</td><td colspan="10">Not Analyzed</td><td>%s</td></tr>' % (ifo, dq_flags)
        return

    triggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(xml_files)
    if triggers: 
        # keep those which are near the time
        inj_time = segments.segment(time - 0.1, time + 0.1)
        triggers = triggers.vetoed(inj_time)
        triggers = triggers.ifocut(ifo)
    if triggers and len(triggers):
        for trig in triggers:
            if ifo[0] == "H":
                print >>outfile, '    <td>%s</td><td>%.3f</td><td> - </td><td> - </td><td>%.2f</td><td>%.2f</td><td>%.2f</td><td>%.2f</td><td> - </td><td> - </td><td>%.2f</td><td>%s</td>' % (ifo, trig.get_end(), trig.mass1, trig.mass2, trig.mchirp, trig.eff_distance, trig.snr, dq_flags)
            print >>outfile, '  </tr>'
            if ifo[0] == "L":
                print >>outfile, '    <td>%s</td><td> - </td><td>%.3f</td><td> - </td><td>%.2f</td><td>%.2f</td><td>%.2f</td><td> - </td><td>%.2f</td><td> - </td><td>%.2f</td><td>%s</td>' % (ifo, trig.get_end(), trig.mass1, trig.mass2, trig.mchirp, trig.eff_distance, trig.snr, dq_flags)
            print >>outfile, '  </tr>'
            if ifo[0] == "V":
                print >>outfile, '    <td>%s</td><td> - </td><td> - </td><td>%.3f</td><td>%.2f</td><td>%.2f</td><td>%.2f</td><td> - </td><td> - </td><td>%.2f</td><td>%.2f</td><td>%s</td>' % (ifo, trig.get_end(), trig.mass1, trig.mass2, trig.mchirp, trig.eff_distance, trig.snr, dq_flags)
            print >>outfile, '  </tr>'

    else:
        print >>outfile, '  <tr valign="top" bgcolor="ff3333"><td>%s</td><td colspan="10">Not Found</td><td>%s</td></tr>' % (ifo, dq_flags)

    return
# =============================================================================
def write_page_long(opts,injections, ifos, filenames, hwinj_done):
    outfile=open(opts.outfile,'w')
    for inj in injections:
        if (inj.get_end("H") > opts.gps_start_time) and \
               (inj.get_end("H") < opts.gps_end_time): 
            print >>outfile, '<table border=1>'
            print >>outfile,'  <tr bgcolor="#9999ff"><th>ifo</th><th>H End Time</th><th>L End Time</th><th>V End Time</th><th>Mass 1</th><th>Mass 2</th><th>Chirp Mass</th><th>H Eff Dist</th><th>L Eff Dist</th><th>V Eff Dist</th><th>snr</th><th>DQ flags</th>'
            print >>outfile, '  <tr valign="top" bgcolor="ffdddd">'
            print >>outfile, '    <td></td><td>%.3f</td><td>%.3f</td><td>%.3f</td><td>%.2f</td><td>%.2f</td><td>%.2f</td><td>%.2f</td><td>%.2f</td><td>%.2f</td><td></td><td></td>' %  \
                  (inj.get_end("H"), inj.get_end("L"), inj.get_end("V"), 
                   inj.mass1, inj.mass2, inj.mchirp, inj.eff_dist_h, inj.eff_dist_l, 
                   inj.eff_dist_v) 

            for ifo in ifos:
                list_results(ifo, inj.get_end(ifo[0]), opts.segment_db, filenames,\
                             hwinj_done,outfile)
    
            print >>outfile, '</table>'
            print >>outfile, '<p>'
    return
# =============================================================================
def write_page_short(opts,injections,ifos,filenames,hwinj_done):
	"""
	Generate the short page
	"""
	outfile=open(opts.outfile,'w')
	print >>outfile, '<html><head><title>Hardware injection summary: '+str(opts.gps_start_time)+' - '+str(opts.gps_end_time)+\
			'</title></head><body><table border=1><tr bgcolor="#9999ff"><th>GPS end time</th><th>Mass 1</th><th>Mass 2</th><th>Distance (Mpc)</th>'
	totalinj={}
	totalfound={}
	totalanalysed={}
	statelist={}
	# Write table header
	for ifo in ifos:
		print >>outfile, '<th>'+ifo+'</th>'
		totalinj[ifo]=0
		totalfound[ifo]=0
		totalanalysed[ifo]=0
		statelist[ifo]=[]
	# Write table contents
	for inj in injections:
		if(int(inj.get_end("H")) < opts.gps_start_time or int(inj.get_end("H")) > opts.gps_end_time):
			print 'skipping %d'%(inj.get_end("H"))
			continue
		print 'processing '+str(inj.get_end("H"))	
		print >>outfile,'<tr><td>%.3f</td>' % (inj.geocent_end_time)
		print >>outfile,'<td>%.3f</td><td>%.3f</td><td>%.3f</td>'% (inj.mass1,inj.mass2,inj.distance)
		for ifo in ifos:
			(injected,analysed,found)=check_ifo_result(ifo,inj.get_end(ifo[0]),filenames,hwinj_done)
			print >>outfile,get_ifo_result_string((injected,analysed,found))
			totalinj[ifo]=totalinj[ifo]+injected
			totalanalysed[ifo]=totalanalysed[ifo]+analysed
			totalfound[ifo]=totalfound[ifo]+found
			statelist[ifo].append((inj.get_end(ifo[0]),inj,injected,analysed,found))
		print >>outfile,'</tr>'
	print >>outfile,'<tr><td bgcolor=#9999ff colspan=4>Recovered /Analysed / Injected</td>'
	for ifo in ifos:
		print >>outfile,'<td>%i / %i / %i</td>'%(totalfound[ifo],totalanalysed[ifo],totalinj[ifo])
	print >>outfile,'</tr>'
	print >>outfile,'</table>'
	
	# Generate plot for injections
	import pylab
	for ifo in ifos:
		foundx=[]
		foundy=[]
		missedx=[]
		missedy=[]
		nax=[]
		nay=[]
		thisplot=pylab.figure()
#		for tup in statelist[ifo]:
#			if tup[2]:
#				if tup[4]==1: # plot a found
#					print 'Add a found'
#					foundx.append(int(tup[0]))
#					foundy.append(chirp_dist(tup[1],ifo))
#				elif tup[3]: 
#					print 'Add a missed'
#					missedx.append(int(tup[0]))
#					missedy.append(chirp_dist(tup[1],ifo))
#				else:
#					print 'Not analysed'
#					nax.append(int(tup[0]))
#					nay.append(chirp_dist(tup[1],ifo))
		def isBNS(tup):
			return tup[1].mass1<2.0 and tup[1].mass2<2.0
		def isNSBH(tup):
			return (tup[1].mass1<2.0 and tup[1].mass2>2.0) or (tup[1].mass2<2.0 and tup[1].mass1>2.0)
		def isBBH(tup):
			return (tup[1].mass1>2.0 and tup[1].mass2>2.0)
		# Plot BNS
		for (filt,symb,injtype) in zip((isBNS,isNSBH,isBBH) , ('+','x','o'),('BNS','NSBH','BBH')):
			results=filter(filt,statelist[ifo])
			print (filt,symb,injtype)
			if results is not None:
				(foundx,foundy)=(map(lambda i: int(i[0]), filter(lambda tup: tup[4]==1,results)),map(lambda i: chirp_dist(i[1].ifo),filter(lambda tup: tup[4]==1,results)))
				(missedx,missedy)=(map(lambda i: int(i[0]), filter(lambda tup: tup[4]==1,results)),map(lambda i: chirp_dist(i[1].ifo),filter(lambda tup: tup[4]!=1 and tup[3],results)))
				(nax,nay)=(map(lambda i: int(i[0]), filter(lambda tup: tup[4]==1,results)),map(lambda i: chirp_dist(i[1].ifo),filter(lambda tup: tup[4]!=1 and not tup[3],results)))

			pylab.plot(foundx,foundy,'g'+'symb',label='Found '+injtype)
			thisplot.hold()
			pylab.plot(missedx,missedy,'r'+'symb',label='Missed '+injtype)
			pylab.plot(nax,nay,'y'+'symb',label='Not Analysed '+injtype)
		thisplot.gca().set_xbound(int(opts.gps_start_time),int(opts.gps_end_time))
		thisplot.gca().set_ybound(0,100)
		pylab.title(ifo+' Hardware injections '+ opts.gps_start_time+' - '+opts.gps_end_time)
		pylab.xlabel('GPS time')
		pylab.ylabel('Chirp Distance (Mpc)')
		pylab.legend()
		pylab.grid(b=True)
		# save figure
		print 'save figure'
		plotname=os.path.splitext(opts.outfile)[0]+'_'+str(ifo)+'.png'
		thisplot.savefig(plotname)
		print >>outfile,'<img src="'+plotname+'">'
	print >>outfile,'</body></html>'
	return

# =============================================================================
# Main program begins here
# =============================================================================

usage = """ %prog [options]
Program to parse the inspiral injection log
"""

parser = OptionParser( usage )
parser.add_option("-D","--dq",action="store_true",dest="long_page",default=False,help="Poll DQ flags for each injection and write long page")
parser.add_option("-o","--outfile",action="store",type="string",\
                  metavar="FILE.html",help="Filename for output page")
parser.add_option("-t","--gps-start-time",action="store",type="int",\
    default=924600000, metavar="START",
    help="start of GPS time range (default = 924600000)" )

parser.add_option("-e","--gps-end-time",action="store",type="int",\
    default=999999999, metavar="END",
    help="end of GPS time range (default = 999999999)")

parser.add_option("-i","--h1-injections",action="store_true",\
    default=False, help="look at H1 injections")

parser.add_option("-l","--l1-injections",action="store_true",\
    default=False, help="look at L1 injections")

parser.add_option("-v","--v1-injections",action="store_true",\
    default=False, help="look at V1 injections")

parser.add_option("-x","--source-xml",action="store",type="string",\
    metavar="IN_XML", help="input xml file of injections" )

parser.add_option("-s", "--segment-db", metavar = "segment_url", \
    default = "ldbd://segdb.ligo.caltech.edu:30015", \
    help = "URL pointing to segment database") 

parser.add_option("-d","--trig-dir", action="store",\
    type="string",default="/archive/home/cbc/mbta/triggers", help="Directory contianing trigger files",metavar="TRIG_DIR")

opts,args  = parser.parse_args()
if opts.outfile is None:
        parser.error("Please specify an output file using the -o option")

filenames = segmentdb_utils.get_all_files_in_range(opts.trig_dir, opts.gps_start_time, opts.gps_end_time)

# =============================================================================
ifos = []
hwinj_done = {}
if opts.h1_injections:
    ifos.append("H1")

if opts.l1_injections:
    ifos.append("L1")

if opts.v1_injections:
    ifos.append("V1")

if ifos == []:
    print >>sys.stderr, "Must specify an ifo"
    sys.exit(1)

# =============================================================================
# Work out times of injections
hwinj_done = {}

for ifo in ifos:
    # set the segment name
    if ifo == "V1":
        seg_name = "INJECTION_INSPIRAL"
    else:
        seg_name = "DMT-INJECTION_INSPIRAL"
    # query for segments
    out_xml = "-".join([ifo,"inj_times.xml"])
    out_txt = "-".join([ifo,"inj_times.txt"])
    retcode = subprocess.call(["ligolw_segment_query", "--database", \
        "--query-segments", "--gps-start-time", str(opts.gps_start_time), \
        "--gps-end-time", str(opts.gps_end_time), \
        "--output-file", out_xml, \
        "--include-segments", ":".join([ifo,seg_name]), \
        "--segment-url", opts.segment_db] )
    if retcode != 0:
        print >>sys.stderr, "Segment call failed."
        sys.exit(1)
    x = subprocess.Popen(["ligolw_print", "-t", "segment", "-c", "start_time",
        "-c", "end_time", "-d" " ", out_xml], stdout=subprocess.PIPE)
    retcode = x.wait()
    if retcode != 0:
        print >>sys.stderr, "Segment call failed."
        sys.xit(1)

    hwinj_done[ifo] = segmentsUtils.fromsegwizard(x.stdout.readlines())

# =============================================================================
# Read in the injections
injections = SimInspiralUtils.ReadSimInspiralFromFiles([opts.source_xml])

if(opts.long_page): write_page_long(opts,injections,ifos,filenames,hwinj_done)
else:	write_page_short(opts,injections,ifos,filenames,hwinj_done)

