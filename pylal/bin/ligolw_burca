#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

from optparse import OptionParser
import sys

from pylal import ligolw_burca
from pylal import llwapp
from pylal import snglcoinc
from pylal import SnglBurstUtils
from pylal.date import LIGOTimeGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version = "%prog CVS $Id$")
	parser.add_option("--comment", metavar = "text", default = "", help = "set comment string in process table")
	parser.add_option("-f", "--force", action = "store_true", help = "process even if file has already been processed")
	parser.add_option("-p", "--program", metavar = "name", default = "power", help = "set the name of the program that generated the events as it appears in the process table (default = power)")
	parser.add_option("-w", "--window", metavar = "inst1,inst2=seconds", action = "append", default = [], help = "set the time coincidence window for an instrument pair")
	parser.add_option("-s", "--string-compare", metavar = "kappa,epsilon", help = "use the string search coincidence test with H1+H2 kappa and epsilon parameters as given (hint:  try 3.0,0.5)")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	# construct (inst_a, inst_b) --> delta t mappings
	try:
		options.window = snglcoinc.parse_thresholds(options.window)
		for key, value in options.window.iteritems():
			options.window[key] = LIGOTimeGPS(value)
	except ValueError, e:
		raise ValueError, "error parsing --window: %s" % str(e)

	if options.string_compare:
		try:
			options.string_compare = map(float, options.string_compare.split(","))
		except ValueError, e:
			raise ValueError, "error parsing --string-compare: %s" % str(e)
		# construct (inst_a, inst_b) --> (delta t, kappa, epsilon)
		# mappings
		for key, value in options.window.iteritems():
			options.window[key] = (value, options.string_compare[0], options.string_compare[1])

	return options, (filenames or [None])


#
# =============================================================================
#
#                             Coincidence Criteria
#
# =============================================================================
#

def StringCoincCompare(a, b, thresholds):
	"""
	Returns False (a & b are coincident) if their peak times agree
	within dt, and in the case of H1+H2 pairs if their amplitudes agree
	according to some kinda test.
	"""
	dt, kappa, epsilon = thresholds
	result = not (a.get_peak() - dt <= b.get_peak() <= a.get_peak() + dt)
	if a.ifo in ("H1", "H2") and b.ifo in ("H1", "H2"):
		adelta = math.abs(a.amplitude) * (kappa / a.snr + epsilon)
		bdelta = math.abs(b.amplitude) * (kappa / b.snr + epsilon)
		result |= not (a.amplitude - adelta <= b.amplitude <= a.amplitude + adelta or b.amplitude - bdelta <= a.amplitude <= b.amplitude + bdelta)
	return result


def ExcessPowerCoincCompare(a, b, dt):
	"""
	Returns False (a & b are coincident) if a's peak time lies within
	b's time interval and vice versa and the two events' frequency
	bands intersect or touch.  Returns non-zero otherwise.
	"""
	return b.get_peak() not in a.get_period().protract(dt) or a.get_peak() not in b.get_period().protract(dt) or SnglBurstUtils.cmp_segs(a.get_band(), b.get_band())


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

try:
	options, filenames = parse_command_line()
except ValueError, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)

if options.string_compare:
	snglcoinc.EventListDict.EventListType = ligolw_burca.StringEventList
	snglcoinc.CompareFunc = StringCoincCompare
else:
	snglcoinc.EventListDict.EventListType = ligolw_burca.ExcessPowerEventList
	snglcoinc.CompareFunc = ExcessPowerCoincCompare


for n, filename in enumerate(llwapp.sort_files_by_size(filenames, options.verbose)):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	xmldoc = llwapp.load_filename(filename, options.verbose, gz = filename[-3:] == ".gz")
	if llwapp.doc_includes_process(xmldoc, "ligolw_burca"):
		if options.verbose:
			print >>sys.stderr, "warning: %s already processed," % (filename or "stdin"),
		if not options.force:
			if options.verbose:
				print >>sys.stderr, "skipping"
			continue
		if options.verbose:
			print >>sys.stderr, "continuing"
	ligolw_burca.ligolw_burca(xmldoc, **options.__dict__)
	llwapp.write_filename(xmldoc, filename, options.verbose, gz = filename[-3:] == ".gz")
	xmldoc.unlink()
