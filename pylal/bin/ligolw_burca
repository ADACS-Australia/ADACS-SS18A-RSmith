#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import bisect
from optparse import OptionParser
import sys

from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import docutils
from pylal import llwapp
from pylal import SnglBurstUtils
from pylal.date import LIGOTimeGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

parser = OptionParser(version = "%prog CVS $Id$")
parser.add_option("--comment", metavar = "text", default = "", help = "set comment string in process table")
parser.add_option("-i", "--input", metavar = "filename", help = "read from filename (default = stdin)")
parser.add_option("-o", "--output", metavar = "filename", help = "write to filename (default = stdout)")
parser.add_option("-w", "--window", metavar = "inst1,inst2=seconds", action = "append", default = [], help = "set the coincidence window for an instrument pair")
parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
options = parser.parse_args()[0]
del parser


def parse_windows(windows):
	parsed_windows = {}
	for [pair, delay] in map(lambda w: str.split(w, "="), windows):
		pair = pair.split(",")
		pair.sort()
		pair = tuple(pair)
		if len(pair) != 2:
			raise ValueError, "incorrect number of instruments"
		if pair in parsed_windows.keys():
			raise ValueError, "duplicate instrument pair"
		parsed_windows[pair] = LIGOTimeGPS(delay)
	return parsed_windows

try:
	options.window = parse_windows(options.window)
except ValueError, e:
	print >>sys.stdrer, "error parsing --window: %s" % str(e)
	sys.exit(1)


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

doc = ligolw.Document()
if options.input:
	ligolw.make_parser(lsctables.LIGOLWContentHandler(doc)).parse(file(options.input))
else:
	ligolw.make_parser(lsctables.LIGOLWContentHandler(doc)).parse(sys.stdin)


#
# =============================================================================
#
#                                 Preparation
#
# =============================================================================
#

try:
	snglbursttable = llwapp.get_table(doc, lsctables.SnglBurstTable.tableName)
	tisitable = llwapp.get_table(doc, lsctables.TimeSlideTable.tableName)
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)
for row in tisitable:
	row.offset = LIGOTimeGPS(row.offset)

try:
	coinctable = llwapp.get_table(doc, lsctables.CoincTable.tableName)
except ValueError:
	coinctable = lsctables.New(lsctables.CoincTable)
	doc.childNodes[0].appendChild(coinctable)
coincids = docutils.NewILWDs(coinctable, "coinc_event_id")

try:
	coincmaptable = llwapp.get_table(doc, lsctables.CoincMapTable.tableName)
except ValueError:
	coincmaptable = lsctables.New(lsctables.CoincMapTable, columns = ["coinc_event_id", "event_id"])
	doc.childNodes[0].appendChild(coincmaptable)


#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#

process = llwapp.append_process(doc, program = "ligolw_burca", version = __version__, cvs_repository = "lscsoft", cvs_entry_time = __date__, comment = options.comment)

params = []
if options.input != None:
	params += [("--input", "lstring", options.input)]
if options.output != None:
	params += [("--output", "lstring", options.output)]
maxwindow = LIGOTimeGPS(0)
for key, value in options.window.iteritems():
	if value > maxwindow:
		maxwindow = value
	params += [("--window", "lstring", "%s,%s=%s" % (key[0], key[1], str(value)))]
llwapp.append_process_params(doc, process, params)


#
# =============================================================================
#
#              Copy Trigger References Into Per-Instrument Lists
#
# =============================================================================
#

class TriggerList(object):
	def __init__(self, instrument):
		self.instrument = instrument
		self.triggers = []
		self.maxduration = LIGOTimeGPS(0)

	def append(self, trigger):
		if trigger.duration > self.maxduration:
			self.maxduration = LIGOTimeGPS(trigger.duration)
		self.triggers.append(trigger)

	def mkindex(self):
		self.triggers.sort(lambda a, b: cmp(a.get_stop(), b.get_stop()))
		self.start_times = [LIGOTimeGPS(row.get_start()) for row in self.triggers]
		self.stop_times = [LIGOTimeGPS(row.get_stop()) for row in self.triggers]

	def intersects(self, t, dt):
		"""
		Return a list of the triggers whose time intervals
		intersect t +/- dt.
		"""
		l = []
		for i in xrange(bisect.bisect_left(self.stop_times, t - dt), bisect.bisect_right(self.stop_times, t + dt + self.maxduration)):
			if self.start_times[i] <= t + dt:
				l.append(self.triggers[i])
		return l


def construct_trigger_lists(table):
	lists = {}
	for row in table:
		if row.ifo not in lists:
			lists[row.ifo] = TriggerList(row.ifo)
		lists[row.ifo].append(row)
	map(TriggerList.mkindex, lists.values())
	return lists.values()

triggerlists = construct_trigger_lists(snglbursttable)
triggerlists.sort(lambda a, b: cmp(a.instrument, b.instrument))


#
# =============================================================================
#
#                         Iterate Over Multiple Lists
#
# =============================================================================
#

class MultiIter(object):
	def __init__(self, lists):
		self.lists = lists
		self.index = [0] * len(lists)
		self.length = map(len, lists)
		self.stop = 0 in self.length

	def __iter__(self):
		return self

	def next(self):
		if self.stop:
			raise StopIteration
		l = map(lambda l, i: l[i], self.lists, self.index)
		for i in xrange(len(self.index)):
			self.index[i] += 1
			if self.index[i] < self.length[i]:
				break
			self.index[i] = 0
		else:
			self.stop = True
		return l


#
# =============================================================================
#
#                          Build Trigger Coincidences
#
# =============================================================================
#

def append_coinc(tisi_id, trigs):
	coinc = lsctables.Coinc()
	coinc.process_id = process.process_id
	coinc.coinc_event_id = coincids.next()
	coinc.time_slide_id = tisi_id
	coinctable.append(coinc)
	for trig in trigs:
		coincmap = lsctables.CoincMap()
		coincmap.coinc_event_id = coinc.coinc_event_id
		coincmap.event_id = trig.event_id
		coincmaptable.append(coincmap)


def are_coincident(trigs, offsets, windows):
	"""
	Return True if the triggers are all mutually coincident.  Requires
	trigs to be sorted by IFO.
	"""
	try:
		for [a, b] in SnglBurstUtils.choices(trigs, 2):
			if SnglBurstUtils.CompareSnglBurst(a, b, offsets[a.ifo], offsets[b.ifo], windows[(a.ifo, b.ifo)]):
				return False
	except KeyError, e:
		raise KeyError, "no coincidence window provided for instrument pair %s" % str(e)
	return True


def find_n_tuples(trigger_lists, offsets, windows, tisi_id):
	for n, (trig, start) in enumerate(zip(trigger_lists[0].triggers, trigger_lists[0].start_times)):
		if not (n % 1024):
			if options.verbose:
				print >>sys.stderr, "\t%.1f%%\r" % (100.0 * (n + 1) / len(trigger_lists[0].triggers)),
		for l in MultiIter([[trig]] + map(lambda l: l.intersects(start + trig.duration / 2 + offsets[trig.ifo] - offsets[l.instrument], maxwindow + trig.duration / 2), trigger_lists[1:])):
			if are_coincident(l, offsets, windows):
				append_coinc(tisi_id, l)
	if options.verbose:
		print >>sys.stderr, "\t100.0%"


tisiids = tisitable.dict.keys()
for n, tisi_id in enumerate(tisiids):
	offsets = tisitable.get_offset_dict(tisi_id)
	if options.verbose:
		print >>sys.stderr, "time slide %d/%d: %s" % (n + 1, len(tisiids), str(offsets))
	try:
		find_n_tuples([l for l in triggerlists if l.instrument in offsets], offsets, options.window, tisi_id)
	except Exception, e:
		print >>sys.stderr, "error: %s" % str(e)
		sys.exit(1)


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

llwapp.set_process_end_time(process)

if options.output:
	doc.write(file(options.output, "w"))
else:
	doc.write(sys.stdout)
