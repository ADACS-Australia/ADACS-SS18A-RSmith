#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import bisect
from optparse import OptionParser
import sys

from glue import segments
from glue.ligolw import lsctables
from glue.ligolw import docutils
from pylal import llwapp
from pylal import SnglBurstUtils
from pylal.date import LIGOTimeGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_windows(windows):
	parsed_windows = {}
	for [pair, delay] in map(lambda w: str.split(w, "="), windows):
		pair = pair.split(",")
		pair.sort()
		pair = tuple(pair)
		if len(pair) != 2:
			raise ValueError, "incorrect number of instruments"
		if pair in parsed_windows.keys():
			raise ValueError, "duplicate instrument pair"
		parsed_windows[pair] = LIGOTimeGPS(delay)
	return parsed_windows


def parse_command_line():
	parser = OptionParser(version = "%prog CVS $Id$")
	parser.add_option("--comment", metavar = "text", default = "", help = "set comment string in process table")
	parser.add_option("-i", "--input", metavar = "filename", help = "read from filename (default = stdin)")
	parser.add_option("-o", "--output", metavar = "filename", help = "write to filename (default = stdout)")
	parser.add_option("-w", "--window", metavar = "inst1,inst2=seconds", action = "append", default = [], help = "set the coincidence window for an instrument pair")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	if not len(filenames):
		filenames = [None]

	try:
		options.window = parse_windows(options.window)
	except ValueError, e:
		raise ValueError, "error parsing --window: %s" % str(e)
	options.maxwindow = LIGOTimeGPS(0)
	for dt in options.window.itervalues():
		if dt > options.maxwindow:
			options.maxwindow = dt

	return options, filenames

try:
	options, filenames = parse_command_line()
except ValueError, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)


#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#

def append_process(doc, options):
	process = llwapp.append_process(doc, program = "ligolw_burca", version = __version__, cvs_repository = "lscsoft", cvs_entry_time = __date__, comment = options.comment)

	params = []
	for key, value in options.window.iteritems():
		params += [("--window", "lstring", "%s,%s=%s" % (key[0], key[1], str(value)))]
	llwapp.append_process_params(doc, process, params)

	return process


#
# =============================================================================
#
#                                Process Filter
#
# =============================================================================
#

def segment_increment(seg, delta):
	"""
	Add delta to the upper and lower bounds of seg.
	"""
	return segments.segment(seg[0] + delta, seg[1] + delta)


def ss_coinc_segs(searchsummtable, offsetdict):
	"""
	From the instrument/offset pairs in offsetdict, construct the
	corresponding coincident segment list from the output segments in
	the search summary table.
	"""
	seglists = {}
	for row in searchsummtable:
		seglist = segments.segmentlist([segment_increment(row.get_out(), offsetdict[row.ifos])])
		if row.ifos in seglists:
			seglists[row.ifos] |= seglist
		else:
			seglists[row.ifos] = seglist
	return reduce(segments.segmentlist.__and__, seglists.itervalues())


#
# =============================================================================
#
#                            Trigger List Interface
#
# =============================================================================
#

class TriggerList(object):
	"""
	A class for retrieving subsets of a trigger list by time interval.
	"""
	def __init__(self, instrument):
		self.instrument = instrument
		self.triggers = []

	def append(self, trigger):
		self.triggers.append(trigger)

	def mkindex(self):
		self.triggers.sort(lambda a, b: cmp(a.get_stop(), b.get_stop()))
		self.start_times = [LIGOTimeGPS(row.get_start()) for row in self.triggers]
		self.stop_times = [LIGOTimeGPS(row.get_stop()) for row in self.triggers]
		self.maxduration = max(map(lambda stop, start: stop - start, self.stop_times, self.start_times))

	def intersects(self, t, dt):
		"""
		Return a list of the triggers whose time intervals
		intersect t +/- dt.
		"""
		return [self.triggers[i] for i in xrange(bisect.bisect_left(self.stop_times, t - dt), bisect.bisect_right(self.stop_times, t + dt + self.maxduration)) if self.start_times[i] <= t + dt]


def construct_trigger_lists(table, procids):
	lists = {}
	for row in table:
		if not llwapp.bisect_contains(procids, row.process_id):
			continue
		instrument = row.ifo
		if instrument not in lists:
			lists[instrument] = TriggerList(instrument)
		lists[instrument].append(row)
	map(TriggerList.mkindex, lists.values())
	return lists


#
# =============================================================================
#
#                              Document Interface
#
# =============================================================================
#

class Document(object):
	"""
	A wrapper interface to the XML document.
	"""
	def __init__(self, doc, process):
		"""
		Initialize the document interface.  If coinc and coincmap
		tables are not found in doc, they are appended to it.
		"""
		self.process = process
		self.tisitable = llwapp.get_table(doc, lsctables.TimeSlideTable.tableName)
		self.searchsummtable = llwapp.get_table(doc, lsctables.SearchSummaryTable.tableName)
		self.triggerlists = construct_trigger_lists(llwapp.get_table(doc, lsctables.SnglBurstTable.tableName), self.get_coinc_procids())
		for row in self.tisitable:
			row.offset = LIGOTimeGPS(row.offset)

		try:
			self.coinctable = llwapp.get_table(doc, lsctables.CoincTable.tableName)
		except ValueError:
			self.coinctable = lsctables.New(lsctables.CoincTable)
			doc.childNodes[0].appendChild(self.coinctable)
		self.coincids = docutils.NewILWDs(self.coinctable, "coinc_event_id")

		try:
			self.coincmaptable = llwapp.get_table(doc, lsctables.CoincMapTable.tableName)
		except ValueError:
			self.coincmaptable = lsctables.New(lsctables.CoincMapTable, columns = ["coinc_event_id", "event_id"])
			doc.childNodes[0].appendChild(self.coincmaptable)

	def get_tisi_ids(self):
		"""
		Return a list of the time slide IDs in this document.
		"""
		return self.tisitable.dict.keys()

	def get_offsetdict(self, tisi_id):
		"""
		Return the dictionary of instrument/offset pairs for time
		slide ID tisi_id.
		"""
		return self.tisitable.get_offset_dict(tisi_id)

	def get_triglists(self, instruments):
		"""
		Return the list of TriggerList objects corresponding to the
		given instruments.
		"""
		return map(self.triggerlists.__getitem__, instruments)

	def get_coinc_procids(self):
		"""
		Return a list of the process IDs in this document
		participating in the coincidence analysis.
		"""
		ids = []
		for offsetdict in map(self.get_offsetdict, self.get_tisi_ids()):
			seglist = ss_coinc_segs(self.searchsummtable, offsetdict)
			for row in self.searchsummtable:
				if (segments.segmentlist([segment_increment(row.get_out(), offsetdict[row.ifos])]) & seglist) and not llwapp.bisect_contains(ids, row.process_id):
					bisect.insort_left(ids, row.process_id)
		return ids

	def append_coinc(self, tisi_id, trigs):
		"""
		Takes a time slide ID and a list of triggers, and adds the
		triggers as a new coincidence to the coinc and coincmap
		tables
		"""
		coinc = lsctables.Coinc()
		coinc.process_id = self.process.process_id
		coinc.coinc_event_id = self.coincids.next()
		coinc.time_slide_id = tisi_id
		coinc.nevents = len(trigs)
		self.coinctable.append(coinc)
		for trig in trigs:
			coincmap = lsctables.CoincMap()
			coincmap.coinc_event_id = coinc.coinc_event_id
			coincmap.event_id = trig.event_id
			self.coincmaptable.append(coincmap)


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

doc = llwapp.load_filename(options.input, options.verbose)


#
# =============================================================================
#
#                                 Preparation
#
# =============================================================================
#

if options.verbose:
	print >>sys.stderr, "preparing metadata..."
try:
	process = append_process(doc, options)
	document = Document(doc, process)
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)


#
# =============================================================================
#
#                               Iteration Tools
#
# =============================================================================
#

class MultiIter(object):
	"""
	An iterator class for iterating over the elements of multiple lists
	simultaneously.  An instance of the class is initialized with a
	list of lists.  A call to next() returns a list of elements, one
	from each of the lists.  Subsequent calls next() iterate over all
	combinations of elements from the lists.
	"""
	def __init__(self, lists):
		self.lists = tuple(lists)
		self.index = [0] * len(lists)
		self.length = tuple(map(len, lists))
		self.stop = 0 in self.length

	def __len__(self):
		return reduce(int.__mul__, self.length)

	def __iter__(self):
		return self

	def next(self):
		if self.stop:
			raise StopIteration
		l = map(lambda l, i: l[i], self.lists, self.index)
		for i in xrange(len(self.index)):
			self.index[i] += 1
			if self.index[i] < self.length[i]:
				break
			self.index[i] = 0
		else:
			self.stop = True
		return l


def choices(vals, n):
	"""
	Return a list of all choices of n elements from the list vals.
	"""
	if n < 1:
		raise ValueError, n
	if n == 1:
		return [[v] for v in vals]
	if n == len(vals):
		return [vals]
	l = []
	for i in range(len(vals) - n + 1):
		for c in choices(vals[i+1:], n - 1):
			c[0:0] = [vals[i]]
			l.append(c)
	return l


#
# =============================================================================
#
#                             Level 1 Coincidence
#
# =============================================================================
#

class Level1Iterator(object):
	"""
	Performs a coarse coincidence cut, generating a sequence of
	MultiIter objects for iterating over sets of surviving n-tuples.
	"""
	def __init__(self, triggerlists, offsetdict, maxwindow):
		triggerlists.sort(lambda a, b: cmp(a.instrument, b.instrument))
		self.len = len(triggerlists[0].triggers)
		self.trigiter = iter(triggerlists[0].triggers)
		self.startiter = iter(triggerlists[0].start_times)
		self.triggerlists = triggerlists[1:]
		self.offsetdict = offsetdict
		self.maxwindow = maxwindow

	def __len__(self):
		return self.len

	def __iter__(self):
		return self

	def next(self):
		trig = self.trigiter.next()
		start = self.startiter.next()
		return MultiIter([[trig]] + map(lambda l: l.intersects(start + trig.duration / 2 + self.offsetdict[trig.ifo] - self.offsetdict[l.instrument], self.maxwindow + trig.duration / 2), self.triggerlists))


#
# =============================================================================
#
#                             Level 2 Coincidence
#
# =============================================================================
#

Level2Test = SnglBurstUtils.CompareSnglBurst

def coincident(trigs, offsetdict, windows):
	"""
	Return True if the triggers are all mutually coincident in the
	context of the offsets in offsetdict.  Requires trigs to be sorted
	by instrument.
	"""
	try:
		for [a, b] in choices(trigs, 2):
			a_inst = a.ifo
			b_inst = b.ifo
			if Level2Test(a, b, offsetdict[a_inst], offsetdict[b_inst], windows[(a_inst, b_inst)]):
				return False
	except KeyError, e:
		raise KeyError, "no coincidence window provided for instrument pair %s" % str(e)
	return True


#
# =============================================================================
#
#                          Build Trigger Coincidences
#
# =============================================================================
#

def find_coincident_ntuples(document, offsetdict, windows, tisi_id):
	level1iterator = Level1Iterator(document.get_triglists(offsetdict.keys()), offsetdict, options.maxwindow)
	for n, ntuples in enumerate(level1iterator):
		if not (n % 1024):
			if options.verbose:
				print >>sys.stderr, "\t%.1f%%\r" % (100.0 * (n + 1) / len(level1iterator)),
		for ntuple in ntuples:
			if coincident(ntuple, offsetdict, windows):
				document.append_coinc(tisi_id, ntuple)
	if options.verbose:
		print >>sys.stderr, "\t100.0%"


def find_coincidences(document, windows):
	tisiids = document.get_tisi_ids()
	for n, tisi_id in enumerate(tisiids):
		offsetdict = document.get_offsetdict(tisi_id)
		if options.verbose:
			print >>sys.stderr, "time slide %d/%d: %s" % (n + 1, len(tisiids), str(offsetdict))
		find_coincident_ntuples(document, offsetdict, windows, tisi_id)


try:
	find_coincidences(document, options.window)
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

llwapp.set_process_end_time(process)

llwapp.write_filename(doc, options.output, options.verbose)
