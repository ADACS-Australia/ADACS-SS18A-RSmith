#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import bisect
from optparse import OptionParser
import sys

from glue import segments
from glue.ligolw import lsctables
from glue.ligolw import docutils
from pylal import llwapp
from pylal import SnglBurstUtils
from pylal.date import LIGOTimeGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                               Iteration Tools
#
# =============================================================================
#

class MultiIter(object):
	"""
	An iterator class for iterating over the elements of multiple lists
	simultaneously.  An instance of the class is initialized with a
	list of lists.  A call to next() returns a list of elements, one
	from each of the lists.  Subsequent calls to next() iterate over
	all combinations of elements from the lists.
	"""
	def __init__(self, lists):
		self.lists = tuple(lists)
		self.index = [0] * len(lists)
		self.length = tuple(map(len, lists))
		self.stop = 0 in self.length

	def __len__(self):
		return reduce(int.__mul__, self.length)

	def __iter__(self):
		return self

	def next(self):
		if self.stop:
			raise StopIteration
		l = map(lambda l, i: l[i], self.lists, self.index)
		for i in xrange(len(self.index)):
			self.index[i] += 1
			if self.index[i] < self.length[i]:
				break
			self.index[i] = 0
		else:
			self.stop = True
		return l


def choices(vals, n):
	"""
	Return a list of all choices of n elements from the list vals.
	Order is preserved.
	"""
	if n == len(vals):
		return [vals]
	if n == 1:
		return [[v] for v in vals]
	if n < 1:
		raise ValueError, n
	l = []
	for i in xrange(len(vals) - n + 1):
		for c in choices(vals[i+1:], n - 1):
			c.insert(0, vals[i])
			l.append(c)
	return l


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_windows(windowstrings):
	"""
	Turn a list of strings of the form "inst1,inst2=delta" into a
	dictionary with (inst1, inst2) 2-tuples as keys and the deltas as
	the values.  The instruments in the 2-tuples are sorted.
	"""
	windows = {}
	for [pair, delay] in map(lambda w: str.split(w, "="), windowstrings):
		pair = pair.split(",")
		pair.sort()
		pair = tuple(pair)
		if len(pair) != 2:
			raise ValueError, "incorrect number of instruments"
		if pair in windows.keys():
			raise ValueError, "duplicate instrument pair"
		windows[pair] = LIGOTimeGPS(delay)
	return windows


def parse_command_line():
	parser = OptionParser(version = "%prog CVS $Id$")
	parser.add_option("--comment", metavar = "text", default = "", help = "set comment string in process table")
	parser.add_option("-f", "--force", action = "store_true", help = "process even if file has already been processed")
	parser.add_option("-w", "--window", metavar = "inst1,inst2=seconds", action = "append", default = [], help = "set the coincidence window for an instrument pair")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	try:
		options.window = parse_windows(options.window)
	except ValueError, e:
		raise ValueError, "error parsing --window: %s" % str(e)

	return options, (filenames or [None])


#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#

def append_process(doc, **kwargs):
	process = llwapp.append_process(doc, program = "ligolw_burca", version = __version__, cvs_repository = "lscsoft", cvs_entry_time = __date__, comment = kwargs["comment"])

	params = []
	for key, value in kwargs["window"].iteritems():
		params += [("--window", "lstring", "%s,%s=%s" % (key[0], key[1], str(value)))]
	llwapp.append_process_params(doc, process, params)

	return process


#
# =============================================================================
#
#                     Process Filter (Level 0 Coincidence)
#
# =============================================================================
#

class SegListDict(dict):
	"""
	A dictionary of segmentlist objects constructed from a search
	summary table, with the ability to apply offsets to the segment
	lists.
	"""
	def __new__(cls, searchsummtable):
		"""
		Construct a new SegListDict object from the contents of a
		search summary table.  The result is dictionary-like object
		whose keys are the instrument names appearing in the search
		summary table, and whose values are segmentlist
		representations of the times spanned by the rows.
		"""
		seglists = dict.__new__(cls, None)
		for row in searchsummtable:
			if row.ifos in seglists:
				seglists[row.ifos].append(row.get_out())
			else:
				seglists[row.ifos] = segments.segmentlist([row.get_out()])
		for seglist in seglists.itervalues():
			seglist.coalesce()
		return seglists

	def __init__(self, *args):
		self.offsets = {}
		for instrument in self.iterkeys():
			self.offsets[instrument] = LIGOTimeGPS(0)

	def set_offsets(self, offsetdict):
		"""
		Shift the segment lists according to the instrument/offset
		pairs in offsetdict.
		"""
		for instrument, offset in offsetdict.iteritems():
			delta = offset - self.offsets[instrument]
			if delta != 0:
				self[instrument] = self[instrument].shift(delta)
				self.offsets[instrument] += delta
		return self

	def remove_offsets(self):
		"""
		Remove the offsets from all segmentlists.
		"""
		for instrument, offset in self.offsets.iteritems():
			if offset:
				self[instrument] = self[instrument].shift(-offset)
				self.offsets[instrument] = LIGOTimeGPS(0)
		return self

	def protract(self, x):
		"""
		Protract the segmentlists.
		"""
		for key in self.iterkeys():
			self[key] = self[key].protract(x)
		return self

	def intersect(self, instruments):
		"""
		Return the intersection of the segmentlists for the
		instruments in instruments.
		"""
		return reduce(segments.segmentlist.__and__, map(self.__getitem__, instruments))


def coinc_procids(doccontents):
	"""
	Take a DocContents object and return a list of the process IDs that
	will participate in any coincidence identified by the time slide
	table.
	"""
	try:
		halfmaxwindow = max(doccontents.windows.itervalues()) / 2
	except:
		halfmaxwindow = LIGOTimeGPS(0)
	seglists = SegListDict(doccontents.searchsummtable).protract(halfmaxwindow)
	ids = []
	for offsetdict in map(doccontents.get_offsetdict, doccontents.get_tisi_ids()):
		seglist = seglists.set_offsets(offsetdict).intersect(offsetdict.keys())
		for row in doccontents.searchsummtable:
			if seglist.intersects_segment(row.get_out().protract(halfmaxwindow).shift(offsetdict[row.ifos])) and not llwapp.bisect_contains(ids, row.process_id):
				bisect.insort_left(ids, row.process_id)
	return ids


#
# =============================================================================
#
#                 Trigger List Interface (Level 1 Coincidence)
#
# =============================================================================
#

class TriggerList(object):
	"""
	A class for retrieving subsets of a trigger list by time interval.
	"""
	def __init__(self, instrument):
		self.instrument = instrument
		self.triggers = []
		self.offset = LIGOTimeGPS(0)

	def __len__(self):
		return len(self.triggers)

	def append(self, trigger):
		self.triggers.append(trigger)

	def mkindex(self):
		self.triggers.sort(lambda a, b: cmp(a.get_stop(), b.get_stop()))
		self.start_times = [LIGOTimeGPS(row.get_start()) for row in self.triggers]
		self.stop_times = [LIGOTimeGPS(row.get_stop()) for row in self.triggers]
		self.maxduration = max(map(lambda stop, start: stop - start, self.stop_times, self.start_times))

	def set_offset(self, offset):
		"""
		Set a time offset on all triggers in the list.
		"""
		if offset != self.offset:
			delta = offset - self.offset
			for row in self.triggers:
				row.set_start(row.get_start() + delta)
			self.offset = offset

	def remove_offset(self):
		"""
		Remove the offset from all triggers in the list.
		"""
		if self.offset != LIGOTimeGPS(0):
			for row in self.triggers:
				row.set_start(row.get_start() - self.offset)
			self.offset = LIGOTimeGPS(0)

	def intersects(self, t, dt):
		"""
		Return a list of the triggers whose time intervals
		intersect t +/- dt.
		"""
		return [self.triggers[i] for i in xrange(bisect.bisect_left(self.stop_times, t - dt - self.offset), bisect.bisect_right(self.stop_times, t + dt + self.maxduration - self.offset)) if self.start_times[i] + self.offset <= t + dt]


def construct_trigger_lists(trigtable, coinc_procids):
	"""
	From a trigger table and a list of process IDs, return a dictionary
	of instrument name / TriggerList object pairs.  Only triggers from
	from the given processes are included in the lists.
	"""
	lists = {}
	for row in trigtable:
		if not llwapp.bisect_contains(coinc_procids, row.process_id):
			continue
		instrument = row.ifo
		if instrument not in lists:
			lists[instrument] = TriggerList(instrument)
		lists[instrument].append(row)
	map(TriggerList.mkindex, lists.values())
	return lists


class Level1Iterator(object):
	"""
	Performs a coarse coincidence cut, generating a sequence of
	MultiIter objects for iterating over sets of surviving n-tuples.
	"""
	def __init__(self, document, instruments):
		instruments.sort()
		self.triggerlists = document.get_triglists(instruments)
		lengths = map(len, self.triggerlists)
		self.len = min(lengths)
		self.shortest = lengths.index(self.len)
		self.trigiter = iter(self.triggerlists[self.shortest].triggers)
		del self.triggerlists[self.shortest]
		self.maxwindow = max(map(lambda pair: document.windows[tuple(pair)], choices(instruments, 2)))

	def __len__(self):
		return self.len

	def __iter__(self):
		return self

	def next(self):
		trig = self.trigiter.next()
		start = LIGOTimeGPS(trig.get_start())
		intersectingtrigs = map(lambda l: l.intersects(start + trig.duration / 2, self.maxwindow + trig.duration / 2), self.triggerlists)
		intersectingtrigs.insert(self.shortest, [trig])
		return MultiIter(intersectingtrigs)


#
# =============================================================================
#
#                         Level 2 (Final) Coincidence
#
# =============================================================================
#

Level2Test = SnglBurstUtils.CompareSnglBurst

def coincident(trigs, windows):
	"""
	Return True if the triggers are all mutually coincident.  Requires
	trigs to be sorted by instrument.
	"""
	try:
		for [a, b] in choices(trigs, 2):
			if Level2Test(a, b, windows[(a.ifo, b.ifo)]):
				return False
	except KeyError, e:
		raise KeyError, "no coincidence window provided for instrument pair %s" % str(e)
	return True


#
# =============================================================================
#
#                              Document Interface
#
# =============================================================================
#

class DocContents(object):
	"""
	A wrapper interface to the XML document.
	"""
	def __init__(self, doc, process, windows):
		"""
		Initialize the document interface.  If coinc and coincmap
		tables are not found in doc, they are appended to it.
		"""
		self.process_id = process.process_id
		self.windows = windows
		self.tisitable = llwapp.get_table(doc, lsctables.TimeSlideTable.tableName)
		for row in self.tisitable:
			row.offset = LIGOTimeGPS(row.offset)
		self.searchsummtable = llwapp.get_table(doc, lsctables.SearchSummaryTable.tableName)
		self.triggerlists = construct_trigger_lists(llwapp.get_table(doc, lsctables.SnglBurstTable.tableName), coinc_procids(self))

		try:
			self.coinctable = llwapp.get_table(doc, lsctables.CoincTable.tableName)
		except ValueError:
			self.coinctable = lsctables.New(lsctables.CoincTable)
			doc.childNodes[0].appendChild(self.coinctable)
		self.coincids = docutils.NewILWDs(self.coinctable, "coinc_event_id")

		try:
			self.coincmaptable = llwapp.get_table(doc, lsctables.CoincMapTable.tableName)
		except ValueError:
			self.coincmaptable = lsctables.New(lsctables.CoincMapTable, columns = ["coinc_event_id", "event_id"])
			doc.childNodes[0].appendChild(self.coincmaptable)

	def get_tisi_ids(self):
		"""
		Return a list of the time slide IDs in this document.
		"""
		return self.tisitable.dict.keys()

	def get_offsetdict(self, tisi_id):
		"""
		Return the dictionary of instrument/offset pairs for time
		slide ID tisi_id.
		"""
		return self.tisitable.get_offset_dict(tisi_id)

	def get_triglists(self, instruments):
		"""
		Return the list of TriggerList objects corresponding to the
		given instruments.
		"""
		return map(self.triggerlists.__getitem__, instruments)

	def set_offsetdict(self, offsetdict):
		"""
		Set the trigger list offsets to those in the dictionary of
		instrument/offset pairs.  Instruments not in offsetdict are
		not modified.
		"""
		for instrument, offset in offsetdict.iteritems():
			self.triggerlists[instrument].set_offset(offset)

	def remove_offsetdict(self):
		"""
		Remove the offsets from all trigger lists.
		"""
		for triggerlist in self.triggerlists.itervalues():
			triggerlist.remove_offset()

	def append_coinc(self, tisi_id, trigs):
		"""
		Takes a time slide ID and a list of triggers, and adds the
		triggers as a new coincidence to the coinc and coincmap
		tables
		"""
		coinc = lsctables.Coinc()
		coinc.process_id = self.process_id
		coinc.coinc_event_id = self.coincids.next()
		coinc.time_slide_id = tisi_id
		coinc.nevents = len(trigs)
		self.coinctable.append(coinc)
		for trig in trigs:
			coincmap = lsctables.CoincMap()
			coincmap.coinc_event_id = coinc.coinc_event_id
			coincmap.event_id = trig.event_id
			self.coincmaptable.append(coincmap)


#
# =============================================================================
#
#                          Build Trigger Coincidences
#
# =============================================================================
#

def find_coincident_ntuples(document, instruments, tisi_id, verbose = False):
	"""
	Given a DocContents object, a list of instruments and a time slide
	ID, identify and append to the document all n-way coincidences
	involving exactly one trigger from each instrument.
	"""
	level1iterator = Level1Iterator(document, instruments)
	for n, ntuples in enumerate(level1iterator):
		if not (n % 2048):
			if verbose:
				print >>sys.stderr, "\t%.1f%%\r" % (100.0 * (n + 1) / len(level1iterator)),
		for ntuple in ntuples:
			if coincident(ntuple, document.windows):
				document.append_coinc(tisi_id, ntuple)
	if verbose:
		print >>sys.stderr, "\t100.0%"


def find_coincidences(document, verbose = False):
	"""
	Given a DocContents object, identify and append all coincidences.
	"""
	tisiids = document.get_tisi_ids()
	for n, tisi_id in enumerate(tisiids):
		offsetdict = document.get_offsetdict(tisi_id)
		if verbose:
			print >>sys.stderr, "time slide %d/%d: %s" % (n + 1, len(tisiids), str(offsetdict))
		document.set_offsetdict(offsetdict)
		find_coincident_ntuples(document, offsetdict.keys(), tisi_id, verbose)
	document.remove_offsetdict()


#
# =============================================================================
#
#                                 Library API
#
# =============================================================================
#

def ligolw_burca(doc, **kwargs):
	process = append_process(doc, **kwargs)
	if kwargs["verbose"]:
		print >>sys.stderr, "indexing..."
	find_coincidences(DocContents(doc, process, kwargs["window"]), kwargs["verbose"])
	llwapp.set_process_end_time(process)
	return doc


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

try:
	options, filenames = parse_command_line()
except ValueError, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)
try:
	for filename in filenames:
		doc = llwapp.load_filename(filename, options.verbose)
		if llwapp.doc_includes_process(doc, "ligolw_burca"):
			if options.verbose:
				print >>sys.stderr, "warning: %s already processed," % (filename or "stdin"),
			if options.force:
				if options.verbose:
					print >>sys.stderr, "continuing"
			else:
				if options.verbose:
					print >>sys.stderr, "skipping"
				continue
		ligolw_burca(doc, **options.__dict__)
		llwapp.write_filename(doc, filename, options.verbose)
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)
