#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import bisect
from optparse import OptionParser
import sys

from glue.ligolw import lsctables
from pylal import itertools
from pylal import llwapp
from pylal import SnglBurstUtils
from pylal.date import LIGOTimeGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_windows(windowstrings):
	"""
	Turn a list of strings of the form "inst1,inst2=delta" into a
	dictionary with (inst1, inst2) 2-tuples as keys and the deltas as
	the values.  The instruments in the 2-tuples are sorted.
	"""
	windows = {}
	for [pair, delay] in map(lambda w: str.split(w, "="), windowstrings):
		pair = pair.split(",")
		pair.sort()
		pair = tuple(pair)
		if len(pair) != 2:
			raise ValueError, "incorrect number of instruments"
		if pair in windows:
			raise ValueError, "duplicate instrument pair"
		windows[pair] = LIGOTimeGPS(delay)
	return windows


def parse_command_line():
	parser = OptionParser(version = "%prog CVS $Id$")
	parser.add_option("--comment", metavar = "text", default = "", help = "set comment string in process table")
	parser.add_option("-f", "--force", action = "store_true", help = "process even if file has already been processed")
	parser.add_option("-p", "--program", metavar = "name", default = "power", help = "set the name of the program that generated the triggers as it appears in the process table (default = power)")
	parser.add_option("-w", "--window", metavar = "inst1,inst2=seconds", action = "append", default = [], help = "set the coincidence window for an instrument pair")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	try:
		options.window = parse_windows(options.window)
	except ValueError, e:
		raise ValueError, "error parsing --window: %s" % str(e)

	return options, (filenames or [None])


#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#

def append_process(doc, **kwargs):
	process = llwapp.append_process(doc, program = "ligolw_burca", version = __version__, cvs_repository = "lscsoft", cvs_entry_time = __date__, comment = kwargs["comment"])

	params = [("--program", "lstring", kwargs["program"])]
	for key, value in kwargs["window"].iteritems():
		params += [("--window", "lstring", "%s,%s=%s" % (key[0], key[1], str(value)))]
	llwapp.append_process_params(doc, process, params)

	return process


#
# =============================================================================
#
#                     Process Filter (Level 0 Coincidence)
#
# =============================================================================
#

def find_coinc_proc_ids(doccontents, xmldoc, program):
	"""
	Take a DocContents object and set its coinc_proc_ids attribute to
	the list of process IDs that will participate in coincidences
	identified by the time slide table.
	"""
	ids = llwapp.get_process_ids_by_program(xmldoc, program)

	# find the largest coincidence window
	try:
		halfmaxwindow = max(doccontents.windows.itervalues()) / 2
	except:
		halfmaxwindow = LIGOTimeGPS(0)

	# extract a segmentlistdict;  protract by half the largest
	# coincidence window so as to not miss edge effects
	seglistdict = llwapp.segmentlistdict_fromsearchsummary(xmldoc, program).protract(halfmaxwindow)

	# determine the coincident segments for each instrument
	coincseglists = llwapp.get_coincident_segmentlistdict(seglistdict, map(doccontents.get_offsetdict, doccontents.get_tisi_ids()))

	# find the IDs of the processes which contributed to the coincident
	# segments
	doccontents.coinc_proc_ids = []
	for row in doccontents.searchsummtable:
		if (not llwapp.bisect_contains(ids, row.process_id)) or llwapp.bisect_contains(doccontents.coinc_proc_ids, row.process_id):
			continue
		if coincseglists[row.ifos].intersects_segment(row.get_out()):
			bisect.insort_left(doccontents.coinc_proc_ids, row.process_id)


#
# =============================================================================
#
#                            Trigger List Interface
#
# =============================================================================
#

class TriggerList(list):
	"""
	A class for managing a list of triggers:  applying time offsets,
	and retrieving subsets of the list selected by time interval.
	"""
	def __init__(self):
		self.offset = LIGOTimeGPS(0)

	def mkindex(self):
		"""
		Build look-up tables for the triggers.  Must be called after
		triggers have been added to the list, and before the
		intersects() method is called.
		"""
		self.sort(lambda a, b: cmp(a.get_start() + a.duration, b.get_start() + b.duration))
		self.start_times = [LIGOTimeGPS(row.get_start()) for row in self]
		self.stop_times = [LIGOTimeGPS(row.get_start()) + row.duration for row in self]
		self.maxduration = max(map(lambda stop, start: stop - start, self.stop_times, self.start_times))

	def set_offset(self, offset):
		"""
		Set a time offset on all triggers in the list.
		"""
		if offset != self.offset:
			delta = offset - self.offset
			for row in self:
				row.set_start(row.get_start() + delta)
			self.offset = offset

	def remove_offset(self):
		"""
		Remove the offset from all triggers in the list.
		"""
		self.set_offset(LIGOTimeGPS(0))

	def intersects(self, t, dt):
		"""
		Return a list of the triggers whose time intervals
		intersect t +/- dt.
		"""
		return [self[i] for i in xrange(bisect.bisect_left(self.stop_times, t - dt - self.offset), bisect.bisect_right(self.stop_times, t + dt + self.maxduration - self.offset)) if self.start_times[i] + self.offset <= t + dt]


#
# =============================================================================
#
#                              Document Interface
#
# =============================================================================
#

def construct_trigger_lists(trigtable, coinc_procids):
	"""
	From a trigger table and a list of process IDs, return a dictionary
	of instrument name / TriggerList object pairs.  Only triggers from
	from the given processes are included in the lists.
	"""
	lists = {}
	for row in trigtable:
		if not llwapp.bisect_contains(coinc_procids, row.process_id):
			continue
		try:
			lists[row.ifo].append(row)
		except KeyError:
			lists[row.ifo] = TriggerList()
			lists[row.ifo].append(row)
	map(TriggerList.mkindex, lists.values())
	return lists


class DocContents(object):
	"""
	A wrapper interface to the XML document.
	"""
	def __init__(self, doc, program, process, windows):
		"""
		Initialize the document interface.  If coinc, coincdef, and
		coincmap tables are not found in doc, they are appended to
		it.
		"""
		self.process_id = process.process_id
		self.windows = windows

		# find the time slide table, and type-cast all offsets to
		# LIGOTimeGPS
		self.tisitable = llwapp.get_table(doc, lsctables.TimeSlideTable.tableName)
		for row in self.tisitable:
			row.offset = LIGOTimeGPS(row.offset)
		self.searchsummtable = llwapp.get_table(doc, lsctables.SearchSummaryTable.tableName)

		# find the process IDs for jobs that can participate in a
		# coincidence
		find_coinc_proc_ids(self, doc, program)

		# build the trigger list accessors
		self.triggerlists = construct_trigger_lists(llwapp.get_table(doc, lsctables.SnglBurstTable.tableName), self.coinc_proc_ids)

		# get the coinc_def_id for sngl_burst <--> sngl_burst
		# coincs
		self.coinc_def_id = llwapp.get_coinc_def_id(doc, [lsctables.SnglBurstTable.tableName])

		# find the coinc table or create one if not found
		try:
			self.coinctable = llwapp.get_table(doc, lsctables.CoincTable.tableName)
		except ValueError:
			self.coinctable = lsctables.New(lsctables.CoincTable)
			doc.childNodes[0].appendChild(self.coinctable)
		self.coincids = lsctables.NewILWDs(self.coinctable, "coinc_event_id")

		# find the coinc_map table or create one if not found
		try:
			self.coincmaptable = llwapp.get_table(doc, lsctables.CoincMapTable.tableName)
		except ValueError:
			self.coincmaptable = lsctables.New(lsctables.CoincMapTable)
			doc.childNodes[0].appendChild(self.coincmaptable)

	def get_tisi_ids(self):
		"""
		Return a list of the time slide IDs in this document.
		"""
		return self.tisitable.dict.keys()

	def get_offsetdict(self, tisi_id):
		"""
		Return the dictionary of instrument/offset pairs for time
		slide ID tisi_id.
		"""
		return self.tisitable.get_offset_dict(tisi_id)

	def get_triglists(self, instruments):
		"""
		Return the list of TriggerList objects corresponding to the
		given instruments.
		"""
		return map(self.triggerlists.__getitem__, instruments)

	def set_offsetdict(self, offsetdict):
		"""
		Set the trigger list offsets to those in the dictionary of
		instrument/offset pairs.  Instruments not in offsetdict are
		not modified.
		"""
		for instrument, offset in offsetdict.iteritems():
			self.triggerlists[instrument].set_offset(offset)

	def remove_offsetdict(self):
		"""
		Remove the offsets from all trigger lists.
		"""
		for triggerlist in self.triggerlists.itervalues():
			triggerlist.remove_offset()

	def append_coinc(self, tisi_id, trigs):
		"""
		Takes a time slide ID and a list of triggers, and adds the
		triggers as a new coincidence to the coinc and coincmap
		tables
		"""
		coinc = lsctables.Coinc()
		coinc.process_id = self.process_id
		coinc.coinc_def_id = self.coinc_def_id
		coinc.coinc_event_id = self.coincids.next()
		coinc.time_slide_id = tisi_id
		coinc.nevents = len(trigs)
		self.coinctable.append(coinc)
		for trig in trigs:
			coincmap = lsctables.CoincMap()
			coincmap.coinc_event_id = coinc.coinc_event_id
			coincmap.event_id = trig.event_id
			self.coincmaptable.append(coincmap)


#
# =============================================================================
#
#                             Level 1 Coincidence
#
# =============================================================================
#

class Level1Iterator(object):
	"""
	Performs a coarse coincidence cut, generating a sequence of
	MultiIter objects for iterating over sets of surviving n-tuples.
	"""
	def __init__(self, document, instruments):
		instruments.sort()
		self.triggerlists = document.get_triglists(instruments)
		lengths = map(len, self.triggerlists)
		self.len = min(lengths)
		self.shortest = lengths.index(self.len)
		self.trigiter = iter(self.triggerlists[self.shortest])
		del self.triggerlists[self.shortest]
		self.maxwindow = max(map(lambda pair: document.windows[tuple(pair)], itertools.choices(instruments, 2)))

	def __len__(self):
		return self.len

	def __iter__(self):
		return self

	def next(self):
		trig = self.trigiter.next()
		start = LIGOTimeGPS(trig.get_start())
		intersectingtrigs = map(lambda l: l.intersects(start + trig.duration / 2, self.maxwindow + trig.duration / 2), self.triggerlists)
		intersectingtrigs.insert(self.shortest, [trig])
		return itertools.MultiIter(intersectingtrigs)


#
# =============================================================================
#
#                         Level 2 (Final) Coincidence
#
# =============================================================================
#

Level2Test = SnglBurstUtils.CompareSnglBurst

def coincident(trigs, windows):
	"""
	Return True if the triggers are all mutually coincident.  Requires
	trigs to be sorted by instrument.
	"""
	try:
		for [a, b] in itertools.choices(trigs, 2):
			if Level2Test(a, b, windows[(a.ifo, b.ifo)]):
				return False
	except KeyError, e:
		raise KeyError, "no coincidence window provided for instrument pair %s" % str(e)
	return True


#
# =============================================================================
#
#                          Build Trigger Coincidences
#
# =============================================================================
#

def find_coincident_ntuples(document, instruments, tisi_id, verbose = False):
	"""
	Given a DocContents object, a list of instruments and a time slide
	ID, identify and append to the document all n-way coincidences
	involving exactly one trigger from each instrument.
	"""
	level1iterator = Level1Iterator(document, instruments)
	for n, ntuples in enumerate(level1iterator):
		if not (n % 2048):
			if verbose:
				print >>sys.stderr, "\t%.1f%%\r" % (100.0 * (n + 1) / len(level1iterator)),
		for ntuple in ntuples:
			if coincident(ntuple, document.windows):
				document.append_coinc(tisi_id, ntuple)
	if verbose:
		print >>sys.stderr, "\t100.0%"


def find_coincidences(document, verbose = False):
	"""
	Given a DocContents object, identify and append all coincidences.
	"""
	tisiids = document.get_tisi_ids()
	for n, tisi_id in enumerate(tisiids):
		offsetdict = document.get_offsetdict(tisi_id)
		if verbose:
			print >>sys.stderr, "time slide %d/%d: %s" % (n + 1, len(tisiids), str(offsetdict))
		document.set_offsetdict(offsetdict)
		find_coincident_ntuples(document, offsetdict.keys(), tisi_id, verbose)
	document.remove_offsetdict()


#
# =============================================================================
#
#                                 Library API
#
# =============================================================================
#

def ligolw_burca(doc, **kwargs):
	process = append_process(doc, **kwargs)
	if kwargs["verbose"]:
		print >>sys.stderr, "indexing..."
	find_coincidences(DocContents(doc, kwargs["program"], process, kwargs["window"]), kwargs["verbose"])
	llwapp.set_process_end_time(process)
	return doc


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

try:
	options, filenames = parse_command_line()
except ValueError, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)
for n, filename in enumerate(filenames):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	doc = llwapp.load_filename(filename, options.verbose)
	if llwapp.doc_includes_process(doc, "ligolw_burca"):
		if options.verbose:
			print >>sys.stderr, "warning: %s already processed," % (filename or "stdin"),
		if not options.force:
			if options.verbose:
				print >>sys.stderr, "skipping"
			continue
		if options.verbose:
			print >>sys.stderr, "continuing"
	ligolw_burca(doc, **options.__dict__)
	llwapp.write_filename(doc, filename, options.verbose)
	doc.unlink()
