#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

import bisect
from optparse import OptionParser
import sys

from glue.ligolw import lsctables
from pylal import itertools
from pylal import llwapp
from pylal import SnglBurstUtils
from pylal.date import LIGOTimeGPS

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_windows(windowstrings):
	"""
	Turn a list of strings of the form "inst1,inst2=delta" into a
	dictionary with (inst1, inst2) 2-tuples as keys and the deltas as
	the values.  Each pair is listed twice, once in each order.
	"""
	windows = {}
	for [pair, delay] in map(lambda w: str.split(w, "="), windowstrings):
		AB = pair.split(",")
		AB.sort()
		AB = tuple(AB)
		if len(AB) != 2:
			raise ValueError, "incorrect number of instruments"
		BA = (AB[1], AB[0])
		if (AB in windows) or (BA in windows):
			raise ValueError, "duplicate instrument pair"
		windows[AB] = windows[BA] = LIGOTimeGPS(delay)
	return windows


def parse_command_line():
	parser = OptionParser(version = "%prog CVS $Id$")
	parser.add_option("--comment", metavar = "text", default = "", help = "set comment string in process table")
	parser.add_option("-f", "--force", action = "store_true", help = "process even if file has already been processed")
	parser.add_option("-p", "--program", metavar = "name", default = "power", help = "set the name of the program that generated the triggers as it appears in the process table (default = power)")
	parser.add_option("-w", "--window", metavar = "inst1,inst2=seconds", action = "append", default = [], help = "set the coincidence window for an instrument pair")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	try:
		options.window = parse_windows(options.window)
	except ValueError, e:
		raise ValueError, "error parsing --window: %s" % str(e)

	return options, (filenames or [None])


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

def sngl_burst_get_start(self):
	return LIGOTimeGPS(self.start_time, self.start_time_ns)

def sngl_burst_cmp(self, other):
	return cmp(self.start_time, other.start_time) or cmp(self.start_time_ns, other.start_time_ns)

lsctables.SnglBurst.get_start = sngl_burst_get_start


#
# =============================================================================
#
#                           Add Process Information
#
# =============================================================================
#

def append_process(doc, **kwargs):
	process = llwapp.append_process(doc, program = "ligolw_burca", version = __version__, cvs_repository = "lscsoft", cvs_entry_time = __date__, comment = kwargs["comment"])

	params = [("--program", "lstring", kwargs["program"])]
	for key, value in kwargs["window"].iteritems():
		params += [("--window", "lstring", "%s,%s=%s" % (key[0], key[1], str(value)))]
	llwapp.append_process_params(doc, process, params)

	return process


#
# =============================================================================
#
#                     Process Filter (Level 0 Coincidence)
#
# =============================================================================
#

def find_coinc_proc_ids(xmldoc, windows, program):
	"""
	Take a DocContents object and set its coinc_proc_ids attribute to
	the list of process IDs that will participate in coincidences
	identified by the time slide table.
	"""
	# find the largest coincidence window
	try:
		halfmaxwindow = max(windows.itervalues()) / 2
	except:
		halfmaxwindow = LIGOTimeGPS(0)

	# extract a segmentlistdict;  protract by half the largest
	# coincidence window so as to not miss edge effects
	seglistdict = llwapp.segmentlistdict_fromsearchsummary(xmldoc, program).protract(halfmaxwindow)

	# determine the coincident segments for each instrument
	tisitable = llwapp.get_table(xmldoc, lsctables.TimeSlideTable.tableName)
	seglistdict = llwapp.get_coincident_segmentlistdict(seglistdict, map(tisitable.get_offset_dict, tisitable.dict.keys()))

	# get the list of all process IDs for the given program
	proc_ids = llwapp.get_process_ids_by_program(xmldoc, program)

	# find the IDs of the processes which contributed to the coincident
	# segments
	coinc_proc_ids = []
	for row in llwapp.get_table(xmldoc, lsctables.SearchSummaryTable.tableName):
		if (not llwapp.bisect_contains(proc_ids, row.process_id)) or llwapp.bisect_contains(coinc_proc_ids, row.process_id):
			continue
		if seglistdict[row.ifos].intersects_segment(row.get_out()):
			bisect.insort_left(coinc_proc_ids, row.process_id)
	return coinc_proc_ids


#
# =============================================================================
#
#                            Trigger List Interface
#
# =============================================================================
#

class TriggerList(list):
	"""
	A class for managing a list of triggers:  applying time offsets,
	and retrieving subsets of the list selected by time interval.
	"""
	def __init__(self):
		self.offset = LIGOTimeGPS(0)

	def mkindex(self):
		"""
		Build look-up tables for the triggers.  Must be called
		after triggers have been added to the list, and before the
		coincs() method is called.
		"""
		self.sort(sngl_burst_cmp)
		self.start_times = [row.get_start() for row in self]
		self.max_duration = max([row.duration for row in self])

	def set_offset(self, offset):
		"""
		Set a time offset on all triggers in the list.
		"""
		if offset != self.offset:
			delta = offset - self.offset
			for row in self:
				row.set_start(row.get_start() + delta)
			self.offset = offset

	def remove_offset(self):
		"""
		Remove the offset from all triggers in the list.
		"""
		self.set_offset(LIGOTimeGPS(0))

	def coincs(self, burst, window, comparefunc):
		"""
		Return a list of the triggers coincident with burst.
		"""
		start = burst.get_start() - window - self.offset
		stop = burst.get_start() + burst.duration + window - self.offset
		return [self[i] for i in xrange(bisect.bisect_left(self.start_times, start - self.max_duration), bisect.bisect_right(self.start_times, stop)) if not comparefunc(burst, self[i], window)]


#
# =============================================================================
#
#                              Document Interface
#
# =============================================================================
#

def construct_trigger_lists(trigtable, coinc_procids):
	"""
	From a trigger table and a list of process IDs, return a dictionary
	of instrument name / TriggerList object pairs.  Only triggers from
	from the given processes are included in the lists.
	"""
	lists = {}
	for row in trigtable:
		if not llwapp.bisect_contains(coinc_procids, row.process_id):
			continue
		try:
			lists[row.ifo].append(row)
		except KeyError:
			lists[row.ifo] = TriggerList()
			lists[row.ifo].append(row)
	map(TriggerList.mkindex, lists.values())
	return lists


class DocContents(object):
	"""
	A wrapper interface to the XML document.
	"""
	def __init__(self, doc, program, process, windows):
		"""
		Initialize the document interface.  If coinc, coincdef, and
		coincmap tables are not found in doc, they are appended to
		it.
		"""
		self.process_id = process.process_id
		self.windows = windows

		# find the time slide table, and type-cast all offsets to
		# LIGOTimeGPS
		self.tisitable = llwapp.get_table(doc, lsctables.TimeSlideTable.tableName)
		for row in self.tisitable:
			row.offset = LIGOTimeGPS(row.offset)

		# find the process IDs for jobs that can participate in a
		# coincidence
		self.coinc_proc_ids = find_coinc_proc_ids(doc, self.windows, program)

		# build the trigger list accessors
		self.triggerlists = construct_trigger_lists(llwapp.get_table(doc, lsctables.SnglBurstTable.tableName), self.coinc_proc_ids)

		# get the coinc_def_id for sngl_burst <--> sngl_burst
		# coincs
		self.coinc_def_id = llwapp.get_coinc_def_id(doc, [lsctables.SnglBurstTable.tableName])

		# find the coinc table or create one if not found
		try:
			self.coinctable = llwapp.get_table(doc, lsctables.CoincTable.tableName)
		except ValueError:
			self.coinctable = lsctables.New(lsctables.CoincTable)
			doc.childNodes[0].appendChild(self.coinctable)
		self.coincids = lsctables.NewILWDs(self.coinctable, "coinc_event_id")

		# find the coinc_map table or create one if not found
		try:
			self.coincmaptable = llwapp.get_table(doc, lsctables.CoincMapTable.tableName)
		except ValueError:
			self.coincmaptable = lsctables.New(lsctables.CoincMapTable)
			doc.childNodes[0].appendChild(self.coincmaptable)

	def get_triglists(self, instruments):
		"""
		Return the list of TriggerList objects corresponding to the
		given instruments.
		"""
		return map(self.triggerlists.__getitem__, instruments)

	def set_offsetdict(self, offsetdict):
		"""
		Set the trigger list offsets to those in the dictionary of
		instrument/offset pairs.  Instruments not in offsetdict are
		not modified.
		"""
		for instrument, offset in offsetdict.iteritems():
			self.triggerlists[instrument].set_offset(offset)

	def remove_offsetdict(self):
		"""
		Remove the offsets from all trigger lists.
		"""
		for triggerlist in self.triggerlists.itervalues():
			triggerlist.remove_offset()

	def append_coinc(self, tisi_id, bursts):
		"""
		Takes a time slide ID and a list of triggers, and adds the
		triggers as a new coincidence to the coinc and coincmap
		tables
		"""
		coinc = lsctables.Coinc()
		coinc.process_id = self.process_id
		coinc.coinc_def_id = self.coinc_def_id
		coinc.coinc_event_id = self.coincids.next()
		coinc.time_slide_id = tisi_id
		coinc.nevents = len(bursts)
		self.coinctable.append(coinc)
		for burst in bursts:
			coincmap = lsctables.CoincMap()
			coincmap.coinc_event_id = coinc.coinc_event_id
			coincmap.event_id = burst.event_id
			self.coincmaptable.append(coincmap)


#
# =============================================================================
#
#                             Level 1 Coincidence
#
# =============================================================================
#

def Level1Iterator(document, instruments):
	"""
	First-pass coincidence generator.  Generates a sequence of tuples
	whose elements are, in order:

	n:  a progress indicator whose value is in the range [0, length)
	length:  the upper bound for n
	event:  a burst event
	ntuples:  see below

	ntuples is (yet) another generator that produces a sequence of
	lists of burst events.  Each list of burst events, when event is
	added to it, constitutes a potential coincidence with exactly one
	event from each instrument.  Each event in the list is guaranteed
	to be coincident with event, but the mutual coincidence of the
	events in the list has not yet been established.
	"""
	triggerlists = document.get_triglists(instruments)
	lengths = map(len, triggerlists)
	length = min(lengths)
	shortest = lengths.index(length)
	shortestlist = triggerlists[shortest]
	del triggerlists[shortest]

	windows = map(lambda inst: document.windows[(inst, instruments[shortest])], instruments[:shortest] + instruments[shortest + 1:])

	for n, event in enumerate(shortestlist):
		yield n, length, event, itertools.MultiIter(map(lambda (n, l): l.coincs(event, windows[n], Level2Test), enumerate(triggerlists)))


#
# =============================================================================
#
#                         Level 2 (Final) Coincidence
#
# =============================================================================
#

Level2Test = SnglBurstUtils.CompareSnglBurst

def coincident(events, windows):
	"""
	Return True if the triggers are all mutually coincident.
	"""
	try:
		for [a, b] in itertools.choices(events, 2):
			if Level2Test(a, b, windows[(a.ifo, b.ifo)]):
				return False
	except KeyError, e:
		raise KeyError, "no coincidence window provided for instrument pair %s" % str(e)
	return True


#
# =============================================================================
#
#                          Build Trigger Coincidences
#
# =============================================================================
#

def find_coincident_ntuples(document, instruments, tisi_id, verbose = False):
	"""
	Given a DocContents object, a list of instruments and a time slide
	ID, identify and append to the document all n-way coincidences
	involving exactly one trigger from each instrument.
	"""
	for n, length, event, ntuples in Level1Iterator(document, instruments):
		if not (n % (length / 200 + 1)):
			if verbose:
				print >>sys.stderr, "\t%.1f%%\r" % (100.0 * n / length),
		# iterate over the n-tuples, and check for mutual
		# co-incidence
		for ntuple in ntuples:
			if coincident(ntuple, document.windows):
				document.append_coinc(tisi_id, [event] + ntuple)
	if verbose:
		print >>sys.stderr, "\t100.0%"


def find_coincidences(document, verbose = False):
	"""
	Given a DocContents object, identify and append all coincidences.
	"""
	tisiids = document.tisitable.dict.keys()
	for n, tisi_id in enumerate(tisiids):
		offsetdict = document.tisitable.get_offset_dict(tisi_id)
		if verbose:
			print >>sys.stderr, "time slide %d/%d: %s" % (n + 1, len(tisiids), str(offsetdict))
			print >>sys.stderr, "\tapplying time offsets ..."
		document.set_offsetdict(offsetdict)
		if verbose:
			print >>sys.stderr, "\tsearching ..."
		find_coincident_ntuples(document, offsetdict.keys(), tisi_id, verbose)
	document.remove_offsetdict()


#
# =============================================================================
#
#                                 Library API
#
# =============================================================================
#

def ligolw_burca(doc, **kwargs):
	process = append_process(doc, **kwargs)
	if kwargs["verbose"]:
		print >>sys.stderr, "indexing..."
	find_coincidences(DocContents(doc, kwargs["program"], process, kwargs["window"]), kwargs["verbose"])
	llwapp.set_process_end_time(process)
	return doc


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

try:
	options, filenames = parse_command_line()
except ValueError, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)
for n, filename in enumerate(filenames):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	doc = llwapp.load_filename(filename, options.verbose)
	if llwapp.doc_includes_process(doc, "ligolw_burca"):
		if options.verbose:
			print >>sys.stderr, "warning: %s already processed," % (filename or "stdin"),
		if not options.force:
			if options.verbose:
				print >>sys.stderr, "skipping"
			continue
		if options.verbose:
			print >>sys.stderr, "continuing"
	ligolw_burca(doc, **options.__dict__)
	llwapp.write_filename(doc, filename, options.verbose)
	doc.unlink()
