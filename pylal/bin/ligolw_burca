#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


import glob
from optparse import OptionParser
import sys


from glue.ligolw import lsctables
from pylal import snglcoinc


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_thresholds(options):
	#
	# parse --thresholds options into instrument pairs and components
	#

	try:
		thresholds = snglcoinc.parse_thresholds(options.thresholds)
	except Exception, e:
		raise ValueError, "error parsing --thresholds: %s" % str(e)

	#
	# parse the components from --thresholds options
	#

	if options.coincidence_algorithm == "excesspower":
		#
		# parse threshold components into dt, df, dh_rss triples
		# for excesspower coincidence algorithm
		#

		try:
			#
			# don't use iteritems because we're going to modify
			# the dictionary while we go
			#

			for instrumentpair, (dt, df, dhrss) in thresholds.items():
				thresholds[instrumentpair] = (float(dt), float(df), float(dhrss))
		except Exception, e:
			raise ValueError, "error parsing --thresholds: %s" % str(e)
	elif options.coincidence_algorithm == "stringcusp":
		#
		# parse threshold components into dt, kappa, epsilon
		# triples for stringcusp coincidence algorithm
		#

		try:
			kappa, epsilon = map(float, options.stringcusp_params.split(","))
		except Exception, e:
			raise ValueError, "error parsing --stringcusp-params: %s" % str(e)
		try:
			thresholds = dict((instrumentpair, (float(dt), kappa, epsilon)) for instrumentpair, (dt,) in thresholds.iteritems())
		except Exception, e:
			raise ValueError, "error parsing --thresholds: %s" % str(e)
	else:
		#
		# unrecognized coincidence algorithm
		#

		raise ValueError, options.coincidence_algorithm

	#
	# Done
	#

	return thresholds


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog [options] [file [file ...]]",
		description = "%prog implements the excess power and string cusp coincidence algorithms for use in performing trigger-based multi-instrument searches for gravitational wave events.  The LIGO Light Weight XML files listed on the command line are processed one by one in order, and over-written with the results.  If no files are named, then input is read from stdin and output written to stdout.  Any files whose names end in \".gz\" are assumed to be gzip-compressed and will be decompressed and recompressed during I/O."
	)
	parser.add_option("-c", "--comment", metavar = "text", default = "", help = "Set comment string in process table (default is \"\").")
	parser.add_option("-f", "--force", action = "store_true", help = "Process document even if it has already been processed.")
	parser.add_option("-p", "--program", metavar = "name", help = "Set the name of the program that generated the events as it appears in the process table.  The program name is used to extract live time information from the search summary tables in the input files.")
	parser.add_option("-a", "--coincidence-algorithm", metavar = "[excesspower|excesspower2|stringcusp]", default = None, help = "Select the coincidence test algorithm to use.")
	parser.add_option("-d", "--distribution-files", metavar = "pattern", default = [], action = "append", help = "Set the shell filename pattern of the LIGO Light Weight XML files from which to read the coincidence parameter distribution functions.  The distribution data from all files is summed to construct a single set of distribution functions.  Can be given more than once, all matching files will be used.")
	parser.add_option("-t", "--thresholds", metavar = "inst1,inst2=threshold1[,threshold2,...]", action = "append", default = [], help = "Set the coincidence algorithm's thresholds for an instrument pair.  For excesspower the threshold format is dt,df,dhrss.  For stringcusp the threshold format is dt.  One set of thresholds must be provided for each instrument combination that will be compared")
	# FIXME:  split this next one into two arguments
	parser.add_option("-s", "--stringcusp-params", metavar = "kappa,epsilon", help = "Set the H1+H2 kappa and epsilon parameters for the stringcusp coincidence test (hint: try 3.0,0.5).")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	#
	# expand the distribution_files file list
	#

	if options.distribution_files:
		options.distribution_files = reduce(list.__add__, [glob.glob(g) for g in options.distribution_files])
		options.distribution_files.sort()

	#
	# check and convert and bunch of arguments
	#

	if options.coincidence_algorithm is None:
		raise ValueError, "missing required argument --coincidence-algorithm"
	if options.coincidence_algorithm not in ("excesspower", "excesspower2", "stringcusp"):
		raise ValueError, "unrecognized --coincidence-algorithm %s" % options.coincidence_algorithm
	if options.coincidence_algorithm == "excesspower2":
		if not options.distribution_files:
			raise ValueError, "missing required argument --distribution-files"
	else:
		if options.program is None:
			raise ValueError, "missing required argument --program"

	#
	# parse the --thresholds arguments
	#

	if options.coincidence_algorithm in ("excesspower", "stringcusp"):
		options.thresholds = parse_thresholds(options)

	# success
	return options, (filenames or [None])


#
# =============================================================================
#
#                                Stage 1 Burca
#
# =============================================================================
#


def burca1(options, filenames):
	#
	# Finish imports.
	#


	from glue.ligolw import utils
	from pylal import ligolw_burca
	from pylal import llwapp


	#
	# Use interning row builder to save memory.
	#


	lsctables.table.RowBuilder = lsctables.table.InterningRowBuilder


	#
	# For excesspower and stringcusp methods, select the appropriate
	# event comparison and book-keeping functions.
	#


	if options.coincidence_algorithm == "excesspower":
		snglcoinc.EventListDict.EventListType = ligolw_burca.ExcessPowerEventList
		comparefunc = ligolw_burca.ExcessPowerCoincCompare
		CoincTables = ligolw_burca.ExcessPowerCoincTables
		options.get_max_segment_gap = ligolw_burca.ExcessPowerMaxSegmentGap
	elif options.coincidence_algorithm == "stringcusp":
		snglcoinc.EventListDict.EventListType = ligolw_burca.StringEventList
		comparefunc = ligolw_burca.StringCoincCompare
		CoincTables = snglcoinc.CoincTables
		options.get_max_segment_gap = ligolw_burca.StringMaxSegmentGap
	else:
		raise Exception, "should never get here"


	#
	# Iterate over files.
	#


	for n, filename in enumerate(filenames):
		#
		# Load the file.
		#

		if options.verbose:
			print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
		xmldoc = utils.load_filename(filename, options.verbose, gz = (filename or "stdin").endswith(".gz"))
		lsctables.table.InterningRowBuilder.strings.clear()

		#
		# Have we already processed it?
		#

		if llwapp.doc_includes_process(xmldoc, ligolw_burca.process_program_name):
			if options.verbose:
				print >>sys.stderr, "warning: %s already processed," % (filename or "stdin"),
			if not options.force:
				if options.verbose:
					print >>sys.stderr, "skipping"
				continue
			if options.verbose:
				print >>sys.stderr, "continuing anyway"

		#
		# Run coincidence algorithm.
		#

		ligolw_burca.ligolw_burca(xmldoc, CoincTables, comparefunc, **options.__dict__)

		#
		# Write back to disk, and clean up.
		#

		utils.write_filename(xmldoc, filename, options.verbose, gz = (filename or "stdout").endswith(".gz"))
		xmldoc.unlink()


#
# =============================================================================
#
#                                Stage 2 Burca
#
# =============================================================================
#


def burca2(options, filenames):
	#
	# Finish imports.
	#


	from pysqlite2 import dbapi2 as sqlite3


	from pylal import ligolw_burca_tailor
	from pylal import ligolw_burca2
	from pylal import SnglBurstUtils


	#
	# Load likelihood data, and construct a LikelihoodRatio instance.
	#


	likelihood_ratio = ligolw_burca2.LikelihoodRatio(ligolw_burca_tailor.coinc_params_distributions_from_filenames(options.distribution_files, u"ligolw_burca_tailor", verbose = options.verbose).finish())

	
	#
	# Finish imports for real this time.
	#


	from glue.ligolw import dbtables


	#
	# Iterate over files.
	#


	for n, filename in enumerate(filenames):
		#
		# Open the file.
		#


		if options.verbose:
			print >>sys.stderr, "%d/%d: %s" % (n + 1, len(filenames), filename)
		connection = sqlite3.connect(filename)
		dbtables.DBTable_set_connection(connection)
		database = SnglBurstUtils.CoincDatabase().summarize(dbtables.DBTable_get_xml(), options.program, options.verbose)


		#
		# Run likelihood ratio calculation.
		#


		ligolw_burca2.ligolw_burca2(database, likelihood_ratio, verbose = options.verbose)


		#
		# Done with this file.
		#


		connection.commit()
		connection.close()


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# Command line
#


options, filenames = parse_command_line()


#
# Run program
#


if options.coincidence_algorithm in ("excesspower", "stringcusp"):
	burca1(options, filenames)
else:
	burca2(options, filenames)
