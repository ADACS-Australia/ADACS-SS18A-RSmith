#!/usr/bin/python
try:
	import sqlite3
except ImportError:
	# pre 2.5.x
	from pysqlite2 import dbapi2 as sqlite3
from glue.ligolw import dbtables 
from pylal import SnglInspiralUtils
from pylal import db_thinca_rings
from pylal import git_version
from time import clock,time
from optparse import *
import glob
import sys

__author__ = "Kari Hodge <kari.hodge@ligo.org>"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date

description="""
put the MVSC rank back into the SQL tables, after it's been turned into a likelihood, we put it in the likelihood column of the coinc_inspiral table
use it like:
mvsc_update_sql db1.sqlite db2.sqlite ... etc
mvsc_update_sql --files=*CAT_2*.dat --files=*CAT_2*_info.pat *CAT_2*.sqlite
or a combination of the two
"""

time1=time()

parser=OptionParser(usage="%prog [options] [file ...]", description = description, version="Name: %%prog\n%s" % git_version.verbose_msg)
(opts,inputfiles)=parser.parse_args()

files = []
infofiles = []
databases = []
for file in inputfiles:
	extension = file.split('.')[-1]
	if extension == 'dat': files.append(file)
	elif extension == 'pat': infofiles.append(file)
	elif extension == 'sqlite': databases.append(file)
	else:
		print >> sys.stderr, "Error: args contain %s which is not a database, .dat, or .pat file" % file
		sys.exit(1)

def files_to_dict(f1, f1_info, databases, ldict):
	for f in databases: 
		try: ldict[f]
		except: ldict[f] = {}
	f1lines = open(f1).readlines()
	#the first line of the first file is a header
	if f1lines: f1lines.pop(0)
	f1_infolines = open(f1_info).readlines()
	if len(f1lines) != len(f1_infolines): 
		print>> sys.stderr, "file " + f1 + " and " +f1_info + " have different lengths"
		sys.exit(1)
	for i, f1row in enumerate(f1lines):
		likelihood = float(f1row.split()[-1])
		if likelihood == 1: likelihood = float("inf")
		else: likelihood = likelihood / (1.0 - likelihood)
		cid, dfile = f1_infolines[i].split()[0:2]
		ldict[dfile][cid] = likelihood
	return ldict
	
# first, initialize the databases, so that all of the likelihood values are set to 1
for database in databases:
	filename = database
	local_disk = None #"/tmp"
	working_filename = dbtables.get_connection_filename(filename, tmp_path = local_disk, verbose = True)
	connection = sqlite3.connect(working_filename)
	xmldoc = dbtables.get_xml(connection)
	cursor = connection.cursor()
	connection.cursor().execute("""
	UPDATE coinc_event
		SET likelihood = 1
	""")
	connection.commit()
	dbtables.put_connection_filename(filename, working_filename, verbose = True)

# pair up each file with the appropriate info file
files.sort()
infofiles.sort()
if len(files) != len(infofiles): 
	print>> sys.stderr, "the number of infofiles does not match the number of files"
	sys.exit(1)
file_map=[]
for i in range(len(files)):
	file_map.append([files[i],infofiles[i]])
print file_map

ldict = {}
for pair in file_map:
	files_to_dict(str(pair[0]),str(pair[1]),databases, ldict)

for f in databases:
	filename = f
	local_disk = None #"/tmp"
	working_filename = dbtables.get_connection_filename(filename, tmp_path = local_disk, verbose = True)
	connection = sqlite3.connect(working_filename)
	xmldoc = dbtables.get_xml(connection)
	cursor = connection.cursor()
	def likelihood_from_coinc_id(id, ldict_f = ldict[f]):
		try: 
			return ldict_f[id]
		except: return 1
	if ldict[f]:	
		connection.create_function("likelihood_from_coinc_id", 1, likelihood_from_coinc_id)		
		cursor.execute("""
		UPDATE coinc_event
			SET likelihood = likelihood * likelihood_from_coinc_id(coinc_event.coinc_event_id)
		""")
		connection.commit() 
	dbtables.put_connection_filename(filename, working_filename, verbose = True)

time2=time()
elapsed_time=time2-time1
print elapsed_time


