#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

"""
String cusp search final output rendering tool.
"""

import bisect
from optparse import OptionParser
import math
import numarray
import re
from pysqlite2 import dbapi2 as sqlite
import sys

from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import utils
from glue import segments
from pylal import rate
from pylal import SnglBurstUtils

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("-a", "--amplitude-factor", metavar = "factor", default = "1e-20", help = "multiple amplitudes in XML files by this amount (default = 1e-20)")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("-i", "--injections", action = "store_true", help = "generate efficiency plots from the output files of an injection run")
	parser.add_option("--loudest-survivor", metavar = "instrument=amplitude", default = None, help = "set amplitude of loudest zero-lag non-injection survivor for efficiency plots")
	parser.add_option("-l", "--live-time-program", metavar = "program", default = "StringSearch", help = "set the name, as it appears in the process table, of the program whose search summary entries define the search live time (default = StringSearch)")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	options.amplitude_factor = float(options.amplitude_factor)
	if options.injections:
		if options.loudest_survivor == None:
			raise ValueError, "must set --loudest-survivor with --injections"
		options.loudest_survivor = options.loudest_survivor.split("=")
		options.loudest_survivor = {options.loudest_survivor[0]: float(options.loudest_survivor[1])}

	return options, (filenames or [None])


#
# =============================================================================
#
#                              Zero-Lag Survivors
#
# =============================================================================
#

class Survivors(object):
	def __init__(self):
		self.xmldoc = None

	def add_contents(self, contents):
		if self.xmldoc == None:
			self.xmldoc = ligolw.Document()
			self.xmldoc.appendChild(ligolw.LIGO_LW())
			self.sngl_burst_table = lsctables.New(lsctables.SnglBurstTable, contents.sngl_burst_table.columnnames)
			self.xmldoc.childNodes[0].appendChild(self.sngl_burst_table)

		time_slide_id = [id for id in contents.time_slide_table.iterkeys() if contents.time_slide_table.is_null(id)]
		if len(time_slide_id) != 1:
			raise ValueError, "document does not contain exactly 1 zero-lag time slide (contains %d of them)" % len(time_slide_id)
		time_slide_id = time_slide_id[0]

		self.sngl_burst_table.extend(map(contents.sngl_burst_table._row_from_cols, contents.connection.cursor().execute(
			"""
SELECT sngl_burst.* FROM
	sngl_burst
	JOIN coinc_event_map ON (
		coinc_event_map.event_id == sngl_burst.event_id
		AND coinc_event_map.table_name == 'sngl_burst'
	)
	JOIN coinc_event ON (
		coinc_event.coinc_event_id == coinc_event_map.coinc_event_id
	)
WHERE
	coinc_event.coinc_def_id == ?
	AND coinc_event.time_slide_id == ?
			""",
			(contents.bb_definer_id, time_slide_id)
		)))

	def finish(self, filename, verbose = "False"):
		self.sngl_burst_table.sort(lambda a, b: cmp((a.ifo, abs(a.amplitude)), (b.ifo, abs(b.amplitude))))
		utils.write_filename(self.xmldoc, filename, verbose = verbose, gz = (filename or "stdout")[-3:] == ".gz")


#
# =============================================================================
#
#                              Rate vs. Amplitude
#
# =============================================================================
#

class RateVsAmplitude(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, amplitude_factor):
		SnglBurstUtils.BurstPlot.__init__(self, r"%s Amplitude \(A\)" % instrument, "Coincident Event Rate (Hz)")
		self.instrument = instrument
		self.amplitude_factor = amplitude_factor
		self.foreground = []
		self.background = []
		self.foreground_time = 0.0
		self.background_time = 0.0
		self.axes.loglog()

	def add_contents(self, contents):
		for time_slide_id in contents.time_slide_table.iterkeys():
			offsets = contents.time_slide_table[time_slide_id]
			contents.seglists.offsets.update(offsets)
			live_time = float(contents.seglists.intersection(offsets.keys()).duration())
			if contents.time_slide_table.is_null(time_slide_id):
				bins = self.foreground
				self.foreground_time += live_time
			else:
				bins = self.background
				self.background_time += live_time
			for coinc in contents.coinc_table.selectByTimeSlideID(time_slide_id):
				if coinc.coinc_def_id != contents.bb_definer_id:
					continue
				for burst in coinc.sngl_bursts():
					if burst.ifo == self.instrument:
						bins.append(burst.amplitude * self.amplitude_factor)
		contents.seglists.offsets.clear()

	def finish(self):
		self.axes.set_title(r"\begin{center}Cummulative Coincident Event Rate vs.\ Amplitude in %s\\%d Foreground, %d Background Events\end{center}" % (self.instrument, len(self.foreground), len(self.background)))
		self.background.sort()
		self.foreground.sort()
		# ratio of live times
		foregrounds_per_background = self.foreground_time / self.background_time
		# cummulative number expected in foreground
		background_y = numarray.arange(len(self.background), 0.0, -1.0, "Float64") * foregrounds_per_background
		# \sqrt{N} std dev expected in foreground
		background_yerr = numarray.sqrt(numarray.array(background_y))
		# convert to rate and uncertainty expected in foreground
		background_y /= self.foreground_time
		background_yerr /= self.foreground_time
		# cummulative rate observed in foreground
		foreground_y = numarray.arange(len(self.foreground), 0.0, -1.0, "Float64") / self.foreground_time
		# plot
		self.axes.errorbar(self.background, background_y, yerr = background_yerr, fmt = "k-")
		self.axes.plot(self.foreground, foreground_y, "ro-", markeredgecolor = "r")
		#self.axes.set_xlim([1e-21, 1e-18])
		#self.axes.set_ylim([1e-9, 1e-5])
		self.axes.xaxis.grid(True, which="minor")
		self.axes.yaxis.grid(True, which="minor")


#
# =============================================================================
#
#                                  Efficiency
#
# =============================================================================
#

def interpolate(y, x1, y1, x2, y2):	
	"""
	Given (x1, y1) and (x2, y2), solve for the x corresponding to y
	assuming a straight line between between the two points.
	"""
	return x1 + (x2 - x1) * (y - y1) / (y2 - y1)


def latexnumber(s):
	"""
	Convert strings of the form "d.dddde-dd" to "d.dddd \times
	10^{-dd}"
	"""
	return re.sub(r"([.0-9]+)e?([+-]?[0-9]+)", r"\1 \\times 10^{\2}", s)


class Efficiency(SnglBurstUtils.BurstPlot):
	def __init__(self, loudest_survivor, amplitude_factor):
		SnglBurstUtils.BurstPlot.__init__(self, r"Injection Amplitude (\(\mathrm{s}^{-\frac{1}{3}}\))", "Detection Efficiency")
		self.axes.set_title(r"Detection Efficiency vs.\ Amplitude")
		self.loudest_survivor_inst, self.loudest_survivor_ampl = loudest_survivor.items()[0]
		self.amplitude_factor = amplitude_factor
		self.found = []
		self.found_above_loudest = []
		self.all = []
		self.axes.semilogx()

	def add_contents(self, contents):
		# find all found injections:  assemble a list of sngl_burst
		# event_id's for events participating in coincidences, then
		# get a list of the sim_burst simulation_id's for
		# injections that matched one of those, then extract the
		# rows for those injections.
		self.found.extend(map(contents.sim_burst_table._row_from_cols, contents.connection.cursor().execute(
			"""
SELECT * FROM
	sim_burst
WHERE
	simulation_id IN (
		SELECT DISTINCT a.event_id FROM
			coinc_event_map AS a
			JOIN coinc_event_map AS b ON (
				a.coinc_event_id == b.coinc_event_id
				AND a.table_name == 'sim_burst'
				AND b.table_name == 'sngl_burst'
			)
		WHERE
			b.event_id IN (
				SELECT DISTINCT event_id FROM
					coinc_event_map
					JOIN coinc_event ON (
						coinc_event_map.coinc_event_id == coinc_event.coinc_event_id
						AND coinc_event_map.table_name == 'sngl_burst'
					)
				WHERE
					coinc_event.coinc_def_id == ?
			)
	)
			""",
			(contents.bb_definer_id,)
		)))
		# find all injections recovered in loudest_survivor_inst
		# with an amplitude greater than loudest_survivor_ampl:
		# assemble a list of sngl_burst event_id's for events
		# matching the conditions and participating in
		# coincidences, then get a list of the sim_burst
		# simulation_id's for injections that matched one of those,
		# then extract the rows for those injections.
		self.found_above_loudest.extend(map(contents.sim_burst_table._row_from_cols, contents.connection.cursor().execute(
			"""
SELECT * FROM
	sim_burst
WHERE
	simulation_id IN (
		SELECT DISTINCT a.event_id FROM
			coinc_event_map AS a
			JOIN coinc_event_map AS b ON (
				a.coinc_event_id == b.coinc_event_id
				AND a.table_name == 'sim_burst'
				AND b.table_name == 'sngl_burst'
			)
		WHERE
			b.event_id IN (
				SELECT DISTINCT sngl_burst.event_id FROM
					sngl_burst
					JOIN coinc_event_map ON (
						sngl_burst.event_id == coinc_event_map.event_id
						AND coinc_event_map.table_name == 'sngl_burst'
					)
					JOIN coinc_event ON (
						coinc_event_map.coinc_event_id == coinc_event.coinc_event_id
					)
				WHERE
					sngl_burst.ifo == ?
					AND abs(sngl_burst.amplitude) > ?
					AND coinc_event.coinc_def_id == ?
			)
	)
			""",
			(self.loudest_survivor_inst, self.loudest_survivor_ampl, contents.bb_definer_id,)
		)))
		self.all.extend(iter(contents.sim_burst_table))

	def finish(self):
		self.all.sort(lambda a, b: cmp(a.hpeak, b.hpeak))
		min_amplitude = self.all[0].hpeak * self.amplitude_factor
		max_amplitude = self.all[-1].hpeak * self.amplitude_factor

		bins = rate.Bins(min_amplitude, max_amplitude, 100, spacing = ["log"])
		efficiency = rate.BinnedRatios(bins)
		efficiency_above_loudest = rate.BinnedRatios(bins)
		for sim in self.found:
			efficiency.incnumerator((sim.hpeak * self.amplitude_factor,))
		for sim in self.found_above_loudest:
			efficiency_above_loudest.incnumerator((sim.hpeak * self.amplitude_factor,))
		for sim in self.all:
			efficiency.incdenominator((sim.hpeak * self.amplitude_factor,))
			efficiency_above_loudest.incdenominator((sim.hpeak * self.amplitude_factor,))
		efficiency.regularize()
		efficiency_above_loudest.regularize()

		# generate and plot dots with error bars
		(x,) = efficiency.centres()
		eff = efficiency.ratio()
		eff_yerr = numarray.sqrt(eff * (1 - eff) / efficiency.denominator)
		eff_above_loudest = efficiency_above_loudest.ratio()
		eff_above_loudest_yerr = numarray.sqrt(eff_above_loudest * (1 - eff_above_loudest) / efficiency_above_loudest.denominator)

		self.axes.errorbar(x, eff, yerr = eff_yerr, fmt = "ko", label = None)
		self.axes.errorbar(x, eff_above_loudest, yerr = eff_above_loudest_yerr, fmt = "ro", label = None)

		# generate and plot trend curves
		windowfunc = rate.gaussian_window(5.882352941176471)
		rate.filter_array(efficiency.numerator, windowfunc)
		rate.filter_array(efficiency.denominator, windowfunc)
		rate.filter_array(efficiency_above_loudest.numerator, windowfunc)
		rate.filter_array(efficiency_above_loudest.denominator, windowfunc)
		eff = efficiency.ratio()
		eff_above_loudest = efficiency_above_loudest.ratio()
		line1 = self.axes.plot(x, eff, "k-")
		line2 = self.axes.plot(x, eff_above_loudest, "r-")
		self.axes.legend((line1, line2), ("All recovered injections", r"Injections recovered in %s with \(A > %s\,\mathrm{s}^{-\frac{1}{3}}\)" % (self.loudest_survivor_inst, latexnumber("%g" % (self.loudest_survivor_ampl * self.amplitude_factor)))), loc = "lower right")

		# compute 50% point from trend curves
		i = bisect.bisect_left(eff, 0.5)
		A50 = interpolate(0.5, x[i - 1], eff[i - 1], x[i], eff[i])
		print "Pipeline's 50%% efficiency point for all detections = %g" % A50
		i = bisect.bisect_left(eff_above_loudest, 0.5)
		A50_above_loudest = interpolate(0.5, x[i - 1], eff_above_loudest[i - 1], x[i], eff_above_loudest[i])
		print "Pipeline's 50%% efficiency point for detections above loudest = %g" % A50_above_loudest

		# mark on graph
		self.axes.axhline(0.5, color = "k", linestyle = "--")
		self.axes.axvline(A50, color = "k")
		self.axes.axvline(A50_above_loudest, color = "r")


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

options, filenames = parse_command_line()

if options.injections:
	plots = [
		Efficiency(options.loudest_survivor, options.amplitude_factor)
	]
	survivors = None
else:
	plots = [
		RateVsAmplitude("H1", options.amplitude_factor),
		RateVsAmplitude("H2", options.amplitude_factor),
		RateVsAmplitude("L1", options.amplitude_factor),
	]
	survivors = Survivors()


for n, filename in enumerate(utils.sort_files_by_size(filenames, options.verbose, reverse = True)):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	database = SnglBurstUtils.CoincDatabase(sqlite.connect(":memory:"))
	xmldoc = utils.load_filename(filename, options.verbose, gz = filename[-3:] == ".gz")
	database.summarize(xmldoc, options.live_time_program, options.verbose)
	for n, plot in enumerate(plots):
		if options.verbose:
			print >>sys.stderr, "adding to plot %d ..." % n
		plot.add_contents(database)
	if survivors:
		if options.verbose:
			print >>sys.stderr, "storing zero-lag survivors ..."
		survivors.add_contents(database)
	xmldoc.unlink()

n = 0
format = "%%s%%0%dd.%%s" % (int(math.log10(max(len(plots) - 1, 1))) + 1)
while len(plots):
	filename = format % ("string_", n, options.format)
	if options.verbose:
		print >>sys.stderr, "finishing plot %d ..." % n
	plots[0].finish()
	if options.verbose:
		print >>sys.stderr, "writing %s ..." % filename
	plots[0].fig.savefig(filename)
	del plots[0]
	n += 1
if survivors:
	survivors.finish("string_survivors.xml", verbose = options.verbose)
if options.verbose:
	print >>sys.stderr, "done."
