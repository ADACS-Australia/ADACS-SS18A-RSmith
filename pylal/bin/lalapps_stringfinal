#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

"""
String cusp search final output rendering tool.
"""

from optparse import OptionParser
import math
import numarray
from pysqlite2 import dbapi2 as sqlite
import sys

from glue import segments
from pylal import llwapp
from pylal import SnglBurstUtils

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("-f", "--format", metavar = "format", default = "png", help = "set the output image format (default = png)")
	parser.add_option("-l", "--live-time-program", metavar = "program", default = "StringSearch", help = "set the name, as it appears in the process table, of the program whose search summary entries define the search live time (default = StringSearch)")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	return options, (filenames or [None])


#
# =============================================================================
#
#                           Highest Amplitude Event
#
# =============================================================================
#

class HighestAmplitude(object):
	def __init__(self, instrument, amplitude_factor):
		self.instrument = instrument
		self.amplitude_factor = amplitude_factor
		self.event = None

	def add_contents(self, contents):
		for coinc in contents.coinc_table.selectByDefID(contents.bb_definer_id):
			if not coinc.is_zero_lag():
				continue
			for burst in coinc.sngl_bursts():
				if burst.ifo == self.instrument and (self.event == None or burst.amplitude > self.event.amplitude):
					self.event = burst

	def finish(self):
		print "%s zero-lag triple-coincident survivor with highest amplitude:" % self.instrument
		if self.event != None:
			print "\tAmplitude = %g, at GPS time %s s" % (self.event.amplitude * self.amplitude_factor, self.event.get_peak())
		else:
			print "\tNo event found!"


#
# =============================================================================
#
#                              Rate vs. Amplitude
#
# =============================================================================
#

class RateVsAmplitude(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, amplitude_factor):
		SnglBurstUtils.BurstPlot.__init__(self, "%s Amplitude" % instrument, "Coincident Event Rate (Hz)")
		self.instrument = instrument
		self.amplitude_factor = amplitude_factor
		self.foreground = []
		self.background = []
		self.foreground_time = 0.0
		self.background_time = 0.0
		self.axes.loglog()

	def add_contents(self, contents):
		for time_slide_id in contents.time_slide_table.iterkeys():
			offsets = contents.time_slide_table[time_slide_id]
			contents.seglists.offsets.update(offsets)
			live_time = float(contents.seglists.intersection(offsets.keys()).duration())
			if contents.time_slide_table.is_null(time_slide_id):
				bins = self.foreground
				self.foreground_time += live_time
			else:
				bins = self.background
				self.background_time += live_time
			for coinc in contents.coinc_table.selectByTimeSlideID(time_slide_id):
				if coinc.coinc_def_id != contents.bb_definer_id:
					continue
				for burst in coinc.sngl_bursts():
					if burst.ifo == self.instrument:
						bins.append(burst.amplitude * self.amplitude_factor)
		contents.seglists.offsets.clear()

	def finish(self):
		self.axes.set_title(r"\begin{center}Cummulative Coincident Event Rate vs. Amplitude in %s\\%d Foreground, %d Background Events\end{center}" % (self.instrument, len(self.foreground), len(self.background)))
		self.background.sort()
		self.foreground.sort()
		background_y = numarray.arange(len(self.background), 0.0, -1.0, "Float64")
		background_yerr = numarray.sqrt(numarray.array(background_y))
		background_y /= self.background_time
		background_yerr /= self.background_time
		foreground_y = numarray.arange(len(self.foreground), 0.0, -1.0, "Float64") / self.foreground_time
		self.axes.errorbar(self.background, background_y, yerr = background_yerr, fmt = "k-")
		self.axes.plot(self.foreground, foreground_y, "ro-", markeredgecolor = "r")


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

def new_plots():
	return [
		RateVsAmplitude("H1", 10**-20),
		RateVsAmplitude("H2", 10**-20),
		RateVsAmplitude("L1", 10**-20),
	]
def new_amplitudes():
	return [
		HighestAmplitude("H1", 10**-20),
		HighestAmplitude("H2", 10**-20),
		HighestAmplitude("L1", 10**-20)
	]

options, filenames = parse_command_line()

plots = new_plots()
amplitudes = new_amplitudes()

for n, filename in enumerate(llwapp.sort_files_by_size(filenames, options.verbose, reverse = True)):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	database = SnglBurstUtils.CoincDatabase(sqlite.connect(":memory:"))
	xmldoc = llwapp.load_filename(filename, options.verbose, gz = filename[-3:] == ".gz")
	database.summarize(xmldoc, options.live_time_program, options.verbose)
	for n, plot in enumerate(plots):
		if options.verbose:
			print >>sys.stderr, "adding to plot %d ..." % n
		plot.add_contents(database)
	if options.verbose:
		print >>sys.stderr, "checking for loudest event:",
	for amplitude in amplitudes:
		if options.verbose:
			print >>sys.stderr, "%s" % amplitude.instrument,
		amplitude.add_contents(database)
	if options.verbose:
		print >>sys.stderr
	xmldoc.unlink()

n = 0
format = "%%s%%0%dd.%%s" % (int(math.log10(len(plots) - 1)) + 1)
while len(plots):
	filename = format % ("string_", n, options.format)
	if options.verbose:
		print >>sys.stderr, "finishing plot %d ..." % n
	plots[0].finish()
	if options.verbose:
		print >>sys.stderr, "writing %s ..." % filename
	plots[0].fig.savefig(filename)
	del plots[0]
	n += 1
for amplitude in amplitudes:
	amplitude.finish()
if options.verbose:
	print >>sys.stderr, "done."
