#!/usr/bin/python

import os, sys, glob, optparse, shutil, warnings
from collections import namedtuple
import numpy as np
from pylal.xlal.datatypes.ligotimegps import LIGOTimeGPS
from pylal.xlal.date import XLALGPSToUTC
import glue.GWDataFindClient, glue.segments, glue.segmentsUtils, glue.lal
import pylal.dq.dqSegmentUtils
import pylal.pylal_seismon_psd, pylal.pylal_seismon_html, pylal.pylal_seismon_omicron
import pylal.pylal_seismon_eqmon, pylal.pylal_seismon_eqmon_plot
import nds2

__author__ = "Michael Coughlin <michael.coughlin@ligo.org>"
__date__ = "2013/7/29"
__version__ = "0.2"

# =============================================================================
#
#                               DEFINITIONS
#
# =============================================================================

def parse_commandline():
    """
    Parse the options given on the command-line.
    """
    parser = optparse.OptionParser(usage=__doc__,version=__version__)

    parser.add_option("-p", "--paramsFile", help="Seismon params file.", 
                      default ="/home/mcoughlin/Seismon/seismon/input/seismon_params_HIFOY.txt")

    parser.add_option("-s", "--gpsStart", help="GPS Start Time.", default=1054028959,type=int)
    parser.add_option("-e", "--gpsEnd", help="GPS End Time.", default=1054029209,type=int)
    parser.add_option("-f", "--fftDuration", help="FFT duration.", default=64,type=int)

    parser.add_option("--gpsSpectraStart", help="GPS spectra Start Time.", type=int)
    parser.add_option("--gpsSpectraEnd", help="GPS spectra End Time.", type=int)

    parser.add_option("--segmentDatabase", help="Segment database", default="https://segdb2.ligo.caltech.edu")
    parser.add_option("--segmentFlag", help="Segment flag", default="H1:ODC-PSL_SUMMARY:1")
    parser.add_option("--segmentsTextFile", help="Segments text file.", default=None)

    parser.add_option("--fmin", help="fmin.", default=1.0/64.0,type=float)
    parser.add_option("--fmax", help="fmax.", default=64.0,type=float)

    parser.add_option("--doPlots",  action="store_true", default=False)
    parser.add_option("--doEarthquakes",  action="store_true", default=False)
    parser.add_option("--doEarthquakesAnalysis",  action="store_true", default=False)
    parser.add_option("--doEarthquakesMonitor",  action="store_true", default=False)
    parser.add_option("--doOmicron",  action="store_true", default=False)
    parser.add_option("--doFreqAnalysis",  action="store_true", default=False)
    parser.add_option("--doAnalysis",  action="store_true", default=False)
    parser.add_option("--doHTML",  action="store_true", default=False)
    parser.add_option("--doSegmentsDatabase",  action="store_true", default=False)
    parser.add_option("--doSegmentsTextFile",  action="store_true", default=False)

    parser.add_option("--doBokeh",  action="store_true", default=False)

    parser.add_option("-v", "--verbose", action="store_true", default=False,
                      help="Run verbosely. (Default: False)")

    opts, args = parser.parse_args()

    # show parameters
    if opts.verbose:
        print >> sys.stderr, ""
        print >> sys.stderr, "running pylal_seismon_run..."
        print >> sys.stderr, "version: %s"%__version__
        print >> sys.stderr, ""
        print >> sys.stderr, "***************** PARAMETERS ********************"
        for o in opts.__dict__.items():
          print >> sys.stderr, o[0]+":"
          print >> sys.stderr, o[1]
        print >> sys.stderr, ""

    return opts

def params_struct(opts):

    params = readParamsFromFile(opts.paramsFile)
    params["gpsStart"] = opts.gpsStart
    params["gpsEnd"] = opts.gpsEnd
    params["fftDuration"] = opts.fftDuration

    if opts.gpsSpectraStart == None:
        params["gpsSpectraStart"] = opts.gpsStart - 24*60*60
    else:
        params["gpsSpectraStart"] = opts.gpsSpectraStart

    if opts.gpsSpectraEnd == None:
        params["gpsSpectraEnd"] = opts.gpsEnd 
    else:
        params["gpsSpectraEnd"] = opts.gpsSpectraEnd

    params["segmentDatabase"] = opts.segmentDatabase
    params["segmentFlag"] = opts.segmentFlag
    params["segmentsTextFile"] = opts.segmentsTextFile

    params["fmin"] = opts.fmin
    params["fmax"] = opts.fmax
    params["doPlots"] = opts.doPlots
    params["doEarthquakes"] = opts.doEarthquakes
    params["doEarthquakesAnalysis"] = opts.doEarthquakesAnalysis
    params["doEarthquakesMonitor"] = opts.doEarthquakesMonitor
    params["doOmicron"] = opts.doOmicron
    params["doAnalysis"] = opts.doAnalysis
    params["doFreqAnalysis"] = opts.doFreqAnalysis
    params["doHTML"] = opts.doHTML
    params["doSegmentsDatabase"] = opts.doSegmentsDatabase
    params["doSegmentsTextFile"] = opts.doSegmentsTextFile

    params["doBokeh"] = opts.doBokeh

    params["date"] = XLALGPSToUTC(LIGOTimeGPS(params["gpsStart"]))
    params["dateString"] = "%d-%d-%d %d:%d:%d"%(params["date"][0],params["date"][1],params["date"][2],params["date"][3],params["date"][4],params["date"][5])

    if params["doEarthquakesAnalysis"]:
       params["earthquakesMinMag"] = 5
    else:
       params["earthquakesMinMag"] = 0

    return params

def readParamsFromFile(file):
        
    params = {}
    if os.path.isfile(file):
        with open(file,'r') as f:
            for line in f:
                line_without_return = line.split("\n")
                line_split = line_without_return[0].split(" ")
                params[line_split[0]] = line_split[1]
    return params

def channel_struct(channelList):
    # Create channel structure
    structproxy_channel = namedtuple( "structproxy_channel", "station station_underscore samplef calibration latitude longitude" )

    channel = []

    with open(channelList,'r') as f:

       for line in f:

           line_without_return = line.split("\n")
           line_split = line_without_return[0].split(" ")

           station = line_split[0]
           station_underscore = station.replace(":","_")

           samplef = float(line_split[1])
           calibration = float(line_split[2])

           if station[0] == "H":
               latitude = 46.6475
               longitude = -119.5986;
           elif station[0] == "L":
               latitude = 30.4986
               longitude = -90.7483
           elif station[0] == "G":
               latitude = 52.246944
               longitude = 9.808333
           elif station[0] == "V":
               latitude = 43.631389
               longitude = 10.505
           elif station[0] == "C":
               latitude = 34.1391
               longitude = -118.1238
           elif station[0] == "M":
               latitude = 44.3465
               longitude = -103.7574

           channel.append( structproxy_channel(station,station_underscore,samplef,calibration,latitude,longitude))
    return channel

def frame_struct(params):

    gpsStart = params["gpsStart"]-1000
    gpsEnd = params["gpsEnd"]

    if params["ifo"] == "XG":
        frameDir = "/archive/frames/MBH/"
        frameList = [os.path.join(root, name)
            for root, dirs, files in os.walk(frameDir)
            for name in files]

        datacache = []
        for frame in frameList:
            thisFrame = frame.replace("file://localhost","")
            if thisFrame == "":
                continue

            thisFrameSplit = thisFrame.split(".")
            if thisFrameSplit[-1] == "log":
                continue

            thisFrameSplit = thisFrame.split("-")
            gps = float(thisFrameSplit[-2])
            dur = float(thisFrameSplit[-1].replace(".gwf",""))

            if gps+dur < gpsStart:
                continue
            if gps > gpsEnd:
                continue

            cacheFile = glue.lal.CacheEntry("%s %s %d %d %s"%("XG","Homestake",gps,dur,frame))
            datacache.append(cacheFile)

    else:
        if params["frameType"] == "nds":
            conn = nds2.connection(params["ndsServer"])
            #y = conn.find_channels('*',nds2.channel.CHANNEL_TYPE_RAW,\
            #    nds2.channel.DATA_TYPE_FLOAT32, 128, 16384)

            params["ndsConnection"] = conn

        else:
            connection = glue.GWDataFindClient.GWDataFindHTTPConnection()
            datacache = connection.find_frame_urls(params["ifo"][0], params["frameType"],
                                                   gpsStart, gpsEnd,
                                                   urltype="file",
                                                   on_gaps="warn")
            connection.close()

            params["frame"] = datacache

    return params

def segment_struct(params):
  
    if params["doSegmentsDatabase"]:    
        segmentlist, segmentlistValid = pylal.dq.dqSegmentUtils.grab_segments(
                                               params["gpsStart"],params["gpsEnd"],
                                               params["segmentFlag"],params["segmentDatabase"],
                                               segment_summary=True)
    elif params["doSegmentsTextFile"]:
        segmentlist = glue.segments.segmentlist() 
        segs = np.loadtxt(params["segmentsTextFile"])
        for seg in segs:
            segmentlist.append(glue.segments.segment(seg[0],seg[1]))
    else:
        segmentlist = [glue.segments.segment(params["gpsStart"],params["gpsEnd"])]
 
    params["segments"] = segmentlist
    
    return params

# =============================================================================
#
#                                    MAIN
#
# =============================================================================

warnings.filterwarnings("ignore")

# Parse command line
opts = parse_commandline()
params = params_struct(opts)

if params["doEarthquakesMonitor"] or params["doEarthquakesAnalysis"]: 
    channelList = params["codePath"] + "/seismon/input/seismon-" + params["ifo"] + "-" + params["frameType"] + "-channel_list_EarthquakesAnalysis.txt"
else:
    channelList = params["codePath"] + "/seismon/input/seismon-" + params["ifo"] + "-" + params["frameType"] + "-channel_list.txt"
channels = channel_struct(channelList)
params["channels"] = channels

params = frame_struct(params)
params = segment_struct(params)

if params["doEarthquakesMonitor"]:

    # Output path for run
    params["path"] = params["dirPath"] + "/" + params["ifo"] + "/" + params["runName"]
    if not os.path.isdir(params["path"]):
        os.makedirs(params["path"])

    segmentlist = pylal.pylal_seismon_eqmon.run_earthquakes(params)

    sys.exit()

if params["doEarthquakesAnalysis"]:
    # Output path for run
    params["path"] = params["dirPath"] + "/" + params["ifo"] + "/" + params["runName"] + "-" + str(params["gpsStart"]) + "-" + str(params["gpsEnd"])
    if not os.path.isdir(params["path"]):
        os.makedirs(params["path"])

    print params["path"]

    params["segments"] = pylal.pylal_seismon_eqmon.run_earthquakes(params)

if params["doAnalysis"] or params["doPlots"]:
    # Output path for run
    params["path"] = params["dirPath"] + "/" + params["ifo"] + "/" + params["runName"] + "-" + str(params["gpsStart"]) + "-" + str(params["gpsEnd"])
    if not os.path.isdir(params["path"]):
        os.makedirs(params["path"])

    print params["path"]

if params["doEarthquakes"]:
    print "Finding earthquakes"
    segments = pylal.pylal_seismon_eqmon.run_earthquakes(params)

if params["doOmicron"]:
    print "Generating Omicron triggers"
    pylal.pylal_seismon_omicron.generate_triggers(params,channels)

if params["doBokeh"]:

    import pylal.pylal_seismon_bokeh

    for channel in channels:
        print "Generating bokeh page for %s"%channel.station
        pylal.pylal_seismon_bokeh.channel_page(params,channel)
    sys.exit()

for channel in channels:
    print "Generating PSD for %s"%channel.station
    for segment in params["segments"]:
        print "Segment: %d-%d"%(segment[0],segment[1])
        pylal.pylal_seismon_psd.mat(params,channel,segment)
    if params["doAnalysis"]:
        print "Analyzing PSD significance for %s"%channel.station
        pylal.pylal_seismon_psd.analysis(params,channel)

    if params["doOmicron"]:
        print "Plotting Omicron triggers for %s"%channel.station
        pylal.pylal_seismon_omicron.plot_triggers(params,channel)

for segment in params["segments"]:
    print "Running summary for Segment: %d-%d"%(segment[0],segment[1])
    pylal.pylal_seismon_psd.channel_summary(params, channels, segment)

if params["doHTML"]:
    htmlPage = pylal.pylal_seismon_html.summary_page(params,channels)
    if htmlPage is not None:
        f = open(os.path.join(params["path"],"summary.html"),"w")
        f.write(htmlPage)
        f.close()

    # Public HTML output path
    params["outputPath"] = os.path.join(params["publicPath"],params["ifo"]);
    if not os.path.isdir(params["outputPath"]):
        os.makedirs(params["outputPath"])

    os.system("rm -r %s/%s"%(params["outputPath"],params["runName"]))
    os.system("cp -r %s %s/%s"%(params["path"],params["outputPath"],params["runName"]))

