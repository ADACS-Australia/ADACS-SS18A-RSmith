#!/usr/bin/python

import sys
import os
import re
import exceptions
import glob
import fileinput
import linecache
import string
import random 
from optparse import *
from types import *
from pylab import *
from glue import segments
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from pylal import llwapp
from pylal import CoincInspiralUtils

##############################################################################
# redefine the SimInspiral columns of interest
##############################################################################
class SimInspiralCut(lsctables.LSCTableRow):
  __slots__ = [
    "waveform",
    "geocent_end_time",
    "geocent_end_time_ns",
    "h_end_time",
    "h_end_time_ns",
    "l_end_time",
    "l_end_time_ns",
    "source",
    "mass1",
    "mass2",
    "mchirp",
    "eta",
    "distance",
    "spin1x": "real_4",
    "spin1y": "real_4",
    "spin1z": "real_4",
    "spin2x": "real_4",
    "spin2y": "real_4",
    "spin2z": "real_4",
    "eff_dist_h",
    "eff_dist_l",
    "eff_dist_g",
    "eff_dist_t",
    "eff_dist_v"]
  
  # FIXME: It would be nice to inherit from lsctables.SimInspiral.  For now
  # that is not possible (while cutting columns), so we repeat the methods.
  def get_end(self,site = None):
    if not site:
      return lal.LIGOTimeGPS(self.geocent_end_time, self.geocent_end_time_ns)
    else:
      return lal.LIGOTimeGPS(getattr(self,site + 'end_time'), \
          getattr(self,site + 'end_time_ns'))

lsctables.SimInspiralTable.RowType = SimInspiralCut

##############################################################################
# redefine the SnglInspiral columns of interest
##############################################################################
class SnglInspiralCut(lsctables.SnglInspiral):
  __slots__ = [
    "ifo",
    "end_time",
    "end_time_ns",
    "eff_distance",
    "mass1",
    "mass2",
    "mchirp",
    "eta",
    "snr",
    "chisq",
    "sigmasq",
    "event_id"]

  # FIXME: It would be nice to inherit from lsctables.SimInspiral.  For now
  # that is not possible (while cutting columns), so we repeat the methods.
  def get_effective_snr(self):
    return self.snr/ (1 + self.snr**2/250)**(0.25)/ \
        (self.chisq/(2*self.chisq_dof - 2) )**(0.25) 

lsctables.SnglInspiralTable.RowType = SnglInspiralCut

##############################################################################
# Define a Square Array
##############################################################################
def square(xdata,xedges,ydata,yedges,lum_weight=None):
  """
  generate a square array with from xdata and ydata with the edges specified
  by xedges and yedges.  Can rescale the entries by lum_weight
  @param xdata:  array of data for parameter x
  @param xedges: bin boundaries for parameter x
  @param ydata:  array of data for parameter y
  @param yedges: bin boundaries for parameter y
  @param lum_weight: rescaling factor for the histogram
  """
  ng_x_y = zeros((len(xedges),len(yedges)),'d')
  xstep = xedges[1] - xedges[0]
  ystep = yedges[1] - yedges[0]
  
  for i in range(len(xdata)):  
    k = int((xdata[i]-xedges[0])/xstep)
    l = int((ydata[i]-yedges[0])/ystep)
    
    if not lum_weight:
      lum_array = 1
    else:
      lum_array = lum_weight[i]

    if (k>=0 and k<len(xedges)) and (l>=0 and l<len(yedges)):
      ng_x_y[l][k] += lum_array

  return ng_x_y
  
##############################################################################
# Define a Hist Function
##############################################################################
def histng(xdata,xedges,lum_weight=None):

  """
  histogram xdata with edges specified xedges and yedges.  
  Can rescale the entries by lum_weight
  @param xdata:  array of data for parameter x
  @param xedges: bin boundaries for parameter x
  @param lum_weight: rescaling factor for the histogram
  """
  ng_x = zeros(len(xedges),'d')
  xstep = xedges[1] - xedges[0]
  
  for i in range(len(xdata)):
    l = int((xdata[i] - xedges[0])/xstep)

    if not lum_weight:
      lum_array = 1
    else: 
      lum_array = lum_weight[i]

    if (l>=0 and l<len(xedges)):
      ng_x[l] += lum_array
 
  return ng_x

##############################################################################
# Chop a simInspiralTable based on component masses.
##############################################################################
def massCut (sim_table, m_low, m_high):
  """
  function to remove injections whose masses do not lie within [m_low,m_high]
  @param sim_table: a list of sim inspirals
  @param m_low:     the low mass threshold
  @param m_high:    the high mass threshold
  """
  tmpTable = lsctables.New(lsctables.SimInspiralTable)

  for entry in sim_table:
    m1 = getattr(entry,'mass1')
    m2 = getattr(entry,'mass2')
    if not (m_low and min(m1,m2) < m_low) and \
       not (m_high and max(m1,m2) > m_high):
      tmpTable.append(entry)

  return tmpTable

##############################################################################
# function to read in a list of files and extract the simInspiral tables
##############################################################################
def readFiles(fileGlob,statistic='effective_snr'):
  """
  read in the Sngl and SimInspiralTables from a list of files
  if Sngls are found, construct coincs, add injections (if any)
  also return Sims (if any)
  @param fileGlob: glob of input files
  @param statistic: statistic to use in creating coincs
  """
  fList = glob.glob(fileGlob)
  if not fList:
    print >>sys.stderr, "The glob for " + fileGlob + " returned no files"
    sys.exit(1)
  sims = None
  coincs = None
  for thisFile in fList:
    doc = llwapp.load_filename(thisFile)
    # extract the sim inspiral table
    try: 
      simInspiralTable = \
          llwapp.get_table(doc, lsctables.SimInspiralTable.tableName)
      if sims: sims.extend(simInspiralTable)
      else: sims = simInspiralTable
    except: simInspiralTable = None
    # extract the sngl inspiral table, construct coincs
    try: snglInspiralTable = \
      llwapp.get_table(doc, lsctables.SnglInspiralTable.tableName)
    except: snglInspiralTable = None
    if snglInspiralTable:
      coincInspiralTable = \
        CoincInspiralUtils.coincInspiralTable(snglInspiralTable,statistic)
      if simInspiralTable: 
        coincInspiralTable.add_sim_inspirals(simInspiralTable) 
      if coincs: coincs.extend(coincInspiralTable)
      else: coincs = coincInspiralTable
  return sims,coincs

##############################################################################
# Function to read in the source file and return a sorted list of its
# components according to the luminosity
##############################################################################
def read_source_file( source_file ):
  """
  read in the galaxy list, from an inspsrcs.dat type file
  @param source_file: input file name
  """
  f = open( source_file , "r")
  lines = f.readlines()
  f.close()

  sourceList = {}
  sourceList["MW"] = {"luminosity": 0.0, "delta_d": 0.0,\
                      "delta_m":opts.mw_mag_error}
  for line in lines:
    if line[0] != '#':
      b  = string.split(line)
      
      if opts.distance_error and opts.magnitude_error:
        c = {"luminosity": float(b[4]) , "delta_d": float(b[6]), \
             "delta_m": float(b[7])}
      elif opts.distance_error:
        c = {"luminosity": float(b[4]) , "delta_d": float(b[6])}
      elif opts.magnitude_error:
        c = {"luminosity": float(b[4]) , "delta_m": float(b[7])}
      else:
        c = {"luminosity": float(b[4])}   
      sourceList[b[0]] = c

  return sourceList

##############################################################################
def add_actual_error( sourceList, distErrorType, magErrorType ):
  """
  add an column containing a random error on distance/magnitude to a
  galaxy sourceList
  @param sourceList: a list of galaxies as generated by read_source_file
  """
  for galaxy in sourceList.itervalues():
    if distErrorType == "positive":
      galaxy["actual_delta_d"] = galaxy["delta_d"]
    elif distErrorType == "negative":
      galaxy["actual_delta_d"] = -galaxy["delta_d"]
    elif distErrorType == "random":
      galaxy["actual_delta_d"] = random.gauss(0,galaxy["delta_d"])

    if magErrorType == "positive":
      galaxy["actual_delta_m"] = galaxy["delta_m"]
    elif magErrorType == "negative":
      galaxy["actual_delta_m"] = -galaxy["delta_m"]
    elif magErrorType == "random":
      galaxy["actual_delta_m"] = random.gauss(0,galaxy["delta_m"])

  return sourceList
    
##############################################################################
# Class for storing the time slide information
##############################################################################
class slideZeroData:
  """
  class to hold the time slide data, has methods to make the relevant plots
  """
  def __init__(self, slideGlob, numSlides, statistic):
    self.num_slides = numSlides
    self.statistic = statistic

    # read in triggers, get slide loudest
    nosims,slideCoinc = readFiles(slideGlob,statistic)
    slideNum = range(1 , numSlides + 1)
    slideNum.extend(range(-numSlides, 0))
    slideLoudest = []
    for slide in slideNum:
      slideTrigs = slideCoinc.getslide(slide)
      try: stat = max(slideCoinc.getslide(slide).getstat() )
      except: stat = 0.0
      slideLoudest.append(stat)
      
    self.slide_loudest = asarray(slideLoudest)
    self.zero_loudest = None
    minSnr = 0.95 * min(self.slide_loudest)
    maxSnr = 1.05 * max(self.slide_loudest)
    self.snr_array = \
        arange(minSnr, maxSnr, (maxSnr - minSnr)/(2 * self.num_slides))
  
  def add_zero_lag(self, zeroGlob):
    """
    add zero lag data 
    """
    nosims,zeroCoinc = readFiles(zeroGlob,self.statistic)
    try: stat = max(zeroCoinc.getstat())
    except: stat = 0.0
    self.zero_loudest = stat
  
  def get_cumulative(self, snrArray = None):
    """
    get cumulative distribution of snrs 
    """
    if not snrArray: snrArray = self.snr_array
    numBelow = []
    for snrValue in snrArray:
      numBelow.append(sum(self.slide_loudest < snrValue))
    numBelow = asarray(numBelow,'f')/(2 * self.num_slides)
    return numBelow
  
  def plot_cumulative(self,figNum,figureName):
    """
    plot cumulative distribution of snrs of slide loudest events
    """
    figure(figNum)
    slideCum = self.get_cumulative()
    plot(self.snr_array, slideCum,linewidth=2,label="slide dist")
    grid()
    xlabel(self.statistic, size='x-large')
    ylabel('Probability loudest event < value', size='x-large')
    if self.zero_loudest:
      axvline(self.zero_loudest,linewidth=2,color='r',label="zero lag")
      P_b = self.get_cumulative([self.zero_loudest])[0]
      print 'cumulative probability P_b at loudest event is %.2f' % P_b
    legend()
    if figureName:
      savefig( figureName + '_slide_cumulative_dist.png' )
    return P_b
  
  def get_smooth_pdf(self, snrArray = None):
    """
    get the smooth pdf of the snrs of the slide loudest events
    """
    if not snrArray: snrArray = self.snr_array
    # plot a smoothed probability distribution
    num = [0]
    for i in range(len(snrArray) - 1):
      num.append(sum((self.slide_loudest > snrArray[i]) * \
                     (self.slide_loudest < snrArray[i+1])))
    # normalize pdf to unity                 
    num = asarray(num,'f') / ( len(self.slide_loudest) * \
        (snrArray[1] - snrArray[0]) )
    # gaussian average over 5 points
    width = 5.0
    gauss = exp(- arange(- 1.0* (self.num_slides - 1) /width, 
        1.0 * self.num_slides / width,
        1.0/width )**2 / 2) / sqrt(2.0 * pi) /width
    smooth_pb = convolve(num,gauss,mode=1)
    return smooth_pb
  
  def plot_pdf(self,figNum,figureName):
    """
    plot the smooth pdf of the snrs of the slide loudest events
    """
    figure(figNum)
    slidePDF = self.get_smooth_pdf()
    plot(self.snr_array, slidePDF, 'k',linewidth=2,label="smoothed pdf")
    xlabel(self.statistic, size='x-large')
    ylabel('pdf of loudest event', size='x-large')
    grid()
    if self.zero_loudest:
      x = arange(len(self.snr_array))
      axvline(self.zero_loudest,linewidth=2,color='r',label="zero lag")
      p_b = 0.5 * (slidePDF[max(x[self.snr_array < self.zero_loudest])] + \
                   slidePDF[min(x[self.snr_array > self.zero_loudest])] )
      print 'pdf p_b at loudest event is %.2f' % p_b
    legend()
    if figureName:
      savefig( figureName + '_slide_pdf.png' )
    return p_b
  
##############################################################################
# Class for storing the astrophysical data
##############################################################################
class astroData:
  """
  class to hold the data from astrophysical injections
  """
  def __init__(self, astroGlob, sourceFile, figName, distErrorType = None, \
      magErrorType = None):
    self.astro_inj,nocoincs = readFiles(astroGlob)
    self.source_list = read_source_file(sourceFile)
    if distErrorType or magErrorType: 
      self.source_list = add_actual_error(self.source_list,distErrorType,\
          magErrorType)
    self.fig_name = figName
    self.max_luminosity = 0
    for galaxy, params in self.source_list.iteritems():
      if params["luminosity"] > self.max_luminosity:
        self.max_galaxy = galaxy
        self.max_luminosity = params["luminosity"]
    self.count_sources()

  def count_sources(self):
    """
    store details about galaxies
    """
    self.max_sources = \
        self.astro_inj.getColumnByName('source').count(self.max_galaxy)
    self.mw_sources = \
        self.astro_inj.getColumnByName('source').count('MW') 
    self.astro_normalization = self.max_luminosity/self.max_sources

  def segment_cut(self,segmentFile):
    """
    cut injections which lie outside the given segment file
    """
    segFile = open( segmentFile , "r")
    segList = segmentsUtils.fromsegwizard(segFile)
    segFile.close()
    self.astro_inj = self.astro_inj.veto(segList.__invert__())
    self.count_sources()

  def get_values(self,column,error=None):
    """
    return the values in the specified column, 
    if error is specified, then correct values if they are distances
    """
    if (error == "Distance") and ("dist" in column):
      gal_name = self.astro_inj.getColumnByName('source')
      col_data = self.astro_inj.get_column(column)
      for i in range(len(gal_name)):
        col_data[i] *= (1 + self.source_list[gal_name[i]]['actual_delta_d'])
      return col_data

    else: return self.astro_inj.get_column(column)

  def hist_ng(self,column,edges,error=None):
    """
    return a hist of the given column, with specified edges
    """
    if error:
      gal_name = self.astro_inj.getColumnByName('source')
      lum = []
      for name in gal_name:
        if error=="Distance":
          lum.append( (1 + self.source_list[name]['actual_delta_d'])**2 ) 
        elif error=="Magnitude":
          lum.append( 10**(self.source_list[name]['actual_delta_m']/2.5) )
      return (histng(self.get_values(column,error),edges,lum) * \
              self.astro_normalization)
    else:
      return (histng(self.get_values(column),edges) * self.astro_normalization)

  def hist_2d_ng(self,col1,edges1,col2,edges2,error=None):
    """
    return a 2-d hist of columns, given edges
    """
    if error:
      gal_name = self.astro_inj.getColumnByName('source')
      lum = []
      for name in gal_name:
        if error=="Distance":
          lum.append( (1+self.source_list[name]['actual_delta_d'])**2 )  
        elif error=="Magnitude":
          lum.append( 10**(self.source_list[name]['actual_delta_m']/2.5) )
      return (square(self.get_values(col1,error), edges1, \
                     self.get_values(col2,error), edges2, lum) *\
                     self.astro_normalization)
    else:
      return (square(self.get_values(col1),edges1, \
                     self.get_values(col2),edges2) * \
                     self.astro_normalization)

  def plot_ng(self, figNum, column, edges, type = 'plot', error = None):
    """
    make a plot of ng vs column
    """
    figure(figNum)
    if type == 'hist':
      bar(edges, self.hist_ng(column,edges,error), (edges[1]-edges[0]))
      ending = '_ng_hist'
      title_text = 'Luminosity vs ' + column
    elif type == 'cum_log':
      loglog(edges, cumsum(self.hist_ng(column,edges,error)),
             linewidth=2)
      ending = '_ng_cum_log'
      title_text = 'Cumulative Luminosity vs ' + column
    elif (type == 'cum' or type == 'curvefit'):
      plot(edges, cumsum(self.hist_ng(column,edges,error)),linewidth=2)
      ending = '_ng_cum'
      title_text = 'Cumulative Luminosity vs ' + column
    else:
      plot(edges, self.hist_ng(column,edges,error),linewidth=2)
      ending = '_ng_plot'    
      title_text = 'Luminosity vs ' + column
    grid( True)
    xlim(min(edges),max(edges))
    xlabel(column, size='x-large')
    ylabel('N_10', size='x-large')
    if error == "Distance":
      title_text += ' with galaxy distance errors'
      ending += '_dist_err'
    elif error == "Magnitude":
      title_text += ' with galaxy magnitude errors'
      ending += '_mag_err'
    if type == 'curvefit':
      print 
      print "The Fitted Curve was generated using Regression method" 
      print "using the first 30 galaxies and fitting a Cubic polynomial"   
      x = arange(min(edges),max(edges),(max(edges) - min(edges))/100)
      N_Gr = 0.00611877*(x)*(x)*(x)-0.0164998*(x)*(x)+2.52*(x)
      plot(x,N_Gr,label='Fitted Curve',linewidth=2)
      ending = 'ng_cum_curvefit.png'
      legend()      
    title( title_text, size='x-large')  
    ending += '.png'
    if self.fig_name:
      savefig(self.fig_name + '_' + column + ending )

  def plot_2d_ng(self, figNum, col1,edges1,col2,edges2,error=None):
    """
    make a 2d plot of ng vs columns
    """
    figure(figNum)
    ng = self.hist_2d_ng(col1,edges1,col2,edges2,error)
    V = arange(0,ng.max(),ng.max()/40)
    contourf(edges1,edges2,ng + 0.5 * V[1],V)
    V = arange(0,ng.max(),ng.max()/10)
    contour(edges1,edges2,ng,V,colors='k',linewidths=2)
    colorbar()
    title_text = "Luminosity contour"
    ending = "_ng"
    if error == "Distance":
      title_text += ' with galaxy distance errors'
      ending += '_dist_err'
    elif error == "Magnitude":
      title_text += ' with galaxy magnitude errors'
      ending += '_mag_err'
    ending += ".png"
    xlim(min(edges1), max(edges1))
    ylim(min(edges2), max(edges2))
    xlabel(col1, size='x-large')
    ylabel(col2, size='x-large')
    title( title_text, size='x-large')
    if self.fig_name:
      savefig( self.fig_name  + '_' + col1 + '_' + \
             col2 + ending )

##############################################################################
# Class for storing the injection data
##############################################################################
class injData:
  """
  class to hold the injection data
  """
  def __init__(self,foundGlob, missedGlob, statistic, figName):
    found,self.coincs = readFiles(foundGlob,statistic)
    missed,nocoincs = readFiles(missedGlob)
    self.coincs.add_missed_sims(missed)
    self.fig_name = figName

  def get_injections(self,threshold):
    """
    extract the injections found above giventhreshold
    """
    return self.coincs.return_sim_inspirals(threshold)

  def get_values(self,column,threshold):
    """
    get the values contained in column for inj above threshold
    """
    return self.get_injections(threshold).get_column(column)

  ############################################################################
  # 1-d operations and plots
  ############################################################################
  def hist_inj(self,column,edges,threshold):
    """
    return a hist of the given column, with specified edges
    """  
    return histng(self.get_values(column,threshold), edges)
      
  def eff(self,column,edges,threshold):
    """
    get efficiency vs column, above given threshold
    """
    all_inj = histng(self.get_values(column,0), edges)
    found_inj = histng(self.get_values(column,threshold), edges)
    return found_inj / (all_inj + 1e-5)

  def mc(self,column,edges,threshold):
    """
    get mc errors for column, above given threshold
    """
    all_inj = histng(self.get_values(column,0), edges)
    found_inj = histng(self.get_values(column,threshold), edges)
    return sqrt(found_inj * (all_inj - found_inj) / (all_inj**3 + 1e-5))

  def error(self,column,edges,error,threshold):
    """
    get errors for column, above given threshold
    """
    all_val = self.get_values(column,0)
    found_val = self.get_values(column,threshold)
    if "dist" in column and \
        (error == "Waveform" or error[0].lower() == column[-1]):
      # apply the correction
      all_val = distError(all_val, errorVal[error], 0)
      found_val = distError(found_val, errorVal[error], 0)
    all_inj = histng(all_val, edges)
    found_inj = histng(found_val, edges)
    return (found_inj/(all_inj + 1e-5) - self.eff(column,edges,threshold) )

  def plot_efficiency(self, figNum, column, edges, threshold = 0, error = None):
    """
    plot efficency above threshold for column adding errors if specified
    """
    figure(figNum)
    eff = self.eff(column,edges,threshold)
    plot(edges,eff,'b',linewidth=2)
    if error:
      ending = error.lower() + ".png"
      title_text = 'Efficiency vs ' + column + ' with ' + error + ' errors'
      if error == "Monte_Carlo":
        mc = self.mc(column,edges,threshold)
        fit,errors = errorbar(edges,eff,mc,fmt=None,ecolor='r',linewidth=2)
      elif "dist" in column and \
          (error == "Waveform" or error[0].lower() == column[-1]):
        if error == "Waveform":
          fit,errors = errorbar(edges,eff, \
              xerr=([edges*errorVal["Waveform"],zeros(len(edges))]),\
              fmt=None,ecolor='g',linewidth=2)
        else:
          fit,errors = errorbar(edges,eff,xerr=(edges*errorVal[error]),\
              fmt=None,ecolor='k',linewidth=2)
      else:
        fit,errors = errorbar(edges,eff,xerr=(zeros(len(edges))),\
              fmt=None,ecolor='k',linewidth=2)
              
      for line in errors:
        matplotlib.lines.Line2D.set_linewidth(line,1)
        matplotlib.lines.Line2D.set_markeredgewidth(line,1)
    else:
      ending = "efficiency.png"
      if threshold:
        title_text = 'Efficiency vs ' + column
    grid(True)
    ylim(0, 1.1) 
    xlabel( column, size='x-large')
    ylabel('Efficiency', size='x-large')
    title(title_text, size='x-large')
    if self.fig_name:
      savefig( self.fig_name + '_' + column + "_" + ending )

  ############################################################################
  # 2-d operations and plots
  ############################################################################
  def hist_2d_inj(self,col1,edges1,col2,edges2,threshold):
    """
    return a hist of the given columns, with specified edges
    """  
    return square(self.get_values(col1,threshold), edges1, \
                  self.get_values(col2,threshold), edges2)
  
  def eff_2d(self,col1,edges1,col2,edges2,threshold):
    """
    get efficiency vs columns, above given threshold
    """
    all_inj = self.hist_2d_inj(col1,edges1,col2,edges2,0)
    found_inj = self.hist_2d_inj(col1,edges1,col2,edges2,threshold)
    return found_inj / (all_inj + 1e-5)

  def mc_2d(self,col1,edges1,col2,edges2,threshold):
    """
    get mc errors for columns, above given threshold
    """
    all_inj = self.hist_2d_inj(col1,edges1,col2,edges2,0)
    found_inj = self.hist_2d_inj(col1,edges1,col2,edges2,threshold)
    return sqrt(found_inj * (all_inj - found_inj) / (all_inj**3 + 1e-5))

  def error_2d(self,col1,edges1,col2,edges2,error,threshold):
    """
    get errors for columns, above given threshold
    """
    all = {}
    found = {}
    for col in [col1, col2]:
      all[col] = self.get_values(col,0)
      found[col] = self.get_values(col,threshold)
      if "dist" in col and (error == "Waveform" or error[0].lower() == col[-1]):
        # apply the correction
        all[col] = distError(all[col], errorVal[error], 0)
        found[col] = distError(found[col], errorVal[error], 0)
    all_inj = square(all[col1], edges1, all[col2], edges2)
    found_inj = square(found[col1], edges1, found[col2], edges2)
    return (found_inj/(all_inj + 1e-5) - \
        self.eff_2d(col1,edges1,col2,edges2,threshold) )

  def plot_injections(self, figNum, col1, edges1, col2, edges2, threshold = 0):
    """
    plot injections above threshold for column
    """
    figure(figNum)
    inj = self.hist_2d_inj(col1,edges1,col2,edges2,threshold)
    V = arange(0,inj.max(),inj.max()/40)
    contourf(edges1,edges2,inj + 0.5*V[1],V)
    V = arange(0,inj.max(),inj.max()/10)
    contour(edges1,edges2,inj,V,colors='k',linewidths=1)
    xlabel(col1, size='x-large' )
    ylabel(col2, size='x-large' )
    colorbar()
    if threshold:
      title('Number of injections found above threshold %.2f' % threshold, 
          size='x-large' )
      ending = '_inj_found_above_%.2f.png' % threshold
    else:
      title('Number of injections', size='x-large')
      ending = '_inj.png'
    if self.fig_name:
      savefig( self.fig_name + '_' + col1 + '_'  + col2 + ending )


  def plot_eff_contour(self, figNum, col1, edges1, col2, edges2, threshold):
    """
    plot efficency above threshold for columns
    """
    figure(figNum)
    eff_2d = self.eff_2d(col1, edges1, col2, edges2, threshold)
    V = arange(0,41./40,1./40)
    contourf(edges1,edges2,eff_2d + 0.5 * V[1],V)
    hold(True)
    V = arange(0.1,1,0.1)
    contour(edges1,edges2,eff_2d,V,colors='k',linewidths=1)
    xlabel(col1, size='x-large')
    ylabel(col2, size='x-large')
    colorbar()
    title('Efficiency Contour', size='x-large') 
    if self.fig_name:
      savefig( self.fig_name + '_' + col1 + '_' + col2 + '_efficiency.png' )

  def plot_mc_contour(self, figNum, col1, edges1, col2, edges2, threshold):
    """
    plot efficency above threshold for columns
    """
    figure(figNum)
    mc_2d = self.mc_2d(col1, edges1, col2, edges2, threshold)
    V = arange(0,mc_2d.max(),mc_2d.max()/40)
    contourf(edges1,edges2,mc_2d + 0.5 * V[1],V)
    hold(True)
    V = arange(0,mc_2d.max(),mc_2d.max()/10)
    contour(edges1,edges2,mc_2d,V,colors='k',linewidths=1)
    xlabel(col1, size='x-large')
    ylabel(col2, size='x-large')
    colorbar()
    title('Monte_Carlo Errors in Efficiency', size='x-large') 
    if self.fig_name:
      savefig( self.fig_name + '_' + col1 + '_' + col2 + '_mc_errors.png' )

##############################################################################
# Class for storing the injection data
##############################################################################
class injAstroData:
  """
  class to hold the time slide data, has methods to make the relevant plots
  """
  def __init__(self, xValue, yValue, nBins, figName = None, \
               xMin = None, xMax = None, yMin = None, yMax = None):
    self.x_value = xValue
    self.y_value = yValue
    self.nbins = nBins
    self.fig_name = figName
    self.x_min = xMin
    self.x_max = xMax
    self.y_min = yMin
    self.y_max = yMax
    self.astro = None
    self.inj = None

  def add_astro_data(self,astroGlob, sourceFile, distErrorType = None, \
      magErrorType = None):
    """
    add the astrophyscially distributed injections 
    """
    self.astro =  astroData(astroGlob, sourceFile, self.fig_name, \
        distErrorType, magErrorType)

  def add_found_missed(self,foundGlob, missedGlob, statistic):
    """
    add the performed injections 
    """
    self.inj = injData(foundGlob, missedGlob, statistic, self.fig_name) 

  ############################################################################
  # General stuff to fix axes etc
  ############################################################################
  def set_x_min(self, value):
    """
    set the minimum value for x 
    """
    self.x_min = value

  def set_x_max(self, value):
    """
    set the maximum value for x 
    """
    self.x_max = value

  def set_y_min(self, value):
    """
    set the minimum value for y 
    """
    self.y_min = value

  def set_y_max(self, value):
    """
    set the maximum value for y 
    """
    self.y_max = value

  def axes_square(self):
    """
    make the axes square
    """
    if self.x_min > self.y_min:
      self.set_x_min(self.y_min)
    else:
      self.set_y_min(self.x_min)
      
    if self.x_max < self.y_max:
      self.set_x_max(self.y_max)
    else:
      self.set_y_max(self.x_max)

  def axes_from_found(self):
    """
    take the axes from the found injections
    """
    if self.inj:
      self.set_x_min(0.99 * min(self.inj.get_values(self.x_value)) )
      self.set_x_max(1.01 * max(self.inj.get_values(self.x_value)) )
      self.set_y_min(0.99 * min(self.inj.get_values(self.y_value)) )
      self.set_y_max(1.01 * max(self.inj.get_values(self.y_value)) )
    
  def x_edges(self):
    """
    return the edges in the x-direction
    """
    return arange(self.x_min, self.x_max, (self.x_max - self.x_min)/self.nbins)
    
  def y_edges(self):
    """
    return the edges in the y-direction
    """
    return arange(self.y_min, self.y_max, (self.y_max - self.y_min)/self.nbins)

  ############################################################################
  # Make plots using astro data
  ############################################################################
  def plot_x_ng(self, figNum, type = 'plot',error=None):
    """
    make a plot of ng vs x-value
    """
    self.astro.plot_ng(figNum, self.x_value, self.x_edges(), type, error)

  def plot_y_ng(self, figNum, type = 'plot'):
    """
    make a plot of ng vs y-value
    """
    self.astro.plot_ng(figNum, self.y_value, self.y_edges(), type)
 
  def plot_2d_ng(self, figNum,error=None):
    """
    make a 2d plot of ng vs x-value,y-value
    """
    self.astro.plot_2d_ng(figNum, self.x_value, self.x_edges(), 
                          self.y_value, self.y_edges(),error)
    
  ############################################################################
  # Make plots using injection results
  ############################################################################
  def plot_x_eff(self, figNum, threshold = 0, error = None):
    """
    plot efficency above threshold for x-value
    """
    self.inj.plot_efficiency(figNum, self.x_value, self.x_edges(), \
        threshold, error)

  def plot_y_eff(self, figNum, threshold = 0, error = None):
    """
    plot efficency above threshold for x-value
    """
    self.inj.plot_eff(figNum, self.y_value, self.y_edges(), \
        threshold, error)

  def plot_eff_contour(self, figNum, threshold):
    """
    plot efficency above threshold for x-value, y-value
    """
    self.inj.plot_eff_contour(figNum, self.x_value, self.x_edges(), \
                              self.y_value, self.y_edges(), threshold)

  def plot_mc_contour(self, figNum, threshold):
    """
    plot mc errors above threshold for x-value, y-value
    """
    self.inj.plot_mc_contour(figNum, self.x_value, self.x_edges(), \
                              self.y_value, self.y_edges(), threshold)

  def plot_inj(self, figNum, threshold = 0):
    """
    plot injections above threshold for x-value
    """
    self.inj.plot_injections(figNum, self.x_value, self.x_edges(), \
                             self.y_value, self.y_edges(), threshold)

  ############################################################################
  # Make plots using injection results and astrophysical distributions
  ############################################################################
  def plot_search_x_ng(self, figNum, threshold):
    """
    plot number of galaxies searched
    """
    figure(figNum)
    xng_search = self.inj.eff(self.x_value, self.x_edges(), threshold) * \
                 self.astro.hist_ng(self.x_value, self.x_edges())
    plot(self.x_edges(),cumsum(xng_search),linewidth=2)
    grid( True )
    xlabel( self.x_value, size='x-large' )
    ylabel('N_10' , size='x-large')
    title( 'Cumulative Search Luminosity vs ' + self.x_value, size='x-large')
    if self.fig_name:
      savefig( self.fig_name + '_' + self.x_value + '_ng_search_cum.png' )

  def get_search_x_ng(self, threshold, astroError=None):
    """
    get the number of galaxies searched using x integral
    """
    return sum(self.inj.eff(self.x_value, self.x_edges(), threshold) * \
               self.astro.hist_ng(self.x_value, self.x_edges(), astroError) )

  def get_search_x_error(self, error, threshold):
    """
    get the error on number of galaxies searched using x integral
    """
    if error == "Monte_Carlo":
      return sqrt( sum(self.inj.mc(self.x_value, self.x_edges(), threshold)**2\
           * self.astro.hist_ng(self.x_value, self.x_edges()) ))
    else:
      return sum(self.inj.error(self.x_value,self.x_edges(),error,threshold) \
           * self.astro.hist_ng(self.x_value, self.x_edges()) )
     
  def get_search_2d_ng(self, threshold, astroError=None):
    """
    get the number of galaxies searched using 2d integral
    """
    return sum(sum(self.inj.eff_2d(self.x_value, self.x_edges(), self.y_value, \
                   self.y_edges(), threshold) * \
                   self.astro.hist_2d_ng(self.x_value, self.x_edges(), \
                   self.y_value, self.y_edges(), astroError) ))

  def get_search_2d_error(self, error, threshold):
    """
    get the monte carlo error on number of galaxies searched using 2d integral
    """
    if error == "Monte_Carlo":
      return sqrt( sum(sum( self.inj.mc_2d(self.x_value, self.x_edges(), \
                   self.y_value, self.y_edges(), threshold)**2 * \
                   self.astro.hist_2d_ng(self.x_value, self.x_edges(), \
                   self.y_value, self.y_edges()) )) )
    else:
      return sum(sum( self.inj.error_2d(self.x_value, self.x_edges(), \
                      self.y_value, self.y_edges(), error, threshold) * \
                      self.astro.hist_2d_ng(self.x_value, self.x_edges(), \
                      self.y_value, self.y_edges()) ))


##############################################################################
# Make the plot of N_G and N_G'
##############################################################################
def plot_ng_vs_stat(injAstro, slideZero, figNum, integrate, figName = None):
  """
  plot the luminosity vs statistic, using stat values taken from 
  slides/zero lag.
  @param injAstro:  an instance of the injAstroData class, containing the 
                    injections and astrophysical distributions
  @param slideZero: an instance of the slideZeroData class, containing the
                    time slides and (possibly) zero lag information.
  @param figNum:    the figure number
  @param integrate: which integral to do, either 'x', 'y' or 'xy'.
  @param figName:   the figure name
  """
  ng_array = []
  for statValue in slideZero.snr_array:
    if integrate == 'x':
      ng_array.append(injAstro.get_search_x_ng(statValue))
    elif integrate == 'y':
      ng_array.append(injAstro.get_search_y_ng(statValue))
    elif integrate == 'xy':
      ng_array.append(injAstro.get_search_2d_ng(statValue))
    
  figure(figNum)
  plot(slideZero.snr_array, ng_array, 'b', linewidth=2, label="luminosity")
  grid()
  xlabel(slideZero.statistic, size='x-large')
  ylabel('Luminosity visible above threshold', size='x-large')
  if slideZero.zero_loudest:
    axvline(slideZero.zero_loudest,linewidth=2,color='r',label="zero lag")
    if integrate == 'x':
      ng_zero = injAstro.get_search_x_ng(slideZero.zero_loudest)
      figName += "_ng_vs_stat_using_" + opts.x_value + "_integral.png"
    elif integrate == 'y':
      ng_zero = injAstro.get_search_y_ng(slideZero.zero_loudest)
      figName += "_ng_vs_stat_using_" + opts.y_value + "_integral.png"
    elif integrate == 'xy':
      ng_zero = injAstro.get_search_2d_ng(slideZero.zero_loudest)
      figName += "_ng_vs_stat_using_" + opts.x_value + "_" + opts.y_value + \
          "_integral.png"
  if figName:
      savefig( figName )

##############################################################################
# Add systematic errors to distances
##############################################################################
def distError(distance, systematic=None, random = None):
  """
  function to apply errors to the distance.
  Systematic error applied by D -> D ( 1 + systematic )
  Random error applied by D -> D * lognormal(0,random)
  @param distance:    an array of distances
  @param systematic:  the systematic error in the distance
  @param random:      the random error in the distance
  """
  if not systematic and not random:
    return None
  
  if systematic:
    #rescale distances systematically
    distance = distance * ( 1 + systematic)
  if random:
    # rescale distances randomly
    for i in range(len(distance)):
      distance[i] = distance[i] * random.lognormvariate(0,random)

  return distance

##############################################################################
# help message
usage = """\
plotnumgalaxies [options]

  Generate plots necessary to calculate an upper limit from a search.  The
  code reads in different types of data files and makes the appropriate plots.

  ----------------------------------------------------------------------------
  An astrophysical population distribution can be specified with:
  --source-file:     A list of source galaxies (such as inspsrcs.dat)
  --injection-glob:  A glob of xml files of sim inspirals, generated with the
                     source file given above.
                     
  The injections can be cut to keep only those in the relevant times, if a 
  --segment-file is specified.
  
  The luminosity distribution can be plotted against the specified
  --x-value, where this can be any column in the siminspiral table, or the 
  chirp_dist_X (where X is one of g,h,l,t,v).  
  
  The following plots can be made:

  --plot-ng:       A plot of the luminosity.
  --hist-ng:       A histogram of the luminosity (binned version of above)
  --cumulative-ng: A cumulative plot of the luminosity.
  --add-curvefit:  The above plot with a fitted curve added.
  --cum-log-ng:    A log-log plot of the cumulative luminosity.
  --plot-2d-ng:    A 2-d contour plot of the luminosity distribution.
                   (A --y-value must also be specified)
  
  If the --source-file contains distance errors for galaxies, you can add
  --distance-error which will remake the above plots taking into account the
  distance errors to the galaxies.

  ----------------------------------------------------------------------------
  Injection results from a search can be specified using:
  
  --found-glob:  A glob of xml files containing found injections and  
  --missed-glob: A glob of xml files containing missed injections
  
  In this case, the available plots are:

  --plot-efficiency:  An efficiency plot vs x-value
  --plot-effcontour:  A 2-d efficiency plot vs x-value and y-value.
  --plot-injections:  2-d contour plots of total and found injections.

  Errors can also be added, using:
  --h-calibration, --l-calibration, --waveform-systematic, --mc-errors

  ----------------------------------------------------------------------------
  If both astrophysical and injection data are given, the following additional
  results are available:

  --cum-search-ng:    The cumulative luminosity available to the search using
                      an integration over the x-value
  --cum-search-2d-ng: The cumulative luminosity available to the search using
                      a 2-d integration over the x-value and y-value
                   
  ----------------------------------------------------------------------------
  The time slide and zero lag results can be specified using:
  --slide-glob, --zero-glob
  If these are given, then you can make plots of the distributions of loudest
  slide events to estimate the background:

  --plot-cum-loudest: Plot the cumulative distribution of loudest slide events
  --plot-pdf-loudest: Plot the pdf of the loudest events from slides
  
  If the zero lag results are given, they are added to the plot.
  
  ----------------------------------------------------------------------------
  If the time-slide, injection and astrophysical results are given, then plots
  of search luminosity vs statistic value are also available using:

  --plot-ng-vs-stat
  --plot-2d-ng-vs-stat
  
  ----------------------------------------------------------------------------   
"""

##############################################################################
parser = OptionParser( usage )

# used letters: 
# abcefghijlmnopqrstuvwxyz
# BCDEFGHIJKLMNOQRSTUVWXYZ
# basics
parser.add_option("-V","--verbose",action="store_true",default=False,\
    help="print additional information when running" )

# input files
parser.add_option("-S","--source-file",action="store",type="string",\
    default=None,metavar=" SOURCES",help="full path to source file")

parser.add_option("-I","--injection-glob",action="store",type="string",\
    default=None,metavar=" INJ_GLOB",\
    help="GLOB of files containing astrophysically distributed injections")

parser.add_option("-G","--segment-file",action="store",type="string",\
    default=None,metavar=" SEG_LIST",help="full path to segment file")

parser.add_option("-g","--found-glob",action="store",type="string",\
    default=None, metavar=" FOUND_GLOB", \
    help="GLOB of found trigger/injection files to read" )
    
parser.add_option("-m","--missed-glob",action="store",type="string",\
    default=None, metavar=" MISS_GLOB", \
    help="GLOB of files containing missed injections to read" )
    
parser.add_option("-z","--zero-glob",action="store",type="string",\
    default=None, metavar=" ZERO_GLOB", \
    help="GLOB of files containing zero lag triggers" )
    
parser.add_option("-T","--slide-glob",action="store",type="string",\
    default=None, metavar=" SLIDE_GLOB", \
    help="GLOB of files containing time slide triggers" )

# statistic
parser.add_option("-K","--statistic",action="store",type="string",\
    default="effective_snr",metavar=" STAT",\
    help="coincident statistic (default = effective_snr)")

parser.add_option("-J","--num-slides",action="store",type="int",\
    default=None,metavar=" NUM_SLIDES",\
    help="number of slides")
# mass cut
parser.add_option("-L","--m-low",action="store",type="float",default=None,\
    metavar=" M_LOW", 
    help="low mass threshold in mass cut" )

parser.add_option("-H","--m-high",action="store",type="float",default=None,\
    metavar=" M_HIGH", 
    help="high mass threshold in mass cut" )

# efficiency errors
parser.add_option("-C","--h-calibration",action="store",type="float",
    default=None,metavar=" H_CAL",
    help="systematic error in h calibration, rescale distances D->(1+/-CAL)*D")
    
parser.add_option("-D","--l-calibration",action="store",type="float",
    default=None,metavar=" L_CAL",
    help="systematic error in y calibration, rescale distances D->(1+/-CAL)*D")
    
parser.add_option("-w","--waveform-systematic",action="store",type="float",
    default=None, metavar=" WAV",
    help="systematic errors in waveform, rescale distances by D->(1+WAV)*D")
    
parser.add_option("-M","--mc-errors",action="store_true",default=False,\
    help="monte carlo errors, calculated from injections performed" )

parser.add_option("-R","--distance-error",action="store",default=None,\
    metavar=" DIST_ERROR",\
    help="error in galaxy distance/luminosity due to error in distance\n" + \
    "DIST_ERROR must be one of ('positive'|'negative'|'random')" )

parser.add_option("-Z","--magnitude-error",action="store",default=None,\
    metavar=" MAG_ERROR",\
    help="error in galaxy luminosity due to error in magnitude\n" + \
    "MAG_ERROR must be one of ('positive'|'negative'|'random')" )

parser.add_option("-j","--mw-mag-error",action="store",type="float",default=0,\
    metavar=" MW_MAGERR", \
    help="errors in milky way apparent magnitude (default = 0)")

# plotting details
parser.add_option("-f","--figure-name",action="store",type="string",\
    default=None,metavar=" FNAME",\
    help="generate ps figures with name FNAME_PlotType.ps")
    
parser.add_option("-t","--title",action="store",type="string",default=None,\
    metavar=" STRING",help="title string for plots")
    
parser.add_option("-s","--show-plot",action="store_true",default=False,\
    help="display the figures on the terminal" )
        
parser.add_option("-X","--x-value",action="store",type="string",\
    default ="eff_dist_h",\
    help="Assigns x axis parameter for plot contour, (default eff_dist_h)")

parser.add_option("-x","--x-max",action="store",type="float",default = 100.0,\
    help="maximum value plotted on x axis (default 100)")

parser.add_option("-q","--x-min",action="store",type="float",default = 1e-4,\
    help="minimum value plotted on x axis (default 0.0001)")

parser.add_option("-Y","--y-value",action="store",type="string",\
    default ="mchirp",\
    help="Assigns the parameter to x axis to plot contour, (default mchirp)")

parser.add_option("-y","--y-max",action="store",type="float",default = 2.62,\
    help="maximum value plotted on y axis (default 2.62")

parser.add_option("-p","--y-min",action="store",type="float",default = 0.87,\
    help="minimum value plotted on y axis (default 0.87)")

parser.add_option("-o","--axes-from-found",action="store_true",default=False,\
    help= \
    "overwrite the default or specified axes with the max/min from found inj")

parser.add_option("-Q","--axes-square",action="store_true",default=False,\
    help="make the axis ranges for x and y equal")

parser.add_option("-n","--nbins",action="store",type="int",default=20,\
    metavar=" NBINS", 
    help="number of bins for the histogram plots (default = 20)" )


# plots to be made

# using slide/zero data
parser.add_option("-r","--plot-cum-loudest",action="store_true",
    default=False,
    help="plot the cumulative distribution of slide loudest events")

parser.add_option("-i","--plot-pdf-loudest",action="store_true",
    default=False,
    help="plot the non-cumulative distribution of slide loudest events")

# using astrophysical data
parser.add_option("-N","--plot-ng",action="store_true",default=False,\
    help="plot the astrophysical ng vs x-value")

parser.add_option("-b","--hist-ng",action="store_true",default=False,\
    help="make a histogram of ng vs x-value" )

parser.add_option("-u","--cumulative-ng",action="store_true",default=False,\
    help="make a plot of cumulative Ng vs x-value" )
    
parser.add_option("-l","--cum-log-ng",action="store_true",default=False,\
    help="make a log-log plot of ng vs x-value" )

parser.add_option("-c","--add-curvefit",action="store_true",default=False,\
    help="add a curve to fit the ng distribution" )

# using injection data
parser.add_option("-e","--plot-efficiency",action="store_true",default=False,\
    help="make a plot of efficiency vs x-value" )

parser.add_option("-E","--plot-effcontour",action="store_true",default=False,\
    help="make an efficiency contour plot of parameters x and y")

parser.add_option("-F","--plot-injections",action="store_true",default=False,\
    help="make contour plots of found and total injections")

# using injection and astrophysical data
parser.add_option("-U","--cum-search-ng",action="store_true",default=False,\
    help="make a plot of cumulative Ng for search vs x-value" )

parser.add_option("-O","--plot-2d-ng",action="store_true",default=False,\
    help="plot the astrophysical ng vs x-value")

parser.add_option("-W","--cum-search-2d-ng",action="store_true",default=False,\
    help="calculate the cumulateive number of galaxies for this search" )

# using injection, astrophysical and slide/zero data
parser.add_option("-v","--plot-ng-vs-stat",action="store_true", \
    default=False, \
    help="plot the astrophysical ng from 1-dim integral vs statistic value")

parser.add_option("-a","--plot-2d-ng-vs-stat",action="store_true",\
    default=False, \
    help="plot the astrophysical ng from 2-dim integral vs statistic value")

(opts,args) = parser.parse_args()

##############################################################################
# Check options
##############################################################################

astroPlots = False
injPlots = False

# if making plots of background:
if (opts.plot_cum_loudest or opts.plot_pdf_loudest or opts.plot_ng_vs_stat \
    or opts.plot_2d_ng_vs_stat):
  if not opts.slide_glob:
    print >>sys.stderr, "Must specify a GLOB of slide files to read\n" + \
                        "when plotting the distribution of loudest events\n" + \
                        "Enter 'plotnumgalaxies --help' for usage\n"
    sys.exit(1)
    
  if not opts.num_slides:
    print >>sys.stderr, \
      "Must specify the num_slides when plotting loudest event distributions"
    sys.exit(1)
  
# if making plots of astrophysical distribution:
if (opts.plot_ng or opts.cum_log_ng or opts.hist_ng or opts.cumulative_ng or \
    opts.cum_search_ng or opts.plot_2d_ng or opts.cum_search_2d_ng or \
    opts.plot_ng_vs_stat or opts.plot_2d_ng_vs_stat):
  astroPlots = True
  # check at least one injection file was specified
  if not opts.injection_glob:
    print >>sys.stderr, "Must specify a GLOB of injection files to read"
    print >>sys.stderr, "Enter 'plotnumgalaxies --help' for usage"
    sys.exit(1)

  # check that the source file was supplied
  if not opts.source_file:
    print >>sys.stderr, "the source list file must be supplied"
    print >>sys.stderr, "Enter 'plotnumgalaxies --help' for usage"
    sys.exit(1)


# if making plots of efficiencies:
if (opts.plot_efficiency or opts.cum_search_ng or opts.plot_effcontour or \
    opts.plot_injections or opts.cum_search_2d_ng or \
    opts.plot_ng_vs_stat or opts.plot_2d_ng_vs_stat):
  injPlots = True
  # check at least one found file was specified
  if not opts.found_glob:
    print >>sys.stderr, "Must specify a GLOB of found injection files to read"
    print >>sys.stderr, "Enter 'plotnumgalaxies --help' for usage"
    sys.exit(1)

  # check that at least one missed file was specified
  if not opts.missed_glob:
    print >>sys.stderr, "Must specify a GLOB of missed injection files to read"
    print >>sys.stderr, "Enter 'plotnumgalaxies --help' for usage"
    sys.exit(1)

# store the error values
errorVal = {}

if opts.h_calibration:
  errorVal['Hanford_Calibration'] = opts.h_calibration
  key_ini = 'Hanford_Calibration'
if opts.l_calibration:
  errorVal['Livingston_Calibration'] = opts.l_calibration
if opts.waveform_systematic:
  errorVal['Waveform'] = opts.waveform_systematic
if opts.mc_errors:
  errorVal['Monte_Carlo'] = None

figNum = 0
##############################################################################
# Create an ini file
##############################################################################
ini_file = open("png-output.ini","w")
ini_file.write("[apriori]\n")
ini_file.write("ngprime=1.0\n")

##############################################################################
# read in the time slides and zero lag
##############################################################################

# set the default threshold on statistic 
# (above 0 so missed injections are not included)
statThresh = 1e-6

if opts.slide_glob:
  if opts.verbose:
    print "Reading time slides"
  slideLoudest = slideZeroData(opts.slide_glob, opts.num_slides, opts.statistic)
  statThresh = max(slideLoudest.slide_loudest)
  
  if opts.zero_glob: 
    slideLoudest.add_zero_lag(opts.zero_glob)
    statThresh = slideLoudest.zero_loudest
  
  if opts.plot_cum_loudest: 
    figNum += 1
    P_b=slideLoudest.plot_cumulative(figNum, opts.figure_name)
    ini_file.write("pb=%f\n" % P_b)

  if opts.plot_pdf_loudest: 
    figNum += 1
    pbprime=slideLoudest.plot_pdf(figNum, opts.figure_name)
    ini_file.write("pbprime=%f\n" % pbprime)


##############################################################################
# read in the data
##############################################################################
injAstro = injAstroData(opts.x_value, opts.y_value, opts.nbins, \
                        opts.figure_name, opts.x_min, opts.x_max, \
                        opts.y_min, opts.y_max)
if astroPlots:
  if opts.verbose:
    print "Reading the astrophysical injections"
  injAstro.add_astro_data(opts.injection_glob, opts.source_file, \
      opts.distance_error, opts.magnitude_error)

  if opts.verbose:
    print 'The maximum luminosity = %.2f' % injAstro.astro.max_luminosity
    print 'The Galaxy having Maximum Luminosity is ' + \
        injAstro.astro.max_galaxy 

  if opts.segment_file:
    print 'Number of Sources in ' + injAstro.astro.max_galaxy + \
          ' before segment selection = %d' % + injAstro.astro.max_sources
    injAstro.astro.segment_cut(opts.segment_file)

  if opts.verbose:
    print 'The number of Sources in ' + injAstro.astro.max_galaxy + ' = %d' \
          % injAstro.astro.max_sources
    print 'The number of Sources in the Milky Way = %d' % \
        injAstro.astro.mw_sources
    print 'The inferred Milky Way luminosity is = %.2f' % \
        (injAstro.astro.mw_sources * injAstro.astro.max_luminosity / \
        injAstro.astro.max_sources)

if injPlots:
  if opts.verbose:
    print "Reading the found/missed injections"
  injAstro.add_found_missed(opts.found_glob, opts.missed_glob, opts.statistic)

if opts.axes_from_found: injAstro.axes_from_found()

if opts.axes_square: injAstro.axes_square()


##############################################################################
# Make plots from astrophysical distributions
##############################################################################
astroErrors = {}
if opts.distance_error: astroErrors["Distance"] = opts.distance_error
if opts.magnitude_error:astroErrors["Magnitude"] = opts.distance_error 

for astroError in astroErrors.keys() + [None]:
  if opts.plot_ng: 
    figNum += 1
    injAstro.plot_x_ng(figNum,'plot',error = astroError)
  if opts.hist_ng:
    figNum += 1
    injAstro.plot_x_ng(figNum,'hist',error = astroError)
  if opts.cumulative_ng:
    figNum += 1
    injAstro.plot_x_ng(figNum,'cum',error = astroError)
  if opts.add_curvefit:
    figNum += 1
    injAstro.plot_x_ng(figNum,'curvefit',error = astroError)
  if opts.cum_log_ng:
    figNum += 1
    injAstro.plot_x_ng(figNum,'cum_log',error = astroError)
  if opts.plot_2d_ng:
    figNum += 1
    injAstro.plot_2d_ng(figNum,error = astroError)

##############################################################################
# Make plots using found and missed injections
##############################################################################
if opts.plot_efficiency:
  figNum += 1
  injAstro.plot_x_eff(figNum, statThresh)
for key in errorVal.keys():
  figNum += 1
  injAstro.plot_x_eff(figNum, statThresh, key)
if opts.plot_effcontour:
  figNum += 1
  injAstro.plot_eff_contour(figNum, statThresh)
if opts.mc_errors:
  figNum += 1
  injAstro.plot_mc_contour(figNum, statThresh)
  
if opts.plot_injections:
  figNum += 1
  injAstro.plot_inj(figNum, 0)
  figNum += 1
  injAstro.plot_inj(figNum, statThresh)

##############################################################################
# Make plots requiring both astrophysical and injection data
##############################################################################
if opts.cum_search_ng:
  figNum += 1
  injAstro.plot_search_x_ng(figNum, statThresh)
  xng_cum = injAstro.get_search_x_ng(statThresh)
  ini_file.write("ng=%f\n" % xng_cum)
  print 
  print '1-d calculation using ' + injAstro.x_value + ' yields'
  print 'The total luminosity = %.2f L_10' % xng_cum
  for key in errorVal.keys():
    err = injAstro.get_search_x_error(key,statThresh)
    ini_file.write(key+"=%f\n" % err)
    if key == "Monte_Carlo":
      print "Monte_Carlo error gives error in luminosity = %.2f L_10" % err
    else:  
      print key + ' error of %.1f' % float(100 * errorVal[key]) + \
      '% gives error in luminosity = ' + '%.2f L_10' % err
  for key in astroErrors:
      error = injAstro.get_search_x_ng(statThresh, key) - xng_cum
      print astroErrors[key].capitalize() + " " + key + \
          " error for galaxies gives an error in luminosity = %.2f L_10" % \
          error
      ini_file.write(key+"=%f\n" % error)

if opts.cum_search_2d_ng:
  N_G = injAstro.get_search_2d_ng(statThresh)
  ini_file.write("ng=%f\n" % N_G)
  print '2-d calculation using ' + injAstro.x_value + ' and ' + \
         injAstro.y_value + ' yields'
  print "The total luminosity = %.2f L_10" % N_G    
  for key in errorVal.keys():
    err = injAstro.get_search_2d_error(key,statThresh)
    ini_file.write(key+"=%f\n" % err)
    if key == "Monte_Carlo":
      print "Monte_Carlo error gives error in luminosity = %.2f L_10" % err
    else:
      print key + ' error of %.1f' % float(100 * errorVal[key]) + \
          '% gives error in luminosity =' + ' %.2f L_10' % err
       
  for key in astroErrors:
      error = injAstro.get_search_2d_ng(statThresh, key) - N_G
      print astroErrors[key].capitalize() + " " + key + \
          " error for galaxies gives an error in luminosity = %.2f L_10" % \
          error
      ini_file.write(key+"=%f\n" % error)

##############################################################################
# Make plots requiring both astrophysical and injection data
##############################################################################
if opts.plot_ng_vs_stat:
  figNum +=1
  plot_ng_vs_stat(injAstro, slideLoudest, figNum, integrate = 'x', \
      figName = opts.figure_name)

if opts.plot_2d_ng_vs_stat:
  figNum +=1
  plot_ng_vs_stat(injAstro, slideLoudest, figNum, integrate = 'xy', \
      figName = opts.figure_name )

##############################################################################
ini_file.close()

if opts.show_plot:
  show()
