#!/usr/bin/python

import sys
import os
import re
import exceptions
import glob
import fileinput
import linecache
import string
from optparse import *
from types import *
from pylab import *
from random import *
from glue import segments
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from pylal import viz

##############################################################################
# redefine the SimInspiral columns of interest
##############################################################################
class SimInspiralCut(lsctables.LSCTableRow):
  __slots__ = {
    "waveform": "lstring",
    "geocent_end_time": "int_4s",
    "geocent_end_time_ns": "int_4s",
    "h_end_time": "int_4s",
    "h_end_time_ns": "int_4s",
    "l_end_time": "int_4s",
    "l_end_time_ns": "int_4s",
    "source": "lstring",
    "mass1": "real_4",
    "mass2": "real_4",
    "mchirp": "real_4",
    "eta": "real_4",
    "distance": "real_4",
    "eff_dist_h": "real_4",
    "eff_dist_l": "real_4",
    "eff_dist_g": "real_4",
    "eff_dist_t": "real_4",
    "eff_dist_v": "real_4" }

lsctables.SimInspiralTable.RowType = SimInspiralCut

##############################################################################
# function to read in a list of files and extract the simInspiral tables
##############################################################################
def isSimInsp(name, attrs):
  return lsctables.IsTableProperties(lsctables.SimInspiralTable, name, attrs)

def readFiles(injGlob):
  """
  read in the SimInspiralTables from a list of files
  @param fList:       list of input files
  """
  fList = glob.glob(injGlob)
  if not fList:
    print >>sys.stderr, "The glob for " + injGlob + " returned no files"
    sys.exit(1)

  output = None
  for thisFile in fList:
    doc = ligolw.Document()
    # read in SimInspiral
    f = file(thisFile)
    doc = ligolw.Document()
    ligolw.make_parser(ligolw.PartialLIGOLWContentHandler(doc, \
        isSimInsp)).parse(file(thisFile))
    simInspiralTable = doc.childNodes[0]
    if output:
      output.extend(simInspiralTable)
    else:
      output = simInspiralTable
  return output

##############################################################################
# Function to read in the source file and return a sorted list of its
# components according to the luminosity
##############################################################################
def read_source_file( source_file ):
  f = open( source_file , "r")
  lines = f.readlines()
  f.close()

  sourcelist = []
  luminosity = []

  for line in lines:
    if line[0] != '#':
      b  = string.split(line)
      if opts.delta_error:
      	c  = { 'name': b[0], 'luminosity': float(b[4]) , 'delta_d': float(b[6])}
      else:
	c = {'name': b[0], 'luminosity': float(b[4])} 	
      sourcelist.append(c)

  sort_on = "luminosity"
  decorated = [(dict_[sort_on], dict_) for dict_ in sourcelist]
  decorated.sort()
  sortedlist = [dict_ for (key, dict_) in decorated]

  return sortedlist

##############################################################################
# Chop a simInspiralTable into segments that we care about.
##############################################################################
def segmentCut ( sim_table, seglist, col_name ):
  """
  function to remove injections outside of times contained in seglist
  @param sim_table: a list of sim inspirals
  @param seglist:   a list of segments 
  @param col_name:  the column containing the time parameter
  """
  tmpTable = lsctables.New(lsctables.SimInspiralTable)

  for entry in sim_table.rows:
    end_time = getattr(entry,col_name)
    if seglist.__contains__(end_time):
      tmpTable.append(entry)

  return tmpTable

##############################################################################
# Define a Square Array
##############################################################################
def square(M,medges,mstep,D,dedges,dstep,lum_weight=None):
  
  i = 0
  ng_m_d = zeros((len(medges),len(dedges)),'d')
 
  while i < len(M):  
    k = int((M[i]-medges[0])/mstep)
    l = int((D[i]-dedges[0])/dstep)
    
    if not lum_weight:
      lum_array = 1
    else:
      lum_array = lum_weight[i]

    if (k>=0 and k<len(medges)) and (l>=0 and l<len(dedges)):
      ng_m_d[l][k] = ng_m_d[l][k] + lum_array
  
    i = i+1

  return ng_m_d
  
##############################################################################
# Define a Hist Function
##############################################################################
def histng(M,medges,mstep,lum_weight=None):
  

  i = 0
  ng_m = zeros(len(medges),'d')
 
  while i < len(M):  
      l = int((M[i]-medges[0])/mstep)
 
      if not lum_weight:
        lum_array = 1

      else: 
        lum_array = lum_weight[i]

      if (l>=0 and l<len(medges)):
        ng_m[l] = ng_m[l] + lum_array
  
      i = i+1
 
  return ng_m

    
   

##############################################################################
# Chop a simInspiralTable based on component masses.
##############################################################################
def massCut (sim_table, m_low, m_high):
  """
  function to remove injections whose masses do not lie within [m_low,m_high]
  @param sim_table: a list of sim inspirals
  @param m_low:     the low mass threshold
  @param m_high:    the high mass threshold
  """
  tmpTable = lsctables.New(lsctables.SimInspiralTable)

  for entry in sim_table.rows:
    m1 = getattr(entry,'mass1')
    m2 = getattr(entry,'mass2')
    if not (m_low and min(m1,m2) < m_low) and \
       not (m_high and max(m1,m2) > m_high):
      tmpTable.append(entry)

  return tmpTable
  
##############################################################################
# Read in a column (and if necessary calculate chirp dist)
##############################################################################
def readColumn(table_elem, column):
  """
  function to read a given column from an xml table.
  If the column is chirp_dist_X, a function is called to calculate the chirp
  distance from mchirp and effective distance for ifo X.
  @param table_elem:       a list of sim inspirals
  @param column:      name of the column to extract
  """

  if 'chirp_dist' in column:
    return chirpDistance(table_elem, column)

  return table_elem.getColumnByName(column).asarray()

##############################################################################
# Calculate the chirp distance for inspirals.
##############################################################################
def chirpDistance (sim_table, column, ref_mass = 1.4):

  effDist = 'eff_dist_' + column[-1]
  dist = sim_table.getColumnByName(effDist).asarray()
  mchirp = sim_table.getColumnByName('mchirp').asarray()

  chirpDist = dist * (  (2.**(-1./5)) * ref_mass / mchirp)**(5./6)

  return chirpDist

##############################################################################
# Add systematic errors to distances
##############################################################################
def distError(distance, systematic=None, random = None):
  """
  function to apply errors to the distance.
  Systematic error applied by D -> D ( 1 + systematic )
  Random error applied by D -> D * lognormal(0,random)
  @param distance:    an array of distances
  @param systematic:  the systematic error in the distance
  @param random:      the random error in the distance
  """
  if not systematic and not random:
    return None
  
  if systematic:
    #rescale distances systematically
    distance = distance * ( 1 + systematic)
  if random:
    # rescale distances randomly
    for i in range(len(distance)):
      distance[i] = distance[i] * lognormvariate(0,random)

  return distance

##############################################################################
# help message
usage = """\
plotnumgalaxies [options]

  Generate a set of plots of galaxy distributions.  There are two classes of
  plots which can be made.  The first require only the astrophysical
  distribution of galaxies and the second require efficiency measurements from
  a search.
  
  For the astrophysical plots, you must specify:
  
  --source-file:     A list of source galaxies (such as inspsrcs.dat)
  --injection-glob:  A glob of xml files of sim inspirals, generated with the
                     source file given above.
  
  The injections can be cut to keep only those in the relevant times, if a 
  --segment-file is specified.
  
  The number of galaxies can be plotted against the specified
  --x-value, where this can be any column in the siminspiral table, or the 
  chirp_dist_X (where X is one of g,h,l,t,v).  The plots are:
  
  1.  A plot of the number of galaxies.
  
  2.  A histogram of the number of galaxies (basically a binned version of 1).
  
  3.  A plot of the cumulative number of galaxies.
  
  3b. The above plot with a fitted curve of the cumulative number of
  
  4.  A log-log plot of number of galaxies.
  
  5.  A 2-d contour plot of the number of galaxies can be made, for this
      --y-value must also be given.
  
  In order to plot efficiencies from a search, you must specify:
  
  --glob-found:  A glob of xml files containing found injections and  
  --glob-missed: A glob of xml files containing missed injections
  
  In this case, the plots are

  6.  An efficiency plot vs x-value

  7.  The Monte Carlo errors on the efficiency.
  
  8.  The cumulative number of galaxies (taking into account the search
      efficiency).

  9.  Contour plots of the number of injections performed and found.
  
  10. A 2-d efficiency plot vs x-value and y-value.

  11. The Monte Carlo errors on the 2-d efficiency plot.

  12. A calculation of the total number of galaxies available to the
      search, using the 2-d integral.
"""

##############################################################################
parser = OptionParser( usage )

# basics
parser.add_option("-V","--verbose",action="store_true",default=False,\
    help="print additional information when running" )


# input files
parser.add_option("-S","--source-file",action="store",type="string",\
    default=None,metavar=" SOURCES",help="full path to source file")

parser.add_option("-I","--injection-glob",action="store",type="string",\
    default=None,metavar=" INJ_GLOB",\
    help="GLOB of files containing astrophysically distributed injections")

parser.add_option("-G","--segment-file",action="store",type="string",\
    default=None,metavar=" SEG_LIST",help="full path to segment file")

parser.add_option("-g","--glob-found",action="store",type="string",\
    default=None, metavar=" FOUND_GLOB", \
    help="GLOB of found trigger/injection files to read" )
    
parser.add_option("-m","--glob-missed",action="store",type="string",\
    default=None, metavar=" MISS_GLOB", \
    help="GLOB of files containing missed injections to read" )

# mass cut
parser.add_option("-L","--m-low",action="store",type="float",default=None,\
    metavar=" M_LOW", 
    help="low mass threshold in mass cut" )

parser.add_option("-H","--m-high",action="store",type="float",default=None,\
    metavar=" M_HIGH", 
    help="high mass threshold in mass cut" )

# efficiency errors
parser.add_option("-C","--h-calibration",action="store",type="float",
    default=None,metavar=" H_CAL",
    help="systematic error in h calibration, rescale distances D->(1+/-CAL)*D")
    
parser.add_option("-D","--l-calibration",action="store",type="float",
    default=None,metavar=" L_CAL",
    help="systematic error in y calibration, rescale distances D->(1+/-CAL)*D")
    
parser.add_option("-w","--waveform-systematic",action="store",type="float",
    default=None, metavar=" WAV",
    help="systematic errors in waveform, rescale distances by D->(1+WAV)*D")

parser.add_option("-R","--delta-error",action="store_true",default=False,\
    help="incorporates the change in distance due to error in distance" )

parser.add_option("-M","--mc-errors",action="store_true",default=False,\
    help="monte carlo errors, calculated from injections performed" )

# plotting details
parser.add_option("-f","--figure-name",action="store",type="string",\
    default=None,metavar=" FNAME",\
    help="generate ps figures with name FNAME_PlotType.ps")
    
parser.add_option("-t","--title",action="store",type="string",default=None,\
    metavar=" STRING",help="title string for plots")
    
parser.add_option("-s","--show-plot",action="store_true",default=False,\
    help="display the figures on the terminal" )
        
parser.add_option("-X","--x-value",action="store",type="string",\
    default ="eff_dist_h",\
    help="Assigns x axis parameter for plot contour, (default eff_dist_h)")

parser.add_option("-x","--x-max",action="store",type="float",default = 100.0,\
    help="maximum value plotted on x axis (default 100)")

parser.add_option("-q","--x-min",action="store",type="float",default = 1e-4,\
    help="minimum value plotted on x axis (default 0.0001)")

parser.add_option("-Y","--y-value",action="store",type="string",\
    default ="mchirp",\
    help="Assigns the parameter to x axis to plot contour, (default mchirp)")

parser.add_option("-y","--y-max",action="store",type="float",default = 2.62,\
    help="maximum value plotted on y axis (default 2.62")

parser.add_option("-p","--y-min",action="store",type="float",default = 0.87,\
    help="minimum value plotted on y axis (default 0.87)")

parser.add_option("-o","--axes-from-found",action="store_true",default=False,\
    help= \
    "overwrite the default or specified axes with the max/min from found inj")

parser.add_option("-Q","--axes-square",action="store_true",default=False,\
    help="make the axis ranges for x and y equal")

parser.add_option("-n","--nbins",action="store",type="int",default=20,\
    metavar=" NBINS", 
    help="number of bins for the histogram plots (default = 20)" )

parser.add_option("-B","--delta-luminosity",action="store_true",default=False,\
    help="Take into account the error in luminosity" )


# plots to be made
parser.add_option("-N","--plot-ng",action="store_true",default=False,\
    help="plot the astrophysical ng vs x-value")

parser.add_option("-b","--hist-ng",action="store_true",default=False,\
    help="make a histogram of ng vs x-value" )

parser.add_option("-u","--cumulative-ng",action="store_true",default=False,\
    help="make a plot of cumulative Ng vs x-value" )
    
parser.add_option("-l","--cum-log-ng",action="store_true",default=False,\
    help="make a log-log plot of ng vs x-value" )

parser.add_option("-c","--add-curvefit",action="store_true",default=False,\
    help="add a curve to fit the ng distribution" )

parser.add_option("-e","--plot-efficiency",action="store_true",default=False,\
    help="make a plot of efficiency vs x-value" )

parser.add_option("-U","--cum-search-ng",action="store_true",default=False,\
    help="make a plot of cumulative Ng for search vs x-value" )

parser.add_option("-E","--plot-effcontour",action="store_true",default=False,\
    help="make an efficiency contour plot of parameters x and y")

parser.add_option("-F","--plot-injections",action="store_true",default=False,\
    help="make contour plots of found and total injections")

parser.add_option("-O","--plot-2d-ng",action="store_true",default=False,\
    help="plot the astrophysical ng vs x-value")

parser.add_option("-W","--cum-search-2d-ng",action="store_true",default=False,\
    help="calculate the cumulateive number of galaxies for this search" )

(opts,args) = parser.parse_args()

##############################################################################
# Check options
##############################################################################

astro_plot = False
eff_plot = False

# if making plots of astrophysical distribution:
if (opts.plot_ng or opts.cum_log_ng or opts.hist_ng or opts.cumulative_ng or \
    opts.cum_search_ng or opts.plot_2d_ng or opts.cum_search_2d_ng):
  astro_plot = True
  # check at least one trig file was specified
  if not opts.injection_glob:
    print >>sys.stderr, "Must specify a GLOB of injection files to read"
    print >>sys.stderr, "Enter 'plotnumgalaxies --help' for usage"
    sys.exit(1)

  # check that the source file was supplied
  if not opts.source_file:
    print >>sys.stderr, "the source list file must be supplied"
    print >>sys.stderr, "Enter 'plotnumgalaxies --help' for usage"
    sys.exit(1)


# if making plots of efficiencies:
if (opts.plot_efficiency or opts.cum_search_ng or opts.plot_effcontour or \
    opts.plot_injections or opts.cum_search_2d_ng):
  eff_plot = True
  # check at least one found file was specified
  if not opts.glob_found:
    print >>sys.stderr, "Must specify a GLOB of found injection files to read"
    print >>sys.stderr, "Enter 'plotnumgalaxies --help' for usage"
    sys.exit(1)

  # check that at least one missed file was specified
  if not opts.glob_missed:
    print >>sys.stderr, "Must specify a GLOB of missed injection files to read"
    print >>sys.stderr, "Enter 'plotnumgalaxies --help' for usage"
    sys.exit(1)


##############################################################################
# read in the astrophysical injections + distributions
##############################################################################
if (astro_plot or eff_plot):
  simInspTriggers = readFiles(opts.injection_glob)

  # sourcelist sorted from smallest to largest in the luminosity
  sourcelist = read_source_file( opts.source_file )
  max_luminosity = sourcelist[-1]['luminosity']
  max_galaxy = sourcelist[-1]['name']

  if opts.verbose:
    print 'The maximum luminosity = %.2f' % max_luminosity
    print 'The Galaxy having Maximum Luminosity is ' + max_galaxy 

  # select binaries with end times inside analyzed segments
  if opts.segment_file:

    if opts.verbose:
      numSources = simInspTriggers.getColumnByName('source').count(max_galaxy)
      print 'Number of Sources in ' + max_galaxy + \
            ' before segment selection = %.2f' % numSources
    seg_file = open( opts.segment_file , "r")
    segList = segmentsUtils.fromsegwizard(seg_file)
    seg_file.close()
    simInspTriggers = segmentCut(simInspTriggers, segList , "geocent_end_time")

  
  # Determine the number of sources with highest luminousity
  numSources = simInspTriggers.getColumnByName('source').count(max_galaxy)
  mwSources = simInspTriggers.getColumnByName('source').count('MW')

  if opts.verbose:
    print 'The number of Sources in ' + max_galaxy + ' = %d' % numSources
    print 'The number of Sources in the Milky Way = %d' % mwSources
    print 'The inferred Milky Way luminosity is = %.2f' % \
         (mwSources * max_luminosity / numSources)

  # Read the relevant columns
  xAstro = readColumn(simInspTriggers,opts.x_value)
  yAstro = readColumn(simInspTriggers,opts.y_value)
   
  
  if(opts.delta_error):
    gal_name = simInspTriggers.getColumnByName('source')

    lum = []
    for i in range(len(xAstro)):
        c = 0
        lum.append(c)


    for i in range(len(sourcelist)):
       for j in range(len(gal_name)):
         if(gal_name[j]==sourcelist[i]['name']):
            lum[j] = (1+sourcelist[i]['delta_d'])**2          
         if (gal_name[j]=='MW'):
            lum[j] = 1.0


         if ('dist' in opts.x_value):  
             xAstro[j]=xAstro[j]*(1 + sourcelist[i]['delta_d'])
	 if ('dist' in opts.y_value):  
	     yAstro[j]=yAstro[j]*(1 + sourcelist[i]['delta_d'])
          
    
##############################################################################
# read in the found/missed injections
##############################################################################
if eff_plot:
  # read in the found/missed injections
  found = readFiles(opts.glob_found)
  missed = readFiles(opts.glob_missed)

  if opts.verbose:
    print "Read in " + str(found.__len__()) + " found injections"
    print "Read in " + str(missed.__len__()) + " missed injections"

  # perform the mass cut, if requested:
  if opts.m_low or opts.m_high:
    found = massCut(found, opts.m_low, opts.m_high)
    missed = massCut(missed , opts.m_low, opts.m_high)
    
    if opts.verbose:
      print "After mass cut, " + str(found.__len__()) + " found injections"
      print "After mass cut, " + str(missed.__len__()) + " missed injections"

  # extract the x-values
  xFound = readColumn(found,opts.x_value)
  xMissed = readColumn(missed,opts.x_value)
  # extract the x-values
  yFound = readColumn(found,opts.y_value)
  yMissed = readColumn(missed,opts.y_value)


  # reset the axes based on found injections
  if opts.axes_from_found:
    opts.x_max = 1.01 * max(xFound) 
    opts.x_min = 0.99 * min(xFound) 
  
    opts.y_max = 1.01 * max(yFound)
    opts.y_min = 0.99 * min(yFound)

    if opts.verbose:

      print "Overwriting max value for " + opts.x_value + \
            " with found injection max, %.2f" % opts.x_max 

      print "Overwriting min value for " + opts.x_value + \
            " with found injection min, %.2f" % opts.x_min

      print "Overwriting max value for " + opts.y_value + \
            " with found injection max, %.2f" % opts.y_max

      print "Overwriting min value for " + opts.y_value + \
            " with found injection min, %.2f" % opts.y_min

##############################################################################
# generate the bins and the square array:
##############################################################################
if opts.axes_square:
  if opts.x_min > opts.y_min:
    opts.x_min = opts.y_min
  else:
    opts.y_min = opts.x_min
  
  if opts.x_max < opts.y_max:
    opts.x_max = opts.y_max
  else:
    opts.y_max = opts.x_max

xStep = (opts.x_max - opts.x_min)/opts.nbins
yStep = (opts.y_max - opts.y_min)/opts.nbins

# for 1-d plots, extend and then delete last entry
x1Edges = arange(opts.x_min,opts.x_max + 0.9*xStep,xStep)
xEdges = arange(opts.x_min,opts.x_max,xStep)
yEdges = arange(opts.y_min,opts.y_max,yStep)

##############################################################################
# calculate ng 
##############################################################################
if astro_plot:
  
  
  if opts.delta_error:
    x_ng = histng(xAstro,x1Edges,xStep,lum)
  else:
    x_ng = histng(xAstro,x1Edges,xStep)
  
  x_ng=x_ng[0:-1]
  x_ng = x_ng*max_luminosity/numSources
  xng_cum = cumsum(x_ng)
  
 
  if opts.delta_error:
    ng = square(xAstro,xEdges,xStep,yAstro,yEdges,yStep,lum)
  else:
    ng = square(xAstro,xEdges,xStep,yAstro,yEdges,yStep)

  ng *= max_luminosity/numSources


##############################################################################
# calculate efficiencies 
##############################################################################

if eff_plot:
  # calculations for 1-d plots
  histFound,bins, stuff = hist(xFound, x1Edges)
  histMissed,bins,stuff = hist(xMissed,x1Edges)
  # delete the last entries to clean up plots:
  histFound = histFound[0:-1]
  histMissed = histMissed[0:-1]
  xEff = 1.*(histFound)/(histFound + histMissed + 1e-5)

  # calculate the MC errors
  xError = {}
  xError['Monte Carlo'] = \
      sqrt(xEff * (1. - xEff) / (histFound + histMissed + 1e-5) )

  # calculate the systematics
  xFoundError = {}
  xMissedError = {}
  errorVal = {}
  if opts.h_calibration:
    errorVal['Hanford Calibration'] = opts.h_calibration
  if opts.l_calibration:
    errorVal['Livingston Calibration'] = opts.l_calibration
  if opts.waveform_systematic:
    errorVal['Waveform'] = opts.waveform_systematic

  if 'dist' in opts.x_value:
    if len(errorVal):
      for key in errorVal.keys():
        if key == 'Waveform' or key[0].lower() == opts.x_value[-1]:
          xf = distError(xFound,errorVal[key],0)
          xm = distError(xMissed,errorVal[key],0)
          histFound,bins, stuff = hist(xf, x1Edges)
          histMissed,bins,stuff = hist(xm,x1Edges)
          # delete the last entries to clean up plots:
          histFound = histFound[0:-1]
          histMissed = histMissed[0:-1]
          xError[key] = 1.*(histFound)/(histFound + histMissed + 1e-5) - xEff
  clf()
  
  # calculations for 2D plots: 

  found = square(xFound,xEdges,xStep,yFound,yEdges,yStep)
  missed = square(xMissed,xEdges,xStep,yMissed,yEdges,yStep)
  
  eff2d = found/(found + missed + 1e-5) 
  error2d = {}
  error2d['Monte Carlo'] = sqrt(eff2d * (1. - eff2d) / (found + missed + 1e-5))

 

  if len(errorVal):
    for key in errorVal.keys():
      if ('dist' in opts.x_value) and \
          (key == 'Waveform' or key[0].lower() == opts.x_value[-1]):
        xf = distError(xFound,errorVal[key],0)
        xm = distError(xMissed,errorVal[key],0)
      else:
        xf = xFound
        xm = xMissed
        
      if ('dist' in opts.y_value) and \
          (key == 'Waveform' or key[0].lower() == opts.y_value[-1]):
        yf = distError(yFound,errorVal[key],0)
        ym = distError(yMissed,errorVal[key],0)
      else:
        yf = yFound
        ym = yMissed

      f = square(xf,xEdges,xStep,yf,yEdges,yStep)
      m = square(xm,xEdges,xStep,ym,yEdges,yStep)
      error2d[key] = f/(f + m + 1e-5) - eff2d

x1Edges = x1Edges[0:-1]

##############################################################################
# make a plot of n_g vs x-value
##############################################################################
if opts.plot_ng:
  figure()
  plot( x1Edges, x_ng, linewidth = 1)
  grid( True )
  xlim(opts.x_min,opts.x_max)
  xlabel( opts.x_value, size='x-large' )
  ylabel('n_10', size='x-large' )
  title( 'Luminosity vs ' + opts.x_value, size='x-large')
  if opts.figure_name:
    savefig( opts.figure_name + '_' + opts.x_value + '_ng_plot.png' )

##############################################################################
# make a histogram of n_g vs x-value
##############################################################################
if opts.hist_ng:
  figure()
  bar(x1Edges,x_ng,xStep)
  grid( True )
  xlabel( opts.x_value, size='x-large' )
  ylabel('n_10', size='x-large' )
  title( 'Luminosity vs ' + opts.x_value, size='x-large')
  if opts.figure_name:
    savefig( opts.figure_name + '_' + opts.x_value + '_ng_hist.png' )

##############################################################################
# plot cumulative N_G
##############################################################################
if opts.cumulative_ng:
  figure()
  plot(x1Edges,xng_cum,linewidth=1,label='source file')
  grid( True )
  xlabel( opts.x_value, size='x-large' )
  ylabel('N_10' , size='x-large')
  title( 'Cumulative Luminosity vs ' + opts.x_value, size='x-large')
  if opts.figure_name:
    savefig( opts.figure_name + '_' + opts.x_value + '_ng_cum.png' )

  if opts.verbose:
    print 
    print 'The total luminosity = %.2f L_10' % max(xng_cum)

  ############################################################################
  # add a curve to fit the data
  if opts.add_curvefit:
    if opts.verbose:
      print 
      print "The Fitted Curve was generated using Regression method" 
      print "using the first 30 galaxies and fitting a Cubic polynomial"  
    
    x = arange(0,opts.x_max,opts.x_max/100)
    N_Gr = 0.00611877*(x)*(x)*(x)-0.0164998*(x)*(x)+2.52*(x)
    plot(x,N_Gr,label='Fitted Curve',linewidth=1)
    grid( True )
    xlim(0,opts.x_max)
    xlabel( 'Effective Distance (Mpc)', size='x-large' )
    ylabel( 'N_G', size='x-large')
    legend( loc=0 )
    if opts.figure_name:
      savefig(opts.figure_name + "_curvefit.png" ) 

##############################################################################
# make a loglog plot of cumulative n_g vs x-value
##############################################################################
if opts.cum_log_ng:
  figure()
  loglog( x1Edges, xng_cum, linewidth = 1)
  grid( True )
  xlim(opts.x_min,opts.x_max)
  xlabel( opts.x_value, size='x-large' )
  ylabel( 'N_10', size='x-large' )
  title( 'Cumulative Luminosity vs ' + opts.x_value, size='x-large')
  if opts.figure_name: 
    savefig( opts.figure_name + "_log_ng_cum.png" )

##############################################################################
# make an efficiency plot
##############################################################################
if opts.plot_efficiency:
  figure()
  plot(x1Edges,xEff,'b',linewidth=1)
  grid(True)
  ylim(0, 1.1) 
  xlabel( opts.x_value, size='x-large')
  ylabel('Efficiency', size='x-large')
  title('Efficiency vs ' + opts.x_value, size='x-large')
  if opts.figure_name:
    savefig( opts.figure_name + '_' + opts.x_value + '_efficiency.png' )

  text = ''
  fname = '_'
  ############################################################################
  # MC errors:
  if opts.mc_errors:
    fit,errors = errorbar(x1Edges,xEff,xError['Monte Carlo'],fmt=None,\
        ecolor='r',linewidth=1)
    for line in errors:
      matplotlib.lines.Line2D.set_linewidth(line,1)
      matplotlib.lines.Line2D.set_markeredgewidth(line,1)
    grid(True)
    ylim(0, 1.1)      
    xlabel(opts.x_value, size='x-large')
    ylabel('n_g', size='x-large')
    text += 'Monte Carlo '
    title(text + 'errors in efficiency', size='x-large')
    fname += 'mc_'
    if opts.figure_name:
      savefig( opts.figure_name + '_' + opts.x_value + '_' + fname + \
          'errors.png' )
      
  ############################################################################
  # Systematic errors:
  for key in errorVal.keys():
    if key == 'Waveform' or key[0].lower() == opts.x_value[-1]:
      if key == 'Waveform':
        fit,errors = errorbar(x1Edges,xEff,\
            xerr=([x1Edges*opts.waveform_systematic,zeros(len(x1Edges))]),\
            fmt=None,ecolor='g',linewidth=1)
        fname += "wav_"
      else:
        fit,errors = errorbar(x1Edges,xEff,xerr=(x1Edges*errorVal[key]),\
            fmt=None,ecolor='k',linewidth=1)
        fname += "cal_"
      for line in errors:
        matplotlib.lines.Line2D.set_linewidth(line,1)
        matplotlib.lines.Line2D.set_markeredgewidth(line,1)
      grid(True)
      ylim(0, 1.1)      
      xlabel(opts.x_value, size='x-large')
      ylabel('n_g', size='x-large')
      text += key + ' '
      title(text + 'systematics in efficiency', size='x-large')
      if opts.figure_name:
        savefig( opts.figure_name + '_' + opts.x_value + '_' + fname + \
            'errors.png')

##############################################################################
# plot cumulative N_G for search
##############################################################################
if opts.cum_search_ng:
  xng_cum = cumsum( x_ng * xEff)
  figure()
  plot(x1Edges,xng_cum,linewidth=1)
  grid( True )
  xlabel( opts.x_value, size='x-large' )
  ylabel('N_10' , size='x-large')
  title( 'Cumulative Luminosity vs ' + opts.x_value, size='x-large')
  if opts.figure_name:
    savefig( opts.figure_name + '_' + opts.x_value + '_ng_search_cum.png' )

  if opts.verbose:
    print 
    print '1-d calculation using ' + opts.x_value + ' yields'
    print 'The total Luminosity = %.2f L_10' % max(xng_cum)
    if len(xError):
      for key in xError.keys():
        if key == 'Monte Carlo':
          err = sqrt(sum(xError['Monte Carlo']**2 *x_ng))
          print 'Monte Carlo error in luminosity = %.2f L_10' % err
        else:
          err = sum(xError[key]*x_ng)
          print key + ' error of %.1f' % float(100 * errorVal[key]) + \
              '% gives error in luminosity = ' + '%.2f L_10' % err

##############################################################################
# Plot two dimensional efficiency contour
##############################################################################
if opts.plot_effcontour: 
  figure()
  V = arange(0,41./40,1./40)
  contourf(xEdges,yEdges,eff2d + 0.5 * V[1],V)
  hold(True)
  V = arange(0.1,1,0.1)
  contour(xEdges,yEdges,eff2d,V,colors='k',linewidths=1)
  
  xlabel(opts.x_value, size='x-large')
  ylabel(opts.y_value, size='x-large')
  colorbar()
  title('Efficiency Contour', size='x-large') 
  if opts.figure_name:
    savefig( opts.figure_name + '_' + opts.x_value + '_' + \
             opts.y_value + '_efficiency.png' )

  ############################################################################
  # MC errors:
  if opts.mc_errors:
    figure()
    V = arange(0,error2d['Monte Carlo'].max(),error2d['Monte Carlo'].max()/40)
    contourf(xEdges,yEdges,error2d['Monte Carlo'],V)
    V = arange(0,error2d['Monte Carlo'].max(),error2d['Monte Carlo'].max()/10)
    contour(xEdges,yEdges,error2d['Monte Carlo'],V,colors='k',linewidths=1)
    xlabel(opts.x_value, size='x-large')
    ylabel(opts.y_value, size='x-large')
    colorbar()
    title('Monte Carlo errors in efficiency', size='x-large')
    if opts.figure_name:
      savefig( opts.figure_name + '_' + opts.x_value + '_' + \
               opts.y_value + '_mc_errors.png' )

##############################################################################
# contour plot of found injections
##############################################################################
if opts.plot_injections:
  figure()
  V = arange(0,found.max(),found.max()/40)
  contourf(xEdges,yEdges,found + 0.5*V[1],V)
  V = arange(0,found.max(),found.max()/10)
  contour(xEdges,yEdges,found,V,colors='k',linewidths=1)
  xlabel(opts.x_value, size='x-large' )
  ylabel(opts.y_value, size='x-large' )
  colorbar()
  title('Number of found injections', size='x-large' )
  if opts.figure_name:
    savefig( opts.figure_name + '_' + opts.x_value + '_' + \
             opts.y_value + '_found_inj.png' )

##############################################################################
# contour plot of all injections
##############################################################################
if opts.plot_injections:
  figure() 
  V = arange(0,(found + missed).max(),(found + missed).max()/40)
  contourf(xEdges,yEdges,found + 0.5*V[1],V)
  hold(True)
  V = arange(0,(found + missed).max(),(found + missed).max()/10)
  contour(xEdges,yEdges,found,V,colors='k',linewidths=1)
  xlabel(opts.x_value, size='x-large')
  ylabel( opts.y_value, size='x-large')
  colorbar()
  title('Number of injections made', size='x-large')
  if opts.figure_name:
    savefig( opts.figure_name + '_' + opts.x_value + '_' + \
             opts.y_value + '_total_inj.png' )

##############################################################################
# contour plot of n_g
##############################################################################
if opts.plot_2d_ng:
  figure()
  V = arange(0,ng.max(),ng.max()/40)
  contourf(xEdges,yEdges,ng + 0.5 * V[1],V)
  V = arange(0,ng.max(),ng.max()/10)
  contour(xEdges,yEdges,ng,V,colors='k',linewidths=1)
  xlabel(opts.x_value, size='x-large')
  ylabel( opts.y_value, size='x-large')
  colorbar()
  title('n_g Contour', size='x-large')
  if opts.figure_name:
    savefig( opts.figure_name + '_' + opts.x_value + '_' + \
             opts.y_value + '_n_g.png' )

##############################################################################
# Count the Number of Galaxies.
##############################################################################
if opts.cum_search_2d_ng:
  N_G = sum(sum(ng*eff2d))
  print
  print '2-d calculation using ' + opts.x_value + ' and ' + \
         opts.y_value + ' yields'
  print "The total luminosity = %.2f L_10" % N_G                      
  if len(error2d):
    for key in error2d.keys():
      if key == 'Monte Carlo':
        err = sqrt(sum(sum(error2d['Monte Carlo']**2 *ng)))
        print 'Monte Carlo error in luminosity = %.2f L_10' % err

      else:
        err = sum(sum(error2d[key]*ng))
        print key + ' error of %.1f' % float(100 * errorVal[key]) + \
            '% gives error in luminosity = ' + '%.2f L_10' % err

##############################################################################
if opts.show_plot:
  show()
