#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


"""
Translate int_8s sngl_inspiral event_id's to ilwd:char and vice-versa.
"""


import itertools
from optparse import OptionParser
import sys


from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from pylal import llwapp
from pylal import date
from pylal import ligolw_tisi


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                  Speed Hack
#
# =============================================================================
#


#
# lal.LIGOTimeGPS is horrifically slow.  Replace its use with the C version
# from pylal.date.
#


lsctables.LIGOTimeGPS = date.LIGOTimeGPS


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog --int-to-ilwd|--ilwd-to-int [options] [file ...]",
		description = "Converts the event_id column in a sngl_inspiral table from int_8s to ilwd:char and vice-versa.  Each file named on the command line is converted in place, or if no file names are given then input is read from stdin and written to stdout.  Files whose names end in \".gz\" are assumed to be gzip-compressed."
	)
	parser.add_option("--int-to-ilwd", action = "store_true", default = False, help = "Convert int_8s IDs to ilwd:char IDs.")
	parser.add_option("--ilwd-to-int", action = "store_true", default = False, help = "Convert ilwd:char to int_8s IDs.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	if not (options.int_to_ilwd ^ options.ilwd_to_int):
		raise ValueError, "must set exactly one of --int-to-ilwd or --ilwd-to-int"
	del options.ilwd_to_int

	return options, (filenames or [None])


#
# =============================================================================
#
#                             Process Information
#
# =============================================================================
#


#
# create and initialize this job's row in the process table
#


def initialize_process(xmldoc, comment = u""):
	return llwapp.append_process(xmldoc, program = u"ligolw_convert_inspid", version = __version__, cvs_repository = u"lscsoft", cvs_entry_time = __date__, comment = comment)


#
# record command line arguments
#


def set_process_params(xmldoc, process, options):
	params = []
	if options.int_to_ilwd:
		params.append(("--int-to-ilwd", None, None))
	else:
		params.append(("--ilwd-to-int", None, None))
	llwapp.append_process_params(xmldoc, process, params)

	return xmldoc


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#


def load_filename(filename, int_to_ilwd, verbose = False, gz = False):
	#
	# set the expected column type so input validation is done
	# correctly, and initialize or clear the ID generator for
	# sngl_inspiral tables
	#

	if int_to_ilwd:
		lsctables.SnglInspiralTable.validcolumns["event_id"] = "int_8s"
		lsctables.SnglInspiralTable.next_id = lsctables.SnglInspiralID(0)
	else:
		lsctables.SnglInspiralTable.validcolumns["event_id"] = "ilwd:char"
		lsctables.SnglInspiralTable.next_id = None

	#
	# read and return the document
	#

	return utils.load_filename(filename, verbose = verbose, gz = gz)


#
# =============================================================================
#
#                          Translate event_id Column
#
# =============================================================================
#


def populate_id_column(xmldoc, table_name, column_name):
	#
	# this function adds a missing ID column to a table.  it should not
	# exist:  fix the lal table code please.
	#

	# find table
	try:
		tbl = table.get_table(xmldoc, table_name)
	except ValueError:
		# doesn't have one
		return
	try:
		# add id column
		tbl.appendColumn(column_name)
	except ValueError:
		# already has one
		pass
	else:
		# populate id column
		for row in tbl:
			setattr(row, column_name, tbl.get_next_id())


def sngl_inspiral_int_to_ilwd(xmldoc):
	#
	# fix broken tables
	#

	populate_id_column(xmldoc,  lsctables.SummValueTable.tableName, "summ_value_id")
	populate_id_column(xmldoc,  lsctables.SearchSummVarsTable.tableName, "search_summvar_id")
	populate_id_column(xmldoc,  lsctables.FilterTable.tableName, "filter_id")

	#
	# find the sngl_inspiral table
	#

	try:
		sngl_inspiral_table = table.get_table(xmldoc, lsctables.SnglInspiralTable.tableName)
	except ValueError:
		print >>sys.stderr, "document does not contain a sngl_inspiral table, will try to continue ..."
		return xmldoc

	#
	# convert the event_id attribute on every row object
	#

	for row in sngl_inspiral_table:
		row.event_id = type(sngl_inspiral_table.next_id)(row.event_id)

	#
	# update the table's list of valid column types, and the Type
	# attribute on the column element, then reset the sngl_inspiral
	# table's internal variables so that writing will work correctly
	#

	lsctables.SnglInspiralTable.validcolumns["event_id"] = "ilwd:char"
	event_id = sngl_inspiral_table.getColumnByName("event_id")
	event_id.setAttribute("Type", "ilwd:char")
	sngl_inspiral_table._update_column_info()

	#
	# done
	#

	return xmldoc


def sngl_inspiral_ilwd_to_int(xmldoc):
	#
	# find the sngl_inspiral table
	#

	try:
		sngl_inspiral_table = table.get_table(xmldoc, lsctables.SnglInspiralTable.tableName)
	except ValueError:
		print >>sys.stderr, "document does not contain a sngl_inspiral table, will try to continue ..."
		return xmldoc

	#
	# convert the event_id attribute on every row object.  the integer
	# ID index is extract with the __int__() method.
	#

	for row in sngl_inspiral_table:
		row.event_id = int(row.event_id)

	#
	# update the table's list of valid column types, and the Type
	# attribute on the column element, then reset the sngl_inspiral
	# table's internal variables so that writing will work correctly
	#

	lsctables.SnglInspiralTable.validcolumns["event_id"] = "int_8s"
	event_id = sngl_inspiral_table.getColumnByName("event_id")
	event_id.setAttribute("Type", "int_8s")
	sngl_inspiral_table._update_column_info()

	#
	# done
	#

	return xmldoc


#
# =============================================================================
#
#                          Populate time_slide Table
#
# =============================================================================
#


def populate_thinca_time_slide_table(xmldoc, process):
	"""
	Reconstruct the list of time slides from lalapps_thinca's command
	line arguments.
	"""
	#
	# find the time_slide table or add one if needed
	#

	try:
		time_slide_table = table.get_table(xmldoc, lsctables.TimeSlideTable.tableName)
	except ValueError:
		time_slide_table = lsctables.New(lsctables.TimeSlideTable)
		xmldoc.childNodes[0].appendChild(time_slide_table)
	time_slide_table.sync_next_id()

	#
	# move existing time_slide IDs out of the way
	#

	if time_slide_table.next_id < type(time_slide_table.next_id)(10000):
		time_slide_table.next_id = type(time_slide_table.next_id)(10000)
	mapping = {}
	time_slide_table.updateKeyMapping(mapping)
	for tbl in xmldoc.getElementsByTagName(time_slide_table.tagName):
		tbl.applyKeyMapping(mapping)

	#
	# identify lalapps_thinca's time slides
	#

	num_slides, = llwapp.get_process_params(xmldoc, "thinca", "--num-slides")
	offset_vector = {}
	# FIXME:  hard-coded instrument list = BAD BAD BAD.
	for instrument in ("G1", "H1", "H2", "L1", "V2"):
		try:
			offset, = llwapp.get_process_params(xmldoc, "thinca", "--%s-slide" % instrument.lower())
		except ValueError:
			# no offset for this instrument
			continue
		offset_vector[instrument] = offset

	#
	# build the time slides
	#

	def ids(num_slides):
		# implements the inspiral group's rule for mapping integer
		# offset multiplier to "slide number"
		for n in range(-num_slides, +num_slides + 1):
			if n < 0:
				yield type(time_slide_table.next_id)(5000 - n)
			elif n == 0:
				continue
			else:
				# n > 0
				yield type(time_slide_table.next_id)(n)

	for offset_vector, id in zip(ligolw_tisi.Inspiral_Num_Slides_Iter(num_slides, offset_vector), ids(num_slides)):
		for row in ligolw_tisi.RowsFromOffsetDict(offset_vector, id, process):
			time_slide_table.append(row)


def populate_coire_time_slide_table(xmldoc, process):
	#
	# FIXME:  figure out what time slides coire needs
	#
	pass


def depopulate_time_slide_table(xmldoc):
	"""
	Search for and remove duplicate time slide definitions from the
	time_slide table.
	"""
	#
	# find the time_slide table
	#

	time_slide_table = table.get_table(xmldoc, lsctables.TimeSlideTable.tableName)

	#
	# translate time_slide table into a dictionary, and identify
	# redundant IDs
	#

	mapping = ligolw_tisi.time_slides_vacuum(time_slide_table.as_dict())

	#
	# remove rows corresponding to redundant IDs
	#

	for i in xrange(len(time_slide_table) - 1, -1, -1):
		if time_slide_table[i].time_slide_id in mapping:
			del time_slide_table[i]

	#
	# reassign time_slide IDs in the rest of the document
	#

	for tbl in xmldoc.getElementsByTagName(time_slide_table.tagName):
		tbl.applyKeyMapping(mapping)


#
# =============================================================================
#
#               Populate coinc_event and coinc_event_map Tables
#
# =============================================================================
#


#
# Globally unique inspiral search types
#
# FIXME:  these definitions should be moved to some central location, e.g.
# LAL or a pyLAL module, so that other code can be kept synchronized.  It
# is here ONLY as an example of the information that needs to be provided.
#


InspiralCoincTypes = {
	"sngl--sngl": lsctables.CoincDef(search = u"inspiral", search_coinc_type = 0, description = u"sngl_inspiral<-->sngl_inspiral coincidences"),
	"sim--sngl": lsctables.CoincDef(search = u"inspiral", search_coinc_type = 1, description = u"sim_inspiral<-->sngl_inspiral coincidences")
}


#
# For sngl_inspiral <--> sngl_inspiral coincidences
#


def populate_coinc_event_sngls(xmldoc, process):
	#
	# find the sngl_inspiral table
	#

	try:
		sngl_inspiral_table = table.get_table(xmldoc, lsctables.SnglInspiralTable.tableName)
	except ValueError:
		print >>sys.stderr, "document does not contain a sngl_inspiral table, will try to continue ..."
		return

	#
	# find the coinc_definer_id for sngl_inspiral <--> sngl_inspiral
	# coincidences, or create one if needed
	#

	coinc_type = InspiralCoincTypes["sngl--sngl"]
	coinc_def_id = llwapp.get_coinc_def_id(xmldoc, coinc_type.search, coinc_type.search_coinc_type, create_new = True, description = coinc_type.description)

	#
	# find the coinc_event table or create one if needed
	#

	try:
		coinc_event = table.get_table(xmldoc, lsctables.CoincTable.tableName)
	except ValueError:
		coinc_event = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.CoincTable))

	#
	# synchronize the coinc_event table's ID generator with any
	# pre-existing rows
	#

	coinc_event.sync_next_id()

	#
	# find the coinc_event_map table or create one if needed
	#

	try:
		coinc_event_map = table.get_table(xmldoc, lsctables.CoincMapTable.tableName)
	except ValueError:
		coinc_event_map = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.CoincMapTable))

	#
	# find the time_slide table
	#

	time_slide_table = table.get_table(xmldoc, lsctables.TimeSlideTable.tableName)

	#
	# iterate over reconstructed coincs
	#

	for event_id, events in itertools.groupby(sngl_inspiral_table, lambda row: row.event_id):
		events = tuple(events)
		if len(events) < 2:
			# not a coincidence, just a single.  assign a new,
			# unique, event_id and continue.
			for event in events:
				event.event_id = sngl_inspiral_table.get_next_id()
			continue

		#
		# build a coinc_event
		#

		coinc = lsctables.Coinc()
		coinc.process_id = process.process_id
		coinc.coinc_def_id = coinc_def_id
		coinc.coinc_event_id = coinc_event.get_next_id()
		# "slide number" is at index 1 in the tuple returned by
		# get_id_parts()
		coinc.time_slide_id = type(time_slide_table.next_id)(events[0].get_id_parts()[1])
		coinc.nevents = len(events)
		coinc.likelihood = None
		coinc_event.append(coinc)

		#
		# link events to coinc with coinc_event_map rows
		#

		for event in events:
			# assign a new, unique, event_id
			event.event_id = sngl_inspiral_table.get_next_id()
			coincmap = lsctables.CoincMap()
			coincmap.coinc_event_id = coinc.coinc_event_id
			coincmap.event_id = event.event_id
			coincmap.table_name = coincmap.event_id.table_name
			coinc_event_map.append(coincmap)


#
# for sngl_inspiral <--> sim_inspiral coincidences
#


def populate_coinc_event_sims(xmldoc, process):
	#
	# find the sngl_inspiral and sim_inspiral tables
	#

	try:
		sngl_inspiral_table = table.get_table(xmldoc, lsctables.SnglInspiralTable.tableName)
	except ValueError:
		print >>sys.stderr, "document does not contain a sngl_inspiral table, will try to continue ..."
		return

	sim_inspiral = table.get_table(xmldoc, lsctables.SimInspiralTable.tableName)

	#
	# find the coinc_definer_id for sngl_inspiral <--> sim_inspiral
	# coincidences, or create one if needed
	#

	coinc_type = InspiralCoincTypes["sim--sngl"]
	coinc_def_id = llwapp.get_coinc_def_id(xmldoc, coinc_type.search, coinc_type.search_coinc_type, create_new = True, description = coinc_type.description)

	#
	# find the coinc_event table or create one if needed
	#

	try:
		coinc_event = table.get_table(xmldoc, lsctables.CoincTable.tableName)
	except ValueError:
		coinc_event = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.CoincTable))

	#
	# synchronize coinc_event table's ID generator with any
	# pre-existing rows
	#

	coinc_event.sync_next_id()

	#
	# find the coinc_event_map table or create one if needed
	#

	try:
		coinc_event_map = table.get_table(xmldoc, lsctables.CoincMapTable.tableName)
	except ValueError:
		coinc_event_map = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.CoincMapTable))

	#
	# find the time_slide table
	#

	time_slide_table = table.get_table(xmldoc, lsctables.TimeSlideTable.tableName)

	#
	# iterate over reconstructed coincs
	#

	for (event_id, events), sim in itertools.izip(itertools.groupby(sngl_inspiral_table, lambda row: row.event_id), sim_inspiral):
		events = tuple(events)

		#
		# build a coinc_event
		#

		coinc = lsctables.Coinc()
		coinc.process_id = process.process_id
		coinc.coinc_def_id = coinc_def_id
		coinc.coinc_event_id = coinc_event.get_next_id()
		# "slide number" is at index 1 in the tuple returned by
		# get_id_parts()
		coinc.time_slide_id = type(time_slide_table.next_id)(events[0].get_id_parts()[1])
		coinc.nevents = len(events)
		coinc.likelihood = None
		coinc_event.append(coinc)

		#
		# link sim and events to coinc with coinc_event_map rows
		#

		coincmap = lsctables.CoincMap()
		coincmap.coinc_event_id = coinc.coinc_event_id
		coincmap.event_id = sim.simulation_id
		coincmap.table_name = coincmap.event_id.table_name
		coinc_event_map.append(coincmap)

		for event in events:
			# assign a new, unique, event_id
			event.event_id = sngl_inspiral_table.get_next_id()
			coincmap = lsctables.CoincMap()
			coincmap.coinc_event_id = coinc.coinc_event_id
			coincmap.event_id = event.event_id
			coincmap.table_name = coincmap.event_id.table_name
			coinc_event_map.append(coincmap)


#
# =============================================================================
#
#                        Depopulate sngl_inspiral Table
#
# =============================================================================
#


def depopulate_sngl_inspiral(xmldoc):
	#
	# find the sngl_inspiral table
	#

	try:
		sngl_inspiral_table = table.get_table(xmldoc, lsctables.SnglInspiralTable.tableName)
	except ValueError:
		print >>sys.stderr, "document does not contain a sngl_inspiral table, will try to continue ..."
		return

	#
	# delete duplicates, recording replacement event_ids.  this relies
	# on the SnglInspiral class' __cmp__() method to define when two
	# triggers are the same
	#

	trigger_to_id_index = {}
	mapping = {}
	for i in xrange(len(sngl_inspiral_table) - 1, -1, -1):
		trigger = sngl_inspiral_table[i]
		if trigger in trigger_to_id_index:
			mapping[trigger.event_id] = trigger_to_id_index[trigger]
			del sngl_inspiral_table[i]
		else:
			trigger_to_id_index[trigger] = trigger.event_id

	#
	# update IDs in other tables
	#

	for tbl in xmldoc.getElementsByTagName(sngl_inspiral_table.tagName):
		tbl.applyKeyMapping(mapping)


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


options, filenames = parse_command_line()


for filename in filenames:
	#
	# read file
	#

	xmldoc = load_filename(filename, options.int_to_ilwd, verbose = options.verbose, gz = (filename or "stdin").endswith(".gz"))

	#
	# has the document been thinca'ed?
	#

	is_thinca_output = llwapp.doc_includes_process(xmldoc, "thinca")

	#
	# is the document a "found injections" list?
	#

	is_found_injections = llwapp.doc_includes_process(xmldoc, "coire") and llwapp.get_process_params(xmldoc, "coire", "--injection-file")

	#
	# create entry in process table
	#

	process = initialize_process(xmldoc)
	set_process_params(xmldoc, process, options)

	#
	# do conversion
	#

	if options.int_to_ilwd:
		#
		# construct time slide entries
		#

		if is_thinca_output:
			if options.verbose:
				print >>sys.stderr, "populating thinca time_slide table ..."
			populate_thinca_time_slide_table(xmldoc, process)
			# FIXME:  must unslide the triggers
		if is_found_injections:
			if options.verbose:
				print >>sys.stderr, "populating coire time_slide table ..."
			populate_coire_time_slide_table(xmldoc, process)

		#
		# construct coincs
		#

		if options.verbose:
			print >>sys.stderr, "constructing coincs ..."
		if is_thinca_output:
			populate_coinc_event_sngls(xmldoc, process)
		elif is_found_injections:
			populate_coinc_event_sims(xmldoc, process)

		#
		# convert event_ids
		#

		if options.verbose:
			print >>sys.stderr, "translating sngl_inspiral event_ids ..."
		sngl_inspiral_int_to_ilwd(xmldoc)

		#
		# remove duplicate sngl_inspirals and time_slides
		#

		if options.verbose:
			print >>sys.stderr, "depopulating sngl_inspirals ..."
		depopulate_sngl_inspiral(xmldoc)
		if is_found_injections or is_thinca_output:
			if options.verbose:
				print >>sys.stderr, "depopulating time_slides ..."
			depopulate_time_slide_table(xmldoc)
	else:
		# FIXME: this doesn't reconstruct inspiral-style coinc
		# files
		sngl_inspiral_ilwd_to_int(xmldoc)

	#
	# finish process metadata
	#

	llwapp.set_process_end_time(process)

	#
	# write file
	#

	utils.write_filename(xmldoc, filename, verbose = options.verbose, gz = (filename or "stdout").endswith(".gz"))
