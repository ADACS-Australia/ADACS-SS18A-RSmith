#!/usr/bin/python

import sys
import os
from optparse import *
import re
import exceptions
import glob
import ConfigParser
import random
from types import *

from pylab import *
from glue import segmentsUtils
from pylal import readMeta
from pylal import viz


#####################################################################
# function to read in and populate information about each time
def read_parameters(file,time):
  cp = ConfigParser.ConfigParser()
  cp.read(file)

  param = {}
  param["ng"] = float(cp.get("apriori","ng"))
  param["ngprime"] = float(cp.get("apriori","ngprime"))
  param["pb"] = float(cp.get("apriori","pb"))
  param["pbprime"] = float(cp.get("apriori","pbprime"))
  param["dn_calibration"] = float(cp.get("apriori","Hanford_Calibration"))
  param["dn_luminosity"] = float(cp.get("apriori","Magnitude"))
  param["dn_distance"] = float(cp.get("apriori","Distance"))
  param["dn_waveform"] = float(cp.get("apriori","Waveform"))
  param["dn_mc"] = float(cp.get("apriori","Monte_Carlo"))
  param["tobs"] = float(time)

  return param



##############################################################################
usage = """usage: %prog [options] file1 (file2 file3)

Inspiral Injection Plotting Functions

Generate a set of summary plots from an injection file to understand
which regions of parameter space are sampled.

Available plots:

1) Chirp mass accuracy can be plotted as:
  a) a function of the injected chirp mass, using --plot-mchirp
  b) a histogram, using --hist-mchirp
  c) a function of the injected effective distance, using --chirp-dist
  d) a function of the detected SNR, using --chirp-snr
The width of all these plots is set using --chirp-axis

"""
parser = OptionParser( usage )
parser.add_option("-v","--version",action="store_true",default=False,\
    help="display version information " )
parser.add_option("-p","--prior",action="store",type="string",\
    default=None,\
    help="which prior to use on the rate" )
parser.add_option("-s","--show-plot",action="store_true",default=False,\
    help="display the figures on the terminal" )
parser.add_option("-V","--verbose",action="store_true",default=False,\
    help="display verbose output" )
parser.add_option("-c","--calibration-error",action="store_true",default=False,\
    help="marginalize over the calibration error" )
parser.add_option("-g","--magnitude-error",action="store_true",default=False,\
    help="marginalize over the magnitude error" )
parser.add_option("-o","--montecarlo-error",action="store_true",default=False,\
    help="marginalize over the monte carlo error" )
parser.add_option("-w","--waveform-error",action="store_true",default=False,\
    help="marginalize over the waveform error" )
parser.add_option("-i","--distance-error",action="store_true",default=False,\
    help="marginalize over the distance error" )
parser.add_option("-f","--galaxies-file",action="append",type="string",\
    default=None, metavar=" FNAME",\
    help="File containing the output from plotnumgalaxies" ) 
parser.add_option("-t","--observation-time",action="append",type="float",\
    default=None, metavar=" TOBS", help="observation time" ) 
parser.add_option("-m","--max-rate",action="store",type="float",\
    default=200.0, metavar=" MAXRATE", \
    help="max rate on integral for posterior" ) 
parser.add_option("-d","--dr",action="store",type="float",\
    default=0.01, metavar=" MAXRATE", \
    help="dr to use in rate integral" ) 
# plotting details
parser.add_option("-F","--figure-name",action="store",type="string",\
    default=None,metavar=" FNAME",\
    help="generate ps figures with name FNAME_PlotType.ps")
parser.add_option("-x","--xmax",action="store",type="float",\
    default=200.0, metavar=" XMAX", help="maximum value on x-axis" ) 

(opts,args) = parser.parse_args()

# if --version flagged
if opts.version:
  sys.exit(0)

if not opts.prior:
  print >>sys.stderr, "Must supply a prior for calculation\n" 
  sys.exit(0)

if (len(opts.galaxies_file)-len(opts.observation_time)):
  print >>sys.stderr, "Must give same number of galaxy files and " +\
                      "observation times\n"
  sys.exit(0)

###########################################################################
# create the config parser object and read in the ini file
parameters = []
for i in range(len(opts.galaxies_file)):
  parameters.append(read_parameters(opts.galaxies_file[i],\
      opts.observation_time[i]))
  
ng = []
ngprime = []
tobs = []
pb = []
pbprime = []
dn_calibration = []
dn_lummu = []
dn_lumsigma = []
dn_distance = []
dn_mc = []
dn_waveform = []

nepochs = len(opts.galaxies_file)
for i in range(nepochs):
  ng.append(parameters[i]["ng"])
  ngprime.append(parameters[i]["ngprime"])
  tobs.append(parameters[i]["tobs"])
  pb.append(parameters[i]["pb"])
  pbprime.append(parameters[i]["pbprime"])
  dn_calibration.append(parameters[i]["dn_calibration"])
  dn_distance.append(parameters[i]["dn_distance"])
  dn_waveform.append(parameters[i]["dn_waveform"])
  dn_mc.append(parameters[i]["dn_mc"])
  dn_lummu.append(log(parameters[i]["ng"]))
  dn_lumsigma.append(log(parameters[i]["ng"]+parameters[i]["dn_luminosity"])\
      -log(parameters[i]["ng"]))


if opts.prior == "fromfile":
  rateprior = []
elif opts.prior == "uniform":
  maxrate = opts.max_rate
  dr = opts.dr
  rate = arange(0,maxrate,dr)
  rateprior = ones([int(maxrate/dr)])/maxrate

ngt = 0
ngprimet = 0
for i in range(nepochs):
  ngt += ng[i] * tobs[i]
  ngprimet += ngprime[i] * tobs[i]
  if opts.verbose:
    print "mu = %f and sigma = %f" % (dn_lummu[i],dn_lumsigma[i])
exprate = exp( - rate * ngt )
nomarginpost = rateprior * exprate \
      * ( pbprime[0] + pb[0] * rate * ngprimet )
exprate *= 0.0

for j in arange(1000):
  ngt = 0
  for i in range(nepochs):
    # magnitude error is lognormal
    if opts.magnitude_error:
      ngt += random.lognormvariate(dn_lummu[i],dn_lumsigma[i]) * tobs[i]
    else:
      ngt += ng[i] * tobs[i]
    
    # calibration error is normal
    if opts.calibration_error:
      tmpngt = -1.0
      while tmpngt < 0.0:
        tmpngt = ngt + random.normalvariate(0.0,dn_calibration[i]) \
            * tobs[i]
      ngt = tmpngt

    # monte carlo error is normal
    if opts.montecarlo_error:
      tmpngt = -1.0
      while tmpngt < 0.0:
        tmpngt = ngt + random.normalvariate(0.0,dn_mc[i]) \
            * tobs[i]
      ngt = tmpngt

    # waveform error is normal
    if opts.waveform_error:
      tmpngt = ngt + 1.0
      while (tmpngt > ngt) or (tmpngt < 0.0):
        tmpngt = ngt + random.normalvariate(0.0,dn_waveform[i]) \
            * tobs[i]
      ngt = tmpngt

    # distance error is normal
    if opts.distance_error:
      tmpngt = -1.0
      while tmpngt < 0.0:
        tmpngt = ngt + random.normalvariate(0.0,dn_distance[i]) \
            * tobs[i]
      ngt = tmpngt
  exprate += exp( - rate * ( ngt ) )
exprate /= 1000.0

marginpost = rateprior * exprate \
      * ( pbprime[0] + pb[0] * rate * ngprimet )

nomarginnorm=sum(nomarginpost)
marginnorm=sum(marginpost)

if opts.verbose:
  print "unmarginalized value at R=0 is %f" %  (nomarginpost[0]/nomarginnorm)
  print "marginalized value at R=0 is %f" % (marginpost[0]/marginnorm)

# plot the posterior pdf
plot(rate,nomarginpost/nomarginnorm,rate,marginpost/marginnorm)
legend(('posterior','marginalized posterior'))
xlabel('Rate per L10 per yr', size='x-large')
ylabel('Probability', size='x-large')
title('Posterior on the rate')
grid()
tmpv = asarray(axis())
tmpv[1]=opts.xmax
axis(tmpv)
if opts.figure_name:
  savefig( opts.figure_name + "-posterior-pdf.png")

figure()
cumnomarginpost=cumsum(nomarginpost)/nomarginnorm
cummarginpost=cumsum(marginpost)/marginnorm
if opts.verbose:
  print "unmarginalized value at R=0 is %f" %  (cumnomarginpost[1])
  print "marginalized value at R=0 is %f" % (cummarginpost[1])
semilogy(rate,1.0-cumnomarginpost,
    rate,1.0-cummarginpost)
legend(('posterior','marginalized posterior'))
xlabel('Rate per L10 per yr', size='x-large')
ylabel('Cumulative Probability', size='x-large')
title('Cumulative posterior on the rate')
grid()
axis([0,opts.xmax,0.001,1])
if opts.figure_name:
  savefig( opts.figure_name + "-posterior-cdf.png")

# print out the upper limit based on 90% confidence
for i in range(len(rate)):
  if cumnomarginpost[i] >= 0.9:
    print "The rate upper limit (before marginalization) is %f" % rate[i]
    break

for i in range(len(rate)):
  if cummarginpost[i] >= 0.9:
    print "The rate upper limit (after marginalization) is %f" % rate[i]
    break



if opts.show_plot:
  show()

