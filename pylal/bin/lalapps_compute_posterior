#!/usr/bin/python

import sys
import os
from optparse import *
import re
import exceptions
import glob
import ConfigParser
import random
from types import *

from pylab import *
from glue import segmentsUtils
from pylal import readMeta
from pylal import viz


#####################################################################
# use tex labels
params =  {'text.usetex': True }
rcParams.update(params)


#####################################################################
# function to read in and populate information about each time
def read_png_file(file):
  f = open( file , "r")
  lines = f.readlines()
  f.close()

  vals = []
  for line in lines:
    if line[0] != '#':
      vals.append([float(val) for val in line.split()[0:]])
           
  M = array(vals)

  return M

def get_png_array(pngmatrix,i,time):

  param = {}
  param["mass"] = pngmatrix[i,0]
  param["ng"] = pngmatrix[i,1]
  param["ngprime"] = pngmatrix[i,2]
  param["pb"] = pngmatrix[i,3]
  param["pbprime"] = pngmatrix[i,4]
  param["dn_lhocal"] = pngmatrix[i,5]
  param["dn_llocal"] = pngmatrix[i,6]
  param["dn_luminosity"] = pngmatrix[i,7]
  param["dn_distance"] = pngmatrix[i,8]
  param["dn_waveform"] = pngmatrix[i,9]
  param["dn_mc"] = pngmatrix[i,10]
  param["tobs"] = float(time)

  return param

#############################################################################
# function to write posterior
def write_file(rate, pdf, filename):
  """
  write out a posterior file
  @param filename: output file name
  """
  outfile = open( filename, 'w' )
  print >> outfile, "# Posterior computed using lalapps_compute_posterior"
  for i in range(len(rate)):
    print >> outfile, "%e\t%e" % (rate[i], pdf[i])
  outfile.close()


#############################################################################
# function to read posterior
def read_file( filename ):
   """
   read in the galaxy list, from an inspsrcs.dat type file
   @param source_file: input file name
   """
   f = open( filename , "r")
   lines = f.readlines()
   f.close()
 
   vals = []
   for line in lines:
     if line[0] != '#':
       vals.append([float(val) for val in line.split()[0:]])
           
   M = array(vals)
   x = M[:,0]
   y = M[:,1]

   return x,y

#############################################################################
# make steps so that fill will work properly
def makesteps(x,y):
  xnew=[]
  ynew=[y[0]]
  for i in arange(x.size-1):
    xnew.append(x[i])
    xnew.append(x[i+1])
    ynew.append(y[i])
    ynew.append(y[i+1])
  xnew.append(x[-1])

  tmpx=asarray(xnew)
  tmpy=asarray(ynew)
  tmpy1=10.0+0.0*tmpx
  xnew=concatenate((tmpx,tmpx[::-1]))
  ynew=concatenate((tmpy,tmpy1[::-1]))

  return xnew,ynew



##############################################################################
usage = """usage: %prog [options] file1 (file2 file3)

Inspiral Injection Plotting Functions

Generate a set of summary plots from an injection file to understand
which regions of parameter space are sampled.

Available plots:

1) Chirp mass accuracy can be plotted as:
  a) a function of the injected chirp mass, using --plot-mchirp
  b) a histogram, using --hist-mchirp
  c) a function of the injected effective distance, using --chirp-dist
  d) a function of the detected SNR, using --chirp-snr
The width of all these plots is set using --chirp-axis

"""
parser = OptionParser( usage )
parser.add_option("-v","--version",action="store_true",default=False,\
    help="display version information " )
parser.add_option("-p","--prior",action="store",type="string",\
    default=None,\
    help="which prior to use on the rate" )
parser.add_option("-P","--prior-file",action="store",type="string",\
    default=None, metavar=" FILE", help="name of prior file" )
parser.add_option("-s","--show-plot",action="store_true",default=False,\
    help="display the figures on the terminal" )
parser.add_option("-V","--verbose",action="store_true",default=False,\
    help="display verbose output" )
parser.add_option("-c","--calibration-error",action="store_true",default=False,\
    help="marginalize over the calibration error" )
parser.add_option("-g","--magnitude-error",action="store_true",default=False,\
    help="marginalize over the magnitude error" )
parser.add_option("-o","--montecarlo-error",action="store_true",default=False,\
    help="marginalize over the monte carlo error" )
parser.add_option("-w","--waveform-error",action="store_true",default=False,\
    help="marginalize over the waveform error" )
parser.add_option("-i","--distance-error",action="store_true",default=False,\
    help="marginalize over the distance error" )
parser.add_option("-f","--galaxies-file",action="append",type="string",\
    default=None, metavar=" FNAME",\
    help="File containing the output from plotnumgalaxies" ) 
parser.add_option("-t","--observation-time",action="append",type="float",\
    default=None, metavar=" TOBS", help="observation time" ) 
parser.add_option("-m","--max-rate",action="store",type="float",\
    default=200.0, metavar=" MAXRATE", \
    help="max rate on integral for posterior" ) 
parser.add_option("-d","--dr",action="store",type="float",\
    default=0.01, metavar=" MAXRATE", \
    help="dr to use in rate integral" ) 
parser.add_option("-n","--ntrials",action="store",type="int",\
    default=1000, metavar=" NTRIALS", help="number of trials for marginalization over errors" ) 
# plotting details
parser.add_option("-F","--figure-name",action="store",type="string",\
    default=None,metavar=" FNAME",\
    help="generate ps figures with name FNAME_PlotType.ps")
parser.add_option("-x","--xmax",action="store",type="float",\
    default=200.0, metavar=" XMAX", help="maximum value on x-axis" ) 

(opts,args) = parser.parse_args()

# if --version flagged
if opts.version:
  sys.exit(0)

if not opts.prior:
  print >>sys.stderr, "Must supply a prior for calculation\n" 
  sys.exit(0)

if (len(opts.galaxies_file)-len(opts.observation_time)):
  print >>sys.stderr, "Must give same number of galaxy files and " +\
                      "observation times\n"
  sys.exit(0)

###########################################################################
# each time-type has a different file which can have parameters for a
# sequence of different masses.  The png_matrices in an array of such
# matrices. 
png_matrices = []
for i in range(len(opts.galaxies_file)):
  png_matrices.append(read_png_file(opts.galaxies_file[i]))

ularray = zeros((len(png_matrices[0]),3),Float32)

# note len(matrix) returns the number of rows in the matrix
for k in range(len(png_matrices[0])):
  parameters = []
  for i in range(len(opts.galaxies_file)):
    parameters.append(get_png_array(png_matrices[i],k,\
        opts.observation_time[i]))
  
  mass = []
  ng = []
  ngprime = []
  tobs = []
  pb = []
  pbprime = []
  dn_lhocal = []
  dn_llocal = []
  dn_lummu = []
  dn_lumsigma = []
  dn_distance = []
  dn_mc = []
  dn_waveform = []
  
  nepochs = len(opts.galaxies_file)
  for i in range(nepochs):
    mass.append(parameters[i]["mass"])
    ng.append(parameters[i]["ng"])
    ngprime.append(parameters[i]["ngprime"])
    tobs.append(parameters[i]["tobs"])
    pb.append(parameters[i]["pb"])
    pbprime.append(parameters[i]["pbprime"])
    dn_lhocal.append(parameters[i]["dn_lhocal"])
    dn_llocal.append(parameters[i]["dn_llocal"])
    dn_distance.append(parameters[i]["dn_distance"])
    dn_waveform.append(parameters[i]["dn_waveform"])
    dn_mc.append(parameters[i]["dn_mc"])
    dn_lummu.append(log(parameters[i]["ng"]))
    dn_lumsigma.append(log(parameters[i]["ng"]+parameters[i]["dn_luminosity"])\
        -log(parameters[i]["ng"]))
  
  
  if opts.prior == "fromfile":
    rate,rateprior = read_file(opts.prior_file)
  elif opts.prior == "uniform":
    maxrate = opts.max_rate
    dr = opts.dr
    rate = arange(0,maxrate,dr)
    rateprior = ones([int(maxrate/dr)])/maxrate
  
  ngt = 0
  ngprimet = 0
  for i in range(nepochs):
    ngt += ng[i] * tobs[i]
    ngprimet += ngprime[i] * tobs[i]
    if opts.verbose:
      print "mu = %f and sigma = %f" % (dn_lummu[i],dn_lumsigma[i])
  exprate = exp( - rate * ngt )
  nomarginpost = rateprior * exprate \
        * ( pbprime[0] + pb[0] * rate * ngprimet )
  exprate *= 0.0
  
  for j in arange(opts.ntrials):
    ngt = 0
    for i in range(nepochs):
      # magnitude error is lognormal
      if opts.magnitude_error:
        ngt += random.lognormvariate(dn_lummu[i],dn_lumsigma[i]) * tobs[i]
      else:
        ngt += ng[i] * tobs[i]
      
      # lho calibration error is normal
      if ( opts.calibration_error and dn_lhocal[i] != 0.0 ):
        tmpngt = -1.0
        while tmpngt < 0.0:
          tmpngt = ngt + random.normalvariate(0.0,dn_lhocal[i]) \
              * tobs[i]
        ngt = tmpngt
  
      # llo calibration error is normal
      if ( opts.calibration_error and dn_llocal[i] != 0.0 ):
        tmpngt = -1.0
        while tmpngt < 0.0:
          tmpngt = ngt + random.normalvariate(0.0,dn_llocal[i]) \
              * tobs[i]
        ngt = tmpngt
  
      # monte carlo error is normal
      if opts.montecarlo_error:
        tmpngt = -1.0
        while tmpngt < 0.0:
          tmpngt = ngt + random.normalvariate(0.0,dn_mc[i]) \
              * tobs[i]
        ngt = tmpngt
  
      # waveform error is normal
      if opts.waveform_error:
        tmpngt = ngt + 1.0
        while (tmpngt > ngt) or (tmpngt < 0.0):
          tmpngt = ngt + random.normalvariate(0.0,dn_waveform[i]) \
              * tobs[i]
        ngt = tmpngt
  
      # distance error is normal
      if opts.distance_error:
        tmpngt = -1.0
        while tmpngt < 0.0:
          tmpngt = ngt + random.normalvariate(0.0,dn_distance[i]) \
              * tobs[i]
        ngt = tmpngt
    exprate += exp( - rate * ( ngt ) )
  exprate /= float(opts.ntrials)
  
  marginpost = rateprior * exprate \
        * ( pbprime[0] + pb[0] * rate * ngprimet )
  
  nomarginnorm=sum(nomarginpost)
  marginnorm=sum(marginpost)
  
  if opts.verbose:
    print "unmarginalized value at R=0 is %f" %  (nomarginpost[0]/nomarginnorm)
    print "marginalized value at R=0 is %f" % (marginpost[0]/marginnorm)
  
  # plot the posterior pdf
  write_file(rate, marginpost/marginnorm, opts.figure_name + "-" + str(k) + "-posterior-pdf.txt")
  plot(rate,nomarginpost/nomarginnorm,rate,marginpost/marginnorm)
  legend(('posterior','marginalized posterior'))
  xlabel('Rate per L10 per yr', size='x-large')
  ylabel('Probability', size='x-large')
  title('Posterior on the rate')
  grid()
  tmpv = asarray(axis())
  tmpv[1]=opts.xmax
  axis(tmpv)
  if opts.figure_name:
    savefig( opts.figure_name  + "-" + str(k) + "-posterior-pdf.png")
  
  figure()
  cumnomarginpost=cumsum(nomarginpost)/nomarginnorm
  cummarginpost=cumsum(marginpost)/marginnorm
  if opts.verbose:
    print "unmarginalized value at R=0 is %f" %  (cumnomarginpost[1])
    print "marginalized value at R=0 is %f" % (cummarginpost[1])
  semilogy(rate,1.0-cumnomarginpost, rate,1.0-cummarginpost)
  legend(('posterior','marginalized posterior'))
  xlabel('Rate per L10 per yr', size='x-large')
  ylabel('Cumulative Probability', size='x-large')
  title('Cumulative posterior on the rate')
  grid()
  axis([0,opts.xmax,0.001,1])
  if opts.figure_name:
    savefig( opts.figure_name  + "-" + str(k) + "-posterior-cdf.png")
  
  # print out the upper limit based on 90% confidence
  
  ularray[k,0]=mass[0]
  for i in range(len(rate)):
    if cumnomarginpost[i] >= 0.9:
      print "The rate upper limit (before marginalization) is %f" % rate[i]
      ularray[k,1]=rate[i]
      break
  
  for i in range(len(rate)):
    if cummarginpost[i] >= 0.9:
      print "The rate upper limit (after marginalization) is %f" % rate[i]
      ularray[k,2]=rate[i]
      break

# write the output to a file
ulfile = open(opts.figure_name + "-upper-limit","w")
for k in range(len(ularray)):
  ulfile.write("%e %e %e\n" % (ularray[k,0], ularray[k,1], ularray[k,2]))
ulfile.close()

# and plot this result
figure()
x1=ularray[:,0]
y1=ularray[:,1]
y2=ularray[:,2]
semilogy(x1,y1,x1,y2)

# to shade the region above the curve
x,y=makesteps(x1,y2)
p=fill(x,y, facecolor='k')
setp(p, alpha=0.3)
legend(('unmarginalized','marginalized'))
xlabel('Total mass (Msun)', size='x-large')
ylabel('Rate / yr / L$_{10}$', size='x-large')
title('Rate versus mass')
grid()
if opts.figure_name:
  savefig( opts.figure_name  + "-rate-v-mass.png")
  
# show the plots is asked
if opts.show_plot:
  show()

