#!/usr/bin/python

# $Id$

__author__ = "Drew Keppel <drew.keppel@ligo.org>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]
__name__="plotifar"
__Id__ = "$Id$"

import sys
import os
from optparse import *
import re
import exceptions
import glob
from types import *

from glue import lal
from glue import segments
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
import glue.iterutils
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils
from pylal import InspiralUtils
from numpy import histogram

import itertools
import numpy
import operator

from glue.ligolw import ligolw, table as tab, lsctables, utils

from pylal import SnglInspiralUtils, SimInspiralUtils

year = 31557600.

##############################################################################
# redefine the SnglInspiral columns of interest
##############################################################################
lsctables.SnglInspiralTable.loadcolumns = [
    "process_id",
    "ifo",
    "snr",
    "chisq",
    "chisq_dof",
    "alpha",
    "alpha1",
    "event_id"]

##############################################################################
usage = """
"""


def parse_command_line():
  """
  Parser function dedicated
  """

  parser = OptionParser( usage=usage, version="%prog CVS $Id$ " )

  # options related to input and output
  parser.add_option("-g","--glob",action="store",type="string",\
      default=None, metavar=" GLOB",help="GLOB of corse files to read" )
  parser.add_option("","--slide-glob",action="store",type="string",\
      default=None, metavar=" GLOB",help="GLOB of slide corse files to read" )
  parser.add_option("-I", "--cache-file", help="read corse filenames from cache input file")  
  parser.add_option("-O","--enable-output",action="store_true",\
      default="false",  metavar="OUTPUT",\
      help="enable the generation of the html and cache documents")
  parser.add_option("-u","--user-tag",action="store",type="string",\
      default=None, metavar=" USERTAG",\
      help="The user tag used in the name of the figures" )
  parser.add_option("","--ifo-tag",action="store",type="string",\
      default=None, metavar=" IFOTAG",\
      help="The ifo tag used in the name of the figures (e.g. SECOND_H1H2L1)")      
  parser.add_option("","--gps-start-time",action="store", type="int", metavar="GPSSTARTTIME",\
      help="gps start time used in the figure and output file names")
  parser.add_option("","--gps-end-time",action="store", type= "int", metavar="GPSENDTIME",\
      help="gps end time used in the figure and output file names")
  parser.add_option("-P","--output-path",action="store",\
      type="string",default="",  metavar="PATH",\
      help="path where the figures would be stored")
  parser.add_option("","--ifo-times",action="store",type="string",\
      default=None,metavar="IFOS",\
      help="sets ifo times for which plots will be made (e.g. H1H2L1)" )
  parser.add_option("-s","--show-plot",action="store_true",default=False,\
      help="display the figures on the terminal" )
  parser.add_option("-v","--verbose",action="store_true",\
      default=False,help="print information" )
  parser.add_option("-A","--g1-triggers",action="store_true",default=False,\
      help="input files contain triggers from G1" )
  parser.add_option("-B","--h1-triggers",action="store_true",default=False,\
      help="input files contain triggers from H1" )
  parser.add_option("-C","--h2-triggers",action="store_true",default=False,\
      help="input files contain triggers from H2" )
  parser.add_option("-D","--l1-triggers",action="store_true",default=False,\
      help="input files contain triggers from L1" )
  parser.add_option("-U","--v1-triggers",action="store_true",default=False,\
      help="input files contain triggers from V1" )


  # options used in sieving the cache file, in case it is given    
  parser.add_option("","--coinc-pattern",
      default="", metavar="COINCPATTERN",
      help="pattern for zerolag files the cache "\
           "input file  will be sieved with" )
  parser.add_option("","--match",action="store",type="string",\
      default=None,metavar="MATCH",\
      help="To sieve exactly according to a pattern, if its set True" )

  #options that set parameters specific to the plots 

  parser.add_option("","--num-categories",action="store",type= "int",
      default=1,metavar="NUM",help="number of categories plotted together")
  parser.add_option("","--combine-types",action="store_true",default=False,
      help="combine the different types together" )
  parser.add_option("--far-time-correction",action="store",type="float",\
      default=1.,metavar=" T_COR",\
      help="zero-lag time correction for FAR: FAR -> T_COR*FAR " + \
          "(for use when FAR calculated with all_data and need " + \
          "exclude_play FAR)")

  parser.add_option("","--min-ifar",action="store",type= "float",
      default=None,metavar="IFAR",help="the minimum IFAR to plot")
  parser.add_option("","--max-ifar",action="store",type= "float",
      default=None,metavar="IFAR",help="the maximum IFAR to plot")

  parser.add_option("-a","--snr-ifar",action="store_true",default=False,\
      help="plot the snr vs ifar of coinc triggers" )
  parser.add_option("-b","--ifar-dist",action="store_true",default=False,\
      help="make the cumulative distribution of IFAR" )

  parser.add_option("","--time-analyzed-file",action="store",type="string",\
      default=None,metavar="FILE",\
      help="the analyzed time file" )
  parser.add_option("--add-num-background",action="append",type="float",
      default=[],metavar="NUM",
      help="add the total number of background triggers for a category" )

  (options,args) = parser.parse_args()

  # test the input options
  if not options.ifo_times:
    raise ValueError, "--ifo-times (which ifos were analysed) must be provided"


  return options, sys.argv[1:]


# ============================================================================
# -- get command line arguments
opts, args = parse_command_line()

if not opts.glob and not opts.cache_file:
  print >>sys.stderr, "Must specify a --glob of files or --cache-input file to read"
  print >>sys.stderr, "Enter 'plotifar --help' for usage"
  sys.exit(1)

if len(opts.add_num_background) and not opts.combine_types:
  print >>sys.stderr, "--add-num-background only used with --combine-types"
  sys.exit(1)

if opts.num_categories and not opts.combine_types:
  print >>sys.stderr, "--num-categories only used with --combine-types"
  sys.exit(1)

if len(opts.add_num_background) != opts.num_categories and opts.combine_types:
  print >>sys.stderr, "Must have same number of --add-num-background as given in --num-categories"
  sys.exit(1)


#####################################################################
# -- some initialisation
opts = InspiralUtils.initialise(opts, __name__, __version__)
# -- set the proper color code
colors = InspiralUtils.colors
figure_number = 0  # used for the figure label (showplot)
fnameList = []   # use for the cache file
tagList= []   # use for the cache file


# Change to Agg back-end if show() will not be called thus avoiding display problem
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from pylal import viz
from numpy import histogram
rc('text', usetex=True)


####################################################################

statistic = CoincInspiralUtils.coincStatistic( 'effective_snr' )

plotsymbols = ['r+','bx','ko','g1']
hanfordsym = ['b+','bx','r1']
addsym = ['k+','kx','k1']

xlow = 20
xhigh = 0

##################################
# compute the background min IFARs

modifierFAR = 1.
if opts.num_categories and opts.combine_types:
  modifierFAR *= float(opts.num_categories)
if opts.far_time_correction:
  modifierFAR *= float(opts.far_time_correction)

if len(opts.add_num_background) and opts.combine_types:
  fp = open(opts.time_analyzed_file,'r')
  slideTime = 0.
  slideTimes = {}
  for line in fp.readlines():
    thisSlide,thisTime = (line.replace('\n','')).split(' ')
    if not int(thisSlide):
      zeroTime = float(thisTime)
    if int(thisSlide):
      slideTime += float(thisTime)
      slideTimes[int(thisSlide)] = float(thisTime)
  fp.close()

  numKinks=len(opts.add_num_background)
  kinks = []
  for num in opts.add_num_background:
    kinks.append(num/(slideTime/zeroTime))
  kinks.sort()
  kinks = array(kinks)*modifierFAR
  numKinks = len(kinks)-1
  A = []
  B = []
  for kink,kinkNum in zip(kinks[:-1],range(numKinks)):
    thisA = 1. - float(kinkNum)/float(numKinks + 1)
    thisB = 0.
    if len(A):
      thisB += B[-1] + A[-1]*prevKink - thisA*prevKink
    A.append(thisA)
    B.append(thisB)
    prevKink = kink
  thisA = 1./float(numKinks + 1)
  thisB = 0.
  if len(A):
    thisB += B[-1] + A[-1]*prevKink - thisA*prevKink
  A.append(thisA)
  B.append(thisB)

#######################################################
# determine IFOs and IFO combos in play

ifo_list = [ifo for ifo in ("G1", "H1", "H2", "L1", "V1") \
            if getattr(opts, "%s_triggers" % ifo.lower())]
ifo_non_h = [ifo for ifo in ifo_list if ifo[0] != "H"]

ifo_coincs = []
for num_ifos in range(2, len(ifo_list) + 1):
  ifo_coincs.extend(list(glue.iterutils.choices(ifo_list, num_ifos)))
combos = ["".join(ifos) for ifos in ifo_coincs]

###################################
# glob the list of files to read in
if opts.glob is not None or opts.cache_file is not None:
  if opts.glob is not None:
    allfiles = []
    for gl in opts.glob.split(" "):
      allfiles.extend(glob.glob(gl))
    if len(allfiles) < 1:
      print >>sys.stderr, "The glob for " + opts.glob + " returned no files" 
      sys.exit(1)

    coincfiles = []
    for file in allfiles:
      coincfiles.append(file)

  elif opts.cache_file is not None:
    allfilesCache = lal.Cache.fromfile(open(opts.cache_file))    

    coincfiles = []
    coincfiles = allfilesCache.sieve(description=opts.coinc_pattern,
        exact_match=opts.match).sieve(ifos=opts.ifo_times,exact_match=True).\
        checkfilesexist()[0].pfnlist()
        #sieve(description=opts.ifo_times, exact_match=False).\
  # check if the file lists are not empty
  if not (coincfiles):
    print >>sys.stdout, "No files match your description."
    sys.exit(1) 

if opts.slide_glob is not None:
  if opts.slide_glob is not None:
    slidefiles = []
    for gl in opts.slide_glob.split(" "):
      slidefiles.extend(glob.glob(gl))
    if len(slidefiles) < 1:
      print >>sys.stderr, "The glob for " + opts.slide_glob + " returned no files"
      sys.exit(1)
         
########################
# read in coinc triggers
inspTriggers = None
coincTriggers = CoincInspiralUtils.coincInspiralTable()

if coincfiles:
  inspTriggers = SnglInspiralUtils.\
                 ReadSnglInspiralFromFiles(coincfiles,
                                           mangle_event_id = True,
                                           verbose=opts.verbose)
  
  # construct the coincs
  coincTriggers = CoincInspiralUtils.coincInspiralTable(inspTriggers,statistic)

stats = {}
stats['IFAR'] = {}
stats['stat'] = {}
FAR = {}
IFAR = {}
cumhist ={}

maxIFAR = -numpy.inf
minIFAR = numpy.inf

for combo,ifos in zip(combos,ifo_coincs):
  coincs = coincTriggers.coinctype(ifos)
  FAR[combo] = []
  for row in coincs.getsngls(ifos[0]):
    FAR[combo].append(modifierFAR*max(row.alpha,zeroTime/slideTime))

  if len(opts.add_num_background) and opts.combine_types:
    A=array(A)
    B=array(B)
    if len(FAR[combo]):
      FAR[combo] = [(max(A[kinks >= thisFAR])*thisFAR \
          + min(B[kinks >= thisFAR])) \
          for thisFAR in FAR[combo]]

  FAR[combo] = array(FAR[combo])

  stats['stat'][combo] = coincs.getstat()
  stats['IFAR'][combo] = []
  stats['IFAR'][combo] = 1./FAR[combo]

  IFAR[combo] = list(1./FAR[combo])

  IFAR[combo].sort()
  IFAR[combo].reverse()
  IFAR[combo] = array(IFAR[combo])
  if len(coincs):
    maxIFAR = max(maxIFAR, IFAR[combo][0])
    minIFAR = min(minIFAR, IFAR[combo][-1])
  cumhist[combo] = array(range(len(IFAR[combo]))) + 1
  if opts.verbose:
    print "%s %d" % (combo,len(IFAR[combo]))

########################
# read in coinc triggers

inspTriggers = None
slideTriggers = CoincInspiralUtils.coincInspiralTable()

if slidefiles:
  inspTriggers = SnglInspiralUtils.\
                 ReadSnglInspiralFromFiles(slidefiles,
                                           mangle_event_id = True,
                                           verbose=opts.verbose)

  # construct the coincs
  slideTriggers = CoincInspiralUtils.coincInspiralTable(inspTriggers,statistic)

slideVals = {}

for slide in slideTimes.keys():
  theseSlideTriggers = slideTriggers.getslide(slide)
  slideTimeCorrection = slideTimes[slide]/zeroTime
  slideVals[slide] = {}
  slideVals[slide]['FAR'] = {}
  slideVals[slide]['IFAR'] = {}
  slideVals[slide]['cumhist'] = {}
  for combo,ifos in zip(combos,ifo_coincs):
    coincs = theseSlideTriggers.coinctype(ifos)
    slideVals[slide]['FAR'][combo] = []
    for row in coincs.getsngls(ifos[0]):
      slideVals[slide]['FAR'][combo].append(\
          slideTimeCorrection * modifierFAR * \
          max(row.alpha,slideTimes[slide]/slideTime))

    if len(opts.add_num_background) and opts.combine_types:
      A=array(A)
      B=array(B)
      if len(slideVals[slide]['FAR'][combo]):
        slideVals[slide]['FAR'][combo] = [\
            (max(A[kinks*slideTimeCorrection >= thisFAR])*thisFAR + \
             min(B[kinks*slideTimeCorrection >= thisFAR])) \
            for thisFAR in slideVals[slide]['FAR'][combo]]

    slideVals[slide]['FAR'][combo] = array(slideVals[slide]['FAR'][combo])

    slideVals[slide]['IFAR'][combo] = list(1./slideVals[slide]['FAR'][combo])
    slideVals[slide]['IFAR'][combo].sort()
    slideVals[slide]['IFAR'][combo].reverse()
    slideVals[slide]['IFAR'][combo] = array(slideVals[slide]['IFAR'][combo])
    if len(coincs):
      maxIFAR = max(maxIFAR, slideVals[slide]['IFAR'][combo][0])
      minIFAR = min(minIFAR, slideVals[slide]['IFAR'][combo][-1])
    slideVals[slide]['cumhist'][combo] = \
        array(range(len(slideVals[slide]['IFAR'][combo]))) + 1


######################################
# calculate the background line to use
if opts.verbose:
  print "calculating background line"

if opts.min_ifar:
  minIFAR = opts.min_ifar
if opts.max_ifar:
  maxIFAR = opts.max_ifar

bkgmin = 0.8*minIFAR
bkgmax = 1.2*maxIFAR
bkg = bkgmin*exp(array(range(10001))*log(bkgmax/bkgmin)/10000.)
ibkg = 1./bkg

if len(opts.add_num_background) and opts.combine_types and False:
  A=array(A)
  B=array(B)
  ibkg = [(max(list(A[kinks >= thisNum]) + [A[-1]])*thisNum \
      + min(list(B[kinks >= thisNum]) + [B[-1]])) \
      for thisNum in ibkg]

ibkg = array(ibkg)
ibkg_p1 = ibkg + sqrt(ibkg)
ibkg_m1 = array([max(x - sqrt(x), 0.1) for x in ibkg])
bkg_x1,bkg_y1 = viz.makesteps(bkg, ibkg_p1, ibkg_m1)

if True:
  if opts.verbose:
    print "normalizing FAR to be in units of yr"
  for combo in combos:
    for slide in slideTimes.keys():
      if len(slideVals[slide]['FAR'][combo]):
       slideVals[slide]['FAR'][combo] /= zeroTime/year
       slideVals[slide]['IFAR'][combo] *= zeroTime/year
    if len(FAR[combo]):
      FAR[combo] /= zeroTime/year
      IFAR[combo] *= zeroTime/year
  bkg *= zeroTime/year
  bkg_x1 *= zeroTime/year
  minIFAR *= zeroTime/year
  maxIFAR *= zeroTime/year
  if opts.min_ifar:
    opts.min_ifar *= zeroTime/year
  if opts.max_ifar:
    opts.max_ifar *= zeroTime/year


colors = itertools.cycle(('b', 'g', 'r', 'c', 'm', 'k'))
symbols = itertools.cycle(('^', 'D', 'H', 'o', '1', '+', 'x'))

################################################
# make histogram of stat distribution
if opts.ifar_dist and not opts.combine_types:
  figure(figure_number)
  figure_number += 1

  for combo,color,symbol in zip(combos,colors,symbols):
    loglog(IFAR[combo], cumhist[combo],
        color+symbol, markerfacecolor=color, markeredgecolor=color,
        alpha=0.65, label=combo)
    hold(True)
  loglog(bkg, ibkg, 'k--', linewidth=2, label='background')
  fill(bkg_x1, bkg_y1, facecolor='y', alpha=.2, label='$N^{1/2}$ errors')
  if opts.min_ifar:
    xlim(xmin=opts.min_ifar)
  else:
    xlim(xmin=0.9*minIFAR)
  if opts.max_ifar:
    xlim(xmax=opts.max_ifar)
  else:
    xlim(xmax=1.1*maxIFAR)
  ylim(ymin=0.6)
  legend()
  xlabel(r"IFAR (${\rm yr}$)", size='x-large')
  ylabel(r"Cumulative \#", size='x-large')
  if opts.enable_output is True:
    name = "cumhist_ifar"
    text = "Cumulative Histogram of IFAR distribution"
    fname = InspiralUtils.set_figure_name(opts, name)
    fname_thumb = InspiralUtils.savefig_pylal( filename=fname )
    fnameList.append(fname)
    tagList.append(text)

if opts.combine_types and opts.ifar_dist:
  figure(figure_number)
  figure_number += 1
  combinedIFAR = {}
  for slide in slideVals.keys():
    combinedIFAR['IFAR'] = [slideVals[slide]['IFAR'][combo][idx] for combo in combos for idx in range(len(slideVals[slide]['IFAR'][combo]))]
    combinedIFAR['IFAR'].sort()
    combinedIFAR['IFAR'].reverse()
    combinedIFAR['cumhist'] = arange(len(combinedIFAR['IFAR'])) + 1.
    loglog(combinedIFAR['IFAR'], combinedIFAR['cumhist'], '-',
        color=(0.5, 0.5, 0.5), alpha=0.65, label='_nolegend_')
  hold(True)
  combinedIFAR['IFAR'] = [IFAR[combo][idx] for combo in combos for idx in range(len(IFAR[combo]))]
  combinedIFAR['IFAR'].sort()
  combinedIFAR['IFAR'].reverse()
  combinedIFAR['cumhist'] = arange(len(combinedIFAR['IFAR'])) + 1.
  loglog(combinedIFAR['IFAR'], combinedIFAR['cumhist'], 'b^',
      markerfacecolor='b', markeredgecolor='b',
      alpha=0.65, label='zero-lag')
  loglog(bkg, ibkg, 'k--', linewidth=2, label='background')
#  if not len(slideVals.keys()):
  fill(bkg_x1, bkg_y1, facecolor='y', alpha=.2, label='$N^{1/2}$ errors')
  if opts.min_ifar:
    xlim(xmin=opts.min_ifar)
  else:
    xlim(xmin=0.9*minIFAR)
  if opts.max_ifar:
    xlim(xmax=opts.max_ifar)
  else:
    xlim(xmax=1.1*maxIFAR)
  ylim(ymin=0.6)
  legend()
  xlabel(r"IFAR (${\rm yr}$)", size='x-large')
  ylabel(r"Cumulative \#", size='x-large')
  if opts.enable_output is True:
    name = "cumhist_ifar_combined"
    text = "Cumulative Histogram of IFAR distribution"
    fname = InspiralUtils.set_figure_name(opts, name)
    fname_thumb = InspiralUtils.savefig_pylal( filename=fname )
    fnameList.append(fname)
    tagList.append(text)

if opts.snr_ifar:
  figure(figure_number)
  figure_number += 1
  for combo,color,symbol in zip(combos,colors,symbols):
    semilogx(stats['IFAR'][combo], stats['stat'][combo], color+symbol,
        markeredgecolor=color, alpha=0.1, label=combo)
    hold(True)
  grid(True)
  legend(loc='lower right')
  xlabel(r"IFAR (per analysis time)", size='x-large')
  ylabel(r"Combined Effective SNR", size='x-large')
  if opts.enable_output is True:
    name = "stat_vs_ifar"
    text = "Combined Effective SNR vs $1/\langle N \rangle$"
    fname = InspiralUtils.set_figure_name(opts, name)
    fname_thumb = InspiralUtils.savefig_pylal( filename=fname )
    fnameList.append(fname)
    tagList.append(text)


# ============================================================================
# final step: html, cache file generation
if opts.enable_output is True:
  html_filename = InspiralUtils.write_html_output(opts, args, fnameList, tagList)
  InspiralUtils.write_cache_output(opts, html_filename, fnameList)

# ============================================================================


if opts.show_plot:
  show()
