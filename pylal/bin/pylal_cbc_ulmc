#!/usr/bin/python
from __future__ import division

__author__ = "Thomas Dent <thomas.dent@ligo.org>"
__prog__ = "pylal_cbc_ulmc"
__title__ = "Loudest Event UL Monte Carlo simulator"

import sys
import warnings

import math
import numpy
with warnings.catch_warnings():
  warnings.simplefilter("ignore")
  import matplotlib as mpl
  mpl.use("Agg")
  #from matplotlib import pyplot as plt
import random

from optparse import *

from pylal import git_version
from pylal import upper_limit_utils as ululs

usage = """
Program to investigate the behaviour of the Loudest Event upper limit procedure
when splitting up the total analysis time into many smaller times and when Lambda
estimation in each has a statistical and/or systematic error.
"""

def parse_command_line():
  parser = OptionParser(usage=usage, version=git_version.verbose_msg)

  parser.add_option( "-m", "--n-montecarlo", action="store", type="int", default=10,\
      help="Number of MC trials to do" )

  parser.add_option( "-n", "--ntimes", action="store", type="int", default=20,\
      help="Number of times to split total analysis into: must be >1" )

  parser.add_option( "-l", "--lambda-error", action="store", type="float", default=0,\
      help="Simulated fractional error on Lambda estimation (log-normal distribution)" )

  parser.add_option( "-b", "--lambda-bias", action="store", type="float", default=1,\
      help="Simulated multiplicative bias on Lambda estimation" )

  parser.add_option( "-v", "--verbose", action="store_true", default=False,\
      help="Print FAR, Lambda, volume and effective numerator values to screen" )

  parser.add_option( "-p", "--make-plots", action="store_true", default=False,\
      help="Scatter plots of something..." )

  (options,args) = parser.parse_args()

  return options, sys.argv[1:]

##################################
# convenience functions

def rhoC_from_FAR(lambdaF):
  # lambdaF is the FAR in 1/yr
  # formula is a fit to the S6 BIC lowmass background estimation
  rhoC = 8 + numpy.log(2000/lambdaF)/numpy.log(100)
  return rhoC

def FAN_from_FAP(pF):
  # pF is the FAP
  return -1*numpy.log(1-pF)

def volume_above_rhoC(rhoC, sensemon=20):
  radius = sensemon*(8*numpy.sqrt(2)/rhoC)
  vol = 4*math.pi*radius**3/3
  return vol


###################################
############ MAIN #################
###################################

opts, args = parse_command_line()

Ttot = 1./2  # half a year
Ti = Ttot/opts.ntimes
Rsense = 20  # sensemon range in Mpc

if opts.verbose: 
  print "Sensemon range is", Rsense, "Mpc"
  print "Splitting", Ttot, "years science run into", opts.ntimes, "analysis times"
  print "Expected loudest event FAR from noise in each time is", 1./Ti, "/yr"
  print " "
  print "Expected volume / upper limit from single loudest event FAP=0.5 is"
  pF = 0.5
  lambdaF = FAN_from_FAP(pF)/Ttot
  rhoC = rhoC_from_FAR(lambdaF)
  vol = volume_above_rhoC(rhoC, sensemon=Rsense)
  Lambda = (3./numpy.log(100))/(rhoC*Ttot*lambdaF)
  mu = numpy.logspace(-numpy.log10(vol*Ttot)-2, -numpy.log10(vol*Ttot)+2, 10**5)
  likely = ululs.margLikelihood([vol*Ttot], [Lambda], mu, calerr=0, mcerrs=None)
  upperLim = ululs.compute_upper_limit(mu, likely, alpha=0.9)
  print "\t %.0d, %.3e" % (vol, upperLim)

# set up outputs
UL90s = []
eff_numerators = []

for nmc in range(opts.n_montecarlo):
  
  Lambdas = []
  estLambdas = []
  Volumes = []
  FARs = []
  for i in range(opts.ntimes):
    # FAP of loudest event in time i
    pF = random.random()
    lambdaF = FAN_from_FAP(pF)/Ti
    FARs.append(lambdaF)
    # convert FAR to a background combined SNR
    rhoC = rhoC_from_FAR(lambdaF)
    vol = volume_above_rhoC(rhoC, sensemon=Rsense)    
    Volumes.append(vol)
    # use analytic Lambda formula
    # given that background drops off with exp(-100*rhoC)
    exactLambda = (3./numpy.log(100))/(rhoC*Ti*lambdaF)
    Lambdas.append(exactLambda)
    # scatter and bias the estimated Lambdas
    estLambda = exactLambda*opts.lambda_bias*random.lognormvariate(0, opts.lambda_error)
    estLambdas.append(estLambda)

  # sample values of rate to cover the smallest and largest possible values of 1/VT
  mu = numpy.logspace(-numpy.log10(sum(Volumes)*Ti)-2, -numpy.log10(min(Volumes)*Ti)+2, 10**5)
  likely = ululs.margLikelihood([Vol*Ti for Vol in Volumes], Lambdas, mu, calerr=0, mcerrs=None)
  estLikely = ululs.margLikelihood([Vol*Ti for Vol in Volumes], estLambdas, mu, calerr=0, mcerrs=None)
  upperLim = ululs.compute_upper_limit(mu, likely, alpha=0.9)
  estupperLim = ululs.compute_upper_limit(mu, estLikely, alpha=0.9)

  # now do the calculation for the single loudest event with the smallest FAR value
  exactLambda_single = (3./numpy.log(100))/(rhoC*Ttot*min(FARs))
  # appropriate sensitive volume is the minimum among the individual times
  likely_single = ululs.margLikelihood([min(Volumes)*Ttot], [exactLambda_single], mu, calerr=0, mcerrs=None)
  upperLim_single = ululs.compute_upper_limit(mu, likely_single, alpha=0.9)

  print " "
  if opts.verbose: print "FARs /yr^-1:", [str(FAR)[0:5] for FAR in FARs] 
  if opts.verbose: print "Volumes /Mpc^3:", [int(Vol) for Vol in Volumes]
  if opts.verbose: print "Exact Lambda values:", [str(Lam)[0:5] for Lam in Lambdas]
  if opts.verbose and (opts.lambda_error or opts.lambda_bias): print "Lambda values with errors:", [str(eLam)[0:5] for eLam in estLambdas]
  print  r"90%UL from", opts.ntimes, "separate analyses: %.2e" % upperLim
  if opts.verbose: print "\t Effective numerator: %.3g" % (upperLim*sum(Volumes)*Ti)
  if (opts.lambda_error or opts.lambda_bias): print r"Factor change in 90%UL due to Lambda errors:", "%.3g" % (estupperLim/upperLim)
  if opts.verbose: print "\t Effective numerator: %.3g" % (estupperLim*sum(Volumes)*Ti)
  if opts.verbose: print "Lambda value from one single analysis: %.3f" % exactLambda_single
  print  r"90%UL from one single analysis would be", "%.2e" % upperLim_single
  if opts.verbose: print "\t Effective numerator: %.3g" % (upperLim_single*min(Volumes)*Ttot)


exit()
