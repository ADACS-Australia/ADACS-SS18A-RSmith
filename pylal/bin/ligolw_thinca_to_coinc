#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


"""
Translate thinca-style sngl_inspiral coincs to coinc-tables-style coincs.
"""


import itertools
import math
from optparse import OptionParser
import sys
import re


from glue import segments
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from glue.ligolw.utils import ligolw_add
from pylal import llwapp
from pylal import ligolw_thinca
from pylal import ligolw_tisi
from pylal import SnglInspiralUtils


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog [options] --output filename",
		description = "Converts thinca output files to coinc tables format.  Files whose names end in \".gz\" are assumed to be gzip-compressed."
	)
	parser.add_option("--zero-lag-file", help = "Thinca output file containing zero lag triggers.")
	parser.add_option("--time-slide-file", help = "Thinca output file containing time slide triggers.")
	parser.add_option("--output", help = "Output file name (required).")
	parser.add_option("--veto-segments", help = "Load veto segments from this XML document.  See ligolw_segments for information on constructing such a document.")
	parser.add_option("--veto-segments-name", help = "Set the name of the veto segments to use from the XML document.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, args = parser.parse_args()

	if not ((options.zero_lag_file or options.time_slide_file) and options.output):
		raise ValueError, "must specify --output and at least one of --zero-lag-file and --time-slide-file"
	if options.veto_segments and not options.veto_segments_name:
		raise ValueError, "must specify --veto-segments-name if --veto-sements is specified"

	if args:
		raise ValueError, "extraneous command line arguments specified"

	return options


#
# =============================================================================
#
#                             Process Information
#
# =============================================================================
#


#
# create and initialize this job's row in the process table
#


def initialize_process(xmldoc, comment = u""):
	return llwapp.append_process(xmldoc, program = u"ligolw_thinca_to_coinc", version = __version__, cvs_repository = u"lscsoft", cvs_entry_time = __date__, comment = comment)


#
# record command line arguments
#


def set_process_params(xmldoc, process, options):
	params = []
	if options.zero_lag_file:
		params.append(("--zero-lag-file", "lstring", options.zero_lag_file))
	if options.time_slide_file:
		params.append(("--time-slide-file", "lstring", options.time_slide_file))
	params.append(("--output", "lstring", options.output))

	llwapp.append_process_params(xmldoc, process, params)

	return xmldoc


#
# =============================================================================
#
#                            Add Missing ID Columns
#
# =============================================================================
#


#
# this is needed because the cbc 2yr tags are on versions of LAL that don't
# have these columns in the tables.  current versions of lal do.
#


def add_missing_id_columns(xmldoc, verbose = False):
	if verbose:
		print >>sys.stderr, "adding any missing ID columns ...",

	#
	# summ_value table
	#

	tbl = table.get_table(xmldoc, lsctables.SummValueTable.tableName)
	try:
		tbl.appendColumn("summ_value_id")
	except ValueError:
		# already has one
		pass
	else:
		if verbose:
			print >>sys.stderr, lsctables.SummValueTable.tableName,
		for row in tbl:
			row.summ_value_id = tbl.get_next_id()

	#
	# search_summvars table
	#

	tbl = table.get_table(xmldoc, lsctables.SearchSummVarsTable.tableName)
	try:
		tbl.appendColumn("search_summvar_id")
	except ValueError:
		# already has one
		pass
	else:
		if verbose:
			print >>sys.stderr, lsctables.SearchSummVarsTable.tableName,
		for row in tbl:
			row.search_summvar_id = tbl.get_next_id()

	#
	# done
	#

	if verbose:
		print >>sys.stderr


#
# =============================================================================
#
#                          Populate time_slide Table
#
# =============================================================================
#


def populate_thinca_time_slide_table(xmldoc, process, verbose = False):
	"""
	Reconstruct the list of time slides from lalapps_thinca's command
	line arguments.
	"""
	if verbose:
		print >>sys.stderr, "populating thinca time_slide table ...",

	#
	# find the time_slide table or add one if needed
	#

	try:
		time_slide_table = table.get_table(xmldoc, lsctables.TimeSlideTable.tableName)
	except ValueError:
		time_slide_table = lsctables.New(lsctables.TimeSlideTable)
		xmldoc.childNodes[0].appendChild(time_slide_table)
	time_slide_table.sync_next_id()

	#
	# move existing time_slide IDs out of the way
	#

	if time_slide_table.next_id < type(time_slide_table.next_id)(10000):
		time_slide_table.set_next_id(type(time_slide_table.next_id)(10000))
	mapping = {}
	time_slide_table.updateKeyMapping(mapping)
	for tbl in xmldoc.getElementsByTagName(time_slide_table.tagName):
		tbl.applyKeyMapping(mapping)

	#
	# identify lalapps_thinca's time slides
	#

	num_slides = None
	offset_vector = {}
        slide_option_pattern = re.compile("--(?P<ifo>[a-zA-Z][0-9])-slide")

	process_ids = table.get_table(xmldoc, lsctables.ProcessTable.tableName).get_ids_by_program("thinca")
	if not process_ids:
		raise ValueError, "document does not contain any thinca jobs"

	for row in table.get_table(xmldoc, lsctables.ProcessParamsTable.tableName):
		if row.process_id in process_ids:
			if row.param == "--num-slides":
				num_slides = row.get_pyvalue()
			else:
				match = re.search(slide_option_pattern, row.param)
				if match is not None:
					offset_vector[match.groupdict()["ifo"].upper()] = row.get_pyvalue()

	#
	# identify the instrument names in play from the search_summary
	# table
	#

	instruments = set([row.ifos for row in table.get_table(xmldoc, lsctables.SearchSummaryTable.tableName) if row.process_id in process_ids])
	if len(instruments) < 1:
		raise ValueError, "cannot find entries for thinca jobs in search_summary table"
	if len(instruments) > 1:
		raise ValueError, "search_summary table contains entries for thinca jobs from more than 1 unique set of instruments:  found %s" % ", ".join(instruments)
	instruments = instruments.pop()
	# instruments is now a single string in the form "H1H2L1".  the
	# following converts this into a set of 2-character strings in the
	# form set(["H1", "H2", "L1"]).
	instruments = [instruments]
	while len(instruments[-1]) > 2:
		instruments = instruments[:-1] + [instruments[-1][:2], instruments[-1][2:]]
	instruments = set(instruments)

	#
	# if the offset vector is empty, assume we've only loaded a
	# zero-lag thinca file, and so synthesize an all-zero vector from
	# the instruments we've retrieved from the search_summary table,
	# and set num_slides to 0.  otherwise, verify there was a
	# --num-slides option in the process_params table.
	#

	if not offset_vector:
		offset_vector = dict([(instrument, 0.0) for instrument in instruments])
		num_slides = 0
	elif num_slides is None:
		raise ValueError, "cannot find --num-slides thinca command line option in process_params table"

	#
	# remove instruments from the offset vector that are were not named
	# in the search summary table entries, and confirm that the offset
	# vector contains entries for all the instruments are were named in
	# the search summary table entries.
	#

	for instrument in set(offset_vector.keys()) - instruments:
		del offset_vector[instrument]
	if set(offset_vector.keys()) != instruments:
		missing_instruments = set(offset_vector.keys()) - instruments
		raise ValueError, "cannot find thinca command line option(s) %s in process_params table for instrument(s) %s found in search_summary table" % (", ".join(["--%s-slide" % instrument.lower() for instrument in missing_instruments]), ", ".join(missing_instruments))

	#
	# build the time slides
	#

	def ids(num_slides):
		# implements the inspiral group's rule for mapping integer
		# offset multiplier to "slide number"
		for n in range(-num_slides, +num_slides + 1):
			if n < 0:
				yield type(time_slide_table.next_id)(5000 - n)
			else:
				yield type(time_slide_table.next_id)(n)

	n = 0
	for offset_vector, id in zip(ligolw_tisi.Inspiral_Num_Slides_Iter(num_slides, offset_vector), ids(num_slides)):
		n += 1
		for row in ligolw_tisi.RowsFromOffsetDict(offset_vector, id, process):
			time_slide_table.append(row)

	#
	# done
	#

	if verbose:
		print >>sys.stderr, "added %d time slide vectors" % n


def depopulate_time_slide_table(xmldoc, verbose = False):
	"""
	Search for and remove duplicate time slide definitions from the
	time_slide table.
	"""
	if verbose:
		print >>sys.stderr, "depopulating time_slides ...",

	#
	# find the time_slide table
	#

	time_slide_table = table.get_table(xmldoc, lsctables.TimeSlideTable.tableName)

	length_before = len(time_slide_table)

	#
	# translate time_slide table into a dictionary, and identify
	# redundant IDs
	#

	mapping = ligolw_tisi.time_slides_vacuum(time_slide_table.as_dict())

	#
	# remove rows corresponding to redundant IDs
	#

	for i in xrange(len(time_slide_table) - 1, -1, -1):
		if time_slide_table[i].time_slide_id in mapping:
			del time_slide_table[i]

	#
	# reassign time_slide IDs in the rest of the document
	#

	for tbl in xmldoc.getElementsByTagName(time_slide_table.tagName):
		tbl.applyKeyMapping(mapping)

	#
	# done
	#

	if verbose:
		print >>sys.stderr, "removed %d redundant time slide vectors" % (length_before - len(time_slide_table))


#
# =============================================================================
#
#       Populate coinc_event, coinc_event_map, and coinc_inspiral Tables
#
# =============================================================================
#


#
# For sngl_inspiral <--> sngl_inspiral coincidences
#


def populate_coinc_event_sngls(xmldoc, process, verbose = False):
	if verbose:
		print >>sys.stderr, "constructing coincs ...",

	#
	# find the sngl_inspiral table
	#

	try:
		sngl_inspiral_table = table.get_table(xmldoc, lsctables.SnglInspiralTable.tableName)
	except ValueError:
		# no sngl_inspiral table --> no-op
		if verbose:
			print >>sys.stderr, "cannot find sngl_inspiral table"
		return

	#
	# find the coinc_definer_ids for sngl_inspiral <--> sngl_inspiral
	# coincidences, or create them if needed
	#

	coinc_type = ligolw_thinca.InspiralCoincTypes
	coinc_def_ids = dict([
		(key, llwapp.get_coinc_def_id(xmldoc, coinc_def.search, coinc_def.search_coinc_type, create_new = True, description = coinc_def.description))
		for key, coinc_def in ligolw_thinca.InspiralCoincTypes.items()
	])

	#
	# find the coinc_event table or create one if needed
	#

	try:
		coinc_event = table.get_table(xmldoc, lsctables.CoincTable.tableName)
	except ValueError:
		coinc_event = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.CoincTable))

	#
	# synchronize the coinc_event table's ID generator with any
	# pre-existing rows
	#

	coinc_event.sync_next_id()

	#
	# find the coinc_event_map table or create one if needed
	#

	try:
		coinc_event_map = table.get_table(xmldoc, lsctables.CoincMapTable.tableName)
	except ValueError:
		coinc_event_map = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.CoincMapTable))

	#
	# find the coinc_inspiral table or create one if needed
	#

	try:
		coinc_inspiral_table = table.get_table(xmldoc, lsctables.CoincInspiralTable.tableName)
	except ValueError:
		coinc_inspiral_table = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.CoincInspiralTable))

	#
	# find the time_slide table
	#

	time_slide_table = table.get_table(xmldoc, lsctables.TimeSlideTable.tableName)

	#
	# iterate over reconstructed coincs
	#

	for event_id, events in itertools.groupby(sngl_inspiral_table, lambda row: row.event_id):
		events = list(events)
		if len(events) < 2:
			# not a coincidence, just a single.  assign a new,
			# unique, event_id and continue.
			for event in events:
				event.event_id = sngl_inspiral_table.get_next_id()
			continue

		#
		# alphabetize events by instrument
		#

		events.sort(lambda a, b: cmp(a.ifo, b.ifo))
		events = tuple(events)

		#
		# instruments (in order) participating in event
		#

		coinc_instruments = tuple(event.ifo for event in events)

		#
		# build a coinc_event
		#

		coinc = lsctables.Coinc()
		coinc.process_id = process.process_id
		coinc.coinc_def_id = coinc_def_ids[coinc_instruments]
		coinc.coinc_event_id = coinc_event.get_next_id()
		# "slide number" is at index 1 in the tuple returned by
		# get_id_parts().  all events in the coinc have the same ID
		# at this stage so it doesn't matter which we use
		coinc.time_slide_id = type(time_slide_table.next_id)(events[0].get_id_parts()[1])
		coinc.nevents = len(events)
		coinc.likelihood = None
		coinc_event.append(coinc)

		#
		# link events to coinc with coinc_event_map rows
		#

		for event in events:
			# assign a new, unique, event_id
			event.event_id = sngl_inspiral_table.get_next_id()
			coincmap = lsctables.CoincMap()
			coincmap.coinc_event_id = coinc.coinc_event_id
			coincmap.event_id = event.event_id
			coincmap.table_name = coincmap.event_id.table_name
			coinc_event_map.append(coincmap)

		#
		# populate coinc_inspiral table with coinc summary:
		#
		# - end_time is the end time of the first trigger in
		#   alphabetical order by instrument (!?)
		# - mchirp is average of mchirps
		# - snr is root-mean-square of SNRs
		# - false-alarm rate is blank
		#

		coinc_inspiral = lsctables.CoincInspiral()
		coinc_inspiral.coinc_event_id = coinc.coinc_event_id
		coinc_inspiral.set_end(events[0].get_end())
		coinc_inspiral.mchirp = sum(event.mchirp for event in events) / len(events)
		coinc_inspiral.snr = math.sqrt(sum(event.snr**2 for event in events) / len(events))
		coinc_inspiral.false_alarm_rate = None
		coinc_inspiral_table.append(coinc_inspiral)

	#
	# done
	#

	if verbose:
		print >>sys.stderr, "constructed %d coincs" % len(coinc_event)


#
# =============================================================================
#
#                        Depopulate sngl_inspiral Table
#
# =============================================================================
#


def depopulate_sngl_inspiral(xmldoc, verbose = False):
	if verbose:
		print >>sys.stderr, "depopulating sngl_inspirals ...",

	#
	# find the sngl_inspiral table
	#

	try:
		sngl_inspiral_table = table.get_table(xmldoc, lsctables.SnglInspiralTable.tableName)
	except ValueError:
		# no sngl_inspiral table --> no-op
		if verbose:
			print >>sys.stderr, "cannot find sngl_inspiral table"
		return

	length_before = len(sngl_inspiral_table)

	#
	# delete duplicates, recording replacement event_ids.  this relies
	# on the SnglInspiral class' __cmp__() method to define when two
	# triggers are the same
	#

	trigger_to_id_index = {}
	mapping = {}
	for i in xrange(len(sngl_inspiral_table) - 1, -1, -1):
		trigger = sngl_inspiral_table[i]
		if trigger in trigger_to_id_index:
			mapping[trigger.event_id] = trigger_to_id_index[trigger]
			del sngl_inspiral_table[i]
		else:
			trigger_to_id_index[trigger] = trigger.event_id

	#
	# update IDs in other tables
	#

	for tbl in xmldoc.getElementsByTagName(sngl_inspiral_table.tagName):
		tbl.applyKeyMapping(mapping)

	#
	# done
	#

	if verbose:
		print >>sys.stderr, "removed %d redundant sngl_inspiral events" % (length_before - len(sngl_inspiral_table))


#
# =============================================================================
#
#                                 Apply Vetoes
#
# =============================================================================
#


def apply_vetoes(xmldoc, veto_segments_name, process, verbose = False):
	if verbose:
		print >>sys.stderr, "applying vetoes ..."

	#
	# find the tables we'll need
	#

	sngl_inspiral_table = table.get_table(xmldoc, lsctables.SnglInspiralTable.tableName)
	coinc_table = table.get_table(xmldoc, lsctables.CoincTable.tableName)
	coinc_map_table = table.get_table(xmldoc, lsctables.CoincMapTable.tableName)
	coinc_inspiral_table = table.get_table(xmldoc, lsctables.CoincInspiralTable.tableName)
	time_slide_table = table.get_table(xmldoc, lsctables.TimeSlideTable.tableName)
	time_slide_table.sync_next_id()

	#
	# turn the time slide table into a dictionary, and retrieve the
	# veto segment lists.
	#

	if verbose:
		print >>sys.stderr, "\tindexing time_slide table and retrieving segment lists ..."
	time_slides = time_slide_table.as_dict()
	veto_segments = llwapp.segmenttable_get_by_name(xmldoc, veto_segments_name).coalesce()

	#
	# retrieve the ring boundaries.  the program has already confirmed
	# that the search_summary table has 1 unique thinca entry so the
	# unpacking done in the assignment here assumes that to be the case
	# (and will cause the program to exit with an error if that
	# assumption doesn't hold).
	#

	[(ignored, rings)] = llwapp.segmentlistdict_fromsearchsummary(xmldoc, program = "thinca").items()
	rings.sort()
	coalesced_rings = segments.segmentlist(rings).coalesce()

	#
	# performance assist:  remove veto segments that don't fall in any
	# of the rings
	#

	for seglist in veto_segments.values():
		seglist &= coalesced_rings

	#
	# create the coinc_event_id --> sngl_inspiral index, and
	# coinc_event_id --> coinc_inspiral index
	#

	if verbose:
		print >>sys.stderr, "\tindexing coinc tables ..."
	index = dict((row.event_id, row) for row in sngl_inspiral_table)

	coinc_map_table.sort(lambda a, b: cmp(a.coinc_event_id, b.coinc_event_id))
	index.update(dict(
		(coinc_event_id, [index[row.event_id] for row in rows])
		for coinc_event_id, rows in itertools.groupby(
			(row for row in coinc_map_table if row.table_name == "sngl_inspiral"),
			lambda row: row.coinc_event_id
		)
	))

	coinc_inspirals = dict((row.coinc_event_id, row) for row in coinc_inspiral_table)

	#
	# iterate over coincs
	#

	if verbose:
		print >>sys.stderr, "\tchecking for coincs during vetoed times ..."

	cached_vetoes = {}
	N = len(coinc_table) / 1000 or 1

	for n, coinc_event in enumerate(coinc_table):
		if verbose and not (n % N):
			print >>sys.stderr, "\t\t%.1f%%\r" % (100.0 * n / len(coinc_table)),

		if coinc_event.coinc_event_id not in index:
			#
			# not a coinc we care about
			#

			continue

		#
		# retrieve the time slide vector
		#

		offset_vector = time_slides[coinc_event.time_slide_id]

		#
		# compare the instruments participating in the coinc to the
		# instruments named in the time slide vector
		#

		expected_instruments = set(offset_vector.keys())
		found_instruments = set(event.ifo for event in index[coinc_event.coinc_event_id])

		if found_instruments == expected_instruments:
			#
			# all instruments contributed to this coinc:
			# nothing more to check
			#

			continue

		if found_instruments - expected_instruments:
			raise ValueError, "coinc '%s' has instrument(s) %s that are not in time slide vector '%s' (%s)" % (coinc_event.coinc_event_id, ", ".join(found_instruments - expected_instruments), coinc_event.time_slide_id, ", ".join(["%s=%g" % item for item in offset_vector.items()]))

		#
		# if we get here, the time shift vector names instruments
		# that did not particicpate in the coinc.  check to see
		# which instruments were on at the time
		#

		#
		# the time of the coinc
		#

		coinc_time = coinc_inspirals[coinc_event.coinc_event_id].get_end()

		#
		# which ring is it in?
		#

		ring = rings[rings.find(coinc_time)]

		#
		# slide the coinc's time on that ring.  the amount of the
		# slide is the offset recorded in the time_slide table for
		# the instrument from which the coinc's time was taken (the
		# coinc_time is taken from the first trigger in
		# alphabetical order by instrument)
		#

		coinc_time = SnglInspiralUtils.slideTimeOnRing(coinc_time, offset_vector[min(found_instruments)], ring)

		#
		# slide the veto segments on that ring, cache the results
		# to avoid recalculation
		#

		try:
			vetoes = cached_vetoes[(ring, coinc_event.time_slide_id)]
		except KeyError:
			vetoes = cached_vetoes[(ring, coinc_event.time_slide_id)] = SnglInspiralUtils.slideSegListDictOnRing(ring, veto_segments, offset_vector)

		#
		# construct a new time slide vector with just the
		# instruments that were on
		#

		offset_vector = dict((instrument, offset) for (instrument, offset) in offset_vector.items() if coinc_time not in vetoes[instrument])
		if found_instruments - set(offset_vector.keys()):
			raise ValueError, "coinc '%s' has instrument(s) %s that were off or vetoed at the slid coinc time %s" % (coinc_event.coinc_event_id, ", ".join(found_instruments - set(offset_vector.keys()), str(coinc_time)))

		#
		# point the coinc_event at it, and add the vector to the
		# time_slide table if needed
		#

		try:
			coinc_event.time_slide_id = ligolw_tisi.time_slides_find(time_slides, offset_vector)
		except KeyError:
			coinc_event.time_slide_id = time_slide_table.get_next_id()
			for row in ligolw_tisi.RowsFromOffsetDict(offset_vector, coinc_event.time_slide_id, process):
				time_slide_table.append(row)
			time_slides[coinc_event.time_slide_id] = offset_vector
			if verbose:
				print >>sys.stderr, "\tadded '%s': %s" % (coinc_event.time_slide_id, ", ".join(["%s=%g" % item for item in offset_vector]))

	if verbose:
		print >>sys.stderr, "\t\t100.0%"


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


options = parse_command_line()

xmldoc = ligolw_add.ligolw_add(ligolw.Document(), [filename for filename in (options.zero_lag_file, options.time_slide_file, options.veto_segments) if filename], verbose = options.verbose)
lsctables.SnglInspiralTable.next_id = lsctables.SnglInspiralID(0)

process = initialize_process(xmldoc)
set_process_params(xmldoc, process, options)

add_missing_id_columns(xmldoc, verbose = options.verbose)

populate_thinca_time_slide_table(xmldoc, process, verbose = options.verbose)

populate_coinc_event_sngls(xmldoc, process, verbose = options.verbose)

depopulate_sngl_inspiral(xmldoc, verbose = options.verbose)

if options.veto_segments:
	apply_vetoes(xmldoc, options.veto_segments_name, process, verbose = options.verbose)
elif options.verbose:
	print >>sys.stderr, "no vetoes applied"

depopulate_time_slide_table(xmldoc, verbose = options.verbose)

llwapp.set_process_end_time(process)

utils.write_filename(xmldoc, options.output, verbose = options.verbose, gz = (options.output or "stdout").endswith(".gz"))
