#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


"""
Translate int_8s sngl_inspiral event_id's to ilwd:char and vice-versa.
"""


import itertools
from optparse import OptionParser
import sys


from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from glue.ligolw.utils import ligolw_add
from pylal import llwapp
from pylal import date
from pylal import ligolw_tisi


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                  Speed Hack
#
# =============================================================================
#


#
# lal.LIGOTimeGPS is horrifically slow.  Replace its use with the C version
# from pylal.date.
#


lsctables.LIGOTimeGPS = date.LIGOTimeGPS


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog [options] [file ...]",
		description = "Converts the event_id column in a sngl_inspiral table from int_8s to ilwd:char and vice-versa.  Each file named on the command line is converted in place, or if no file names are given then input is read from stdin and written to stdout.  Files whose names end in \".gz\" are assumed to be gzip-compressed."
	)
	parser.add_option("--zero-lag-file", help = "Thinca file containing zero lag triggers.")
	parser.add_option("--time-slide-file", help = "Thinca file containing time slide triggers.")
	parser.add_option("--num-slides", type = "int", help = "Number of time slides.")
	parser.add_option("--output", help = "Output file name.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, args = parser.parse_args()

	if not (options.zero_lag_file and options.time_slide_file and options.num_slides and options.output):
		raise ValueError, "must specify all of --zero-lag-file, --time-slide-file, --num-slides and --output"

	if args is not None:
		raise ValueError, "extraneous command line arguments specified"

	return options


#
# =============================================================================
#
#                             Process Information
#
# =============================================================================
#


#
# create and initialize this job's row in the process table
#


def initialize_process(xmldoc, comment = u""):
	return llwapp.append_process(xmldoc, program = u"ligolw_thinca_to_coinc", version = __version__, cvs_repository = u"lscsoft", cvs_entry_time = __date__, comment = comment)


#
# record command line arguments
#


def set_process_params(xmldoc, process, options):
	params = []
	params.append(("--zero-lag-file", "lstring", options.zero_lag_file))
	params.append(("--time-slide-file", "lstring", options.time_slide_file))
	params.append(("--num-slides", "int_4s", options.num_slides))
	params.append(("--output", "lstring", options.output))

	llwapp.append_process_params(xmldoc, process, params)

	return xmldoc


#
# =============================================================================
#
#                          Translate event_id Column
#
# =============================================================================
#


def populate_id_column(xmldoc, table_name, column_name):
	#
	# this function adds a missing ID column to a table.  it should not
	# exist:  fix the lal table code please.
	#

	# find table
	try:
		tbl = table.get_table(xmldoc, table_name)
	except ValueError:
		# doesn't have one
		return
	try:
		# add id column
		tbl.appendColumn(column_name)
	except ValueError:
		# already has one
		pass
	else:
		# populate id column
		for row in tbl:
			setattr(row, column_name, tbl.get_next_id())



#
# =============================================================================
#
#                          Populate time_slide Table
#
# =============================================================================
#


def populate_thinca_time_slide_table(xmldoc, process):
	"""
	Reconstruct the list of time slides from lalapps_thinca's command
	line arguments.
	"""
	#
	# find the time_slide table or add one if needed
	#

	try:
		time_slide_table = table.get_table(xmldoc, lsctables.TimeSlideTable.tableName)
	except ValueError:
		time_slide_table = lsctables.New(lsctables.TimeSlideTable)
		xmldoc.childNodes[0].appendChild(time_slide_table)
	time_slide_table.sync_next_id()

	#
	# move existing time_slide IDs out of the way
	#

	if time_slide_table.next_id < type(time_slide_table.next_id)(10000):
		time_slide_table.next_id = type(time_slide_table.next_id)(10000)
	mapping = {}
	time_slide_table.updateKeyMapping(mapping)
	for tbl in xmldoc.getElementsByTagName(time_slide_table.tagName):
		tbl.applyKeyMapping(mapping)

	#
	# identify lalapps_thinca's time slides
	#

	num_slides, = llwapp.get_process_params(xmldoc, "thinca", "--num-slides")
	offset_vector = {}
	# FIXME:  hard-coded instrument list = BAD BAD BAD.
	for instrument in ("G1", "H1", "H2", "L1", "V2"):
		try:
			offset, = llwapp.get_process_params(xmldoc, "thinca", "--%s-slide" % instrument.lower())
		except ValueError:
			# no offset for this instrument
			continue
		offset_vector[instrument] = offset

	#
	# build the time slides
	#

	def ids(num_slides):
		# implements the inspiral group's rule for mapping integer
		# offset multiplier to "slide number"
		for n in range(-num_slides, +num_slides + 1):
			if n < 0:
				yield type(time_slide_table.next_id)(5000 - n)
			elif n == 0:
				continue
			else:
				# n > 0
				yield type(time_slide_table.next_id)(n)

	for offset_vector, id in zip(ligolw_tisi.Inspiral_Num_Slides_Iter(num_slides, offset_vector), ids(num_slides)):
		for row in ligolw_tisi.RowsFromOffsetDict(offset_vector, id, process):
			time_slide_table.append(row)


def depopulate_time_slide_table(xmldoc):
	"""
	Search for and remove duplicate time slide definitions from the
	time_slide table.
	"""
	#
	# find the time_slide table
	#

	time_slide_table = table.get_table(xmldoc, lsctables.TimeSlideTable.tableName)

	#
	# translate time_slide table into a dictionary, and identify
	# redundant IDs
	#

	mapping = ligolw_tisi.time_slides_vacuum(time_slide_table.as_dict())

	#
	# remove rows corresponding to redundant IDs
	#

	for i in xrange(len(time_slide_table) - 1, -1, -1):
		if time_slide_table[i].time_slide_id in mapping:
			del time_slide_table[i]

	#
	# reassign time_slide IDs in the rest of the document
	#

	for tbl in xmldoc.getElementsByTagName(time_slide_table.tagName):
		tbl.applyKeyMapping(mapping)


#
# =============================================================================
#
#               Populate coinc_event and coinc_event_map Tables
#
# =============================================================================
#


#
# Globally unique inspiral search types
#
# FIXME:  these definitions should be moved to some central location, e.g.
# LAL or a pyLAL module, so that other code can be kept synchronized.  It
# is here ONLY as an example of the information that needs to be provided.
#


InspiralCoincTypes = {
	"sngl--sngl": lsctables.CoincDef(search = u"inspiral", search_coinc_type = 0, description = u"sngl_inspiral<-->sngl_inspiral coincidences")
}


#
# For sngl_inspiral <--> sngl_inspiral coincidences
#


def populate_coinc_event_sngls(xmldoc, process):
	#
	# find the sngl_inspiral table
	#

	try:
		sngl_inspiral_table = table.get_table(xmldoc, lsctables.SnglInspiralTable.tableName)
	except ValueError:
		print >>sys.stderr, "document does not contain a sngl_inspiral table, will try to continue ..."
		return

	#
	# find the coinc_definer_id for sngl_inspiral <--> sngl_inspiral
	# coincidences, or create one if needed
	#

	coinc_type = InspiralCoincTypes["sngl--sngl"]
	coinc_def_id = llwapp.get_coinc_def_id(xmldoc, coinc_type.search, coinc_type.search_coinc_type, create_new = True, description = coinc_type.description)

	#
	# find the coinc_event table or create one if needed
	#

	try:
		coinc_event = table.get_table(xmldoc, lsctables.CoincTable.tableName)
	except ValueError:
		coinc_event = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.CoincTable))

	#
	# synchronize the coinc_event table's ID generator with any
	# pre-existing rows
	#

	coinc_event.sync_next_id()

	#
	# find the coinc_event_map table or create one if needed
	#

	try:
		coinc_event_map = table.get_table(xmldoc, lsctables.CoincMapTable.tableName)
	except ValueError:
		coinc_event_map = xmldoc.childNodes[0].appendChild(lsctables.New(lsctables.CoincMapTable))

	#
	# find the time_slide table
	#

	time_slide_table = table.get_table(xmldoc, lsctables.TimeSlideTable.tableName)

	#
	# iterate over reconstructed coincs
	#

	for event_id, events in itertools.groupby(sngl_inspiral_table, lambda row: row.event_id):
		events = tuple(events)
		if len(events) < 2:
			# not a coincidence, just a single.  assign a new,
			# unique, event_id and continue.
			for event in events:
				event.event_id = sngl_inspiral_table.get_next_id()
			continue

		#
		# build a coinc_event
		#

		coinc = lsctables.Coinc()
		coinc.process_id = process.process_id
		coinc.coinc_def_id = coinc_def_id
		coinc.coinc_event_id = coinc_event.get_next_id()
		# "slide number" is at index 1 in the tuple returned by
		# get_id_parts()
		coinc.time_slide_id = type(time_slide_table.next_id)(events[0].get_id_parts()[1])
		coinc.nevents = len(events)
		coinc.likelihood = None
		coinc_event.append(coinc)

		#
		# link events to coinc with coinc_event_map rows
		#

		for event in events:
			# assign a new, unique, event_id
			event.event_id = sngl_inspiral_table.get_next_id()
			coincmap = lsctables.CoincMap()
			coincmap.coinc_event_id = coinc.coinc_event_id
			coincmap.event_id = event.event_id
			coincmap.table_name = coincmap.event_id.table_name
			coinc_event_map.append(coincmap)


#
# =============================================================================
#
#                        Depopulate sngl_inspiral Table
#
# =============================================================================
#


def depopulate_sngl_inspiral(xmldoc):
	#
	# find the sngl_inspiral table
	#

	try:
		sngl_inspiral_table = table.get_table(xmldoc, lsctables.SnglInspiralTable.tableName)
	except ValueError:
		print >>sys.stderr, "document does not contain a sngl_inspiral table, will try to continue ..."
		return

	#
	# delete duplicates, recording replacement event_ids.  this relies
	# on the SnglInspiral class' __cmp__() method to define when two
	# triggers are the same
	#

	trigger_to_id_index = {}
	mapping = {}
	for i in xrange(len(sngl_inspiral_table) - 1, -1, -1):
		trigger = sngl_inspiral_table[i]
		if trigger in trigger_to_id_index:
			mapping[trigger.event_id] = trigger_to_id_index[trigger]
			del sngl_inspiral_table[i]
		else:
			trigger_to_id_index[trigger] = trigger.event_id

	#
	# update IDs in other tables
	#

	for tbl in xmldoc.getElementsByTagName(sngl_inspiral_table.tagName):
		tbl.applyKeyMapping(mapping)


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


options = parse_command_line()

lsctables.SnglInspiralTable.validcolumns["event_id"] = "int_8s"
lsctables.SnglInspiralTable.next_id = lsctables.SnglInspiralID(0)
xmldoc = ligolw_add.ligolw_add(ligolw.Document(), [options.zero_lag_file, options.time_slide_file], verbose = options.verbose)

process = initialize_process(xmldoc)
set_process_params(xmldoc, process, options)

if options.verbose:
	print >>sys.stderr, "populating thinca time_slide table ..."
populate_thinca_time_slide_table(xmldoc, process)
if options.verbose:
	print >>sys.stderr, "constructing coincs ..."
populate_coinc_event_sngls(xmldoc, process)

if options.verbose:
	print >>sys.stderr, "translating sngl_inspiral event_ids ..."
sngl_inspiral_int_to_ilwd(xmldoc)

if options.verbose:
	print >>sys.stderr, "depopulating sngl_inspirals ..."
depopulate_sngl_inspiral(xmldoc)
if options.verbose:
	print >>sys.stderr, "depopulating time_slides ..."
depopulate_time_slide_table(xmldoc)

llwapp.set_process_end_time(process)

utils.write_filename(xmldoc, options.output, verbose = options.verbose, gz = (options.output or "stdout").endswith(".gz"))
