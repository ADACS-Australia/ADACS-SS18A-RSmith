#!/usr/bin/env python

from optparse import OptionParser
import sys
import os
import getpass
import matplotlib
matplotlib.use('Agg')
from pylab import *
import numpy

# =============================================================================
# Function to query and return science time
# =============================================================================
#def calc_flag_time(channel,start_time,end_time)
#  segment_query_command = '''ligolw_segment_query -q -d -a '''+gw_channel[ifo[i]]+''' -s '''+str(GPSstart)+''' -e '''+str(GPSend)+''' -o '''+segment_xml

# =============================================================================
# Function to extract double coincidence segments from single ifo lists
# =============================================================================
def double_coinc_parse(seg_list_1,seg_list_2):
  seg_list_coinc = None
  status=0
  if np.shape(seg_list_1)[0] != 2 or np.shape(seg_list_1)[0] != 2:
    status=1
  if status==0:
    # find intersecting segments
    segment_2 = 0
    for segment_1 in range(0,np.shape(seg_list_1)[1]):
      start_time_1 = seg_list_1[0,segment_1]
      end_time_1 = seg_list_1[1,segment_1]
      while segment_2 < np.shape(seg_list_2)[1]:
        start_time_2 = seg_list_2[0,segment_2]
        end_time_2 = seg_list_2[1,segment_2]
        # seg two begins after seg one ends
        # break the loop, but don't increment segment_2
        # b/c it may intersect with next segment in seg_list_1
        if start_time_2 > end_time_1:
          break
        # seg two ends before seg one starts
        if end_time_2 < start_time_1:
          segment_2 += 1
          continue
        # at this point we know that there is *some* overlap
        # find the boundaries of the overlap
        start_time_coinc = max(start_time_1,start_time_2)
        end_time_coinc = min(end_time_1,end_time_2)
        # append this new segment to the list
        if seg_list_coinc is None:
          seg_list_coinc = np.array([start_time_coinc,end_time_coinc])
        else:
          seg_list_coinc = np.vstack( (seg_list_coinc,[start_time_coinc,end_time_coinc]) )
        # determine if it's time to break the loop
        if end_time_2 > end_time_1:
          break
        else:
          segment_2 += 1
  return seg_list_coinc,status

# =============================================================================
# Function to remove triple time from double time segments
# =============================================================================

def double_coinc_triple_parse(double_list,triple_list):
  seg_list_coinc_parsed = None
  status=0
  if np.shape(double_list)[0] != 2 or np.shape(triple_list)[0] != 2:
    status=1
  if status==0:
    triple_segment = 0
    for double_segment in range(0,np.shape(double_list)[1]):
      double_start_time = double_list[0,double_segment]
      double_end_time = double_list[1,double_segment]
      while triple_segment < np.shape(triple_list)[1]:
        triple_start_time = triple_list[0,triple_segment]
        triple_end_time = triple_list[1,triple_segment]
        if triple_start_time > double_end_time:
          break
        # seg two ends before seg one starts
        if triple_end_time < double_start_time:
          segment_2 += 1
          continue
        if seg_list_coinc_parsed is None:
          seg_list_coinc_parsed = np.array([double_start_time,triple_start_time])
        else:
          seg_list_coinc_parsed = np.vstack( (seg_list_coinc_parsed,[double_start_time,triple_start_time]) )
        double_start_time=triple_end_time
        # determine if it's time to break the loop
        if triple_end_time > double_end_time:
          break
        else:
          triple_segment += 1
  return seg_list_coinc_parsed,status

# =============================================================================
# Function to execute shell command and get output
# =============================================================================
def GetCommandOutput(command, show_stdout=False, show_command=False, show_error=False):
  """
  Run a command line argument and print informative messages on failure.
  It returns two outputs: the stdout of the command, and its status.  

    >>> GetCommandOutput('cp * /tmp', False, False, True)

  @param command: the command to try
  @type command: string
  @param show_stdout: show the stdout 
  @type show_stdout: boolean
  @param show_command: show the command
  @type show_command: boolean
  @param show_error: show the error if any
  @type show_error: boolean
  @return: the stdout and a status  


  """
  if show_command:
    print "--- Trying this command :" + command

  stdin, out, err = os.popen3(command)
  pid, status = os.wait()
  this_output = out.read()
  if show_error & status != 0:
    print >>sys.stderr, "External call failed."
    print >>sys.stderr, "  status: %d" % status
    print >>sys.stderr, "  stdout: %s" % this_output
    print >>sys.stderr, "  stderr: %s" % err.read()
    print >>sys.stderr, "  command: %s" % command
    sys.exit(status)
  if show_stdout:
    if this_output[0:1]=='\n':
      print this_output[1:]  #first character is \n
    else:
      print this_output

  stdin.close()
  out.close()
  err.close()
  return this_output, status

# =============================================================================
# Main program begins here
# =============================================================================
usage = """usage: %prog [options]

This script is designed to create the CBC Data Quality Analysis page for the given times specified in the options. The default is for one week from the given start date. The only required option is:

--start-date

If you are NOT running on CIT, the options

--skip-dq-flags
--skip-hveto-ihope

are set TRUE automatically as the scripts to run these sections require access to ihope_daily on CIT."""

parser = OptionParser(usage=usage)

parser.add_option("-t","--start-date",action="store",type="string",\
    help="start date in format mm/dd/yyyy")

parser.add_option("-n","--number-of-days",action="store",type="int",\
    default=7,dest="number_days",help="number of days required for DQ page")

parser.add_option("-p","--skip-range-plot",action="store_true",\
    default=False,dest="skip_range_plot",help="skip inspiral range plot")

parser.add_option("-q","--skip-science-time",action="store_true",\
    default=False,dest="skip_science_time",help="skip calculation of science time")

parser.add_option("-u","--username",action="store",type="string",\
    help="username required to access Scimon DQ Flag webpage")

parser.add_option("-d","--skip-common-dqflags",action="store_true",\
    default=False,dest="skip_dq_flags",\
    help="skip generation of common DQ flag lists")

parser.add_option("-c","--common-flag-cat",action="store",type="int",\
    default=4,dest="cat_level",help="category veto level for common DQ flags")

parser.add_option("-s","--common-flag-threshold",action="store",type="int",\
    default=100,dest="snr_threshold",help="snr threshold for common DQ flags")

parser.add_option("-k","--skip-hveto-kw",action="store_true",default=False,\
    help="skip analysis of hveto_ihope results")

parser.add_option("-i","--skip-hveto-ihope",action="store_true",default=False,\
    help="skip analysis of KW hveto results")

parser.add_option("-r","--skip-daily",action="store_true",\
    default=False,help="skip generation of daily plots")

parser.add_option("-H","--skip-h1",action="store_true",\
    default=False,dest="skip_h1",help="skip generation of H1 daily plots")

parser.add_option("-L","--skip-l1",action="store_true",\
    default=False,dest="skip_l1",help="skip generation of L1 daily plots")

parser.add_option("-V","--skip-v1",action="store_true",\
    default=False,dest="skip_v1",help="skip generation of V1 daily plots")

parser.add_option("-o","--output-file",action="store",type="string",\
    dest="output_file",help="output file")

parser.add_option("-x","--segment-histogram",action="store_true",\
    default=False,help="plot histogram of segment length")

(options, args) = parser.parse_args()

if options.start_date is None:
        parser.error("Please specify a start date")

if options.username != None:
  password = getpass.getpass()
if options.output_file == None:
  output = sys.stdout
else:
  output = open(options.output_file,'w')

# ==========
# Set up name variables from options
# ==========
ifo_color=[]
ifo_opacity=[]
ifo_color_point=[]
ifo=[]
ligo_ifo=[]
site=[]
site_name=[]
double_coinc=False
triple_coinc=False
if options.skip_h1 is False:
  ifo.append('H1')
  ligo_ifo.append('H1')
  site.append('-wa')
  site_name.append('LHO')
  ifo_color.append('r')
  ifo_opacity.append(1.0)
  ifo_color_point.append('r.')
if options.skip_l1 is False:
  ifo.append('L1')
  ligo_ifo.append('L1')
  site.append('-la')
  site_name.append('LLO')
  ifo_color.append('g')
  ifo_opacity.append(0.8)
  ifo_color_point.append('g.')
if options.skip_v1 is False:
  ifo.append('V1')
  site.append('')
  site_name.append('Virgo')
  ifo_color.append('m')
  ifo_color.append(0.7)
  ifo_color_point.append('m.') 
if len(ifo)>1:
  double_coinc=True
  double_coinc_ifos=[]
if len(ifo)>2:
  triple_coinc=True
  triple_coinc_ifos=[]

if double_coinc is True:
  for i in range(0,len(ifo)):
    for j in range(i+1,len(ifo)):
      double_coinc_ifos.append(ifo[i]+ifo[j])
      if triple_coinc is True:
        for k in range(j+1,len(ifo)):
           triple_coinc_ifos.append(ifo[i]+ifo[j]+ifo[k])

# ==========
# Work out location and set location specific changes
# ==========
hostname = 'hostname -f'
hostname = GetCommandOutput(hostname)[0]
hostname = hostname.replace('\n','')
if hostname == "ldas-pcdev1.ligo.caltech.edu" or hostname == 'ldas-grid.ligo.caltech.edu':
  webURL = "https://ldas-jobs.ligo.caltech.edu/"
elif hostname == "ldas-pcdev1.ligo-wa.caltech.edu" or hostname == "ldas-grid.ligo-wa.caltech.edu":
    webURL = "https://ldas-jobs.ligo-wa.caltech.edu/"
elif hostname == "ldas-pcdev1.ligo-la.caltech.edu" or hostname == "ldas-grid.ligo-la.caltech.edu":
    webURL = "https://ldas-jobs.ligo-la.caltech.edu/"
elif hostname == "atlas1.atlas.aei.uni-hannover.de":
  webURL = "https://atlas1.atlas.aei.uni-hannover.de/"
elif hostname == "atlas2.atlas.aei.uni-hannover.de":
        webURL = "https://atlas2.atlas.aei.uni-hannover.de/"
elif hostname == "atlas3.atlas.aei.uni-hannover.de":
        webURL = "https://atlas3.atlas.aei.uni-hannover.de/"
elif hostname == "atlas4.atlas.aei.uni-hannover.de":
        webURL = "https://atlas4.atlas.aei.uni-hannover.de/"
elif hostname == "sugar.phy.syr.edu":
  webURL = "https://sugar-jobs.phy.syr.edu/"
elif hostname == "coma2.local":
  webURL = "https://coma2.astro.cf.ac.uk/"
elif hostname == "hydra.phys.uwm.edu":
  webURL = "https://ldas-jobs.phys.uwm.edu/"

if hostname[0:5] == "atlas":
  publicFolder = "WWW/LSC"
else:
  publicFolder = "public_html"

if hostname != "ldas-pcdev1.ligo.caltech.edu" and hostname != 'ldas-grid.ligo.caltech.edu':
  options.skip_dq_flags = True
  options.skip_hveto_ihope = True
  options.skip_range_plot = True
# ==========
# Calculate time info
# ==========
numDays=options.number_days
numWeeks = int(round(numDays/7))

GPSday = [0]*(numDays+1)
GPSstart=GPSday[0] = int(GetCommandOutput('''tconvert '''+ str(options.start_date))[0])
DateStart=str(GetCommandOutput('''tconvert '''+str(GPSday[0]))[0])
DateStart=DateStart.replace("\n","")
#DateStartFormatted=GetCommandOutput('''tconvert ''' + str(GPSday[0]) + ''' -f %A", "%B""%e" "%Y''')

for i in range(1,len(GPSday)):
  GPSday[i]=GPSday[i-1]+86400
GPSend=GPSday[-1]
GPSlength=GPSend-GPSstart
DateEnd=str(GetCommandOutput('''tconvert '''+str(GPSend))[0])
DateEnd=DateEnd.replace("\n","")

# ==========
# Calculate date info
# ==========
ihopePathStart=str('''/archive/home/cbc/ihope_daily/''')

ihopePath = ['']*numDays
date = ['']*numDays
day = ['']*numDays
month = ['']*numDays
year = ['']*numDays

dayOfWeek = ['']*numDays
dateFormatted = ['']*numDays

for i in range(0,numDays):
  date[i] = str(GetCommandOutput('''tconvert '''+str(GPSday[i])+''' -f %Y%m%d''')[0])
  dayOfWeek[i] = str(GetCommandOutput('''tconvert '''+str(GPSday[i])+''' -f %a''')[0])
  date[i]=date[i].replace("\n","")
  day[i]=date[i][6:8]
  month[i]=date[i][4:6]
  year[i]=date[i][0:4]
  dateFormatted[i]=month[i]+"/"+day[i]
  dayOfWeek[i]=dayOfWeek[i].replace("\n","")
  ihopePath[i] = ihopePathStart+str(date[i][0:6]+'''/'''+date[i]+'''/''')

# ==========
# Create DQ folder for week
# ==========
homepath = str(GetCommandOutput('echo $HOME')[0])
homepath = homepath.replace('\n','')
user = str(GetCommandOutput('echo $USER')[0])
user = user.replace('\n','')
dqFolder='cbc_dq_week_'+date[0]
dqPath=homepath+'/'+publicFolder+'/'+dqFolder
mkdirStatus=GetCommandOutput('''mkdir -p '''+dqPath)
webURL=webURL+'~'+user
webPath=webURL+'/'+dqFolder

# ==========
# Calculate science time
# ==========
gw_channel = {'H1':'H1:DMT-SCIENCE:1','L1':'L1:DMT-SCIENCE:1','V1':'V1:ITF-SCIENCEMODE:1'}
science_time = [0]*len(ifo)
analysable_time = [0]*len(ifo)
temp_segment_data=[0]*2
segment_data=[0]*len(ifo)
if options.skip_science_time is False:
  for i in range(0,len(ifo)):
    segment_xml = dqPath+'''/'''+ifo[i]+'''-science_segments.xml'''
    segment_query_command = '''ligolw_segment_query -q -t https://segdb.ligo.caltech.edu -a '''+gw_channel[ifo[i]]+''' -s '''+str(GPSstart)+''' -e '''+str(GPSend)+''' -o '''+segment_xml
    segment_status = GetCommandOutput(segment_query_command)[1]
    if segment_status==0:
      temp_segment_list = dqPath+'''/'''+ifo[i]+'''-temp_segment.txt'''
      cat_segments_command = '''ligolw_print '''+segment_xml+''' --table segment --column start_time --column end_time --delimiter " " > '''+temp_segment_list
      GetCommandOutput(cat_segments_command)
      number_segments_command = "wc -l < "+temp_segment_list
      number_segments = GetCommandOutput(number_segments_command)[0]
      number_segments = number_segments.replace('\n','')
      number_segments = int(number_segments)
      if number_segments!=0:
        segment_length=[0]*number_segments
        segment_data_temp = numpy.loadtxt(temp_segment_list,delimiter=' ')
        temp_segment_data[0] = ([int(column[0]) for column in segment_data_temp])
        temp_segment_data[1] = ([int(column[1]) for column in segment_data_temp])
      else:
        temp_segment_data[0] = [0]
        temp_segment_data[1] = [0]
      segment_data[i]=np.array(temp_segment_data)
      for j in range(0,number_segments):
        segment_length[j] = segment_data[i][1,j]-segment_data[i][0,j]
        science_time[i]+=segment_length[j]
        if segment_length[j] > 2048:
          analysable_time[i]+=segment_length[j]
      if options.segment_histogram is True:
        hist(segment_length,bins=100,histtype='bar',log=True,facecolor=ifo_color[i])
    else:
      raise Exception, "ligolw_segment_query has failed."
  if segment_status==0 and options.segment_histogram is True:
    save_name = dqPath+'/segment_histogram.png'
    print >>output, "Saving "+save_name
    savefig(save_name)

  if double_coinc is True:
    double_coinc_data=[0]*len(double_coinc_ifos)
    double_coinc_science_time=[0]*len(double_coinc_ifos)
    double_coinc_analysable_time=[0]*len(double_coinc_ifos)
    for i in range(0,len(double_coinc_ifos)):
      ifo_1=double_coinc_ifos[i][0:2]
      ifo_2=double_coinc_ifos[i][2:4]
      ifo_index_1 = ifo.index(ifo_1)
      ifo_index_2 = ifo.index(ifo_2)
      double_coinc_data[i] = double_coinc_parse(segment_data[ifo_index_1],segment_data[ifo_index_2])[0]
      if double_coinc_data[i] != None:
        double_coinc_segment_length=double_coinc_data[i][:,1]-double_coinc_data[i][:,0]
        double_coinc_science_time[i]=double_coinc_segment_length.sum()
        for segment in double_coinc_segment_length:
          if segment >= 2048:
            double_coinc_analysable_time[i]+=segment
      else:
        double_coinc_segment_length=0
        double_coinc_science_time[i]=0
    if triple_coinc is True:
      triple_coinc_data=[0]*len(triple_coinc_ifos)
      triple_coinc_science_time=[0]*len(triple_coinc_ifos)
      triple_coinc_analysable_time=[0]*len(triple_coinc_ifos)
      for i in range(0,len(triple_coinc_ifos)):
        ifo_1=triple_coinc_ifos[i][0:2]
        ifo_2=triple_coinc_ifos[i][2:4]
        ifo_3=triple_coinc_ifos[i][4:6]
        ifo_index_1 = ifo.index(ifo_1)
        ifo_index_2 = ifo.index(ifo_2)
        ifo_index_3 = ifo.index(ifo_3)
        triple_coinc_data[i] = double_coinc_parse(double_coinc_parse(segment_data[ifo_index_1],segment_data[ifo_index_2])[0],segment_data[ifo_index_3])[0]
        if triple_coinc is True:
          triple_coinc_segment_length=triple_coinc_data[i][:,1]-triple_coinc_data[i][:,0]
          triple_coinc_science_time[i]=triple_coinc_segment_length.sum()
          for segment in triple_coinc_segment_length:
            if segment >= 2048:
             triple_coinc_analysable_time[i]+=segment
        else:
          triple_coinc_segment_length=0
          triple_coinc_science_time[i]=0
    for i in range(0,len(double_coinc_ifos)):
      if triple_coinc is True:
        for j in range(0,len(triple_coinc_ifos)):
          double_coinc_data[i] = double_coinc_triple_parse(double_coinc_data[i],triple_coinc_data[j])[0]
        double_coinc_segment_length=double_coinc_data[i][:,1]-double_coinc_data[i][:,0]
        double_coinc_science_time[i]=double_coinc_segment_length.sum()
        for segment in double_coinc_segment_length:
          if segment >= 2048:
            double_coinc_analysable_time[i]+=segment

# ==========
# HEADER
# ==========
print >>output, "= S6C Data Quality Checks for "+str(GPSstart)+" - "+str(GPSend)+" ="
print >>output 
print >>output, "<<TableOfContents(3)>>"

# ==========
# Generate plot of inspiral range for week
# ==========
if options.skip_range_plot is False:
  maxVal=0
  figure()
  for j in range(0,len(ifo)):
    rangePlotFile = dqPath+'/'+ifo[j]+'-inspiral_range.txt'
    GetCommandOutput('rm -f '+rangePlotFile)
    GetCommandOutput('touch '+rangePlotFile)
    for i in range(0,numDays):
      rangeFilesCommand = '''for line in `ls /archive/home/cbc/ihope_daily/'''+year[i]+month[i]+'''/'''+year[i]+month[i]+day[i]+'''/'''+ifo[j]+'''-INSPIRAL_UNCLUSTERED-*gz`; do ligolw_print -t summ_value -c start_time -c end_time -c name -c value $line | grep inspiral_effective_distance | awk 'NR==1 {print }' | cut -f1,2,4 -d, >> '''+rangePlotFile+'''; done;'''
      GetCommandOutput(rangeFilesCommand)
    number_of_inspiral_points = int(GetCommandOutput('wc -l < '+rangePlotFile)[0].replace('\n',''))
    if number_of_inspiral_points > 0:
      plotdata=numpy.loadtxt(rangePlotFile,delimiter=',')
      starttimes=asarray([float(column[0]) for column in plotdata])
      endtimes=asarray([float(column[1]) for column in plotdata])
      insprange=asarray([float(column[2]) for column in plotdata])
      time=((endtimes+starttimes)/2 - GPSstart)/86400
      plot(time,insprange,ifo_color_point[j])
      if max(insprange) > maxVal:
        maxVal=max(insprange)
  xlim(0,numDays)
  ylim(0,maxVal*1.1)
  xlabel('Time (days since '+DateStart+')')
  ylabel('Effective inspiral range (Mpc)')
  title('Effective inspiral range for period '+str(GPSstart)+'-'+str(GPSend))
  save_name = dqPath+'/inspiral_range.png'
  savefig(save_name)

# ==========
# SUMMARY
# ==========
print >>output, "== Summary Information =="
print >>output, "\'\'\'Start Time:\'\'\' "+DateStart+", "+str(GPSstart)+". \'\'\'End Time:\'\'\' "+DateEnd+", "+str(GPSend)
print >>output
if options.skip_science_time is False:
  print >>output, "Live time statistics:"
  print >>output, "||IFO||Science time %||Science time in seconds (days)|| ||Analysable time %||Analysable time in seconds (days)||"
  for i in range(0,len(ifo)):
    science_percentage = round(float(float(science_time[i])/float(GPSlength)*100),2)
    science_days = round(float(float(science_time[i])/86400),2)
    analysable_percentage = round(float(float(analysable_time[i])/float(GPSlength)*100),2)
    analysable_days = round(float(float(analysable_time[i])/86400),2)
    print >>output, "||"+ifo[i]+"||"+str(science_percentage)+"||"+str(science_time[i])+" ("+str(science_days)+")|| ||"+str(analysable_percentage)+"||"+str(analysable_time[i])+" ("+str(analysable_days)+")||"
  print >>output
  if double_coinc is True:
    print >>output, "Coincidence time statistics:"
    print >>output, "||IFOs||Science time %||Science time in seconds (days)|| ||Analysable time %||Analysable time in seconds (days)||"
    for i in range(0,len(double_coinc_ifos)):
      science_percentage = round(float(float(double_coinc_science_time[i])/float(GPSlength)*100),2)
      science_days = round(float(float(double_coinc_science_time[i])/86400),2)
      analysable_percentage = round(float(float(double_coinc_analysable_time[i])/float(GPSlength)*100),2)
      analysable_days = round(float(float(double_coinc_analysable_time[i])/86400),2)
      print >>output, "||!"+double_coinc_ifos[i]+"||"+str(science_percentage)+"||"+str(double_coinc_science_time[i])+" ("+str(science_days)+")|| ||"+str(analysable_percentage)+"||"+str(double_coinc_analysable_time[i])+" ("+str(analysable_days)+")||"
  if triple_coinc is True:
    for i in range(0,len(triple_coinc_ifos)):
      science_percentage = round(float(float(triple_coinc_science_time[i])/float(GPSlength)*100),2)
      science_days = round(float(float(triple_coinc_science_time[i])/86400),2)
      analysable_percentage = round(float(float(triple_coinc_analysable_time[i])/float(GPSlength)*100),2)
      analysable_days = round(float(float(triple_coinc_analysable_time[i])/86400),2)
      print >>output, "||!"+triple_coinc_ifos[i]+"||"+str(science_percentage)+"||"+str(triple_coinc_science_time[i])+" ("+str(science_days)+")|| ||"+str(analysable_percentage)+"||"+str(triple_coinc_analysable_time[i])+" ("+str(analysable_days)+")||"

if options.skip_range_plot is False:
  print >>output, "Inspiral Range:"
  print >>output
  print >>output, '[['+webPath+'/inspiral_range.png|{{'+webPath+'/inspiral_range.png||width=500}}]]'
  print >>output
print >>output, "[[#top|Back to top]]"
# ==========
# Scimon DQ flags
# ==========

if options.username != None:
  print >>output, "== Scimon DQ Flags =="
  print >>output, "{{{"
  print >>output, '''curl -k -s --user albert.einstein:<password> https://segdb.ligo.caltech.edu/seginsert/listflags.php | ligolw_print -d QQQ -t segment_summary -c start_time -c end_time -c ifos -c scimon_comment -c elog_url  | awk -F 'QQQ' '($1 >= GPSstart && $1 < GPSend) || ( $2 >= GPSstart && $2 < GPSend ) || ( $1 < GPSstart && $2 > GPSend DDD) { printf "||%s||%s||%s||%s||%s||[[%s|elog]]||\\n", $3,$1,$2,$2-$1,$4,$5 }' '''
  print >>output, "}}}"
  scimonFlagCommand = '''curl -k -s --user '''+options.username+''':'''+password+''' https://segdb.ligo.caltech.edu/seginsert/listflags.php | ligolw_print -d QQQ -t segment_summary -c start_time -c end_time -c ifos -c scimon_comment -c elog_url  | awk -F 'QQQ' '($1 >= '''+str(GPSstart)+''' && $1 < '''+str(GPSend)+''') || ( $2 >= '''+str(GPSstart)+''' && $2 < '''+str(GPSend)+''' ) || ( $1 < '''+str(GPSstart)+''' && $2 > '''+str(GPSend)+''' DDD) { printf "||%s||%s||%s||%s||%s||[[%s|elog]]||\\n", $3,$1,$2,$2-$1,$4,$5 }' '''
  scimonFlags,status = GetCommandOutput(scimonFlagCommand)
  if scimonFlags=="":
    print >>output, "No scimon flags were generated for this period."
  else:
    print >>output, "The following scimon flags were generated this period:"
    print >>output, "||IFO||Start time||End time||Duration||Notes||Ilog link||"
    print >>output, scimonFlags

  print >>output
  print >>output, "[[#top|Back to top]]"

# ==========
# Common DQ Flags
# ==========

if options.skip_dq_flags is False:
  commonDQtag = 'common_dq_flag'
  commonDQpath = dqPath+'/'+commonDQtag+'/'
  mkdirCommand = 'mkdir -p '+commonDQpath
  mkdirStatus = GetCommandOutput(mkdirCommand)[1]
  commonDQwebPath = webPath+'/'+commonDQtag+'/'
  commonDQfilename = ['']*len(ifo)
  commonDQfile=['']*len(ifo)
  commonDQcommand=['lalapps_flag_triggers ']*len(ifo)
  commonDQflags = ['']*len(ifo)
  skippedDays=['']*len(ifo)
  for i in range(0,len(ifo)):
    commonDQfilename[i] = commonDQtag+'_'+str(ifo[i])+'-'+str(GPSstart)+'-'+str(GPSlength)+'.txt'
    commonDQfile[i]=commonDQpath+commonDQfilename[i]
    f = open(commonDQfile[i],'w')
    commonDQcommand[i]+=ifo[i]+''' '''+str(options.cat_level)+''' '''+str(options.snr_threshold)+''' '''
    for j in range(0,len(ihopePath)):
      lsCheck = 'ls '+ihopePath[j]+'H1-'+str(options.cat_level)+'-INSPIRAL_16SEC_CLUSTERED.csv'
      status = GetCommandOutput(lsCheck)[1]
      if status == 0:
        commonDQcommand[i]+=ihopePath[j]+''' '''
      else:
        skippedDays[i]+=''' '''+date[j]+''' '''
    commonDQflags[i],status=GetCommandOutput(commonDQcommand[i])
    if status==0:
      f.write(commonDQflags[i])
    else:
      f.write("Command:\n "+commonDQcommand[i])
      f.write("\nfailed, please rerun.")
    f.close()
  print >>output, "== Common DQ Flags =="
  print >>output, "{{{"
  print >>output, "lalapps_flag_triggers $IFO $SNR_THRESHOLD $DAILY_DIRECTORIES" 
  print >>output, "}}}"
  for i in range(0,len(ifo)):
    print >>output, "===== "+ifo[i]+" ====="
    print >>output
    print >>output, "The output of the above command for "+ifo[i]+" with Category "+str(options.cat_level)+" vetoes applied, and an SNR threshold of "+str(options.snr_threshold)+" can be found [["+commonDQwebPath+commonDQfilename[i]+"|here]]."
    if skippedDays[i] != '':
      print >>output, "The following days were not analysed due to a lack of data:"
      print >>output, "  "+skippedDays[i]
  print >>output
  print >>output, "[[#top|Back to top]]"

# ==========
# UPV
# ==========

if dayOfWeek[0] != "Sat":
  UPVstart = [0]*(numWeeks+2)
  UPVstartDate = ['']*(len(UPVstart))
  for i in range(0,numDays):
    if dayOfWeek[i] == "Sat":
      UPVstart[int(i/7)] = GPSday[i]-604800
      UPVstartDate[int(i/7)] = str(GetCommandOutput('''tconvert '''+str(UPVstart[int(i/7)])+''' -f %Y%m%d''')[0])
      UPVstartDate[int(i/7)] = UPVstartDate[int(i/7)].replace('\n','')
      UPVstart[int(i/7)+1] = GPSday[i]
      UPVstartDate[int(i/7)+1] = str(GetCommandOutput('''tconvert '''+str(UPVstart[int(i/7)+1])+''' -f %Y%m%d''')[0])
      UPVstartDate[int(i/7)+1] = UPVstartDate[int(i/7)+1].replace('\n','')
  UPVstart[-1] = UPVstart[-2]+604800
  UPVlink = ['']*(len(ifo)*(numWeeks+1))
else:
  UPVstart = [0]*(numWeeks+1)
  UPVstartDate = [0]*(len(UPVstart))
  for i in range(0,numDays):
    if dayOfWeek[i] == "Sat":
      UPVstart[int(i/7)] = GPSday[i]
      UPVstartDate[int(i/7)] = str(GetCommandOutput('''tconvert '''+str(UPVstart[int(i/7)])+''' -f %Y%m%d''')[0])
      UPVstartDate[int(i/7)] = UPVstartDate[int(i/7)].replace('\n','')
  UPVstart[-1]=UPVstart[-2]+604800
  UPVlink = ['']*(len(ifo)*(numWeeks))

print >>output, "== Used Percentage Veto =="
print >>output, "The UPV studies run weekly starting on Saturdays. The results for this period can be found at the following locations:",

for i in range(0,len(UPVstart)-1):
  for j in range(0,len(ifo)):
    if ifo[j]=="H1" or ifo[j]=="L1":
      UPVlink[len(ifo)*i+j]="https://ldas-jobs.ligo"+site[j]+\
          ".caltech.edu/~detchar/S6/UPV/weekly/"+ifo[j]+\
          "_DARMERR_"+str(UPVstart[i])+"_"\
          +str(UPVstart[i+1])+"_WEEKLY_webpage/"
    elif ifo[j]=="V1":
      UPVlink[len(ifo)*i+j]="https://ldas-jobs.ligo"+site[j]+\
          ".caltech.edu/~detchar/S6/UPV/weekly/V1_PR_B1_ACP_"\
          +str(UPVstart[i])+"_"+str(UPVstart[i+1])+"_webpage/"
    print >>output, "[["+UPVlink[len(ifo)*i+j]+"|"+ifo[j]+" "+UPVstartDate[i]+"]], ",
print >>output, "and all other information on UPV can be found, [[https://ldas-jobs.ligo.caltech.edu/~detchar/S6/UPV/calendar/main.html|here]]."
print >>output
print >>output, "[[#top|Back to top]]"

# ==========
# Glitch Shifts
# ==========

if len(ligo_ifo)>0:
  numWeeks = int(round(numDays/7))
  print >>output, "== Glitch Shifts =="
  if numWeeks > 1:
    print >>output, "The glitch shifts for these "+str(numWeeks)+" weeks can be found here:",
  else:
    print >>output, "The glitch shifts for this period can be found here:",
  if dayOfWeek[0] != "Sat":
    glitchDate=['']*(numWeeks+1)
    for i in range(0,numDays):
      if dayOfWeek[i] == "Sat":
        glitchDate[int(i/7)] = str(GetCommandOutput('''tconvert '''+str(GPSday[i])+'''-604800 -f %Y%m%d''')[0])
        glitchDate[int(i/7)]=glitchDate[int(i/7)].replace("\n","")
        glitchDate[int(i/7)+1] = date[i]
    for i in range(0,len(glitchDate)):
      for j in range(0,len(ligo_ifo)):
        glitchLink="https://www.lsc-group.phys.uwm.edu/twiki/bin/view/DetChar/GlitchWeek-"+ligo_ifo[j]+"-"+glitchDate[i]
        print >>output, " [["+glitchLink+"|"+site_name[j]+" "+glitchDate[i]+"]], ",
    print >>output, "and all other glitch information can be found on the Glitch Studies page, [[https://www.lsc-group.phys.uwm.edu/twiki/bin/view/DetChar/GlitchStudies|here]]."
  else:
    glitchLink=['']*len(ligo_ifo)*numWeeks
    for i in range(0,numWeeks):
      glitchDate = str(GetCommandOutput('''tconvert '''+str(GPSday[i*7])+''' -f %Y%m%d''')[0])
      glitchDate=glitchDate.replace("\n","")
      for j in range(0,len(ligo_ifo)):
        glitchLink[i]="https://www.lsc-group.phys.uwm.edu/twiki/bin/view/DetChar/GlitchWeek"+ligo_ifo[j]+"-"+glitchDate
        print >>output, " [["+glitchLink[i]+"|"+site_name[j]+" "+glitchDate+"]], ",
        print >>output, "and all other glitch information can be found on the Glitch Studies page, [[https://www.lsc-group.phys.uwm.edu/twiki/bin/view/DetChar/GlitchStudies|here]]."

print >>output
print >>output, "[[#top|Back to top]]"

# ==========
# HVeto
# ==========

hvetoGPSday=[0]*numDays
hvetoURL=['']*2*len(ligo_ifo)
hvetoIhopeURL=['']*2*len(ligo_ifo)
winner=['']*2*len(ligo_ifo)
hvetoIhopeWinner=['']*2*len(ligo_ifo)
hvetoIhopeURLstart=webURL+'''/hveto_ihope/'''

if options.skip_hveto_ihope is False or options.skip_hveto_kw is False:
  print >>output, "== HVeto =="

if options.skip_hveto_ihope is False:
  print >>output, "HVeto can be run on ihope triggers following the instructions [[https://www.lsc-group.phys.uwm.edu/ligovirgo/cbcnote/S6Plan/100131174312DQandVetoeshveto_ihope_daily|here]]. The results for this week are:\n"
  for i in range(0,len(ligo_ifo)):
    hvetoIhopeURL[len(ligo_ifo)*i] = hvetoIhopeURLstart+ligo_ifo[i]+'''-HVETO_iHope_INST-'''+str(GPSstart)+'''-'''+str(GPSlength)+'''/'''
    hvetoIhopeURL[len(ligo_ifo)*i+1] = hvetoIhopeURLstart+ligo_ifo[i]+'''-HVETO_iHope_PEM-'''+str(GPSstart)+'''-'''+str(GPSlength)+'''/'''
    if hostname == "ldas-pcdev1.ligo.caltech.edu" or hostname == 'ldas-grid.ligo.caltech.edu':
      hvetoWinnerGrep = '''cat '''+homepath+'''/'''+publicFolder+'''/hveto_ihope/'''+ligo_ifo[i]+'''-HVETO_iHope_INST-'''+str(GPSstart)+'''-'''+str(GPSlength)+'''/summary_stats.txt | awk 'BEGIN{FS=OFS=" "}{print $2}' | awk 'NR==1 {print }' '''
      command_output, status = GetCommandOutput(hvetoWinnerGrep)
      if status == 0:
        if command_output == "":
          hvetoIhopeWinner[len(ligo_ifo)*i]='hveto error'
        else:
          hvetoIhopeWinner[len(ligo_ifo)*i]=str(command_output)
          hvetoIhopeWinner[len(ligo_ifo)*i]=hvetoIhopeWinner[len(ligo_ifo)*i].replace("\n","")
      else:
        hvetoIhopeWinner[len(ligo_ifo)*i]='hveto error'
      hvetoWinnerGrep = '''cat '''+homepath+'''/'''+publicFolder+'''/hveto_ihope/'''+ifo[i]+'''-HVETO_iHope_PEM-'''+str(GPSstart)+'''-'''+str(GPSlength)+'''/summary_stats.txt | awk 'BEGIN{FS=OFS=" "}{print $2}' | awk 'NR==1 {print }' '''
      command_output,status = GetCommandOutput(hvetoWinnerGrep)
      if status==0:
        if command_output == "":
          hvetoIhopeWinner[len(ligo_ifo)*i+1]='hveto error'
        else:
          hvetoIhopeWinner[len(ligo_ifo)*i+1]=str(command_output)
          hvetoIhopeWinner[len(ligo_ifo)*i+1]=hvetoIhopeWinner[len(ligo_ifo)*i+1].replace("\n","")
      else:
        hvetoIhopeWinner[len(ligo_ifo)*i+1]='hveto error'
    else:
      hvetoIhopeWinner[len(ligo_ifo*i)]=hvetoIhopeWinner[len(ligo_ifo)*i+1]='copy winner from link'
  print >>output, "||Date||",
  for det in ligo_ifo:
    print >>output, det+" INST winner||"+det+" PEM winner||",
  print >>output
  print >>output, "||Full period||",
  for k in range(0,len(hvetoIhopeWinner)):
    print >>output, "[["+hvetoIhopeURL[k]+"|"+hvetoIhopeWinner[k]+"]]||",
  print >>output
  if hostname[-16:-1] != "ligo.caltech.ed":
    print >>output, 'Achtung: This run was not performed on CIT, so the winning channels have not been linked automatically, please copy them from the results pages in the table. Please also check the links for the correct path. Delete this message when complete.'
    print >>output
if options.skip_hveto_kw is False:
  hvetoKWpath = dqPath+'/hveto_summaries' 
  mkdirCommand = 'mkdir -p '+hvetoKWpath
  mkdirStatus=GetCommandOutput(mkdirCommand)[1]
  winnerGrep='''cat '''+hvetoKWpath+'''/summary_stats.txt | awk 'BEGIN{FS=OFS=" "}{print $2}' | awk 'NR==1 {print }' '''

  print >>output, "HVeto is run daily on the Kleine-Welle triggers. The results are:\n"
  print >>output, "||Date||",
  for det in ligo_ifo:
    print >>output, det+" INST winner|| "+det+" PEM winner||",
  print >>output
  for i in range(0,numDays):
    hvetoGPSday[i]=GPSday[i]-15  
    for j in range(0,len(ligo_ifo)):
      hvetoURL[len(ligo_ifo)*j] = '''https://ldas-jobs.ligo'''+site[j]+'''.caltech.edu/~jrsmith/hveto/s6b/'''+ligo_ifo[j]+'''-HVETO_KW_INST-'''+str(hvetoGPSday[i])+'''-86400/'''
      hvetoURL[len(ligo_ifo)*j+1] = '''https://ldas-jobs.ligo'''+site[j]+'''.caltech.edu/~jrsmith/hveto/s6b/'''+ligo_ifo[j]+'''-HVETO_KW_PEM-'''+str(hvetoGPSday[i])+'''-86400/'''
      hvetoSummaryCopy = '''gsiscp ldas-grid.ligo'''+site[j]+'''.caltech.edu:/archive/home/jrsmith/public_html/hveto/s6b/'''+ligo_ifo[j]+'''-HVETO_KW_INST-'''+str(hvetoGPSday[i])+'''-86400/summary_stats.txt '''+hvetoKWpath
      copystatus = GetCommandOutput(hvetoSummaryCopy)[1]
      if copystatus==0:  
        command_output,status = GetCommandOutput(winnerGrep)
        winner[len(ligo_ifo)*j]=str(command_output)
        winner[len(ligo_ifo)*j]=winner[len(ligo_ifo)*j].replace("\n","")
      else:
        winner[len(ligo_ifo)*j]='hveto error'
      hvetoSummaryCopy = '''gsiscp ldas-grid.ligo'''+site[j]+'''.caltech.edu:/archive/home/jrsmith/public_html/hveto/s6b/'''+ligo_ifo[j]+'''-HVETO_KW_PEM-'''+str(hvetoGPSday[i])+'''-86400/summary_stats.txt '''+hvetoKWpath
      copystatus=GetCommandOutput(hvetoSummaryCopy)[1]
      if copystatus==0:
        command_output,status = GetCommandOutput(winnerGrep)
        winner[len(ligo_ifo)*j+1]=str(command_output)
        winner[len(ligo_ifo)*j+1]=winner[len(ligo_ifo)*j+1].replace("\n","")
      else:
        winner[len(ligo_ifo)*j+1]='hveto error'
    print >>output, "||"+dateFormatted[i]+"||",
    for k in range(0,len(winner)):
      print >>output, "[["+hvetoURL[k]+"|"+winner[k]+"]]||",
    print >>output
  cleanUpCommand='rm -r '+hvetoKWpath
  status = GetCommandOutput(cleanUpCommand)[1]
  print >>output, "[[#top|Back to top]]"
# ==========
# Detailed Results
# ==========

print >>output, "== Detailed Results =="

print >>output, "=== !SiteWeekly ==="
print >>output, "The !SiteWeekly report from Mike Landry can be found in the archives, [[http://relativity.phys.lsu.edu/pipermail/siteweekly/|here]]."
print >>output
print >>output, "[[#top|Back to top]]"
# ==========
# Daily Results
# ==========

if options.skip_daily is False:
  for i in range(0,numDays):
    print >>output, "=== "+dateFormatted[i]+" ==="
    print >>output, "'''Links: '''",
    print >>output, "[[https://ldas-jobs.ligo.caltech.edu/~cbc/ihope_daily/"+year[i]+month[i]+"/"+year[i]+month[i]+day[i]+"|Daily ihope]], ",
    if len(ligo_ifo) != 0:
      for j in range(0,len(ligo_ifo)):
        print >>output, "[[http://ilog.ligo"+site[j]+".caltech.edu/ilog/pub/ilog.cgi?group=detector&date_to_view="+month[i]+"/"+day[i]+"/"+year[i]+"|"+site_name[j]+" ilog]], ",
        print >>output, "[[https://ldas-jobs.ligo"+site[j]+".caltech.edu/~detchar/S6/glitch/report/Omega-"+str(GPSday[i])+"-"+str(GPSday[i+1])+".html|"+ifo[j]+" Omega]], ",
    if options.skip_v1 is False:
      print >>output, "[[http://wwwcascina.virgo.infn.it/DataAnalysis/Burst/wonline/V1/"+year[i]+"/"+month[i]+"/"+day[i]+"|V1 Omega]]."
    print >>output
    print >>output, "|| ||",
    for det in ifo:    
      print >>output, det+"||",
    print >>output
    print >>output, "|| SNR vs. time <<BR>> (100ms / CAT4) ||",
    for j in range(0,len(ifo)):
      print >>output, "[[https://ldas-jobs.ligo.caltech.edu/~cbc/ihope_daily/"+year[i]+month[i]+"/"+year[i]+month[i]+day[i]+"/"+ifo[j]+"_4_100MILLISEC_CLUSTERED_snr_vs_time.png|{{https://ldas-jobs.ligo.caltech.edu/~cbc/ihope_daily/"+year[i]+month[i]+"/"+year[i]+month[i]+day[i]+"/"+ifo[j]+"_4_100MILLISEC_CLUSTERED_snr_vs_time.png||width=300}}]]||",
    print >>output
    print >>output, "|| Omega ||",
    for j in range(0,len(ifo)):
      if ifo[j] == "H1" or ifo[j] =="L1":
        print >>output, "[[https://ldas-jobs.ligo"+site[j]+".caltech.edu/~detchar/S6/glitch/figures/"+str(GPSday[i])+"_"+str(GPSday[i+1])+"/S6-"+ifo[j]+"-omega-"+str(GPSday[i])+"-"+str(GPSday[i+1])+"-GlitchTS.gif|{{https://ldas-jobs.ligo"+site[j]+".caltech.edu/~detchar/S6/glitch/figures/"+str(GPSday[i])+"_"+str(GPSday[i+1])+"/S6-"+ifo[j]+"-omega-"+str(GPSday[i])+"-"+str(GPSday[i+1])+"-GlitchTS.gif||width=300}}]]||",
      elif ifo[j] == "V1":
        print >>output, "[[http://wwwcascina.virgo.infn.it/DataAnalysis/Burst/wonline/V1/"+year[i]+"/"+month[i]+"/"+day[i]+"/Plots/V1-GlitchTS.gif|{{http://wwwcascina.virgo.infn.it/DataAnalysis/Burst/wonline/V1/"+year[i]+"/"+month[i]+"/"+day[i]+"/Plots/V1-GlitchTS.gif||width=300}}]]||",
    print >>output
    print >>output, "[[#top|Back to top]]"
