#!/usr/bin/env python

from __future__ import division
from optparse import OptionParser
import sys
import os
import getpass
import matplotlib
matplotlib.use('Agg')
import pylab
import numpy
import shutil
from pylal.dq import dqFrameUtils,dqDataUtils,dqSegmentUtils
from socket import getfqdn

# =============================================================================
# Function to execute shell command and get output
# =============================================================================
def GetCommandOutput(command):
  #== function to execute bash commands and return the stdout and error status
  stdin, out, err = os.popen3(command)
  pid, status = os.wait()
  this_output = out.read()
  stdin.close()
  out.close()
  err.close()
  return this_output, status

# =============================================================================
# Function to remove empty strings from a list
# =============================================================================
def remove_empty(self):
  if '' in self:
    parsed=False
    while not parsed:
      self.remove('')
      if not '' in self:  parsed=True

# =============================================================================
# Function to return cluster specific options
# =============================================================================
def parse_cluster(options):
  #== Work out location and set location specific changes
  fqdn = getfqdn()
  if fqdn == "ldas-pcdev1.ligo.caltech.edu" or \
      fqdn == "ldas-grid.ligo.caltech.edu":
    web_url = "https://ldas-jobs.ligo.caltech.edu"
  elif fqdn == "ldas-pcdev1.ligo-wa.caltech.edu" or \
      fqdn == "ldas-grid.ligo-wa.caltech.edu":
    web_url = "https://ldas-jobs.ligo-wa.caltech.edu"
  elif fqdn == "ldas-pcdev1.ligo-la.caltech.edu" or \
      fqdn == "ldas-grid.ligo-la.caltech.edu":
    web_url = "https://ldas-jobs.ligo-la.caltech.edu"
  elif fqdn == "atlas1.atlas.aei.uni-hannover.de":
    web_url = "https://atlas1.atlas.aei.uni-hannover.de"
  elif fqdn == "atlas2.atlas.aei.uni-hannover.de":
    web_url = "https://atlas2.atlas.aei.uni-hannover.de"
  elif fqdn == "atlas3.atlas.aei.uni-hannover.de":
    web_url = "https://atlas3.atlas.aei.uni-hannover.de"
  elif fqdn == "atlas4.atlas.aei.uni-hannover.de":
    web_url = "https://atlas4.atlas.aei.uni-hannover.de"
  elif fqdn == "sugar.phy.syr.edu":
    web_url = "https://sugar-jobs.phy.syr.edu"
  elif fqdn == "coma2.local":
    web_url = "https://coma2.astro.cf.ac.uk"
  elif fqdn == "hydra.phys.uwm.edu":
    web_url = "https://ldas-jobs.phys.uwm.edu"
  else:
    raise Exception, "You are running from an unsupported location, please log\
  in to one of the LDG clusters and try again."

  if fqdn[0:5] == "atlas":
    public_folder = "WWW/LSC"
  else:
    public_folder = "public_html"

  #== if not run on a CIT machine, skip anything requiring ihope_daily
  if fqdn != "ldas-pcdev1.ligo.caltech.edu" and \
      fqdn != 'ldas-grid.ligo.caltech.edu':
    options.skip_dq_flags = True
    options.skip_hveto_ihope = True
    options.skip_range_plot = True
    options.skip_dq_stats = True

  return public_folder,web_url,options

# =============================================================================
# Function to display science statistics
# =============================================================================
def display_segment_data(ifo,seglist,duration):
  #== calculate science time and analysable time
  science,analysable = dqSegmentUtils.duty_cycle(seglist,cbc=True)
  #== calculate statistics
  science_percentage = round((science/duration*100),2)
  science_days = round((science/86400),2)
  analysable_percentage = round((analysable/duration*100),2)
  analysable_days = round((analysable/86400),2)
  #== write
  return "||"+ifo+\
         "||"+str(science_percentage)+\
         "||"+str(science)+" ("+str(science_days)+")|| "+\
         "||"+str(analysable_percentage)+\
         "||"+str(analysable)+" ("+str(analysable_days)+")||"

# =============================================================================
# Function to grab SciMon flags
# =============================================================================
def scimon_flags(start,end,ifos,username,password):
  start = str(start)
  end   = str(end)
  #== set up command
  #== first set to grab flag list and print correct colums
  query_cmd = '''curl -k -s --user '''+username+''':'''+password+' '+\
              '''https://segdb.ligo.caltech.edu/seginsert/listflags.php | '''+\
              '''ligolw_print -d QQQ -t segment_summary -c start_time '''+\
              '''-c end_time -c ifos -c scimon_comment -c elog_url '''

  #== expand command for print
  query_cmd_print = query_cmd+'''| awk -F 'QQQ' '($1 >= '''+start+''' && '''+\
                                               '''$1 < '''+end+''') || '''+\
                                             '''( $2 >= '''+start+''' && '''+\
                                               '''$2 < '''+end+''' ) || '''+\
                                             '''( $1 < '''+start+''' && '''+\
                                               '''$2 > '''+end+''' DDD) '''
  #== and print in CBC wiki format
  query_cmd_print+= '''{ printf "||%s||%s||%s||%s||%s||[[%s|ilog]]||\\n", '''+\
                              '''$3,$1,$2,$2-$1,$4,$5 }' '''
  #== fudge command for print
  query_cmd_print = query_cmd_print.replace(username,'albert.einstein')
  query_cmd_print = query_cmd_print.replace(username,'password')

  try:
    flags,status = Popen(query_cmd,shell=True,stdout=PIPE)
    scimon_flags={}
    for ifo in ifos:
      scimon_flags[ifo]=[]
    for flag in flags.stdout.readlines():
      if len(flag.split('QQQ'))!=5:
        continue
      flag_start,flag_end,flag_ifo,flag_comment,flag_url = flag.split('QQQ')
      flag_start = int(flag_start)
      flag_end = int(flag_end)
      if start<=flag_start<=end or start<=flag_end<end \
          or (flag_start<start and flag_end>end):
        scimon_flags[flag_ifo].append(flag.split('QQQ'))
      flag = [flag_ifo,\
              flag_start,\
              flag_end,\
              flag_end-flag_start,\
              flag_coment,\
              flag_url]
    num_flags=0
    for ifo in ifos:
       num_flags+=len(scimon_flags[ifo])
    if num_flags==0:
      print >>sys.stdout, "SciMonFlags Error: Accessed segdb, "+\
                          "but no flags recovered. To verify please run \n"
      print >>sys.stdout, query_cmd_print+"\n"
  except:
    print >>sys.stdout, "SciMonFlags Error. Query command failed. "+\
                        "To verify please run \n"
    print >>sys.stdout, query_cmd_print+"\n"
    scimon_flags=None

  return scimon_flags,query_cmd_print

# =============================================================================
# Function to parse command line
# =============================================================================
def parse_command_line():
  usage = """usage: %prog [options]

This script is designed to create the CBC Data Quality Analysis page for the given times specified in the options. The default is for one week from the given start date. The only required option is:

--start-date

If you are NOT running on CIT, the options

--skip-dq-flags
--skip-hveto-ihope

are set TRUE automatically as the scripts to run these sections require access to ihope_daily on CIT."""

  parser = OptionParser(usage=usage)

  parser.add_option("--verbose", action="store_true", default=False,\
      help="verbose output")

  parser.add_option("-t","--start-date",action="store",type="string",\
      help="start date in format mm/dd/yyyy")

  parser.add_option("-n","--number-of-days",action="store",type="int",\
      default=7,dest="number_days",help="number of days required for DQ page")

  parser.add_option("-p","--skip-range-plot",action="store_true",\
      default=False,dest="skip_range_plot",help="skip inspiral range plot")

  parser.add_option("-q","--skip-science-time",action="store_true",\
      default=False,dest="skip_science_time",help="skip calculation of science time")

  parser.add_option("-u","--username",action="store",type="string",\
      help="username required to access Scimon DQ Flag webpage")

  parser.add_option("-d","--skip-common-dqflags",action="store_true",\
      default=False,dest="skip_dq_flags",\
      help="skip generation of common DQ flag lists")

  parser.add_option("-D","--skip-dq-stats",action="store_true",default=False,\
      help="skip generation of DQ flag stats (from CBC veto definer file)")

  parser.add_option("-c","--common-flag-cat",action="store",type="int",\
      default=4,dest="cat_level",help="category veto level for common DQ flags")

  parser.add_option("-s","--common-flag-threshold",action="store",type="int",\
      default=100,dest="snr_threshold",help="snr threshold for common DQ flags")

  parser.add_option("-k","--skip-hveto-kw",action="store_true",default=False,\
      help="skip analysis of hveto_ihope results")

  parser.add_option("-i","--skip-hveto-ihope",action="store_true",default=False,\
      help="skip analysis of KW hveto results")

  parser.add_option("-r","--skip-daily",action="store_true",\
      default=False,help="skip generation of daily plots")

  parser.add_option("-H","--skip-h1",action="store_true",\
      default=False,help="skip generation of H1 daily plots")

  parser.add_option("-L","--skip-l1",action="store_true",\
      default=False,help="skip generation of L1 daily plots")

  parser.add_option("-V","--skip-v1",action="store_true",\
      default=False,help="skip generation of V1 daily plots")

  parser.add_option("-o","--output-file",action="store",type="string",\
      help="output file")

  (options, args) = parser.parse_args()

  if options.start_date is None:
    parser.error("Please specify a start date")

  if options.username != None:
    options.password = getpass.getpass()

  # ==========
  # Set up name variables from options
  # ==========

  if options.verbose:  print >>sys.stdout, "Setting variables..."
  
  options.ligo_ifos=['H1','H2','L1']
  options.site={'H1':'-wa','H2':'-wa','L1':'-la','V1':''}
  options.site_name={'H1':'LHO','H2':'LHO','L1':'LLO','V1':'Virgo',\
                     'G1':'GEO','T1':'TAMA'}

  #== set up ifo list and double and triple coincidence options
  options.ifos=[]
  options.double_ifos=[]
  options.triple_ifos=[]
  if options.skip_h1 is False:
    options.ifos.append('H1')
  if options.skip_l1 is False:
    options.ifos.append('L1')
  if options.skip_v1 is False:
    options.ifos.append('V1')

  #== set up double and triple coincidence lists
  for ifo_1 in options.ifos:
    for ifo_2 in options.ifos:
      if options.ifos.index(ifo_2)>options.ifos.index(ifo_1):
        options.double_ifos.append(ifo_1+ifo_2)
        for ifo_3 in options.ifos:
          if options.ifos.index(ifo_3)>options.ifos.index(ifo_2):
            options.triple_ifos.append(ifo_1+ifo_2+ifo_3)

  return options,args

# ==============================================================================
# Main function starts here
# ==============================================================================
def main():

  options,args = parse_command_line()

  # ==========
  # Work out location and set location specific changes
  # ==========

  public_folder,web_url,options = parse_cluster(options)

  # ==========
  # Calculate time info
 # ==========
  if options.verbose:
    print >>sys.stdout, \
        "Working out times and date for "+str(options.number_days)+\
        " days from "+options.start_date+"..."
  
  number_of_days=options.number_days
  
  if number_of_days % 7 == 0:
    number_of_weeks = int(number_of_days/7)
  else:
    number_of_weeks = int(number_of_days/7)+1
  
  #== set up gps times for each day, including dedicated start and finish
  gps_days = [0]*(number_of_days)
  gps_start = gps_days[0] = int(GetCommandOutput('''tconvert '''+ str(options.start_date))[0])
  for i in range(1,len(gps_days)):
    gps_days[i]=gps_days[i-1]+86400
  gps_end=gps_days[-1]+86400
  duration=gps_end-gps_start
  
  date_start=str(GetCommandOutput('tconvert '+str(gps_start))[0])
  date_start=date_start.replace("\n","")
  date_end=str(GetCommandOutput('tconvert '+str(gps_end))[0])
  date_end=date_end.replace("\n","")
 
  # ==========
  # Calculate date info
  # ==========
  ihope_path='/archive/home/cbc/ihope_daily'
  
  ihope_daily_path = {}
  date = {}
  day_of_week = {}
  date_us_format = {}
  
  for day in gps_days:
    date[day] = str(GetCommandOutput('tconvert '+str(day)+' -f %Y%m%d')[0])
    date[day]=date[day].replace("\n","")
  
    day_of_week[day] = str(GetCommandOutput('tconvert '+str(day)+' -f %a')[0])
    day_of_week[day]=day_of_week[day].replace("\n","")
  
    date_us_format[day]=date[day][4:6]+'/'+date[day][6:8]
    ihope_daily_path[day] = os.path.join(ihope_path,date[day][0:6],date[day])
  
  
  #== generate saturdays list for weekly tools
  saturdays=[]
  if day_of_week[gps_start] != 'Sat':
    #== find first Saturday
    for day in gps_days:
      if day_of_week[day]=='Sat':
        saturdays.append(day-604800)
        break
    #== find all the rest
  for day in gps_days:
    if day_of_week[day]=='Sat':
      saturdays.append(day)
  
  # ==========
  # Create DQ folder for week
  # ==========
  #== find user's home
  home = os.getenv('HOME')
  #== generate folder for week output
  dq_folder='cbc_dq_week_'+date[gps_start]
  dq_path=os.path.join(home,public_folder,dq_folder)
  if options.verbose:
    print >>sys.stdout, "Generating output folder:\n"+dq_path
  if not os.path.exists(dq_path):
    os.makedirs(dq_path)
  #== find user's username
  user = os.getenv('USER')
  #== set up web-readable path for linked output
  web_url=os.path.join(web_url,'~'+user)
  web_path=os.path.join(web_url,dq_folder)
 
  if options.output_file == None:
    options.output_file = os.path.join(dq_path,'cbc_dq_page.txt')
  output = open(options.output_file,'w')

  #== try to display output_file to user as https path
  if options.output_file.find(public_folder)!=-1:
    output_file = options.output_file.split(public_folder+'/')[-1]
    options.output_file = os.path.join(web_path,output_file)

  if options.verbose:
    print >>sys.stdout, "Opening output file: "
    print >>sys.stdout
    print >>sys.stdout, options.output_file
    print >>sys.stdout
  
  # ==========
  # HEADER
  # ==========
  if options.verbose:
    print >>sys.stdout, "Writing header..."
  print >>output, "= S6C Data Quality Checks for "+\
                   str(gps_start)+" - "+str(gps_end)+" ="
  print >>output
  print >>output, "<<TableOfContents(3)>>"
  
  output.flush()
  
  # ==========
  # grab science segments
  # ==========
  if options.skip_science_time is False:
    if options.verbose:
      print >>sys.stdout, \
          "Querying segment databse, and calculating duty cycle..."
    if options.triple_ifos: 
      segments,double_segments,triple_segments = \
          dqSegmentUtils.coinc_segments(gps_start,gps_end,options.ifos)
    else:
      segments,double_segments = \
          dqSegmentUtils.coinc_segments(gps_start,gps_end,options.ifos)
  
  # ==========
  # SUMMARY
  # ==========
  if options.verbose:
    print >>sys.stdout, "Writing summary information..."
  print >>output, "== Summary Information =="
  print >>output, "'''Start Time:''' "+date_start+", "+str(gps_start)+". "+\
                  "'''End Time:''' "+date_end+", "+str(gps_end)
  print >>output
  #== print science segment details
  if options.skip_science_time is False:
    print >>output, "'''Live time statistics:'''"
    print >>output, \
        '||<tablewidth="100%" style="width: 9%;" rowbgcolor="#ffffcc">IFO'+\
        '||Science time %||Science time in seconds (days)|| '+\
        '||Analysable time %||Analysable time in seconds (days)||'
    for ifo in options.ifos:
      print >>output, display_segment_data(ifo,segments[ifo],duration)
    print >>output
  
    #== print coincident time header
    if len(options.ifos) > 1:
      print >>output, "'''Coincidence time statistics:'''"
      print >>output, '||<tablewidth="100%" style="width: 9%;" rowbgcolor="#ffffcc">IFOs||Science time %||Science time in seconds (days)|| ||Analysable time %||Analysable time in seconds (days)||'
    for coinc in options.double_ifos:
      print >>output, display_segment_data(coinc,\
                                           double_segments[coinc],\
                                           duration)
    for coinc in options.triple_ifos:
      print >>output, display_segment_data(coinc,\
                                           triple_segments[coinc],\
                                           duration)
  
  output.flush()
  
  # ==========
  # generate plot of inspiral range for week
  # ==========
  if options.skip_range_plot is False:
    sys.path.append('/archive/home/cbc/dq/resources')
    import plot_effective_distance
    if options.verbose:
      print >>sys.stdout, "Generating inspiral range plot..."
    #== set range plot paths
    plot_name = ''
    for ifo in options.ifos:
      plot_name+=ifo
    plot_name+='-inspiral_range_'+str(gps_start)+'-'+str(duration)+'.png'
    plot_url = os.path.join(web_path,plot_name)
    plot_file = os.path.join(dq_path,plot_name)
    #== generate range plot
    plot_effective_distance.main(gps_start,gps_end,options.ifos,plot_file)
    #== write plot
    print >>output, "'''Inspiral Range:'''"
    print >>output
    print >>output, '[['+plot_url+'|{{'+plot_url+'||width=500}}]]'
    print >>output
    if options.verbose:
      print >>sys.stdout, "  Inspiral range plot written to"
      print >>sys.stdout, "    "+plot_url
  
  print >>output, "[[#top|Back to top]]"
  output.flush()
  
  # ==========
  # SciMon DQ flags
  # ==========
  if options.username != None:
    if options.verbose:
      print >>sys.stdout, "Querying for Scimon DQ flags..."
  
    flags,sf_cmd = scimon_flags(gps_start,\
                                gps_end,\
                                options.ifos,\
                                options.username,\
                                options.password)
  
    print >>output, "== Scimon DQ Flags =="
    print >>output, "{{{"
    print >>output, sf_cmd
    print >>output, "}}}"
  
    #== if flags were received
    if flags is not None:
      #== if there were some flags to receive
      num_flags = sum([len(f) for f in flags.values()])
      if num_flags != 0:
        #== write flags to page
        header=True
        for ifo in options.ifos:
          print >>output, len(flags[ifo])+' were defined for '+ifo+'. '
          #== write table header if not done already, and this ifo has some flags
          if flags[ifo] and header:
            print >>output, '||<rowbgcolor="#ffffcc">IFO'+\
                            '||Start time'+\
                            '||End time'+\
                            '||Duration'+\
                            '||<style="width: 99%;">Notes'+\
                            '||link||'
            header=True
          #== print each flag
          for flag in flags[ifo]:
            flag[-1] = '[['+flag[-1]+'|ilog]]'
            flag_print = '||'
            for item in flag:
              flag_print+=str(item)+'||'
            print >>output, flag_print
      #== if no flags, apologise
      else:
        print >>output, "No scimon flags were generated for this period."
    #== if getting the flags didn't work, apologise
    print >>output
    print >>output, "[[#top|Back to top]]"
  
  # ==========
  # Common DQ Flags
  # ==========
  if options.skip_dq_flags is False:
    if options.verbose:
      print >>sys.stdout, \
          "Generating lists of common DQ flags (from lalapps_flag_triggers)..."
  
    #== set directories
    common_dq_tag = 'common_dq_flag'
    common_dq_path = dq_path+'/'+common_dq_tag
    if not os.path.exists(common_dq_path):
      os.makedirs(common_dq_path)
    common_dq_web_path = web_path+'/'+common_dq_tag
  
    #== print header
    print >>output, "== Common DQ Flags =="
    print >>output, "{{{"
    print >>output, "lalapps_flag_triggers ${IFO} ${CAT_LEVEL} "+\
                        "${SNR_THRESHOLD} ${DAILY_DIRECTORIES}"
    print >>output, "}}}"
  
    #== loop over options.ifos
    for ifo in options.ifos:
      #== set variables
      skipped_days = ''
      filename = ifo+'-'+common_dq_tag+'_'+str(gps_start)+'-'+str(duration)+'.txt'
      filename=common_dq_path+'/'+filename
  
      #== print ifo header
      print >>output, "===== "+ifo+" ====="
      print >>output
      print >>output, "A list of common data quality flags for "+ifo+\
          " after category "+str(options.cat_level)+\
          " vetoes applied, on triggers with SNR > "+str(options.snr_threshold)+\
          " can be found [["+common_dq_web_path+'/'+filename+"|here]]."
  
      f = open(filename,'w')
      #== construct query command
      common_dq_cmd = 'lalapps_flag_triggers '+ifo
      common_dq_cmd+= ' '+str(options.cat_level)
      common_dq_cmd+= ' '+str(options.snr_threshold)+' '
      #== for each day: if triggers cache exists: list; else: skip
      for day in gps_days:
        if os.path.exists(ihope_daily_path[day]+'/'+\
               'H1-'+str(options.cat_level)+'-INSPIRAL_16SEC_CLUSTERED.csv'):
          common_dq_cmd+=ihope_daily_path[day]+' '
        else:
          skipped_days+=' '+date[day]+' '
      #== query for command dq flags
      flags,status=GetCommandOutput(common_dq_cmd)
      #== if it worked, write the output to a file
      if status==0:
        f.write(flags)
      #== if it didn't, apologise
      else:
        f.write("Command:\n "+common_dq_cmd)
        f.write("\nfailed, please rerun.")
      f.close()
      #== if we had to skip some days, list these
      if skipped_days:
        print >>output, \
            "The following days were not analysed due to a lack of data:"
        print >>output, skipped_days
  
    print >>output
    print >>output, "[[#top|Back to top]]"
  
  output.flush()
  
  # ==========
  # DQ stats
  # ==========
  if options.skip_dq_stats is False:
    if options.verbose:
      print >>sys.stdout, "Generating DQ flag statistics..."
      print >>sys.stdout, "  The required analysis will be submitted to a "+\
          "background shell,"
      print >>sys.stdout, "  and so the links will not immediately be filled..."
  
    #== set up stats directory
    dq_stats_tag = 'cbc_dq_stats'
    dq_stats_path = os.path.join(dq_path,dq_stats_tag)
    if not os.path.exists(dq_stats_path):
      os.makedirs(dq_stats_path)
    dq_stats_web_path = (web_path,dq_stats_tag)
    #== stats exe
    dq_stats_script = '/archive/home/cavaglia/S6c_daily_week_current/DQweekrun.sh'
    dq_stats_status = {}
  
    #== submit each job under nohup to allow the page script to continue  
    for ifo in options.ifos:
      dq_stats_nohup = os.path.join(dq_stats_path,ifo+'-dq_stats_nohup.out')
      if options.verbose:
        print >>sys.stdout, "  Generating "+ifo+" statistics..."
        print >>sys.stdout, "  See"
        print >>sys.stdout, "    "+dq_stats_nohup
        print >>sys.stdout, "  for status"
      dq_stats_args = ' --ifo='+ifo+\
          ' --igps='+str(gps_start)+' --egps='+str(gps_end)+\
          ' --outputdir='+dq_stats_path
      dq_stats_status[ifo] = os.system('nohup '+dq_stats_script+dq_stats_args+\
          ' > '+dq_stats_nohup+' &')
  
    #== set up link urls
    dq_stats_url={}
    for ifo in options.ifos:
      dq_stats_url[ifo] = (dq_stats_web_path+'/S6c_'+str(gps_start)+\
          '-'+str(gps_end)+'-'+ifo)
    #== write output
    print >>output, "== Veto Flag Statistics =="
    print >>output, "{{{"
    print >>output, "/archive/home/cavaglia/S6c_daily_week_current/DQweekrun.sh"+\
        " --ifo=${IFO} --igps=${GPSSTART} --egps=${GPSEND}"+\
        " --outputdir=${OUTPUT_DIR}"
    print >>output, "}}}"
    print >>output, "The CBC Veto Definer file contains the details of all "+\
        "veto flags used in the analysis, and times for which they are valid. "+\
        "The contents of the veto definer file have been analysed for both raw "+\
        "vetoes and vetoes including the required padding. "+\
        "This analysis is summarised in the following histograms:"
    print >>output, "||",
    for ifo in options.ifos:
      if dq_stats_status[ifo]==0:  print >>output, ifo+"||",
    print >>output
    print >>output, "||",
    for ifo in options.ifos:
      if dq_stats_status[ifo]==0:
        print >> output, "[["+dq_stats_url[ifo]+"/histogram_plots"+\
            "/hist_novetoed_padded_clustered_"+ifo+"_cat1234.jpg|"+\
            "{{"+dq_stats_url[ifo]+"/histogram_plots"+\
            "/hist_novetoed_padded_clustered_"+ifo+"_cat1234.jpg||"+\
            "width=200}}]]||",
    print >>output
  
    print >>output, "The statistics of flag use percentage, "+\
        "and dead time can be found in the following links:"
  
    dq_stats_thresholds = [8,12,20,100]
    dq_stats_types=['Unpadded','Padded']
    dq_stats_tag={'Unpadded':'UNPD','Padded':'PD'}
    print >>output, '||<rowbgcolor="#ffffcc">Threshold',
    for ifo in options.ifos:
      print >>output, "||||"+ifo+"||",
    print >>output
    print >>output, "|| ||",
    for ifo in options.ifos:
      for dq_stats_type in dq_stats_types:
        print >>output, dq_stats_type+"||",
    print >>output
    for threshold in dq_stats_thresholds:
      print >>output, "||"+str(threshold)+"||",
      for ifo in options.ifos:
        if dq_stats_status[ifo]==0:
          for dq_stats_type in dq_stats_types:
            print >>output, "[["+dq_stats_url[ifo]+\
                "/DQ_tables/DQflagsinfo_"+dq_stats_tag[dq_stats_type]+"_"+\
                ifo+"-"+str(threshold)+".html|link]]||",
        else:
          print >>output, "||run error||",
          if options.verbose:
            print >>sys.stdout, "  Error. Please retry. "+\
                "For assistance e-mail Duncan.Macleod or Marco.Cavaglia @LIGO.org"
      print >>output
  
    print >>output
    print >>output, "[[#top|Back to top]]"
  
  # ==========
  # UPV
  # ==========
  print >>output, "== Used Percentage Veto =="
  print >>output, "The UPV studies run weekly starting on Saturdays. "+\
      "The results for this period can be found at the following locations:",
  
  if options.verbose:  print >>sys.stdout, "Writing UPV links..."
  for saturday in saturdays:
    upv_start = saturday
    upv_stop = saturday+604800
    upv_start_date = str(GetCommandOutput('tconvert '+str(upv_start)+\
        ' -f %Y%m%d')[0])
    upv_start_date = upv_start_date.replace('\n','')
  
    for ifo in options.ifos:
      if ifo in options.ligo_ifos:
        upv_link = "https://ldas-jobs.ligo"+options.site[ifo]+\
            ".caltech.edu/~detchar/S6/UPV/weekly/"+ifo+\
            "_DARMERR_"+str(upv_start)+"_"\
            +str(upv_stop)+"_WEEKLY_webpage/"
      elif ifo == 'V1':
        upv_link = "https://ldas-jobs.ligo"+options.site[ifo]+\
            ".caltech.edu/~detchar/S6/UPV/weekly/V1_PR_B1_ACP_"\
            +str(upv_start)+"_"+str(upv_stop)+"_webpage/"
          
      print >>output, "[["+upv_link+"|"+ifo+" "+upv_start_date+"]], ",
  print >>output, "and all other information on UPV can be found, "+\
      "[[https://ldas-jobs.ligo.caltech.edu/~detchar/S6/UPV/calendar/main.html|"+\
      "here]]."
  print >>output
  print >>output, "[[#top|Back to top]]"
  
  output.flush()
  
  # ==========
  # Glitch Shifts
  # ==========
  if list(set(options.ifos)&set(options.ligo_ifos)):
    if options.verbose:  print >>sys.stdout, "Writing Glitch Shift links..."
    print >>output, "== Glitch Shifts =="
    if len(saturdays) > 1:
      print >>output, "The glitch shifts for these "+str(len(saturdays))+" \
  weeks can be found here:",
    else:
      print >>output, "The glitch shifts for this period can be found here:",
    for saturday in saturdays:
      glitch_date = str(GetCommandOutput(\
          '''tconvert '''+str(saturday)+''' -f %Y%m%d''')[0])
      glitch_date = glitch_date.replace("\n","")
      for ifo in options.ifos:
        if ifo in options.ligo_ifos:
          glitch_link="https://www.lsc-group.phys.uwm.edu/twiki/bin/view/"+\
            "DetChar/GlitchWeek-"+ifo+"-"+glitch_date
          print >>output, " [["+glitch_link+"|"+options.site_name[ifo]+" "+glitch_date+"]], ",
    print >>output, "and all other glitch information can be found on the \
        Glitch Studies page, "+\
        "[[https://www.lsc-group.phys.uwm.edu/twiki/bin/view/"+\
        "DetChar/GlitchStudies|here]]."
  
  print >>output
  print >>output, "[[#top|Back to top]]"
  
  output.flush()
  
  # ==========
  # HVeto
  # ==========
  #== print entry info
  if not (options.skip_hveto_ihope) or not (options.skip_hveto_kw):
    print >>output, "== HVeto =="
    hveto_types=['INST','PEM']
  
  #== display hveto ihope data
  if options.skip_hveto_ihope is False:
    hveto_ihope_web_path = os.path.join(web_url,'hveto_ihope')
    hveto_ihope_path = os.path.join(home,public_folder,'hveto_ihope')
    if options.verbose:  print >>sys.stdout, "Writing hveto_ihope results..."
    print >>output, "HVeto can be run on ihope triggers following the "+\
        "instructions "+\
        "[[https://www.lsc-group.phys.uwm.edu/ligovirgo/cbcnote/S6Plan/"+\
        "100131174312DQandVetoeshveto_ihope_daily|here]]. "+\
        "The results for this week are:\n"
    #== for each ligo IFO, set up space in table
    print >>output, '||<tablewidth="100%" rowbgcolor="#ffffcc">',
    for ifo in options.ifos:
      if ifo in options.ligo_ifos:
        for hveto_type in hveto_types:
          print >>output, ifo+" "+hveto_type+" winner||",
    print >>output
  
    #== for each ligo IFO grep the winning channel and link to page
    print >>output, '||',
    for ifo in options.ifos: 
      if ifo in options.ligo_ifos:
        for hveto_type in hveto_types:
          hveto_url = hveto_ihope_web_path+'/'+ifo+'-HVETO_iHope_'+hveto_type+\
              '-'+str(gps_start)+'-'+str(duration)
          hveto_winner_grep_cmd = '''cat '''+hveto_ihope_path+\
              '''/'''+ifo+'''-HVETO_iHope_'''+hveto_type+'''-'''+str(gps_start)+\
              '''-'''+str(duration)+'''/summary_stats.txt | '''+\
              '''awk 'BEGIN{FS=OFS=" "}{print $2}' | awk 'NR==1 {print }' '''
          grep_output, grep_status = GetCommandOutput(hveto_winner_grep_cmd)
  
          if grep_status == 0:
            if grep_output == "":
              hveto_winner='hveto error'
            else:
              hveto_winner=str(grep_output).replace("\n","")
          else:
            hveto_winner='hveto error'
          #== display results in table
          print >>output, "[["+hveto_url+"|"+hveto_winner+"]]||",
    print >>output
  
  output.flush()
  #== display hveto KW data
  if options.skip_hveto_kw is False:
    if options.verbose:  print >>sys.stdout, "Writing hveto (KW) results..."
  
    #== generate temporary path for hveto data to cp into
    hveto_kw_path = dq_path+'/hveto_summaries_tmp' 
    if not os.path.exists(hveto_kw_path):
      os.makedirs(hveto_kw_path)
  
    hveto_winner_grep_cmd='''cat '''+hveto_kw_path+'''/summary_stats.txt | \
        awk 'BEGIN{FS=OFS=" "}{print $2}' | awk 'NR==1 {print }' '''
  
    #== print entry info
    print >>output, \
        "HVeto is run daily on the Kleine-Welle triggers. The results are:\n"
    print >>output, '||<tablewidth="100%" rowbgcolor="#ffffcc">Date||',
    for ifo in options.ifos:
      if ifo in options.ligo_ifos:
        for hveto_type in hveto_types:
          print >>output, ifo+" "+hveto_type+" winner||",
    print >>output
  
    #for each ligo IFO, cp daily summary and grep winning channel
    for day in gps_days:
      hveto_gps = day-15  
      print >>output, "||"+date_us_format[day]+"||",
      for ifo in options.ifos:
        if ifo in options.ligo_ifos:
          for hveto_type in hveto_types:
            #== set up url string
            hveto_url = '''https://ldas-jobs.ligo'''+options.site[ifo]+\
                '''.caltech.edu/~jrsmith/hveto/s6b/'''+ifo+'''-HVETO_KW_'''+\
                hveto_type+'''-'''+str(hveto_gps)+'''-86400/'''
            #== cp hveto summary.txt
            hveto_sum_cp_cmd = '''gsiscp ldas-grid.ligo'''+options.site[ifo]+\
                '''.caltech.edu:/archive/home/jrsmith/public_html/hveto/s6b/'''+\
                ifo+'''-HVETO_KW_'''+hveto_type+'''-'''+str(hveto_gps)+\
                '''-86400/summary_stats.txt '''+hveto_kw_path
            cp_status = GetCommandOutput(hveto_sum_cp_cmd)[1]
            #== grep winning channel name
            if cp_status==0:
              grep_output,grep_status = GetCommandOutput(hveto_winner_grep_cmd)
              if grep_status==0:
                hveto_winner = str(grep_output).replace("\n","")
              else:
                hveto_winner = 'hveto error'
            else:
              hveto_winner = 'hveto error'
            #== display results in table
            print >>output, "[["+hveto_url+"|"+hveto_winner+"]]||",
      print >>output
  
    #== clean up temporary hveto summaries folder
    clean_cmd='rm -r '+hveto_kw_path
    shutil.rmtree(hveto_kw_path)
    print >>output, "[[#top|Back to top]]"
  
  output.flush()
  
  # ==========
  # Detailed Results
  # ==========
  print >>output, "== Detailed Results =="
  
  print >>output, '||||||<tablewidth="100%" rowbgcolor="#ffffcc">Omega glitchgram key||'
  print >>output, '||<bgcolor="blue" style="text-align: center; color: white;">  5 <= SNR < 10 '+\
      '||<bgcolor="green" style="color: white; text-align: center;"> 10 <= SNR < 20 '+\
      '||<bgcolor="red" style="color: white; text-align: center;"> SNR >= 20||'
  print >>output
  
  # ==========
  # SiteWeekly
  # ==========
  
  print >>output, "=== SiteWeekly ==="
  print >>output, "The !SiteWeekly reports for this period can be found here:",
  
  #== find siteweekly address
  fridays=[]
  for saturday in saturdays:
    fridays.append(saturday+6*86400)
  site_weekly_date = []
  for friday in fridays:
    date_tmp = GetCommandOutput('tconvert '+str(friday)+' -f %e\ %b\ %Y')[0].\
        replace('\n','')
    if date_tmp[0]==' ':  date_tmp=date_tmp[1:] 
    site_weekly_date.append(date_tmp.split(' '))
  
  site_weekly_url = 'http://relativity.phys.lsu.edu/pipermail/siteweekly/'
  for site_weekly in site_weekly_date:
    site_weekly_html = GetCommandOutput('curl '+site_weekly_url+'/'+\
        site_weekly[2]+'-'+site_weekly[1]+' | grep "'+site_weekly[0]+' '+site_weekly[1]+' '+site_weekly[2]+'" | cut -d\" -f2')[0]
    print >>output, " [["+site_weekly_url+site_weekly[2]+'-'+site_weekly[1]+'/'+site_weekly_html+"|"+site_weekly[0]+" "+site_weekly[1]+" "+site_weekly[2]+"]],",
  
  print >>output, " and all other reports can be found in the archives, [[http://relativity.phys.lsu.edu/pipermail/siteweekly/|here]]."
  print >>output
  print >>output, "[[#top|Back to top]]"
  
  # ==========
  # Daily Results
  # ==========
  if options.skip_daily is False:
    if options.verbose:  print >>sys.stdout, "Writing daily information..."
    for day in gps_days:
      day_after=day+86400
      print >>output, "=== "+date_us_format[day]+" ==="
      print >>output, "'''Links: '''",
      print >>output, \
          "[[https://ldas-jobs.ligo.caltech.edu/~cbc/ihope_daily/"+\
          date[day][0:6]+"/"+date[day]+"|Daily ihope]], ",
      for ifo in options.ifos:
        if ifo in options.ligo_ifos:
          print >>output, "[[http://ilog.ligo"+options.site[ifo]+\
              ".caltech.edu/ilog/pub/ilog.cgi?group=detector&date_to_view="+\
              date[day][4:6]+"/"+date[day][6:8]+"/"+date[day][0:4]+\
              "|"+options.site_name[ifo]+" ilog]], ",
          print >>output, "[[https://ldas-jobs.ligo"+options.site[ifo]+\
              ".caltech.edu/~detchar/S6/glitch/report/Omega-"+str(day)+\
              "-"+str(day_after)+".html|"+ifo+" Omega]], ",
        elif ifo == "V1":
          print >>output, \
              "[[http://wwwcascina.virgo.infn.it/DataAnalysis/Burst/wonline/V1/"+\
              date[day][0:4]+"/"+date[day][4:6]+"/"+date[day][6:8]+"|V1 Omega]]."
      print >>output
      print >>output, '||<rowbgcolor="#ffffcc">||',
      for ifo in options.ifos:    
        print >>output, ifo+"||",
      print >>output
      newsnr_vs_time = "|| newSNR vs. time <<BR>> (30ms / CAT4) ||"
      for ifo in options.ifos:
        newsnr_vs_time += \
            "<)>[[https://ldas-jobs.ligo.caltech.edu/~cbc/ihope_daily/"+\
            date[day][0:6]+"/"+date[day]+"/"+ifo+\
            "_4_30MILLISEC_CLUSTERED_newsnr_vs_time.png|"+\
            "{{https://ldas-jobs.ligo.caltech.edu/~cbc/ihope_daily/"+\
            date[day][0:6]+"/"+date[day]+"/"+ifo+\
            "_4_30MILLISEC_CLUSTERED_newsnr_vs_time.png||width=300}}]]"+\
            "&nbsp;&nbsp;||"
      print >>output, newsnr_vs_time
      snr_vs_time = "|| SNR vs. time <<BR>> (30ms / CAT4) ||"
      for ifo in options.ifos:
        snr_vs_time += \
            "<)>[[https://ldas-jobs.ligo.caltech.edu/~cbc/ihope_daily/"+\
            date[day][0:6]+"/"+date[day]+"/"+ifo+\
            "_4_30MILLISEC_CLUSTERED_newsnr_vs_time.png|"+\
            "{{https://ldas-jobs.ligo.caltech.edu/~cbc/ihope_daily/"+\
            date[day][0:6]+"/"+date[day]+"/"+ifo+\
            "_4_30MILLISEC_CLUSTERED_snr_vs_time.png||width=300}}]]"+\
            "&nbsp;&nbsp;||"
      print >>output, snr_vs_time
      omega_daily = "|| Omega ||"
      for ifo in options.ifos:
        if ifo in options.ligo_ifos:
          omega_daily += "<)>[[https://ldas-jobs.ligo"+options.site[ifo]+\
              ".caltech.edu/~detchar/S6/glitch/figures/"+\
              str(day)+"_"+str(day_after)+\
              "/S6-"+ifo+"-omega-"+str(day)+"-"+str(day_after)+"-GlitchTS.gif|"+\
              "{{https://ldas-jobs.ligo"+options.site[ifo]+\
              ".caltech.edu/~detchar/S6/glitch/figures/"+\
              str(day)+"_"+str(day_after)+\
              "/S6-"+ifo+"-omega-"+str(day)+"-"+str(day_after)+\
              "-GlitchTS.gif||width=345}}]]||"
        elif ifo == "V1":
          omega_daily += "<)>"+\
              "[[http://wwwcascina.virgo.infn.it/DataAnalysis/Burst/wonline/V1/"+\
              date[day][0:4]+"/"+date[day][4:6]+"/"+date[day][6:8]+\
              "/Plots/V1-GlitchTS.gif|{{"+\
              "http://wwwcascina.virgo.infn.it/DataAnalysis/Burst/wonline/V1/"+\
              date[day][0:4]+"/"+date[day][4:6]+"/"+date[day][6:8]+\
              "/Plots/V1-GlitchTS.gif||width=345}}]]||"
      print >>output, omega_daily
      print >>output, "'''Daily Summary:'''"
      print >>output, "Please enter your daily summary here."
      print >>output
      print >>output, "[[#top|Back to top]]"
  
  output.flush()
  
  print >>sys.stdout
  print >>sys.stdout, \
      "Done! CBC Data Quality page (in CBC wiki format) written to:"
  print >>sys.stdout
  print >>sys.stdout, options.output_file
  print >>sys.stdout
  
  output.close() 
 
if __name__=='__main__': 
  main()
