#!/usr/bin/python

import sys
import os
import re
import exceptions
import glob
import fileinput
import linecache
import string
from optparse import *
from types import *
from glue import segments
from glue import segmentsUtils
from pylab import *
from pylal import readMeta
from pylal import viz

#######################################################################
# Function to read in the source file and return a sorted list of its
# components according to the luminosity
#######################################################################
def read_source_file( source_file ):
  f = open( source_file , "r")
  lines = f.readlines()
  f.close()

  sourcelist = []
  luminosity = []

  for line in lines:
    b  = string.split(line)
    c  = { 'name': b[0], 'luminosity': float(b[4]) }
    sourcelist.append(c)

  sort_on = "luminosity"
  decorated = [(dict_[sort_on], dict_) for dict_ in sourcelist]
  decorated.sort()
  sortedlist = [dict_ for (key, dict_) in decorated]

  return sortedlist

##########################################################################################################################################

# Chop a simInspiralTable into segments that we care about.
def getSegments ( sim_table, seglist, ifokey ):

  tmptable = readMeta.metaDataTable( None, "sim_inspiral" )

  for e in sim_table.table:
    end_time = e[ifokey]
    if seglist.__contains__(end_time):
      tmptable.table.append(e)

  return tmptable


##############################################################################
# temp "file"
def makeData( max, dx ):
# returns P(x), x, dx
  x  = arange( 0, max, dx )
  return 1.0/( x+1.0 )**2.0, x, dx

##############################################################################
# help message
usage = """\
Usage: plotgbb [options]

  SUMMARY:  
  
  Generate a set of summary plots from triggers stored as simInspiral 
  tables in LIGO lightweight format.  The plots are

    1.
    2.
    3.

"""

##############################################################################
parser = OptionParser( usage )
parser.add_option("-v","--version",action="store_true",default=False,\
    help="display version information " )
parser.add_option("-f","--figure-name",action="store",type="string",\
    default=None,metavar=" FNAME",\
    help="generate ps figures with name FNAME_PlotType.ps")
parser.add_option("-G","--segment-file",action="store",type="string",\
    default=None,metavar=" STRING",help="full path to segment file")
parser.add_option("-S","--source-file",action="store",type="string",\
    default=None,metavar=" STRING",help="full path to source file")
parser.add_option("-t","--title",action="store",type="string",default=None,\
    metavar=" STRING",help="title string for plots")
parser.add_option("-s","--show-plot",action="store_true",default=False,\
    help="display the figures on the terminal" )
parser.add_option("-r","--show-reg",action="store_true",default=False,\
    help="display the _plot.ps figure on the terminal" )
parser.add_option("-l","--show-log",action="store_true",default=False,\
    help="display the loglog.ps figure on the terminal" )
parser.add_option("-b","--show-bar",action="store_true",default=False,\
    help="display the hist.ps figure on the terminal" )
parser.add_option("-u","--show-sum",action="store_true",default=False,\
    help="display the sum_plot.ps figure on the terminal" )
parser.add_option("-c","--show-curvefit",action="store_true",default=False,\
    help="display the sum_curvefit.ps figure on the terminal" )
parser.add_option("-g","--glob-found",action="store",type="string",\
    default=None, metavar=" FOUND_GLOB", \
    help="GLOB of found trigger/injection files to read" )
parser.add_option("-m","--glob-missed",action="store",type="string",\
    default=None, metavar=" MISS_GLOB", \
    help="GLOB of files containing missed injections to read" )
	
(opts,args) = parser.parse_args()

# if --version flagged
if opts.version:
  sys.exit(0)

# check at least one trig file was specified
if not args:
  print >>sys.stderr, "at least one trigger file must be specified"
  print >>sys.stderr, "Enter 'plotgbb --help' for usage"
  sys.exit(1)

# check that the source file was supplied
if not opts.source_file:
  print >>sys.stderr, "the source list file must be supplied"
  print >>sys.stderr, "Enter 'plotgbb --help' for usage"
  sys.exit(1)


# check at least one trig file was specified
if not opts.glob_found:
  print >>sys.stderr, "Must specify a GLOB of found injection files to read"
  print >>sys.stderr, "Enter 'plotefficiency --help' for usage"
  sys.exit(1)

if not opts.glob_missed:
  print >>sys.stderr, "Must specify a GLOB of missed injection files to read"
  print >>sys.stderr, "Enter 'plotefficiency --help' for usage"
  sys.exit(1)

foundFiles = glob.glob(opts.glob_found)
if not foundFiles:
  print >>sys.stderr, "The glob for " + opts.glob_found + " returned no files"
  sys.exit(1)

missedFiles = glob.glob(opts.glob_missed)
if not foundFiles:
  print >>sys.stderr, "The glob for " + opts.glob_missed + " returned no files"
  sys.exit(1)

foundTrig = readMeta.metaDataTable(foundFiles, "sngl_inspiral")
foundInj  = readMeta.metaDataTable(foundFiles, "sim_inspiral")
missedInj = readMeta.metaDataTable(missedFiles, "sim_inspiral")



trigFiles = args

# sourcelist sorted from smallest to largest in the luminosity
sourcelist = read_source_file( opts.source_file )


##############################################################################
# Constants:
X_MAX = 100	# x-axis max for plots.
Y_MAX = 3000	# y-axis max for plots.
max_luminosity = sourcelist[len(sourcelist)-2]['luminosity']
max_galaxy = sourcelist[len(sourcelist)-2]['name']


print "This is the Maximum Luminosity"
print max_luminosity
print "This is the Galaxy having Maximum Luminosity"
print max_galaxy 

# an instance of the simInspiralTable
simInspTriggers=readMeta.metaDataTable( trigFiles, "sim_inspiral" )

# select binaries with end times inside analyzed segments
if opts.segment_file:
  file = open( opts.segment_file , "r")
  l = segmentsUtils.fromsegwizard(file)
  file.close()
  simInspTriggers = getSegments( simInspTriggers, l , "l_end_time" )

  

# The following line determines the number of sources with highest luminousity
numSources = len( [e for e in simInspTriggers.table if\
      ( re.match(max_galaxy,e["source"]) )] )

print "The number of Sources in Above Galaxy"
print numSources

h=simInspTriggers.mkarray( "eff_dist_h" )
index=arange( 0, len(h) )*max_luminosity/numSources
hs=sort(h)

l=simInspTriggers.mkarray( "eff_dist_l" )
ls=sort( l )

g=simInspTriggers.mkarray( "eff_dist_g" )
gs=sort( g )

t=simInspTriggers.mkarray( "eff_dist_t" )
ts=sort( t )

v=simInspTriggers.mkarray( "eff_dist_v" )
vs=sort( v )

# make a regular plot.

if opts.show_reg:
	
	plot( hs, index ,ls, index, gs, index, ts, index, vs, index )
	grid( True )
	axis( [	0, X_MAX, 0, Y_MAX] )
	xlabel( 'Effective Distance (Mpc)' )
	ylabel('N_G' )
	legend( ('Hanford', 'Livingston', 'GEO', 'TAMA', 'VIRGO'), loc=0 )
	if opts.title:
	  title( opts.title )
	if opts.figure_name:
	  savefig( opts.figure_name + "_plot.ps" )

	

if opts.show_curvefit:
	
	
	print " This is a Fitted Curve that has been done using Regression method of first 30 galaxies and fitting a Cubical polynomial"	
		
	N_Gr = 0.00611877*(hs)*(hs)*(hs)-0.0164998*(hs)*(hs)+2.52*(hs)
	plot(hs,N_Gr)
	grid( True )
	axis( [0, X_MAX, 0, Y_MAX] )
	xlabel( 'Effective Distance (Mpc)' )
	ylabel( 'N_G')
	legend( ('Fitted Curve') )
	if opts.title:	
          title( opts.title )
	if opts.figure_name:
	  savefig(opts.figure_name + "_curvefit.ps" )	

	

	#j = 0#
	#while j <=40:#
		#for i in range(0, len(hs)):#
			#dist = hs[i]#
			#if dist >=j:#
				#break#
		#print float(hs[i]), index[i]#	
		#j = j + 1#
	
		

# make a loglog plot.

if opts.show_log:

	figure()
	eps=0.00001	# to prevent log(0) craziness.
	log_i=index+eps
	
	loglog( hs, log_i, ls, log_i, gs, log_i, ts, log_i, vs, log_i )
	grid( True )
	axis( [1, X_MAX, 1, Y_MAX] )
	xlabel( 'Effective Distance (Mpc)' )
	ylabel( 'N_G' )
	legend( ('Hanford', 'Livingston', 'GEO', 'TAMA', 'VIRGO'), loc=0 )
	if opts.title:
	  title( opts.title )
	if opts.figure_name:
	  savefig( opts.figure_name + "_loglog.ps" )

	
# effective distance plot.

if opts.show_bar:

	figure()
	P_x, x, dx = makeData( 50, 1 )
	
	ng,a,b = hist( hs, x )
	grid( True )
	axis( [0, X_MAX, 0, max( ng[0:X_MAX+1] )] )
	xlabel( 'Effective Distance (Mpc)' )
	ylabel('N_G' )
	if opts.title:
	  title( opts.title )
	if opts.figure_name:
	  savefig( opts.figure_name + "_hist.ps" )


# cumulative sum plot (approximation of first plot)

if opts.show_sum:

	figure()
	P_x, x, dx = makeData( 50, 1)

	ng,a,b = hist( hs, x )
	ng = ng*max_luminosity/numSources  	# normalize.
	for i in range(1,len(x)):
	  ng[i] = ng[i-1] + ng[i]
	
	
	plot( x[0:X_MAX+1], ng[0:X_MAX+1] )
	grid( True )
	axis( [0, X_MAX, 0, Y_MAX] )
	xlabel( 'Effective Distance (Mpc)' )
	ylabel('N_G' )
	if opts.title:
	  title( opts.title )
	if opts.figure_name:
	  savefig( opts.figure_name + "_sum_plot.ps" )

if opts.show_plot:
  show()



###########################################################
#EFFICIENCY PLOT



# an instance of the simInspiralTable
found = readMeta.metaDataTable(trigFiles, "sim_inspiral" )
missed = readMeta.metaDataTable(trigFiles,"sim_inspiral")

hf = found.mkarray("eff_dist_h")
hm = missed.mkarray("eff_dist_h")
ha = concatenate((hf ,hm))
h_found = sort(hf)
h_missed= sort(hm)
nbins = 50



stepf = (max(hf) - min(hf))/nbins
binsf = arange(min(hf), max(hf), stepf)
h_found, binsf, stuff = hist(hf, binsf)
h_missed,binsf, stuff = hist(hm,binsf)
clf()

plot(binsf, h_found)
grid( True )
xlabel('Effective Distance (Mpc)')
ylabel('Found')

show()

plot(binsf, h_missed)
grid( True )
xlabel('Effective Distance (Mpc)')
ylabel('Missed')

show() 

###########################################################

