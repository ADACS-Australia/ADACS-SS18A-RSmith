#!/usr/bin/env python
"""
exttrig_likelihood_pope - generates steps to test likelihood or to open the box

$Id$

This script generates a condor DAG(?) for the last step of the 
inspiral exttrig pipeline, which is either to create likelihood plots
with a fake onsource trial or to open the box with the real onsource data.
"""

__author__ = 'Alexander Dietz <Alexander.Dietz@lapp.in2p3.fr>'
__date__ = '$Date$'
__version__ = '$Revision$'[11:-2]

##############################################################################
# import standard modules and append the lalapps prefix to the python path
import sys
import os
from optparse import *
import ConfigParser

##############################################################################
# import the modules we need to build the pipeline
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from glue import segmentsUtils
from glue.segments import segment, segmentlist
from glue import lal
from pylal import SimInspiralUtils
from pylal import CoincInspiralUtils
from pylal.xlal.datatypes.ligotimegps import LIGOTimeGPS

lsctables.LIGOTimeGPS = LIGOTimeGPS

############################################
def extract_seglist(doc):
    """
    Return the segmentlist formed from the out segment of the search_summary
    table of doc.
    """
    summ_table = table.get_table(doc, lsctables.SearchSummaryTable.tableName)
    segs = segmentlist([summary.get_out() for summary in summ_table])
    segs.coalesce()
    return segs


############################################
def read_coincs_from_file(filename):
    """
    Reads a coinc-table from a file 'filename'
    """

    doc = utils.load_filename(filename, gz = filename.endswith(".gz"))
    try:
       singles = table.get_table(doc, lsctables.SnglInspiralTable.tableName)
    except:
       singles = None

    coincs = None
    if singles:
       coincs = CoincInspiralUtils.coincInspiralTable(singles, CoincInspiralUtils.coincStatistic("effective_snr"))

    return coincs
 
############################################
def read_sims_from_file(filename):
    """
    Reads the sim_inspiral table from a file 'filename'
    """
 
    doc = utils.load_filename(filename, gz = filename.endswith(".gz"))
    try: 
       sims = \
                 table.get_table(doc, lsctables.SimInspiralTable.tableName)
    except:
       sims = None

    return sims

############################################ 
def shift_triggers(doc, shift):
    """
    Shift each SnglInspiral trigger in doc by an amount shift.
    """
    triggers = table.get_table(doc, lsctables.SnglInspiralTable.tableName)
    for trig in triggers:
        trig.set_end(trig.get_end() + shift)

    return triggers


#
##############################################################################
usage = """usage: %prog [options]

Options examples:
%prog --config-file plot_hipe.ini --fake injections --inj-run injections11  

Lists all the loudest triggers from injection run 'injections11'

%prog --config-file plot_hipe.ini --fake offsource

Lists all the loudest triggers from the offsource trials
"""

parser = OptionParser( usage )

parser.add_option("-v", "--version",action="store_true",default=False,\
    help="print version information and exit")
    
parser.add_option("-f", "--config-file",action="store",type="string",\
    metavar=" FILE",help="use configuration file FILE")

parser.add_option("-F", "--fake",action="store",type="string",\
    metavar=" FAKE",help="specifies how to fake the onsource (one of {offsource,injection})")

parser.add_option("-I", "--inj-run",action="store",type="string",\
    metavar=" INJRUN",help="specifies from what injection run to choose the injection")

parser.add_option("", "--start",action="store",type="int",\
    default = -1, metavar=" START",help="specifies the start trial (default=1)")

parser.add_option("", "--end",action="store",type="int",\
    default = -1, metavar=" END",help="specifies the end trial (default=max. value)")

command_line = sys.argv[1:]
(opts,args) = parser.parse_args()


if opts.fake=='injection' and not opts.inj_run:
   print >>sys.stderr, "Must specify the injection tun, e.g. --inj-run injections11"
   sys.exit(1)

if opts.start<0:
   opts.start = 1
   
   

#################################
# if --version flagged
if opts.version:
  print "$Id$"
  sys.exit(0)


#################################
# Sanity check of input arguments
################################

# Checks for config file
if not opts.config_file:
  print >> sys.stderr, "No configuration file specified."
  print >> sys.stderr, "Use --config-file FILE to specify location."
  sys.exit(1)


  
##############################################################################
# create the config parser object and read in the ini file
cp = ConfigParser.ConfigParser()
cp.read(opts.config_file)

# Checks if input-user-tag is specified (mostly GRB name).
input_user_tag = cp.get('pipeline','input-user-tag')

###########################################################################
# general preparations

# get the cache-file
cache_file = cp.get('common','cache-file')
cache = lal.Cache.fromfile(open(cache_file))

#sieve the onsource file
pattern = 'THINCA_SECOND*'+cp.get('pipeline','zerolag-suffix')
dest_cache = cache.sieve(description = pattern)
if len(dest_cache)!=1:
   raise ValueError, "One onsource file expected, %d files found: %s" %\
         (len(dest_cache), dest_cache.pfnlist())
dest_filename = dest_cache.pfnlist()[0]

## check what to do
if opts.fake=='offsource':

    # extract the THINCA filename
    pattern = 'THINCA_SECOND*'+cp.get('pipeline','offsource-suffix')
    source_cache = cache.sieve(description = pattern)
    source_filename = source_cache.pfnlist()[0]
    
    # extracting segments from the source (THINCA-file)
    src_doc = utils.load_filename(source_filename, False,
                                  gz=source_filename.endswith(".gz"))
    source_segs = extract_seglist(src_doc)

    # extracting the segments from the onsource-file
    dest_doc = utils.load_filename(dest_filename, False,
                                   gz=dest_filename.endswith(".gz"))
    dest_segs = extract_seglist(dest_doc)
    length_onsource = abs(dest_segs)
   
    # check the length
    if abs(source_segs) % length_onsource!= 0:
        sys.stderr.write("The length of off-source is not commensurate with "\
                         "length of on-source.  Did you specify the right files?\n")

    # fix the upper limit
    if opts.end < 0 or opts.end > (abs(source_segs) / length_onsource):
        opts.end = (abs(source_segs) / length_onsource)

   #     shift_a = dest_segs[0][0] - source_segs[0][0]+length_onsource
   #     shift_b = -length_onsource
   
else:
    
    # fix the end of the loop for the injection case (assuming 5000 injections)
    if opts.end<0 or opts.end>1955:
        opts.end = 1000

# get the onsource segments
on_segs = segmentsUtils.fromsegwizard(open('../onSourceSeg.txt'),
                                      coltype=int)

##############################################################################
# make the loop and print out loudest comb. effective SNR
# for each of the trial

## make the loop over the start/end
for i in range(opts.start, opts.end):

   if opts.fake=='offsource':

      # reload source all the time
      src_doc = utils.load_filename(source_filename, False,
                                    gz=source_filename.endswith(".gz"))

      # calculate the time-shift
      shift = dest_segs[0][0] - (source_segs[0][0] + (i - 1)*length_onsource)

   else:
      inj_id = i

      # extract the corresponding INJECTION data
      inj_pattern = 'INJECTION*'+opts.inj_run+'_'+str(inj_id)
      inj_cache = cache.sieve(description = inj_pattern).sieve(ifos='HL')
      inj_filename = inj_cache.pfnlist()[0]
      sims = read_sims_from_file(inj_filename)
             
      # extract the corresponding THINCA data
      pattern = 'THINCA_SECOND*'+opts.inj_run+'_'+str(inj_id)
      source_cache = cache.sieve(description = pattern)
      source_filename = source_cache.pfnlist()[0]
      coincs = read_coincs_from_file(source_filename)
      
      # open the doc of the source file
      src_doc = utils.load_filename(source_filename, False,
                                    gz=source_filename.endswith(".gz"))
                   
      # compute the time-shift
      shift = on_segs[0][0] + 3.0 - sims[0].geocent_end_time - sims[0].geocent_end_time_ns*1.0e-9


   # shift the triggers and create the coincidences
   shift_time = LIGOTimeGPS(shift)
   triggers = shift_triggers(src_doc, shift_time)
   coincs = CoincInspiralUtils.coincInspiralTable(triggers, CoincInspiralUtils.coincStatistic("effective_snr"))

   # find the loudest candidate
   max_stat = 0
   for coinc in coincs:
      time = coinc.H1.end_time

      if time in on_segs:
         if coinc.stat > max_stat:
            max_stat = coinc.stat


   ## make the final printout
   text = "Trial %d: CombSNR= %.2f " % (i, max_stat)
   if opts.fake=='offsource':
      print text
   else:
      print "%s  dist: %.2f  m1: %.2f  m2: %.2f" %\
            (text, sims[0].distance, sims[0].mass1, sims[0].mass2)

      
