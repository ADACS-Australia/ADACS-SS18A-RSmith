#!/usr/bin/python

# =============================================================================
# Preamble
# =============================================================================

from __future__ import division

import os,sys,matplotlib,numpy,re
matplotlib.use('Agg')
import pylab
from optparse import OptionParser
from pylal import SimInspiralUtils,MultiInspiralUtils
from pylal import plotutils
from glue import markup
from glue.ligolw import table,lsctables,utils
from pylal.coh_PTF_pyutils import *

def write_table( page, headers, data, cl='' ):

  """
    Write table in html
  """

  page.table( class_=cl, border="1" )

  # list
  if cl=='list':
    for i in range( len( headers ) ):

      page.tr()
      page.th()
      page.add( '%s' % headers[i] )
      page.th.close()
      page.td()
      page.add( '%s' % data[i] )
      page.td.close()
      page.tr.close()

  else:
    page.tr()
    for n in headers:
      page.th()
      page.add( '%s' % n )
      page.th.close()
    page.tr.close()

    if data and not re.search( 'list',str( type( data[0] ) ) ):
      data = [data]

    for row in data:
      page.tr()
      for item in row:
        if len(row)==1 and len(headers)!=1:
          page.td(colspan="%s" % len(headers))
        else:
          page.td()
        page.add( '%s' % item )
        page.td.close()
      page.tr.close()

  page.table.close()

  return page


# =============================================================================
# Parse command line
# =============================================================================

def parse_command_line():

  usage = """usage: %prog [options] 
  
coh_PTF_efficiency will calculate search efficiency and FAP for loudest triggers

--segment-dir
--offsource-file
"""

  parser = OptionParser( usage )

  parser.add_option(  "-a", "--segment-dir", action="store", type="string",\
                     default=None, help="directory holding buffer, on and "+\
                                        "off source segment files." )

  parser.add_option( "-t", "--offsource-file", action="store", type="string",\
                     default=None, help="The location of the trigger file" )

  parser.add_option( "-O", "--onsource-file", action="store", type="string",\
                     default=None, help="The location of the trigger file" )

  parser.add_option( "-f", "--found-file", action="store", type="string",\
                     default=None,\
                     help="The location of the found injections file" )

  parser.add_option( "-m", "--missed-file",action="store",type="string",\
                     default=None,\
                     help="The location of the missed injections file" )

  parser.add_option( "-o", "--output-path", action="store", type="string",\
                     default=os.getcwd(), help="Output path for plots"  )

  parser.add_option( "-Q", "--chisq-index", action="store", type="float",\
                     default=4.0, help="chisq_index for newSNR calculation, "+\
                                       "default: %default" )

  parser.add_option( "-N", "--chisq-nhigh", action="store", type="float",\
                     default=3.0, help="nhigh for newSNR calculation, "+\
                                       "default: %default" )

  parser.add_option( "-A", "--null-snr-threshold", action="store",\
                     type="string", default="3.5,5.25",\
                     help="comma separated lower,higher null SNR thresholds, "+\
                          " for null SNR cut, default: \"%default\"" )
  
  parser.add_option( "-v", "--verbose", action="store_true", default=False,\
                     help="verbose output, default: %default" )

  (opts,args) = parser.parse_args()

  if not opts.segment_dir:
    parser.error( "must provide --segment-dir" )

  if not opts.offsource_file:
    parser.error( "must provide trig file" )
  
  if (not opts.found_file) and (not opts.missed_file):
    opts.do_injections = False
  elif (opts.found_file) and opts.missed_file:
    opts.do_injections = True
  else:
    parser.error( "must provide both found and missed file if running "+\
                  "injections" )
  
  return opts, args

# =============================================================================
# Main function
# =============================================================================

def main( segdir, outdir, trigFile, foundFile, missedFile,\
          onsourceFile, verbose=False, doinj=False, chisq_index=4.0,\
          chisq_nhigh=3.0, null_thresh = (3.5,5.25) ):

  # set output directory
  if not os.path.isdir(outdir):
    os.makedirs(outdir)

  if verbose:
    print >>sys.stdout
    print >>sys.stdout, 'Loading segments...'

  segs = readSegFiles( segdir )
 
  fRadDeg = round( 180/numpy.pi, 2 )
 
  # Padding time = 7s for padding + 64s lost time
  paddingTime         = 71 
  trialTime           = abs(segs['on'])
  numSegsBeforeBuffer = ( segs['buffer'][0] - (segs['off'][0] + paddingTime) )\
                        //trialTime
  endTimeBefore       = ( segs['off'][0]+paddingTime ) +\
                        numSegsBeforeBuffer*trialTime
  numSegsAfterBuffer  = (( segs['off'][1]-paddingTime ) - segs['buffer'][1] )\
                        //trialTime
  endTimeAfter        = segs['buffer'][1] + numSegsAfterBuffer*trialTime
  numSegs             = numSegsBeforeBuffer + numSegsAfterBuffer
  
  if verbose:
    print >>sys.stdout
    print >>sys.stdout, 'Loading triggers...'

  # load triggers 
  xmldoc = utils.load_filename(trigFile,gz=trigFile.endswith("gz"))
  trigs = table.get_table(xmldoc, lsctables.MultiInspiralTable.tableName)
  searchSumm = table.get_table( xmldoc, lsctables.SearchSummaryTable.tableName )

  # extract variables
  ifos = sorted(map(str,searchSumm[0].get_ifos()))
  ifoAtt = { 'G1':'g', 'H1':'h1', 'H2':'h2', 'L1':'l', 'V1':'v', 'T1':'t' }

  # Parameters for auto and bank veto  
  massBins = [[0,3.48],[3.48,6.],[6.,20]]


  trigTime = {}
  trigSNR = {}
  trigBestNR = {}
  
  for bin in massBins:
    trigTime[bin[0]] = []
    trigSNR[bin[0]] = []
    trigBestNR[bin[0]] = []
  
  timeBinMaxSNR    = numpy.zeros([len(massBins)+1,numSegs],dtype = float)
  timeBinMaxBestNR = numpy.zeros([len(massBins)+1,numSegs],dtype = float)

  # store response function for each sky locations
  fResp = {}
  
  for trig in trigs:
    trigBin = None
    binNum = 0
    for bin in massBins:
      if bin[0] <= trig.mchirp < bin[1]:
        if not trigBin:
          trigBin = bin
          trigBinNum = binNum
        else:
          print >>sys.stderr, "ERROR: Mass bins appear to overlap"
      binNum += 1
  
    if not trigBin:
      print >>sys.stderr, "ERROR: No mass bins match trigger with mchirp %s"\
                          % chirpMass
  
    trigTime[trigBin[0]].append( trig.get_end() )
    trigSNR[trigBin[0]].append( trig.snr )

    # get sky location and response
    trigPos = (trig.ra,trig.dec)
    if trigPos not in fResp.keys():
      ra            = trig.ra*fRadDeg
      dec           = trig.dec*fRadDeg
      fPlus,fCross  = get_det_response( ra, dec, segs['on'][-1]-1 )
      fResp[trigPos] = {}
      for ifo in ifos:
        fResp[trigPos][ifo] = fPlus[ifo]*fPlus[ifo] + fCross[ifo]*fCross[ifo]

    # calculate signal based statistics
    bestNR = get_bestnr( trig, q=chisq_index, n=chisq_nhigh,\
                         null_thresh=null_thresh, fResp=fResp[trigPos])

    trigBestNR[trigBin[0]].append( bestNR )

    # Determine chunk number
    chunkNum = numSegs
    if trig.get_end() < segs['buffer'][0]:
      if trig.get_end() < ( segs['off'][0]+paddingTime ):
        raise ValueError, "ERROR: trig time is outside given analysis "+\
                          "window! %s" % trig.get_end()
      if trig.get_end() < endTimeBefore:
        chunkNum = float(trig.get_end() - (segs['off'][0]+paddingTime))\
                   // trialTime
    elif trig.get_end() > segs['buffer'][1]:
      if trig.get_end() > ( segs['off'][1] - paddingTime ):
        raise ValueError, "ERROR: trig time is outside given analysis "+\
                          "window! %s" % trig.get_end()
      if trig.get_end() < endTimeAfter:
        chunkNum = float(trig.get_end() - segs['buffer'][1])\
                   // trialTime + numSegsBeforeBuffer
    if chunkNum == numSegs:
      continue

    if timeBinMaxSNR[trigBinNum,chunkNum] < trigSNR[trigBin[0]][-1]:
      timeBinMaxSNR[trigBinNum,chunkNum] = trigSNR[trigBin[0]][-1]
    if timeBinMaxSNR[len(massBins),chunkNum] < trigSNR[trigBin[0]][-1]:
      timeBinMaxSNR[len(massBins),chunkNum] = trigSNR[trigBin[0]][-1]

    if timeBinMaxBestNR[trigBinNum,chunkNum] < trigBestNR[trigBin[0]][-1]:
        timeBinMaxBestNR[trigBinNum,chunkNum]    = trigBestNR[trigBin[0]][-1]
    if timeBinMaxBestNR[len(massBins),chunkNum] < trigBestNR[trigBin[0]][-1]:
      timeBinMaxBestNR[len(massBins),chunkNum] = trigBestNR[trigBin[0]][-1]
 
  # ==========================
  # print loudest SNRs to file
  # ==========================
 
  maxSNR       = {}
  maxBestNR    = {}
  medianSNR    = {}
  medianBestNR = {}
  maxBestNR    = {}
  medianBestNR = {}
  
  th = ['','SNR','BestNR']
  td = []

  binNum = 0
  for bin in massBins:
    trigSNR[bin[0]] = numpy.asarray(trigSNR[bin[0]])
    trigTime[bin[0]] = numpy.asarray(trigTime[bin[0]])
    maxSNR[bin[0]] = trigSNR[bin[0]].max()
    timeBinMaxSNR[binNum].sort()
 
    trigBestNR[bin[0]] = numpy.asarray(trigBestNR[bin[0]])
    maxBestNR[bin[0]]  = trigBestNR[bin[0]].max()
    timeBinMaxBestNR[binNum].sort()
    if (numSegs % 2):
      medianSNR[bin[0]] = (timeBinMaxSNR[binNum])[(numSegs - 1) /2]
      medianBestNR[bin[0]] = (timeBinMaxBestNR[binNum])[(numSegs - 1) /2]
    else:
      medianSNR[bin[0]] = (timeBinMaxSNR[binNum])\
                              [numSegs/2 - 1:numSegs/2 + 1].mean()
      medianBestNR[bin[0]]\
          = (timeBinMaxBestNR[binNum])[numSegs/2 - 1:numSegs/2 + 1].mean()
  
    binNum += 1
  
    d = [ 'Loudest in Mchirp bin %s - %s' % tuple(bin), maxSNR[bin[0]],\
          maxBestNR[bin[0]] ]
    td.append(d)
    d = [ 'Median in Mchirp bin %s - %s' % tuple(bin), medianSNR[bin[0]],\
           medianBestNR[bin[0]] ]
    td.append(d)
    td.append([]) 
 
  # work out all mass bins
  maxSNR['all'] = numpy.array(maxSNR.values()).max()
  maxBestNR['all'] = numpy.array(maxBestNR.values()).max()
  if (numSegs % 2):
    medianSNR['all'] = (timeBinMaxSNR[binNum])[(numSegs - 1) /2]
    medianBestNR['all'] = (timeBinMaxBestNR[binNum])[(numSegs - 1) /2]
  else:
    medianSNR['all']\
        = (timeBinMaxSNR[binNum])[numSegs/2 - 1:numSegs/2 + 1].mean()
    medianBestNR['all']\
        = (timeBinMaxBestNR[binNum])[numSegs/2 - 1:numSegs/2 + 1].mean()
  
  # print to html table
  d = [ "Loudest in all bins", maxSNR['all'], maxBestNR['all'] ]
  td.append(d)
  d = [ "Median in all bins", medianSNR['all'], medianBestNR['all'] ]
  td.append(d)

  # write html table with results
  page = markup.page()
  page = write_table( page, th, td )

  file = open( '%s/loudest_offsource.html' % outdir, 'w' ) 
  file.write( page() )
 
  # ============================================ 
  # Now we can start dealing with the injections
  # ============================================ 

  if doinj:

    if verbose:
      print >>sys.stdout
      print >>sys.stdout, 'Loading injections...'

    sites = [ ifo[0] for ifo in ifos ]

    foundInjs  = SimInspiralUtils.ReadSimInspiralFromFiles([foundFile])
    missedInjs = SimInspiralUtils.ReadSimInspiralFromFiles([missedFile])
    foundTrigs = MultiInspiralUtils.ReadMultiInspiralFromFiles([foundFile])
  
    gFoundMchirp = []
    gFoundMtot = []
    gFoundEffDist = []
    gFoundEffSiteDist = {}
    for site in sites:
      gFoundEffSiteDist[site] = []
    gFoundDetStat = []
    gFoundDist = []
    gFoundTime = []
    gFoundSkyAngle = []
    gIFARMchirp = []
    gIFARMtot = []
    gIFAREffDist = []
    gIFAREffSiteDist = {}
    for site in sites:
      gIFAREffSiteDist[site] = []
    gIFARDetStat = []
    gIFARDist = [] 
    gIFARTime = []
    gIFARStat = []
    gIFARTrig = []
    gIFARInj = []
    gIFARSkyAngle = []
    gMissed2Mchirp = []
    gMissed2Effdist = []
    gMissed2EffSitedist = {}
    for site in sites:
      gMissed2EffSitedist[site] = []
    gMissed2Dist = []
    gMissed2Mtot = []
    gMissed2Time = []
    gMissed2Trig = []
    gMissed2Inj = []
    gMissedMchirp = []
    gMissedEffdist = []
    gMissedEffDist = {}
    for site in sites:
      gMissedEffDist[site] = []
    gMissedDist = []
    gMissedTime = []
   
    distBins = [ [0.5,5], [5,10], [10,15], [15,20], [20,25], [25,30], [30,35],\
                 [35,40], [40,45], [45,50] ]
  
    numInjections = numpy.zeros([len(massBins)+1,len(distBins)+1],dtype=float)
    foundmaxSNRinj = numpy.zeros([len(massBins)+1,len(distBins)+1],dtype=float)
    foundmedSNRinj = numpy.zeros([len(massBins)+1,len(distBins)+1],dtype=float)
    foundmaxBestNR = {}
    foundmedBestNR = {}
    foundmaxBestNR = numpy.zeros( [len(massBins)+1, len(distBins)+1 ],\
                                  dtype=float )
    foundmedBestNR = numpy.zeros( [len(massBins)+1, len(distBins)+1 ],\
                                  dtype=float)
   
    # process found injections
    for inj,trig in zip(foundInjs,foundTrigs):

      try:
        effDist = sum([ 1/getattr(trig,'eff_dist_%s' % ifoAtt[ifo] )\
                        for ifo in ifos ])**-1
      except ZeroDivisionError:
        effDist = 0

      injBin = None
      trigBin = None

      for i,bin in enumerate(massBins):
        if bin[0] <= inj.mchirp < bin[1]:
          injBinNum = i
          injBin = bin
        if bin[0] <= trig.mchirp < bin[1]:
          trigBinNum = i
          trigBin = bin
        if trigBin and injBin:  break

      if not injBin:
        print "ERROR: No mass bins match found injection trigger with mchirp "+\
              "%s" % inj.mchirp
      if not trigBin:
        print "ERROR: No mass bins match found injection trigger with mchirp "+\
              "%s" % trig.mchirp

      injDistBin = None
      distNum = 0
      for bin in distBins:
        if bin[0] <= inj.distance < bin[1]:
          if not injDistBin:
            injDistNum = distNum
            injDistBin = bin
          else:
            print "ERROR: Distance bins appear to overlap"
        distNum += 1
  
      if injDistBin:
        numInjections[injBinNum,injDistNum] += 1
        numInjections[len(massBins),injDistNum] += 1
      numInjections[injBinNum,len(distBins)] += 1
      numInjections[len(massBins),len(distBins)] += 1
 
      # get sky location and response
      trigPos = (trig.ra,trig.dec)
      injPos  = (inj.longitude,inj.latitude)
      if trigPos not in fResp.keys():
        ra            = trig.ra*fRadDeg
        dec           = trig.dec*fRadDeg
        fPlus,fCross  = get_det_response( ra, dec, segs['on'][-1]-1 )
        fResp[trigPos] = {}
        for ifo in ifos:
          fResp[trigPos][ifo] = fPlus[ifo]*fPlus[ifo] + fCross[ifo]*fCross[ifo]
 
      bestNR = get_bestnr( trig, q=chisq_index, n=chisq_nhigh,\
                                  null_thresh=null_thresh, fResp=aPat[trigPos])

      statList     = [ trig.snr, bestNR ]
      foundMaxList = [ foundmaxSNRinj, foundmaxBestNR ]
      foundMedList = [ foundmedSNRinj, foundmedBestNR ]
      maxStatList  = [ maxSNR, maxBestNR ]
      medStatList  = [ medianSNR, medianBestNR ]

      # get sky angle between injected and recovered positions
      centralAngle = numpy.arccos( numpy.cos(injPos[1]-trigPos[1]) -\
                                   numpy.cos(injPos[1])*numpy.cos(trigPos[1]) *\
                                   (1 - numpy.cos(injPos[0]-trigPos[0])) )  

      # Note that hero we are using BestNRmk8 as the detection stat
      # if louder than all background:
      if bestNR > maxBestNR[trigBin[0]]:
        gFoundEffDist.append(effDist)
        for site in sites:
          gFoundEffSiteDist[site].append( getattr(inj,'eff_dist_%s'\
                                                               % site.lower()) )
        gFoundDist.append( inj.distance )
        gFoundMchirp.append( inj.mchirp )
        gFoundMtot.append( inj.mass1 + inj.mass2 )
        gFoundDetStat.append( bestNR )
        gFoundTime.append( float(inj.get_time_geocent()) )
        gFoundSkyAngle.append( float(centralAngle) )
      #elif found at all:
      elif bestNR > 0:
        gIFARMchirp.append( inj.mchirp )
        gIFARMtot.append( inj.mass1 + inj.mass2 )
        gIFAREffDist.append( effDist )
        for site in sites:
          gIFAREffSiteDist[site].append( getattr(inj,'eff_dist_%s'\
                                                     % site.lower()) )
        gIFARDist.append( inj.distance )
        gIFARTime.append( float(inj.get_time_geocent()) )
        numTrialsLouder = 0
        for val in timeBinMaxBestNR[trigBinNum]:
          if val > bestNR:
            numTrialsLouder+=1
        gIFARStat.append(numTrialsLouder/numSegs)
        gIFARTrig.append(trig)
        gIFARInj.append(inj)
        gIFARSkyAngle.append( float(centralAngle) )
      # else missed:
      else:
        gMissed2Effdist.append(effDist)
        for site in sites:
          gMissed2EffSitedist[site].append( getattr(inj,'eff_dist_%s'\
                                                        % site.lower()) )
        gMissed2Trig.append( trig )
        gMissed2Inj.append( inj )
        gMissed2Mchirp.append( inj.mchirp )
        gMissed2Mtot.append( inj.mass1 + inj.mass2 )
        gMissed2Dist.append( inj.distance )
        gMissed2Time.append( float(inj.get_time_geocent()) )

    # write quiet triggers to file      
    gQuietFound  = zip(gIFAREffDist,gIFARTrig,gIFARInj,gIFARStat)
    gQuietFound2 = zip(gMissed2Effdist,gMissed2Trig,gMissed2Inj,\
                       numpy.zeros([len(gMissed2Inj)]))
    gQuietFound.extend(gQuietFound2)
    gQuietFound.sort(key = lambda element:element[0])
 
    th = [ 'Num', 'Dist' ]
    for site in sites:  th.append( 'Eff. Dist %s' % site )
    th.extend([ 'Inj. m1', 'Inj. m2', 'Inj. Mc',\
                'Rec. m1', 'Rec. m2', 'Rec. Mc',\
                'Inj. inc', 'Inj. RA', 'Inj. Dec', 'Rec. RA', 'Rec. Dec',\
                'SNR', 'Chi^2', 'Bank veto', 'Auto veto',\
                'Null SNR'])
    for ifo in ifos:  th.append( 'SNR %s' % ifo )
    th.append('BestNR')
    td = []
 
    for i in range(10):
      inj = gQuietFound[i][2]
      trig = gQuietFound[i][1]
      bestNR = get_bestnr( trig, q=chisq_index, n=chisq_nhigh,\
                                  null_thresh=null_thresh, fResp=aPat[trigPos])
      if len(ifos)>2:
        nullsnr = ( sum([ getattr(trig,'snr_%s' % ifoAtt[ifo])**2\
                          for ifo in ifos ])\
                    - trig.snr**2 )**0.5
      else:
        nullsnr = 0
      d = [ i, inj.distance ]
      for site in sites:
        d.append( getattr(inj, 'eff_dist_%s' % site.lower() ) )
      d.extend([ inj.mass1, inj.mass2, inj.mchirp,\
                 trig.mass1, trig.mass2, trig.mchirp,\
                 inj.inclination, inj.longitude*fRadDeg, inj.latitude*fRadDeg,\
                 trig.ra*fRadDeg, trig.dec*fRadDeg,\
                 trig.snr, trig.chisq, trig.bank_chisq,\
                 trig.cont_chisq, nullsnr ])
      for ifo in ifos:
        d.append( getattr(trig,'snr_%s' % ifoAtt[ifo]) )
      d.append(bestNR)
      # append trigger to list
      td.append(d) 
    page = markup.page()
    page = write_table( page, th, td )
    file = open( "%s/quiet_found_triggers.html" % outdir, "w" ) 
    file.write( page() )
    file.close()
  
    # process missed injections
    for inj in missedInjs:
      effDist = sum([ 1/getattr(inj,'eff_dist_%s' % ifo[0].lower() )\
                      for ifo in ifos ])**-1
  
      trigBin = None
      binNum = 0
      for i,bin in enumerate(massBins):
        if bin[0]<= inj.mchirp < bin[1]:
          trigBinNum = i
          trigBin = bin
          break
        binNum += 1
      if not trigBin:
        print "ERROR: No mass bins match missed injection with mchirp "+\
              "%s" % inj.mchirp
      trigDistBin = None
      distNum = 0
      for i,bin in enumerate(distBins):
        if bin[0] <= inj.distance < bin[1]:
          trigDistNum = i
          trigDistBin = bin
        distNum += 1
  
      if trigDistBin:
        numInjections[trigBinNum,trigDistNum] += 1
        numInjections[len(massBins),trigDistNum] += 1
      numInjections[trigBinNum,len(distBins)] += 1
      numInjections[len(massBins),len(distBins)] += 1
  
      gMissedEffdist.append( effDist )
      gMissedMchirp.append(  inj.mchirp )
      gMissedDist.append(    inj.distance )
      gMissedTime.append(    float(inj.get_time_geocent()) )

      for site in sites:
        gMissedEffDist[site].append( getattr(inj,'eff_dist_%s'\
                                                 % site.lower()) )

    start = int(min([min(gMissedTime),min(gFoundTime),min(gIFARTime),\
                     min(gMissed2Time)])) 
    end   = int(max([max(gMissedTime),max(gFoundTime),max(gIFARTime),\
                     max(gMissed2Time)])+1)

    duration = end-start
    start -= duration*0.05
    end += duration*0.05-start

    gMissedTime  = [ t-start for t in gMissedTime ]
    gMissed2Time = [ t-start for t in gMissed2Time ]
    gFoundTime   = [ t-start for t in gFoundTime ]
    gIFARTime    = [ t-start for t in gIFARTime ]
 
  # =======================
  # load on source triggers
  # ======================= 

  if onsourceFile:

    if verbose:
      print >>sys.stdout
      print >>sys.stdout, 'Loading on source triggers...'

    onTrigs = MultiInspiralUtils.ReadMultiInspiralFromFiles([onsourceFile])

    if verbose:
      print >>sys.stdout
      print >>sys.stdout, 'Analysing on source...'

    loudBestNRTrigs = {}
    loudSNRTrigs = {}
    loudBestNR = {}
    loudSNR = {}

    # bin triggers in mass 
    for trig in onTrigs:
      trigBin = None
      for i,bin in enumerate(massBins):
        if bin[0] <= trig.mchirp < bin[1]:
          trigBin = bin
          break
  
      if not trigBin:
        print >>sys.stderr, "ERROR: No mass bins match on source trigger"+\
                            " with mchirp %s" % trig.mchirp

      # get sky location and response
      trigPos = (trig.ra,trig.dec)
      if trigPos not in fResp.keys():
        ra            = trig.ra*fRadDeg
        dec           = trig.dec*fRadDeg
        fPlus,fCross  = get_det_response( ra, dec, segs['on'][-1]-1 )
        fResp[trigPos] = {}
        for ifo in ifos:
          fResp[trigPos][ifo] = fPlus[ifo]*fPlus[ifo] + fCross[ifo]*fCross[ifo]
 
      bestNR = get_bestnr( trig, q=chisq_index, n=chisq_nhigh,\
                                  null_thresh=null_thresh, fResp=fResp[trigPos])

      if loudSNRTrigs.has_key(trigBin[0]):
        if loudSNR[trigBin[0]] < trig.snr:
          loudSNR[trigBin[0]]      = trig.snr
          loudSNRTrigs[trigBin[0]] = trig
      else:
        loudSNR[trigBin[0]]      = trig.snr
        loudSNRTrigs[trigBin[0]] = trig
      if loudBestNRTrigs.has_key(trigBin[0]):
        if loudBestNR[trigBin[0]] < bestNR:
          loudBestNR[trigBin[0]] = bestNR
          loudBestNRTrigs[trigBin[0]] = trig
      elif bestNR != 0:
        loudBestNR[trigBin[0]] = bestNR
        loudBestNRTrigs[trigBin[0]] = trig
  
    file2 = open( '%s/loud_numbers.txt' % outdir, 'w' )
    th = [ 'Bin', 'FAP', 'GPS', 'Rec. m1', 'Rec. m2', 'Rec. Mc', 'Rec. RA',\
           'Rec. Dec', 'SNR', 'Chi^2', 'Bank veto', 'Auto veto', 'Null SNR' ]
    th.extend([ '%s SNR' % ifo for ifo in ifos ])
    th.append('BestNR')
    td = [] 
 
    binNum = 0
    for bin in massBins:
      numTrialsLouder = 0
      if loudBestNR.has_key(bin[0]):
        for val in timeBinMaxBestNR[binNum]:
          if val > loudBestNR[bin[0]]:
            numTrialsLouder += 1
        FAP = numTrialsLouder/numSegs
        trig = loudBestNRTrigs[bin[0]]
        trigPos = (trig.ra,trig.dec)
        bestNR = get_bestnr( trig, q=chisq_index, n=chisq_nhigh,\
                             null_thresh=null_thresh, fResp=fResp[trigPos])
        if len(ifos)>2:
          nullsnr = ( sum([ getattr(trig,'snr_%s' % ifoAtt[ifo])**2\
                            for ifo in ifos ])\
                      - trig.snr**2 )**0.5
        else:
          nullsnr = 0

        d = [ '%s-%s' % tuple(bin), FAP, trig.get_end(),\
              trig.mass1, trig.mass2, trig.mchirp,\
              trig.ra*fRadDeg, trig.dec*fRadDeg,\
              trig.snr, trig.chisq, trig.bank_chisq,\
              trig.cont_chisq, nullsnr ]
        d.extend([ getattr(trig,'snr_%s' % ifoAtt[ifo])\
                   for ifo in ifos ])
        d.append(bestNR)
        print >>file2, str(FAP)
        td.append(d)  

      else:
        td.append(["In mass bin %s to %s there are no events" % tuple(bin)])
        print >>file2, '-2'
      binNum += 1

    file = open( "%s/loudest_events.html" % outdir, "w" )
    page = markup.page()
    page = write_table( page, th, td )
    file.write( page() )
    file.close()
    file2.close()
  
  # ==========
  # make plots
  # ==========
  makePaperPlots()

  # plot cumulative histograms
  if verbose:
    print >>sys.stdout
    print >>sys.stdout, 'Plotting cumulative histograms...'

  binNum = 0
  for bin in massBins:
    fig = pylab.figure()
    ax = fig.gca()
    temp = []
    for item in timeBinMaxBestNR[binNum]:
      temp.append([item])
    cumplot = plotutils.CumulativeHistogramPlot( "BestNR",
                                                 "False alarm probability",
                                                 "" )
    cumplot.add_background(temp)
    cumplot.finalize(num_bins=50)
    cumplot.ax.set_ylim(ymax=1.2)
    cumplot.savefig( '%s/bestnr_vs_fap_%s_%s.png' % ( outdir, bin[0], bin[1] ) )

    fig = pylab.figure()
    ax = fig.gca()
    temp = []
    for item in timeBinMaxSNR[binNum]:
      temp.append([item])
    cumplot = plotutils.CumulativeHistogramPlot( "SNR",
                                                 "False alarm probability",
                                                 "" )
    cumplot.add_background(temp)
    cumplot.finalize(num_bins=50)
    cumplot.ax.set_ylim(ymax=1.2)
    cumplot.savefig( '%s/snr_vs_fap_%s_%s.png' % ( outdir, bin[0], bin[1] ) )
    binNum+=1
  
  if doinj:
    distPlotVals = []
  
    for bin in distBins:
      distPlotVals.append( sum(bin)/2 )
  
    ptfcolormap = pylab.cm.spring
    ptfcolormap.set_over('g')
  
    lineColours = ['r-','b-','g-','m-','c-']
    lineColors = ['r','b','g','m','c']
  
    statList = [ 'SNR', 'BestNR' ]
    maxList = [foundmaxSNRinj, foundmaxBestNR ]
    medList = [foundmedSNRinj, foundmedBestNR ]
  
    file = open( "%s/injection_recovery.html" % outdir, "w" )
  
    for stat,maxi,med in zip(statList,maxList,medList):
      for found,name in zip([maxi,med],['max','med']):

        fig = pylab.figure()
        ax = fig.gca()
        legendText = []
        iter = 0
        for bin in massBins:
          ax.plot( distPlotVals, (found/numInjections)[iter,0:-1],\
                   lineColours[iter] )
          legendText.append( "mchirp %s to %s" % tuple(bin) )
          iter += 1
          if name == 'max':
            print >>file, "Total injections found in bin mchirp %s to %s louder than all background in that bin using %s is: %s"\
                          % ( bin[0], bin[1], stat, found[iter,-1] )

          elif name == 'med':
            print >>file, "Total injections found in bin mchirp %s to %s louder than the median loudest background in that bin using %s is: %s"\
                          % ( bin[0], bin[1], stat, found[iter,-1] )
          print >>file

        ax.plot( distPlotVals, (found/numInjections)[iter,0:-1],\
                 lineColours[iter] )
        legendText.append( "All mass bins" )
        if name == 'max':
          print >>file, "Total injections found in all mass bins louder than "+\
                        "all background using %s is: %s"\
                        % ( stat, found[iter,-1] )

        elif name == 'med':
          print >>file, "Total injections found in all mass bins louder than "+\
                        "the median of the loudest background using %s is: %s"\
                        % ( stat, found[iter,-1] )
        print >>file

        iter = 0
        for bin in massBins:
          ax.errorbar( distPlotVals, (found/numInjections)[iter,0:-1],\
                       yerr=((1/numInjections)**0.5)[iter,0:-1],\
                       c=lineColors[iter] )
          iter += 1
        ax.errorbar( distPlotVals, (found/numInjections)[iter,0:-1],\
                     yerr=((1/numInjections)**0.5)[iter,0:-1],\
                     c=lineColors[iter] )
        ax.set_ylim( [0,1] )
        ax.set_title( "Efficiency of injection finding using "+\
                      "%s as detection statistic" % stat )

        if name == 'max':
          ax.set_ylabel( "Fraction of injections found louder than "+\
                         "loudest background" )
        else:
          ax.set_ylabel( "Fraction of injections found louder than "+\
                         "median loudest background" )
        ax.set_xlabel( "Distance" )
        ax.legend(legendText)
        fig.savefig( '%s/%s_%s_efficiency.png' % ( outdir, stat, name ) )
  
    binNum = 0
    for bin in massBins:
      fig = pylab.figure()
      ax = fig.gca()
      temp = []
      for item in timeBinMaxBestNR[binNum]:
        temp.append([item])
      cumplot = plotutils.CumulativeHistogramPlot( "BestNR",
                                                   "False alarm probability",
                                                   "" )
      cumplot.add_background(temp)
      cumplot.finalize(num_bins=50)
      cumplot.ax.set_ylim(ymax=1.2)
      cumplot.savefig( "%s/bestnr_vs_fap_%s_%s.png"\
                       % ( outdir, bin[0], bin[1] ) )

      fig = pylab.figure()
      ax = fig.gca()
      temp = []
      for item in timeBinMaxSNR[binNum]:
        temp.append([item])
      cumplot = plotutils.CumulativeHistogramPlot( "SNR",
                                                   "False alarm probability",
                                                   "" )
      cumplot.add_background(temp)
      cumplot.finalize(num_bins=50)
      cumplot.ax.set_ylim(ymax=1.2)
      cumplot.savefig( '%s/snr_vs_fap_%s_%s.png' % ( outdir, bin[0], bin[1] ) )
      binNum+=1
  
    fig = pylab.figure()
    ax = fig.gca()
    ax.scatter( gMissedMchirp, gMissedEffdist, c="k", marker='x',\
                edgecolors='k' )
    ax.scatter( gMissed2Mchirp, gMissed2Effdist, c="r", marker='x',\
                edgecolors='r' )
    ax.scatter( gFoundMchirp, gFoundEffDist, c="b", marker='x', edgecolors='g' )
    p = ax.scatter( gIFARMchirp, gIFAREffDist, c=gIFARStat,\
                    norm=pylab.Normalize(0,1,clip=False), marker='o',\
                    edgecolors='none' )
    ax.semilogy()
    cb = ax.figure.colorbar( p )
    cb.ax.set_ylabel( "FAP" )
    ax.set_xlabel( "Mchirp" )
    ax.set_ylabel( "Inverse sum of effective distances" )
    ax.set_title( "Injections found louder than loudest background event" )
    ax.set_ylim([ 0.5, 1000 ])
    fig.savefig( '%s/found_missed_injections_effdist.png' % outdir )
  
    fig = pylab.figure()
    ax = fig.gca()
    ax.scatter( gMissedTime, gMissedEffdist, c="k", marker='x', edgecolors='k' )
    ax.scatter( gMissed2Time, gMissed2Effdist, c="r", marker='x',\
                edgecolors='r' )
    ax.scatter( gFoundTime, gFoundEffDist, c="b", marker='x', edgecolors='g' )
    p = ax.scatter( gIFARTime, gIFAREffDist, c=gIFARStat,\
                    norm=pylab.Normalize(0,1,clip=False), marker='o',\
                    edgecolors='none' )
    ax.semilogy()
    cb = ax.figure.colorbar( p )
    cb.ax.set_ylabel( "FAP" )
    ax.set_xlabel( "Time since %d" % start )
    ax.set_ylabel( "Inverse sum of effective distances" )
    ax.set_title( "Injections found louder than loudest background event" )
    ax.set_xlim([ 0, end ])
    ax.set_ylim([ 0.5, 1000 ])
    fig.savefig( "%s/found_missed_injections_effdist_time.png" % outdir )
  
    sitename = { 'G':'GEO', 'H':'Hanford', 'L':'Livingston', 'V':'Virgo',\
                 'T':'TAMA' }

    for site in sites:
      fig = pylab.figure()
      ax = fig.gca()
      ax.scatter( gMissedMchirp, gMissedEffDist[site],\
                  c="k", marker='x', edgecolors='k' )
      ax.scatter( gMissed2Mchirp, gMissed2EffSitedist[site],\
                  c="r", marker='x', edgecolors='r' )
      ax.scatter( gFoundMchirp, gFoundEffSiteDist[site],\
                  c="b", marker='x', edgecolors='g' )
      p = ax.scatter( gIFARMchirp, gIFAREffSiteDist[site],\
                      c=gIFARStat, norm=pylab.Normalize(0,1,clip=False),\
                      marker='o', edgecolors='none' )
      ax.semilogy()
      cb = ax.figure.colorbar( p )
      cb.ax.set_ylabel( "FAP" )
      ax.set_xlabel( "Mchirp" )
      ax.set_ylabel( "%s effective distance" % sitename[site] )
      ax.set_title( "Injections found louder than loudest background event" )
      ax.set_ylim([ 0.5, 1000 ])
      fig.savefig( "%s/found_missed_injections_effdist_%s.png"\
                   % ( outdir, site.lower() ) )
  
      fig = pylab.figure()
      ax  = fig.gca()
      ax.scatter( gMissedTime, gMissedEffDist[site],\
                  c="k", marker='x', edgecolors='k' )
      ax.scatter( gMissed2Time, gMissed2EffSitedist[site],\
                  c="r", marker='x', edgecolors='r' )
      ax.scatter( gFoundTime, gFoundEffSiteDist[site],\
                  c="b", marker='x', edgecolors='g' )
      p = ax.scatter( gIFARTime ,gIFAREffSiteDist[site],\
                      c=gIFARStat, norm=pylab.Normalize(0,1,clip=False),\
                      marker='o', edgecolors='none' )
      ax.semilogy()
      cb = ax.figure.colorbar( p )
      cb.ax.set_ylabel( "FAP" )
      ax.set_xlabel( "Time since %d" % start )
      ax.set_ylabel( "%s effective distance" % sitename[site] )
      ax.set_title( "Injections found louder than loudest background event" )
      ax.set_xlim([ 0, end ])
      ax.set_ylim([ 0.5, 1000 ])
      fig.savefig( "%s/found_missed_injections_effdist_time_%s.png"\
                   % ( outdir, site.lower() ) )
  
    fig = pylab.figure()
    ax = fig.gca()
    ax.scatter( gMissedMchirp, gMissedDist,c="k", marker='x', edgecolors='k' )
    ax.scatter( gMissed2Mchirp, gMissed2Dist,c="r", marker='x', edgecolors='r' )
    ax.scatter( gFoundMchirp, gFoundDist, c="b", marker='x', edgecolors='g' )
    p = ax.scatter( gIFARMchirp, gIFARDist, c=gIFARStat,\
                    norm=pylab.Normalize(0,1,clip=False),\
                    marker='o', edgecolors='none' )
    ax.semilogy()
    cb = ax.figure.colorbar( p )
    cb.ax.set_ylabel( "FAP" )
    ax.set_xlabel( "Mchirp" )
    ax.set_ylabel( "Distance" )
    ax.set_title( "Injections found louder than loudest background event" )
    ax.set_ylim([ 0.5, 100 ])
    fig.savefig( "%s/found_missed_injections_dist.png" % outdir )
  
    fig = pylab.figure()
    ax = fig.gca()
    ax.scatter( gMissedTime, gMissedDist, c="k", marker='x', edgecolors='k' )
    ax.scatter( gMissed2Time, gMissed2Dist, c="r", marker='x', edgecolors='r' )
    ax.scatter( gFoundTime, gFoundDist, c="b", marker='x', edgecolors='g' )
    p = ax.scatter( gIFARTime, gIFARDist, c=gIFARStat,\
                    norm=pylab.Normalize(0,1,clip=False),\
                    marker='o', edgecolors='none' )
    ax.semilogy()
    cb = ax.figure.colorbar( p )
    cb.ax.set_ylabel("FAP" )
    ax.set_xlabel( "Time since %d" % start )
    ax.set_ylabel( "Distance" )
    ax.set_title( "Injections found louder than loudest background event" )
    ax.set_xlim([ 0, end ])
    ax.set_ylim([ 0.5, 100 ])
    fig.savefig( "%s/found_missed_injections_dist_time.png" % outdir )

    # plot sky recovery
    fig = pylab.figure()
    ax = fig.gca()
    ax.plot( gFoundTime, gFoundSkyAngle, 'b.' )
    ax.plot( gIFARTime, gIFARSkyAngle, 'b.' )
    ax.set_xlabel( "Time since %d" % start )
    ax.set_ylabel( "Rec. sky error (radians)" )
    ax.set_xlim([ 0, end ])
    fig.savefig( '%s/found_sky_error_time.png' % outdir )
  
    fig = pylab.figure()
    ax = fig.gca()
    ax.plot( gFoundMchirp, gFoundSkyAngle, 'b.' )
    ax.plot( gIFARMchirp, gIFARSkyAngle, 'b.' )
    ax.set_xlabel( "Mchirp" )
    ax.set_ylabel( "Rec. sky error (radians)" )
    fig.savefig( '%s/found_sky_error_mchirp.png' % outdir )

    fig = pylab.figure()
    ax = fig.gca()
    ax.plot( gFoundDist, gFoundSkyAngle, 'b.' )
    ax.plot( gIFARDist, gIFARSkyAngle, 'b.' )
    ax.set_xlabel( "Distance" )
    ax.set_ylabel( "Rec. sky error (radians)" )
    ax.semilogx()
    ax.set_xlim([ 0.5,100 ])
    fig.savefig( '%s/found_sky_error_distance.png' % outdir )
 
if __name__=='__main__':

  opts, args = parse_command_line()

  segdir       = opts.segment_dir
  outdir       = opts.output_path
  trigFile     = opts.offsource_file
  foundFile    = opts.found_file
  missedFile   = opts.missed_file
  onsourceFile = opts.onsource_file
  verbose      = opts.verbose
  doinj        = opts.do_injections
  q            = opts.chisq_index
  n            = opts.chisq_nhigh
  nullt        = map( float, opts.null_snr_threshold.split(',') )
 
  main( segdir, outdir, trigFile, foundFile, missedFile,\
        onsourceFile, verbose=verbose, doinj=doinj, chisq_index=q,\
        chisq_nhigh=n, null_thresh = nullt )

