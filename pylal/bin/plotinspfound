#!/usr/bin/python
__author__ = "David McKechan"
__title__ = "Track the SNR of found triggers"
__name__ = "plotinspfound"
###############################################################################
import sys, os, re, glob, exceptions
from optparse import *
from matplotlib.ticker import FormatStrFormatter
from glue import segments
from glue import segmentsUtils
from glue import lal
from glue.ligolw import lsctables
from pylal import SnglInspiralUtils
from pylal import CoincInspiralUtils
from pylal import InspiralUtils
import numpy
import matplotlib
matplotlib.use('Agg')
from pylab import *


###############################################################################
usage =  """Usage: %prog [options]

plotinspfound --cache-file triggers.cache --bbhinj --core-first --h1-triggers

"""


def parse_command_line():
  """
  Parser function dedicated
  """
  parser = OptionParser( usage=usage) 
  parser.add_option("-c", "--cache-file", help="LAL cache of relevant files")
  parser.add_option("-t", "--threshold", action="store", type="float", \
                    default=0.,help="actual loss in  SNR to flag.")
  parser.add_option("-d", "--display", action="store_true",\
                     default=False, help="print snr loss information" )
  parser.add_option("-v", "--verbose",action="store_true",\
                     default=False,help="print all information" )
  parser.add_option("-m", "--plot-mchirp",action="store_true",\
                     default=False,help="plot snr loss against mchirp" )
  parser.add_option("-e", "--plot-end-time",action="store_true",\
                     default=False,help="plot snr loss agains end_time" )
  parser.add_option("-s", "--plot-snr",action="store_true",\
                     default=False,help="plot snr loss agains snr" )
  parser.add_option("-b", "--bbhinj",action="store_true",\
                     default=False,help="use bbhinj trigger files" )
  parser.add_option("-n", "--nsbhinj",action="store_true",\
                     default=False,help="use nsbhinj trigger files" )
  parser.add_option("-l", "--bnsinj",action="store_true",\
                     default=False,help="use bnsinj trigger files" )
  parser.add_option("-S", "--spininj",action="store_true",\
                     default=False,help="use spininj trigger files" )
  parser.add_option("-f", "--coire-first",action="store_true",\
                     default=False,help="check snr at first coincidence stage" )
  parser.add_option("-r", "--sire-second",action="store_true",\
                     default=False,help="check snr at second inspiral stage" )
  parser.add_option("-H", "--h1-triggers",action="store_true",\
                     default=False,help="use H1 triggers" )
  parser.add_option("-w", "--h2-triggers",action="store_true",\
                     default=False,help="use H2 triggers" )
  parser.add_option("-L", "--l1-triggers",action="store_true",\
                     default=False,help="use L1 triggers" )
  parser.add_option("-W", "--write-output",action="store_true", \
                     default=False,help="write trigger informtion to file")
  parser.add_option("-o","--output-path",action="store", type="string", \
                     default=None,help="specify output path")

  command_line = sys.argv[1:]
  (options,args) = parser.parse_args()

  return options, sys.argv[1:]


# ============================================================================
# -- get command line arguments
opts, args = parse_command_line()
if opts.verbose:
  opts.display = True
comments = ""

if opts.cache_file:
  cache = lal.Cache.fromfile(open(opts.cache_file))

else:
  print "--cache-file must be specified!"
  sys.exit()

inj_pattern=[]
if opts.bbhinj:
  inj_pattern.append( "BBHINJ" )
if opts.bnsinj:
  inj_pattern.append( "BNSINJ" )
if opts.nsbhinj:
  inj_pattern.append( "NSBHINJ" )
if opts.spininj:
  inj_pattern.append( "SPININJ" )
if len( inj_pattern ) == 0:
  print "ERROR! must specify one of --bbhinj, --bnsinj, --nsbhinj or --spininj"
  sys.exit()

ifos=[]
if opts.h1_triggers:
  ifos.append( "H1" )
if opts.h2_triggers:
  ifos.append( "H2" )
if opts.l1_triggers:
  ifos.append( "L1" )
if len( ifos ) == 0:
  print "ERROR! must specify one of --h1-triggers, --h2-triggers or ", \
        "--l1-triggers"
  sys.exit()

columns=[]
if opts.plot_snr:
  columns.append("snr")
if opts.plot_mchirp:
  columns.append("mchirp")
if opts.plot_end_time:
  columns.append("end_time")
  sys.exit()

if opts.write_output:
  if opts.output_path:
    outfile = opts.output_path
  else:
    outfile = "pinspfound_log.txt"
else:
  if opts.output_path:
    print "Error! cannot specify --output-path without using --write-output"
    sys.exit()


##############################################################################
def get_sngl_triggers(opts, observatory, pattern):
 
  trigcache = cache.sieve(ifos = observatory, description = pattern)
  trigFiles = trigcache.checkfilesexist()[0].pfnlist()
  if opts.verbose:
    print "\n reading the following trig files..."
    for file in trigFiles:
      print file
    print "\n"

  triggers  = SnglInspiralUtils.ReadSnglInspiralFromFiles(trigFiles)
  
  return triggers


##############################################################################
def get_coinc_triggers(opts, observatory, pattern):

  trigcache = cache.sieve(ifos = observatory, description = pattern)
  trigFiles = trigcache.checkfilesexist()[0].pfnlist()
  if opts.verbose:
    print "\n reading the following trig files..."
    for file in trigFiles:
      print file
    print "\n"

  inspTriggers  = SnglInspiralUtils.ReadSnglInspiralFromFiles(trigFiles)
  coincTriggers = CoincInspiralUtils.coincInspiralTable(inspTriggers, \
                             CoincInspiralUtils.coincStatistic( "snr") )
  
  triggers = coincTriggers.getsngls(observatory)

  return triggers


##############################################################################
def check_snr_loss(opts, observatory, triggers_before, triggers_after, \
                                                  inj_pattern, stages):
  """
  Checks the snrs and end times between different stages of the pipeline.
  """
  loss = []
  above = [[],[]]
  below = [[],[]]
  
  # Convert end_end_times before to a list so we can use list.index
  end_times_before = list( triggers_before.get_column("end_time") )
  snrs_before = triggers_before.get_column("snr")
  
  
  end_times_after  = triggers_after.get_column("end_time")
  snrs_after  = triggers_after.get_column("snr") 
  
  for i in xrange( len(end_times_after) ):
   
    if end_times_after[i] in end_times_before:
      j = end_times_before.index( end_times_after[i] )
      
      loss.append( snrs_before[j] - snrs_after[i])
 
      if loss[i] >= opts.threshold:
        below[0].append( end_times_after[i] )
        below[1].append( loss[i] )
        if opts.display:
          loss_print = '%3.2f' % (loss[i])
          snr1_print = '%3.2f' % (snrs_before[j])
          snr2_print = '%3.2f' % (snrs_after[i])

          print " Warning!", loss_print, "loss in SNR for trigger in \n", \
                "         ", observatory, ",", inj_pattern, ",", stages
          print " end_time = ", end_times_before[j], " snr = ", snr1_print 
          print " end_time = ", end_times_after[i],  " snr = ", snr2_print 
        if opts.write_output:
          outstring = observatory + ' ' + inj_pattern + ' '
          outstring = outstring + str(end_times_after[i]) + ' '
          outstring = outstring + str(snrs_before[j]) + ' '
          outstring = outstring + str(snrs_after[i]) + ' '
          outstring = outstring + str(loss[i]) + ' ' + stages + '\n'
 
          fout.write(outstring)

      else:
        above[0].append( end_times_after[i] )
        above[1].append( loss[i] )

    else:
      if opts.verbose:
        print "ERROR! Can't find original trigger, check cache file."
        print "       Setting loss=0 for this trigger, end_time = ", \
                                                 end_times_after[i]
      loss.append( 0 )  
      
  return loss #, above, below


##############################################################################
def make_plots(opts, observatory, inj_pattern, columns, triggers_after, \
                                                     stages, snr_loss):
  # y-axis is always the same
  graph_ylabel = 'SNR loss'
  delta = 0.05*(max(snr_loss) - min(snr_loss))
  ymin = min(snr_loss) - delta
  ymax = max(snr_loss) + delta
  
  for i in xrange( len(columns) ): 
    if columns[i] == "end_time":
      end_times_after  = triggers_after.get_column("end_time")

      plot(end_times_after, snr_loss, 'ro');
  
      graph_title  = observatory +' end_time ' +inj_pattern +'\n' +stages
      graph_xlabel = 'GPS end time'
      title(graph_title)
      xlabel(graph_xlabel)
      ylabel(graph_ylabel)

      delta = 0.05*(max(end_times_after) - min(end_times_after))
      xmin = min(end_times_after) - delta
      xmax = max(end_times_after) + delta
      axis([xmin, xmax, ymin, ymax])

      name = observatory + '_' +inj_pattern +'_end_time_' +stages
      savefig(name)
      close()
 
 
    elif columns[i] == "snr":
      snrs_after  = triggers_after.get_column("snr")
      semilogx(snrs_after, snr_loss, 'ro');

      graph_title = observatory +' SNR ' +inj_pattern +'\n' +stages
      graph_xlabel = 'SNR (after loss)'
      title(graph_title)
      xlabel(graph_xlabel)
      ylabel(graph_ylabel)

      xmin = 4
      xmax = 1.4*max(snrs_after)
      axis([xmin, xmax, ymin, ymax])

      name = observatory + '_' +inj_pattern +'_SNR_' +stages
      savefig(name)
      close()
 
 
    else:
      values = triggers_after.get_column( columns[i] )
      plot(values, snr_loss, 'ro');
      
      graph_title = observatory +' ' +columns[i] +' ' +inj_pattern +'\n' \
			              +stages
      graph_xlabel = columns[i]
      title(graph_title)
      xlabel(graph_xlabel)
      ylabel(graph_ylabel)

      delta = 0.05*(max(values) - min(values))
      xmin = min(values) - delta
      xmax = max(values) + delta
      axis([xmin, xmax, ymin, ymax])
      
      name = observatory +'_' +inj_pattern +'_' +columns[i] +'_' +stages
      savefig(name)
      close()
		


##############################################################################
def do_everything(opts, ifos, inj_pattern, columns):

  for i in xrange( len(ifos) ):
    observatory = ifos[i]

    for j in xrange( len(inj_pattern) ):
      pattern = 'SIRE*FOUND*FIRST*' +inj_pattern[j]
      sireFirst   = get_sngl_triggers(opts, observatory, pattern)

      pattern = 'COIRE*FOUND*SECOND*' +inj_pattern[j]
      coireSecond  = get_coinc_triggers(opts, observatory, pattern)
       
      if opts.coire_first:
        pattern = 'COIRE*FOUND*FIRST*' +inj_pattern[j]
        coireFirst  = get_coinc_triggers(opts, observatory, pattern)

        stages = "SIRE_FIRST_to_COIRE_FIRST"
        loss = check_snr_loss(opts, observatory, sireFirst, coireFirst, \
                                                inj_pattern[j], stages)
        make_plots(opts, observatory, inj_pattern[j], columns, coireFirst, \
                                                             stages, loss)

        stages = "COIRE_FIRST_to_COIRE_SECOND"
        loss = check_snr_loss(opts, observatory, coireFirst, coireSecond, \
                                                  inj_pattern[j], stages)
        make_plots(opts, observatory, inj_pattern[j], columns, coireSecond, \
                                                              stages, loss)

      else:
        stages = "SIRE_FIRST_to_COIRE_SECOND"
        loss = check_snr_loss(opts, observatory, sireFirst, coireSecond, \
                                                 inj_pattern[j], stages)
        make_plots(opts, observatory, inj_pattern[j], columns, coireSecond, \
                                                              stages, loss)
        



##############################################################################
if opts.write_output:
  fout = open(outfile, "w")
  outstring = " ifo, inj_pattern, end_time, snr_before, snr_after,"
  outstring = outstring + ',snr_loss, stages' + '\n'
  fout.write(outstring);

do_everything(opts, ifos, inj_pattern, columns)

if opts.write_output:
  fout.close()
