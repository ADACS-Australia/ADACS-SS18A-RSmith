#!/usr/bin/python
"""
Plots involving injections and background (for second stage only)

One can either read SIRE or COIRE files, however, COIRE is recommanded 
(if we want to look at detected events found in coincidence only). 



"""
__version__ = "$Revision$"
__date__ = "$Date$"
__name__ = "plotsnrchi"
__Id__ = "$Id$"
__title__ = "Inspiral Plots"



import sys
import os
from optparse import *
import re
import exceptions
import glob
from types import *

from pylal import SnglInspiralUtils
from pylal import SimInspiralUtils
from glue import lal
from pylal import InspiralUtils

##############################################################################
def plotvarlines(snr_range, var):
  loglog(snr_range, 15*snr_range**4 / (snr_range**2 + 0  ), 'm-',linewidth=1)
  loglog(snr_range, 13*snr_range**4 / (snr_range**2 + 2*var ), 'b-',linewidth=1)
  loglog(snr_range, 11*snr_range**4 / (snr_range**2 + 4*var ), 'g-',linewidth=1)
  loglog(snr_range, 9 *snr_range**4 / (snr_range**2 + 6*var ), 'r-',linewidth=1)
  loglog(snr_range, 7 *snr_range**4 / (snr_range**2 + 8*var ), 'y-',linewidth=1)
  loglog(snr_range, 5*snr_range**4 / (snr_range**2 + 10*var ), 'c-',linewidth=1)
  loglog(snr_range, 3*snr_range**4 / (snr_range**2 + 12*var ), 'm-',linewidth=1)
  loglog(snr_range, 2*snr_range**4 / (snr_range**2 + 13*var ), 'b-',linewidth=1)
  loglog(snr_range, 1*snr_range**4 / (snr_range**2 + 14*var ), 'g-',linewidth=1)

##############################################################################
def constant_effective_snr(snr, eff_snr, chisq_dof, denominator_constant):
  # return the value of chisq that will give the requested effective snr for 
  # this snr
  return (chisq_dof * snr**4 / ( 1 + snr**2/denominator_constant) / eff_snr**4)

def plotconstlines(snr_range, const, chisq_dof):
  for [eff_snr,color] in [[5,'m-'], [6,'b-'], [7,'g-'], [8,'r-'], [9,'y-'],
      [10,'c-'], [11,'m-'], [12,'b-']]:
    loglog( snr_range, constant_effective_snr( snr_range, eff_snr, chisq_dof, 
      const), color, linewidth=1)



##############################################################################
def loghistval(trig_val,inj_val,comments,nbins=20):

  figure(100)
  max_val = max(concatenate((trig_val,inj_val)))
  min_val = min(concatenate((trig_val,inj_val)))
  
  
  max_val = log10(max_val)
  min_val = log10(min_val)
  trig_val = log10(trig_val)
  if len(inj_val):
    inj_val = log10(inj_val)
    
  bins = arange(min_val, max_val , (max_val - min_val) /nbins )
  [trigs,bins,stuff] = hist(trig_val, bins, normed=True)
  if len(inj_val):
    [inj,bins,stuff] = hist(inj_val,bins, normed=True)
  close(100)

  bins = 10**bins
  trig_val = 10**trig_val
  inj_val = 10**inj_val
  leg = []
  if len(inj_val):
    semilogx(bins,inj, 'r-',markersize=12, markerfacecolor='None',\
        markeredgewidth=1, linewidth=1)
    leg.append('Injections')
  semilogx(bins,trigs, 'k-',markersize=12, markerfacecolor='None',\
      markeredgewidth=1, linewidth=1)
  leg.append('Triggers')
  legend(leg) 
  xlim(10**min_val, 10**max_val)
 
  grid(True)

  if len(trig_val):
    max_snr = max(trig_val)
  else:
    max_snr = 0
    comments = InspiralUtils.message(opts,  'loudest noise trigger = ' + \
        str(max_snr) )
  num_above = sum(inj_val > max_snr) 
  comments += InspiralUtils.message(opts,  'total number of injections = ' + \
      str(len(inj_val)))
  comments += InspiralUtils.message(opts,  \
      'number of injections louder than all noise = ' + str(num_above))
  
  return comments

##############################################################################
usage = """
prog [options] 

Plots snr vs chisq for a glob of triggers that are read in.  The code expects
a GLOB of input triggers.  It can also accept an INJGLOB containing triggers
associated with injections.  It makes various different plots

1) A plot of SNR vs chisq for the triggers.  Injections are also plotted if
specified.  Called with --snr-chisq

2) A plot of SNR vs chisq with contours.  Called with --trig-contour

3) A plot of the contours and curves meant to appoximate these contours.
Called with --contour-lines.

4) A plot of the triggers, contours and lines.  Called with
--trig-contour-lines.

5) A plot of triggers and lines.  Called with --trig-lines.

The function used to specify the lines is either:

a) chisq = A * snr^4 / (snr^2 + CONST)
   
   This statistic is chosen by specifying --denominator-constant.  The
   value of CONST must also be given.

b) chisq = A * snr^4 / (snr^2 + VAR * (15 - A) )

   This statistic is chonse by specifying --denominator-variable.  The value
   of VAR must also be given.


Additionally, various plots of the distribution of background and injection
triggers can be made.  Three such plots are available:

6) Histograms as a function of snr.  Called with --hist-snr

7) Histogramw as a function of snr/chi.  Called with --hist-snr-chi

8) Histograms as a function of the statistic given above.  Called with
   --hist-stat.

A plot of snr vs rsq can also be made for a glob of triggers that are read in.
If the --rsq-VETO-OPTIONS are used, it will show the triggers cut by that veto
in a different color than those kept by that veto. Injections are also plotted
if specified.
"""
def parse_command_line():
  """
  Parser function dedicated
  """
  parser = OptionParser( usage=usage, \
      version= "%prog CVS\n" +
      "$Id$\n" +
      "$Name$\n")

  ## arguments for data reading
  parser.add_option("-g","--glob",action="store",type="string",\
      default=None, metavar=" GLOB",help="GLOB of trigger files to read" )
  parser.add_option("-I","--inj-glob",action="store",type="string",\
      default=None, metavar=" INJGLOB",
      help="GLOB of injection trigger files to read" )
  parser.add_option("", "--cache-file", metavar="CACHEFILE",\
      help="cache pointing to files of interest")
  # cache description. Note that because we are interesting in second
  # stage only, FOUND and SIRE tag should be followed by underscore

  parser.add_option("","--trig-pattern", action="store",type="string",\
      default=None, metavar="TRIGPTTRN", help="sieve pattern for trig-files" )
#  parser.add_option("","--coinc-pattern", action="store",type="string",\
#      default=None, metavar="COINCPTTRN", help="sieve pattern for coinc-files" )
#  parser.add_option("","--slide-pattern", action="store",type="string",\
#      default=None, metavar="SLIDEPTTRN", help="sieve pattern for trig-files" )
  parser.add_option("","--found-pattern",
      metavar="FOUNDPTTRN", help="sieve pattern for found injection files")

  ## arguments for plot creation
  parser.add_option("-s","--show-plot",action="store_true",default=False,\
      help="display the figures on the terminal" )
  parser.add_option("-a","--snr-chisq",action="store_true",default=False,\
      help="make a plot of snr vs chisq" )
  parser.add_option("-c","--trig-contour",action="store_true",default=False,\
      help="make a contour plot of snr vs chisq" )
  parser.add_option("-C","--contour-lines",action="store_true",default=False,\
      help="make a contour plot of snr vs chisq, with fit lines" )
  parser.add_option("-b","--trig-contour-lines",action="store_true",\
      default=False,\
      help="make a contour plot of snr vs chisq with fitting lines" )
  parser.add_option("-A","--trig-lines",action="store_true",default=False,\
      help="plot triggers and lines" )
  parser.add_option("-B","--trig-inj-lines",action="store_true",default=False,\
      help="plot triggers, injections and lines" )
  parser.add_option("-K","--trig-inj-contour",action="store_true",default=False,\
      help="plot triggers, injections and contours" )
      
  parser.add_option("-E","--hist-snr",action="store_true",default=False,\
      help="histogram of the snr for triggers/injections" )
  parser.add_option("-e","--hist-snr-chi",action="store_true",default=False,\
      help="histogram of snr/chi for triggers/injections" )
  parser.add_option("-k","--hist-stat",action="store_true",default=False,\
      help="histogram of snr,chi statistic for triggers/injections" )
  parser.add_option("-D","--denominator-constant",action="store",type="float",\
      default=0,metavar=" CONST",\
      help="value for the denominator of the statistic")
  parser.add_option("-d","--denominator-variable",action="store",type="float",\
      default=0,metavar=" VAR",\
      help="value for the variable denominator form of the statistic")
  parser.add_option("-n","--nbins",action="store",type="int",default=20,\
      metavar=" NBINS", help="number of bins for the histogram plots" )
  
  parser.add_option("-r","--snr-rsq",action="store_true",default=False,\
      help="make a plot of snr vs rsq" )
  parser.add_option("","--rsq-threshold",action="store",type="float",\
      default=0,metavar="SEC",help="set rsq veto duration threshold to SEC" )
  parser.add_option("","--rsq-max-snr",action="store",type="float",\
      default=0,metavar="MAXSNR",help="set rsq veto maximum snr to MAXSNR" )
  parser.add_option("","--rsq-coeff",action="store",type="float",\
      default=10,metavar="COEFF",help="set rsq veto coefficient to COEFF" )
  parser.add_option("","--rsq-pow",action="store",type="float",\
      default=0,metavar="POW",help="set rsq veto power to POW" )
  
  # output related
  parser.add_option("-Z","--user-tag",action="store",type="string",\
      default=None,metavar=" FNAME",\
      help="a user tag for the output filenames" )
  parser.add_option("-o","--output-path",action="store",\
      type="string",default="",  metavar="PATH",\
      help="path where the figures would be stored")
  parser.add_option("-O","--enable-output",action="store_true",\
      default="false",  metavar="OUTPUT",\
      help="enable the generation of the html and cache documents")
  parser.add_option("","--gps-start-time",action="store",\
      type="int",  metavar="GPSSTARTTIME",\
      help="gps start time (for naming figure and output files")
  parser.add_option("","--gps-end-time",action="store",\
      type="int",  metavar=" GPSENDTIME",\
      help="gps end time (for naming figure and output files")
  parser.add_option("", "--ifo-tag", action="store", type="string",\
      default=None,\
      metavar="IFOTAG", help="sets the IFO tag")
  parser.add_option("-i", "--ifo-times", action="store", type="string",\
      default=None,\
      metavar="IFOTIMES", help="sieve a cache file according to a particular ifo type")
  parser.add_option("-v","--verbose",action="store_true",\
      default=False,help="print information" )
  parser.add_option("", "--figure-resolution",action="store",type="int",\
      default=50, metavar="resolution of the thumbnails (50 by default)", \
      help="read a file of a particular description  from cache file" )
  parser.add_option("", "--exact-match",action="store_true",
      default=False,  \
      help="the pattern should match exactly if this option is used" )
  parser.add_option("", "--html-for-cbcweb",action="store",\
      default=False, metavar = "CVS DIRECTORY", help="publish the html "\
      "output in a format that can be directly published on the cbc webpage "\
      "or in CVS. This only works IF --enable-output is also specified. The "\
      "argument should be the cvs directory where the html file will be placed "\
      "Example: --html-for-cbcweb protected/projects/s5/yourprojectdir")


  (options,args) = parser.parse_args()

  # test the input options
  if not options.ifo_times:
    raise ValueError, "--ifo-times must be provided in (H1, H2, L1, V1, G1)"


  return options, sys.argv[1:]


# ============================================================================
# -- get command line arguments
opts, args = parse_command_line()

# to avoid  display problem when show plot is not used
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from pylal import viz



# ============================================================================
# Initialise
opts = InspiralUtils.initialise(opts, __name__, __version__)

# -- set the proper color code
colors = InspiralUtils.colors
figure_number = 0  # used for the figure label (showplot)
fnameList = []   # use for the cache file
tagList= []   # use for the cache file
comments = ""  # for the html output if needed

# check at least one trig file was specified
if not opts.glob and  not opts.cache_file:
  print >>sys.stderr, "Must specify a GLOB of files to read or a cache input file"
  print >>sys.stderr, "Enter 'plotsnrchi --help' for usage"
  sys.exit(1)

## compile a list of trigger-files
if opts.glob:
  trigFiles = glob.glob(opts.glob)
  if not len(trigFiles):
    print >>sys.stderr, "The glob for " + opts.glob + " returned no files"
    sys.exit(1)

else:
  zerolagAllCache = lal.Cache.fromfile(open(opts.cache_file)).sieve(ifos=opts.ifo_times, exact_match=opts.exact_match)
  comments += InspiralUtils.message(opts,  'The ifo times selected is ' +opts.ifo_times)

  trig_cache = zerolagAllCache.sieve(description=opts.trig_pattern)
  found, missed = trig_cache.checkfilesexist()
  trigFiles = found.pfnlist()
  if not len(trigFiles):
    print >>sys.stderr, opts.cache_file+ " contains no files with " + opts.trig_pattern + " description"
    sys.exit(1)
  else: 
    comments += InspiralUtils.message(opts,  'Reading ' +str(len(trigFiles)) + ' files having the pattern '+opts.trig_pattern)


# compile a list of injection-files
if opts.inj_glob:
  injFiles = glob.glob(opts.inj_glob)
  if not len(injFiles):
    print >>sys.stderr, "The glob for " + opts.inj_glob + " returned no files"
    sys.exit(1)
elif opts.cache_file:
  inj_cache = zerolagAllCache.sieve(description = opts.found_pattern)
  found, missed = inj_cache.checkfilesexist()
  injFiles = found.pfnlist()
  if not len(injFiles):
    print >>sys.stderr, opts.cache_file + " contains no files with " + opts.found_pattern + " description"
    sys.exit(1)
  else: 
    comments += InspiralUtils.message(opts,  'Reading ' +str(len(injFiles)) + ' files having the pattern '+opts.found_pattern)

 
if not opts.denominator_constant and not opts.denominator_variable:
  print >>sys.stderr, "One of --denominator-constant CONST or"
  print >>sys.stderr, "--denominator-variable VAR must be specified"
  sys.exit(1)

if (opts.hist_stat or opts.hist_snr or opts.hist_snr_chi) and not \
    (opts.inj_glob or opts.cache_file):
  print >>sys.stderr, "Must specify an INJ_GLOB if you want to do one of"
  print >>sys.stderr, "--hist-snr, --hist-snr-chi --hist-stat"
  sys.exit(1)

if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from pylal import viz

chisq_dof = 0   
###################################
# input triggers
inspTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(trigFiles, \
    verbose=opts.verbose)
if inspTriggers:
  nevents = len(inspTriggers)
else:
  nevents = 0
comments += InspiralUtils.message(opts, \
    'Read '+str(nevents)+ ' triggers from from inspiral files')

if nevents:
  snr = inspTriggers.get_column('snr')
  chisq = inspTriggers.get_column('chisq')
  chisq_dof = 2 * (inspTriggers.get_column('chisq_dof')[0] - 1 )
  rsq = inspTriggers.get_column('rsqveto_duration') + 0.00001
else:
  snr = array([])
  chisq = array([])
  rsq = array([])

# input injections:
ninj_events = 0
if opts.inj_glob or opts.cache_file:
  injTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(injFiles, \
      verbose=opts.verbose)
  if injTriggers: ninj_events = len(injTriggers)
if ninj_events:
  inj_snr = injTriggers.get_column('snr')
  inj_chisq = injTriggers.get_column('chisq')
  inj_rsq = injTriggers.get_column('rsqveto_duration') + 0.00001
  chisq_dof =  2 * (injTriggers.get_column('chisq_dof')[0] - 1)
else:
  inj_snr = array([])
  inj_chisq = array([])
  inj_rsq = array([])

comments += InspiralUtils.message(opts, \
    'Read '+str(ninj_events)+ ' triggers from inspiral injection files')

if (nevents == 0) and (ninj_events == 0):
  ## give up and exit
  err_msg = "There were no inspiral triggers or injection triggers in the" + \
      " files read in, no plots generated"
  print >>sys.stderr, err_msg
  comments += InspiralUtils.message(opts, err_msg)
  if opts.enable_output is True: 
    html_filename = InspiralUtils.write_html_output(opts, args, fnameList, \
        tagList, comment=comments)
    InspiralUtils.write_cache_output(opts, html_filename, fnameList)
    if opts.show_plot:
      sys.exit(1)
    else:
      sys.exit(0)

###################################
# Determine SNR range
max_snr = max(concatenate((snr,inj_snr)))
min_snr = min(concatenate((snr,inj_snr)))

log_min = log10(min_snr)
log_max = 1.1*log10(max_snr)

snr_range = arange( log_min, log_max , (log_max - log_min)/20)
snr_range = 10**snr_range

###################################
# Determine chisq range
max_chisq = max(concatenate((chisq,inj_chisq)))
min_chisq = min(concatenate((chisq,inj_chisq)))

log_min = log10(min_chisq)
log_max = 1.1*log10(max_chisq)

chisq_range = arange( log_min, log_max, (log_max - log_min)/20)
chisq_range = 10**chisq_range


###################################
# Determine rsq range
max_rsq = max(concatenate((rsq,inj_rsq)))


###################################
# calculate the contours
if (opts.trig_contour or opts.trig_contour_lines or opts.contour_lines \
  or opts.trig_inj_lines) and nevents:
  cont = zeros(shape=(20, 20), dtype='f')
  for i in xrange(20):  
    for j in xrange(20):
      cont[i, j] = sum( asarray(snr > snr_range[j]) * \
          asarray(chisq < chisq_range[i]) )

  v = arange(0,log10(nevents),log10(nevents)/20)
  v = 10**v
  v = concatenate( (v,zeros(1)) )

###################################
# calculate rsq cut line amd sort triggers
if opts.snr_rsq and (opts.rsq_threshold and opts.rsq_max_snr):
  if opts.rsq_coeff and opts.rsq_pow:
    rsq_cut_line_x = [min_snr, opts.rsq_max_snr, opts.rsq_max_snr, max_snr]
    rsq_cut_line_y = [opts.rsq_threshold, opts.rsq_threshold,\
                      opts.rsq_coeff*(opts.rsq_max_snr)**opts.rsq_pow,\
                      opts.rsq_coeff*(max_snr)**opts.rsq_pow]
  else:
    rsq_cut_line_x = [min_snr, opts.rsq_max_snr, opts.rsq_max_snr]
    rsq_cut_line_y = [opts.rsq_threshold, opts.rsq_threshold,max_rsq]

  # determine cuts for triggers
  cut_index = (snr < opts.rsq_max_snr)
  cut_index &= (rsq > opts.rsq_threshold)
  if opts.rsq_coeff > 0 and opts.rsq_pow > 0:
    cut_index |= (rsq > opts.rsq_coeff * snr**opts.rsq_pow)

  snr_cut = snr[cut_index]
  snr_kept = snr[~cut_index]
  rsq_cut = rsq[cut_index]
  rsq_kept = rsq[~cut_index]

  # determine cuts for injections
  if opts.inj_glob or opts.found_pattern:
    cut_index = (inj_snr < opts.rsq_max_snr)
    cut_index &= (inj_rsq > opts.rsq_threshold)
    if opts.rsq_coeff > 0 and opts.rsq_pow > 0:
      cut_index |= (inj_rsq > opts.rsq_coeff * inj_snr**opts.rsq_pow)

    inj_snr_cut = inj_snr[cut_index]
    inj_snr_kept = inj_snr[~cut_index]
    inj_rsq_cut = inj_rsq[cut_index]
    inj_rsq_kept = inj_rsq[~cut_index]

comments += InspiralUtils.message(opts, 'After the rsq cut, we kept '+ \
    str(len(rsq_kept)) +' events.')
comments += InspiralUtils.message(opts, 'After the rsq cut, we removed '+ \
    str(len(rsq_cut))+' events.')


fig_num = 0
###################################
# plot of snr vs chisq
if opts.snr_chisq:
  fig_num +=1
  figure(fig_num)
  
  if nevents:
    viz.plot_a_v_b(inspTriggers,'snr','chisq','loglog','kx')
    hold(True)
  if ninj_events:
    viz.plot_a_v_b(injTriggers,'snr','chisq','loglog','r+')
  xlabel(r'$\rho$', size='x-large')
  ylabel(r'$\chi^2$', size='x-large')
  xlim(min_snr, max_snr)
  ylim(min_chisq, max_chisq)

  legend(['Triggers', 'Injections'])
  if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "snr_vs_chisq")
    fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
        dpi_thumb=opts.figure_resolution)
    fnameList.append(fname)
    tagList.append("Chi square versus SNR")


###################################
# plot of snr vs chisq with contours
if opts.trig_contour and nevents:
  fig_num +=1
  figure(fig_num)
  
  viz.plot_a_v_b(inspTriggers,'snr','chisq','loglog','kx',opts.figure_name)
  contour(snr_range,chisq_range,cont,v)
  
  xlabel(r'$\rho$', size='x-large')
  ylabel(r'$\chi^2$', size='x-large')
  xlim(min_snr, max_snr)
  ylim(min_chisq, max_chisq)
  legend(['Triggers', 'Injections'])

  if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "snr_chisq_contour")
    fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
        dpi_thumb=opts.figure_resolution)
    fnameList.append(fname)
    tagList.append("Chi square versus SNR and iso-contour")


###################################
# plot of snr vs chisq with contours and lines
if opts.contour_lines and nevents:
  if opts.denominator_constant:
    fig_num +=1
    figure(fig_num)

    plotconstlines(snr_range, opts.denominator_constant, chisq_dof)
    contour(snr_range,chisq_range,cont,v)

    xlabel(r'\rho', size='x-large')
    ylabel(r'\chi^2', size='x-large')
    legend(['Triggers'])

    title(opts.ifo_times)
    xlim(min_snr, max_snr)
    ylim(min_chisq, max_chisq)
    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, "contour_const_lines")
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
          dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append("Chi square versus SNR and iso-line contours")

  if opts.denominator_variable:
    fig_num +=1
    figure(fig_num)

    plotvarlines(snr_range, opts.denominator_variable)
    contour(snr_range,chisq_range,cont,v)
    xlabel(r'$\rho$', size='x-large')
    ylabel(r'$\chi^2$', size='x-large')
    title(opts.ifo_times)
    xlim(min_snr, max_snr)
    ylim(min_chisq, max_chisq)
    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, "contour_var_lines")
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
          dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append("Chi square versus SNR and iso-contours and " + \
          "iso-line contours")

###################################
# plot of snr vs chisq with lines
if opts.trig_lines and nevents:
  if opts.denominator_constant:
    fig_num +=1
    figure(fig_num)

    viz.plot_a_v_b(inspTriggers,'snr','chisq','loglog','kx')
    plotconstlines(snr_range, opts.denominator_constant, chisq_dof)
    xlabel(r'$\rho$', size='x-large')
    ylabel(r'$\chi^2$', size='x-large')

    xlim(min_snr,max_snr)
    ylim(min_chisq,max_chisq)  
    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, "snr_chisq_const_lines")
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
          dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append("SNR vs chisq with lines and constant denominator")

  if opts.denominator_variable:
    fig_num +=1
    figure(fig_num)

    viz.plot_a_v_b(inspTriggers,'snr','chisq','loglog','kx')
    plotvarlines(snr_range, opts.denominator_variable)
    xlabel(r'$\rho$', size='x-large')
    ylabel(r'$\chi^2$', size='x-large')

    xlim(min_snr, max_snr)
    ylim(min_chisq, max_chisq)
    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, "snr_chisq_var_lines")
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
          dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append("SNR vs chisq with lines and variable denominator")

###################################
# plot of snr vs chisq with injections and lines
if opts.trig_inj_lines:
  if opts.denominator_constant:
    fig_num +=1
    figure(fig_num)

    if nevents:
      viz.plot_a_v_b(inspTriggers,'snr','chisq','loglog','kx')
    if ninj_events: 
      viz.plot_a_v_b(injTriggers,'snr','chisq','loglog','r+')
    plotconstlines(snr_range, opts.denominator_constant, chisq_dof)
    xlabel(r'$\rho$', size='x-large')
    ylabel(r'$\chi^2$', size='x-large')

    xlim(min_snr,max_snr)
    ylim(min_chisq,max_chisq)  
    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, "snr_chisq_inj_const_lines")
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
          dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append(" plot of snr vs chisq with injections and " + \
          "lines (constant denominator)")

  if opts.denominator_variable:
    fig_num +=1
    figure(fig_num)

    if nevents:
      viz.plot_a_v_b(inspTriggers,'snr','chisq','loglog','kx')
    if ninj_events:
      viz.plot_a_v_b(injTriggers,'snr','chisq','loglog','r+')
    plotvarlines(snr_range, opts.denominator_variable)
    xlabel(r'$\rho$', size='x-large')
    ylabel(r'$\chi^2$', size='x-large')

    xlim(min_snr, max_snr)
    ylim(min_chisq, max_chisq)
    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, "snr_chisq_inj_var_lines")
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
          dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append(" plot of snr vs chisq with injections and " + \
          "lines (variable denominator)")

###################################
# plot of snr vs chisq with injections and contours
if opts.trig_inj_contour:
  fig_num +=1
  figure(fig_num)

  if nevents: 
    viz.plot_a_v_b(inspTriggers,'snr','chisq','loglog','kx')
    contour(snr_range,chisq_range,cont,v)
  if ninj_events: 
    viz.plot_a_v_b(injTriggers,'snr','chisq','loglog','r+')
  xlabel(r'$\rho$', size='x-large')
  ylabel(r'$\chi^2$', size='x-large')
 
  xlim(min_snr,max_snr)
  ylim(min_chisq,max_chisq)  
  if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "snr_chisq_inj_contour")
    fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
        dpi_thumb=opts.figure_resolution)
    fnameList.append(fname)
    tagList.append(" plot of snr vs chisq with injections and " + \
        "contours (variable denominator)")

###################################
# plot of snr vs chisq with contours and lines
if opts.trig_contour_lines and nevents:
  if opts.denominator_constant:
    fig_num +=1
    figure(fig_num)

    viz.plot_a_v_b(inspTriggers,'snr','chisq','loglog','kx')
    contour(snr_range,chisq_range,cont,v)
    plotconstlines(snr_range, opts.denominator_constant, chisq_dof)
    xlabel(r'$\rho$', size='x-large')
    ylabel(r'$\chi^2$', size='x-large')

    xlim(min_snr,max_snr)
    ylim(min_chisq,max_chisq)  
    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, 
          "snr_chisq_contour_const_lines")
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
          dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append(" plot of snr vs chisq with " + \
          "contours and lines (constant method)")

  if opts.denominator_variable:
    fig_num +=1
    figure(fig_num)

    viz.plot_a_v_b(inspTriggers,'snr','chisq','loglog','kx')
    contour(snr_range,chisq_range,cont,v)
    plotvarlines(snr_range, opts.denominator_variable)
    xlabel(r'$\rho$', size='x-large')
    ylabel(r'$\chi^2$', size='x-large')

    xlim(min_snr, max_snr)
    ylim(min_chisq, max_chisq)
    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, "snr_chisq_contour_var_lines")
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
          dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append(" plot of snr vs chisq with " + \
          "contours and lines (variable method)")


###################################
# histogram of snrs
if opts.hist_snr:
  fig_num +=1
  figure(fig_num)
  InspiralUtils.message(opts, '\nPlotting snr histogram')
  comments += loghistval(snr,inj_snr,comments,opts.nbins)
  xlabel(r'$\rho$', size='x-large')
  ylabel('pdf', size='x-large')

  if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "snr_efficiency")
    fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
        dpi_thumb=opts.figure_resolution)
    fnameList.append(fname)
    tagList.append("SNR histogram")
  
###################################
# histogram of snr/chi
if opts.hist_snr_chi:
  fig_num +=1
  figure(fig_num)
  InspiralUtils.message(opts, '\nPlotting snr/chi histrogam')
  comments += loghistval(snr/sqrt(chisq),inj_snr/sqrt(inj_chisq),\
      comments,opts.nbins)
  xlabel(r'$\rho/\chi$', size='x-large')
  ylabel('pdf', size='x-large')
  if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "snr_chi_efficiency")
    fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
        dpi_thumb=opts.figure_resolution)
    fnameList.append(fname)
    tagList.append("snr_chi_efficiency")


###################################
# histogram of funky snr chi
if opts.hist_stat:
  if opts.denominator_variable:
    fig_num +=1
    figure(fig_num)

    B = opts.denominator_variable
    p = 15
    stat = (snr**4 + B * chisq) / (chisq * ( snr**2 + p * B)) 
    inj_stat = (inj_snr**4 + B*inj_chisq) / (inj_chisq * ( inj_snr**2 + p*B))

    InspiralUtils.message(opts, 'Statistic is variable denominator snr chi')
    comment += loghistval(stat,inj_stat, comments,opts.nbins)
    title(opts.ifo_times, size='x-large')
    xlabel('variable den. statistic', size='x-large')
    ylabel('pdf', size='x-large')
    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, "var_den_efficiency")
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
          dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append("var_den_efficiency")

 
  if opts.denominator_constant:
    fig_num +=1
    figure(fig_num)

    C = opts.denominator_constant
    stat = (snr**4) / (chisq * ( 1 + snr**2/C)) 
    inj_stat = (inj_snr**4) / (inj_chisq * ( 1 + inj_snr**2/C))

    InspiralUtils.message(opts,  'Statistic is constant denominator snr chi')
    loghistval(stat,inj_stat,comments,opts.nbins)
    title(opts.ifo_times + ' statistic', size='x-large')
    xlabel("Effective SNR", size='x-large')
    ylabel('pdf', size='x-large')
    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, "const_den_efficiency")
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
          dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append("const_den_efficiency")


###################################
# plot of snr vs rsq
if opts.snr_rsq and (opts.rsq_threshold and opts.rsq_max_snr):
  fig_num +=1
  figure(fig_num)
  leg=[]

  loglog(snr_kept,rsq_kept,'bx',snr_cut,rsq_cut,'bo')
  leg.append('Kept triggers')
  leg.append('Vetoed triggers')

  hold(True)
  if opts.inj_glob or opts.cache_file:
    loglog(inj_snr_kept,inj_rsq_kept,'ro',inj_snr_cut,inj_rsq_cut,'ko')
  loglog(rsq_cut_line_x,rsq_cut_line_y,'k',linewidth=2)
  leg.append('Kept injections')
  leg.append('Vetoed injections')

  xlim(min_snr, max_snr)
  
  grid(True)
  xlabel(r'$\rho$', size='x-large')
  ylabel(r'$r^2$', size='x-large')
  title(r'$r_d=$ '	+ str(opts.rsq_threshold)+\
    r', $\rho_r=$ '	+ str(opts.rsq_max_snr) +\
    r', $r_c=$'		+ str(opts.rsq_coeff) +\
    r', $r_p=$'		+ str(opts.rsq_pow))
  #ylim(1e-5, 10)
  if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "snr_vs_rsq")
    fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
        dpi_thumb=opts.figure_resolution)
    fnameList.append(fname)
    tagList.append("SNR versus RSQ")

elif opts.snr_rsq:
  fig_num +=1
  figure(fig_num)

  loglog(snr,rsq,'bx')
  hold(True)
  if opts.inj_glob or opts.cache_file:
    loglog(inj_snr,inj_rsq,'ro', 'marker')

  xlim(min_snr, max_snr)

  grid(True)
  xlabel(r'$\rho$', size='x-large')
  ylabel(r'$r^2$', size='x-large')
  title('threshold is '+str(opts.rsq_threshold))
 
  #ylim(1e-5, 10)
  if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, "snr_vs>rsp")
    fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
        dpi_thumb=opts.figure_resolution)
    fnameList.append(fname)
    tagList.append("SNR versus RSQ")

# ============================================================================
# final step: html, cache file generation
if opts.enable_output is True:
  html_filename = InspiralUtils.write_html_output(opts, args, fnameList, \
      tagList, comment=comments)
  InspiralUtils.write_cache_output(opts, html_filename, fnameList)

  if opts.html_for_cbcweb:
    html_filename_publish = InspiralUtils.write_html_output(opts, args, fnameList, tagList, cbcweb=True)

if opts.show_plot:
  show()

