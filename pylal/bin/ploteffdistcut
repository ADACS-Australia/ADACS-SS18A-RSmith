#!/usr/bin/python

import sys
import os
from optparse import *
import re
import exceptions
import glob
from types import *

from pylab import *
from pylal import readMeta
from pylal import viz

##############################################################################
def disterr(coinc_table, ifo_list):

  ifoa_dist = coinc_table.mkarray('eff_distance',ifo_list[0])
  ifob_dist = coinc_table.mkarray('eff_distance',ifo_list[1])
  ifoa_snr = coinc_table.mkarray('snr',ifo_list[0])
  ifob_snr = coinc_table.mkarray('snr',ifo_list[1])

  ifoa_sigma = coinc_table.mkarray('sigmasq',ifo_list[0])
  ifob_sigma = coinc_table.mkarray('sigmasq',ifo_list[1])
 
  ifoa_error = abs(ifoa_dist - ifob_dist) / ifob_dist 
  ifob_error = abs(ifob_dist - ifoa_dist) / ifoa_dist

  dist_error = ifoa_error
  small_snr = ifoa_snr
  
  for j in range(len(dist_error)):
    if ifoa_sigma[j] > ifob_sigma[j]:
      dist_error[j] = ifob_error[j]
      small_snr[j] = ifob_snr[j]

  return([small_snr,dist_error])
                                                

##############################################################################
usage = """
Function to test the efficiency of an effective distance cut.  The
function reads in triggers from injections and time slides.  It clusters
the injection triggers (so as to have only one trigger coincident with
each injection).  Then, we calculate the fractional distance error.  The
"true distance" is the observed distance in the ifo with the greater
range (obtained from the sigmasq column in the sngl inspiral table).
The proposed distance cut is specified using the values kappa and
epsilon.  We require:

|D_obs - D_true|     epsilon
 --------------  =   -------  + kappa.
     D_true          rho_obs
"""

parser = OptionParser( usage )
parser.add_option("-v","--version",action="store_true",default=False,\
    help="display version information " )
parser.add_option("-g","--inj-glob",action="store",type="string",\
    default=None, metavar=" GLOB",help="GLOB of thinca files to read" )
parser.add_option("-G","--slide-glob",action="store",type="string",\
    default=None, metavar=" GLOB",help="GLOB of thinca files to read" )
parser.add_option("-L","--cluster-window",action="store",type="int",default=0,\
    metavar=" SEC", help="length of time over which to cluster triggers" )
parser.add_option("-f","--figure-name",action="store",type="string",\
    default=None, metavar=" FNAME",\
    help="generate png figures with name FNAME-fig.png" )
parser.add_option("-s","--show-plot",action="store_true",default=False,\
    help="display the figures on the terminal" )
parser.add_option("-A","--ifoa",action="store",default=None,\
    metavar=" IFOA",help="first ifo for which we have triggers" )
parser.add_option("-B","--ifob",action="store",default=None,\
    metavar=" IFOB",help="second ifo for which we have triggers" )
parser.add_option("-a","--dist-cut",action="store_true",default=False,\
    help="perform distance cut on inj and slide trigs" )
parser.add_option("-b","--dist-snr",action="store_true",default=False,\
    help="plot of distance accuracy vs snr" )
parser.add_option("-c","--dist-hist",action="store_true",default=False,\
    help="histogram of distance accuracy" )
parser.add_option("-N","--num-slides",action="store",type="int",default=0,\
    metavar=" NUM_SLIDES",help="number of time slides performed" )
parser.add_option("-t","--plot-type",action="store",type="string",\
    default="linear",metavar=" PLOT_TYPE", \
    help="make either linear or log or plots" )
parser.add_option("-k","--kappa",action="store",type="float",default=0,\
    metavar=" KAPPA",help="value of kappa in dist cut" )
parser.add_option("-e","--epsilon",action="store",type="float",default=0,\
    metavar=" EPSILON",help="value of epsilon in dist cut" )
(opts,args) = parser.parse_args()

# if --version flagged
if opts.version:
  sys.exit(0)

if not opts.inj_glob:
  print >>sys.stderr, "Must specify a GLOB of inj files to read"
  print >>sys.stderr, "Enter 'plotthinca --help' for usage"
  sys.exit(1)

if not opts.kappa and not opts.epsilon:
  print >> sys.stderr, "Must specify a value of KAPPA and EPSILON"
  print >>sys.stderr, "Enter 'plotthinca --help' for usage"
  sys.exit(1)

if not opts.ifoa or not opts.ifob:
  print >> sys.stderr, "Must specify two ifos, --ifoa and --ifob"
  print >> sys.stderr, "Enter 'plotthinca --help' for usage"
  sys.exit(1)

if opts.slide_glob and not opts.num_slides:
  print >> sys.stderr, "--num-slides must be set if --slide-glob is specified"
  print >> sys.stderr, "Enter 'plotthinca --help' for usage"
  sys.exit(1)
  
#####################################
# glob the input files
injFiles = glob.glob(opts.inj_glob)
injTriggers = readMeta.coincInspiralTable()
for file in injFiles:
  inspTriggers = readMeta.metaDataTable([file],"sngl_inspiral")
  injTrig = readMeta.coincInspiralTable(inspTriggers)
  injTrig = injTrig.coinctype([opts.ifoa,opts.ifob])
  if opts.cluster_window:
    injTrig = injTrig.cluster(opts.cluster_window)
  injTriggers.append(injTrig)

if opts.slide_glob:
  slideFiles = glob.glob(opts.slide_glob)
  inspSlide = readMeta.metaDataTable(slideFiles,"sngl_inspiral")

  slide_num = range(1 , opts.num_slides + 1)
  slide_num.extend(range(-opts.num_slides, 0))

  slideTriggers = readMeta.coincInspiralTable()
  for slide in slide_num:
    this_slide = {}
    this_slide["slide_num"] = slide
    if slide > 0:
      this_slide["sngl_trigs"] = inspSlide.getslide(slide)
    else:
      this_slide["sngl_trigs"] = inspSlide.getslide(5000 - slide)

    # make coincs
    this_slide["coinc_trigs"] = \
        readMeta.coincInspiralTable(this_slide["sngl_trigs"] )
    this_slide["coinc_trigs"] = \
        this_slide["coinc_trigs"].coinctype([opts.ifoa,opts.ifob])

    # cluster triggers
    #if opts.cluster_window:
    #  this_slide["coinc_trigs"] = \
    #    this_slide["coinc_trigs"].cluster(opts.cluster_window)  
    
    # add slide to list
    slideTriggers.append(this_slide["coinc_trigs"])

#######################################################################
# extract the information from the tables

[inj_snr,inj_error] = disterr(injTriggers,[opts.ifoa,opts.ifob])

if opts.slide_glob:
  [slide_snr,slide_error] = disterr(slideTriggers,[opts.ifoa,opts.ifob])


#######################################################################
# plot of distance accuracy vs snr
if opts.dist_snr:
  figure(1)
  # plot the slides
  if opts.slide_glob:
    semilogx(slide_snr, slide_error, 'b+', markersize=12,markeredgewidth=1)
  # plot the injections
  semilogx(inj_snr, inj_error, 'rx', markersize=12,markeredgewidth=1)

  if opts.kappa or opts.epsilon:
    x = arange(int(min(inj_snr)), int(max(inj_snr)) + 2)
    semilogx(x, opts.kappa + opts.epsilon/x,'k',linewidth=1)
    xlim(min(x),max(x))
    ylim(0,1)
    xlabel('snr of trigger')
    ylabel('fractional difference in eff. distance')

 
#######################################################################
# histogram of distance accuracy
if opts.dist_hist:
  figure(2)
  if opts.slide_glob:
    [slide_num,slide_bin,junk] = hist(slide_error,bins=20,normed=True)
  [inj_num,inj_bin,junk] = hist(inj_error,bins=20,normed=True)
  clf()
  if opts.slide_glob:
    bar(slide_bin,slide_num,slide_bin[1]-slide_bin[0],color='b')
  bar(inj_bin,inj_num,inj_bin[1]-inj_bin[0],color='r')
  xlabel('fractional difference in eff. distance')
  ylabel('probability distribution')

#######################################################################
# calculate triggers surviving cut
if (opts.kappa or opts.epsilon) and opts.dist_cut:
  if opts.slide_glob:
    slide_trigs = len(slide_error)
    slide_cut = sum(slide_error > opts.kappa + opts.epsilon/slide_snr)
    print 'Number of time slide triggers ' + str(slide_trigs)
    print 'Number surviving distance cut ' + str(slide_trigs - slide_cut)
  inj_trigs = len(inj_error)
  inj_cut = sum(inj_error > opts.kappa + opts.epsilon/inj_snr)
  print 'Number of injection triggers  ' + str(inj_trigs)
  print 'Number surviving distance cut ' + str(inj_trigs - inj_cut)

if opts.show_plot:
  show()



