#!/usr/bin/python

# $Id$

__author__ = "Patrick Brady <patrick.brady@ligo.org> and Larry Price <larry.price@ligo.org> "
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]
__prog__="plotskypoints"
__Id__ = "$Id$"

import sys
import os
from optparse import *
import re
import exceptions
import glob
from types import *

import random

import numpy
numpy.seterr(all="raise")  # throw an exception on any funny business

from glue import lal
from glue import segments
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
import glue.iterutils
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils
from pylal import InspiralUtils
from pylal import date
from pylal import googlesky
from pylal.xlal import tools
from pylal.xlal import inject
from pylal.xlal.datatypes.ligotimegps import LIGOTimeGPS
import numpy

from glue.ligolw import ligolw, table as tab, lsctables, utils

from pylal import SnglInspiralUtils, SimInspiralUtils
from pylal.tools import XLALEThincaParameterForInjection as ethinca_param

from pylal import galaxyutils

lsctables.LIGOTimeGPS = LIGOTimeGPS

def annotate_plot(x,y,t):
  xlabel(x)
  ylabel(y)
  title(t)
  
def compute_delta_t_rms(gps,longitude,latitude,ifo_list,ifo_coincs,detector_locations):
  earth_center = numpy.zeros(3)
  tgeo={}
  # compute the geocentric time from each trigger
  for ifo in ifo_list:
    tgeo[ifo] = gps[ifo] - LIGOTimeGPS(0,1.0e9*date.XLALArrivalTimeDiff(detector_locations[ifo],earth_center,longitude,latitude,gps[ifo]))
    
  # compute differences in these geocentric times
  time={}
  for ifos in ifo_coincs:
    time[ifos[0]+ifos[1]] = 1.0e-9*date.XLALGPSToINT8NS( tgeo[ifos[0]] - tgeo[ifos[1]] )
  delta_t_rms = 0.0
  for ifos in ifo_coincs:
    delta_t_rms += time[ifos[0]+ifos[1]] * time[ifos[0]+ifos[1]]
  return sqrt(delta_t_rms)
      
def compute_delta_t_rms_ref(gps,mass1,mass2,ref_freq,longitude,latitude,ifo_list,ifo_coincs,detector_locations):
  earth_center = numpy.zeros(3)

  # compute the time to be subtracted to go to reference frequency for each trigger
  tref={}
  for ifo in ifo_list:
    tFromRefFreq = signal_duration(mass1[ifo],mass2[ifo],ref_freq)
    tref[ifo] = LIGOTimeGPS(int(tFromRefFreq),1.e9*(tFromRefFreq-int(tFromRefFreq)))
    
  tgeo={}
  # compute the geocentric time from each trigger
  for ifo in ifo_list:
    tgeo[ifo] = gps[ifo] - tref[ifo] - LIGOTimeGPS(0,1.0e9*date.XLALArrivalTimeDiff(detector_locations[ifo],earth_center,longitude,latitude,gps[ifo]))

  # compute differences in these geocentric times
  time={}
  for ifos in ifo_coincs:
    time[ifos[0]+ifos[1]] = 1.0e-9*date.XLALGPSToINT8NS( tgeo[ifos[0]] - tgeo[ifos[1]] )
  delta_t_rms = 0.0
  for ifos in ifo_coincs:
    delta_t_rms += time[ifos[0]+ifos[1]] * time[ifos[0]+ifos[1]]
  return sqrt(delta_t_rms)

#compute the rms difference in the ratio of the difference of the squares of
#Deff to the sum of the squares of Deff between the measured values
#and a "marginalized" effective distance
#this is just the squared Deff integrated over inclination and polarization
#this quantity is proportional to (F+^2 + Fx^2)^(-1)
def compute_delta_D_rms(gps,longitude,latitude,ifo_list,ifo_coincs,effective_distances,detector_response):
  gmst = {}
  for ifo in ifo_list:
    gmst[ifo] = date.XLALGreenwichMeanSiderealTime(gps[ifo])

  #compute a quantity proportional to the marginalized effective distances
  #we'll only be considering ratios, so the constants don't matter
  D_marg_sq = {}
  F_plus = {}
  F_cross = {}
  for ifo in ifo_list:
    F_plus[ifo], F_cross[ifo] = inject.XLALComputeDetAMResponse(detector_response[ifo], \
                                                                longitude, latitude, 0, gmst[ifo])
    D_marg_sq[ifo] = 1/(F_plus[ifo]*F_plus[ifo]+F_cross[ifo]*F_cross[ifo])

  #compute the difference between these and the measured values 
  delta_D = {}
  effD_diff = 0.0
  effD_sum = 0.0
  Dmarg_diff = 0.0
  Dmarg_sum = 0.0
  for ifos in ifo_coincs:
    effD_diff = effective_distances[ifos[0]]*effective_distances[ifos[0]]  \
                - effective_distances[ifos[1]]*effective_distances[ifos[1]]
    effD_sum = effective_distances[ifos[0]]*effective_distances[ifos[0]]  \
                + effective_distances[ifos[1]]*effective_distances[ifos[1]]
    Dmarg_diff = D_marg_sq[ifos[0]] - D_marg_sq[ifos[1]]
    Dmarg_sum = D_marg_sq[ifos[0]] + D_marg_sq[ifos[1]]
    delta_D[ifos[0]+ifos[1]] = (effD_diff/effD_sum) - (Dmarg_diff/Dmarg_sum)

  delta_D_rms = 0.0
  for ifos in ifo_coincs:
    delta_D_rms += delta_D[ifos[0]+ifos[1]]*delta_D[ifos[0]+ifos[1]]
  return sqrt(delta_D_rms)
    
def skyplot(delta_t_rms, time_threshold, longitude, latitude, symbol, plotpoint=False):
  if delta_t_rms > 2.0*time_threshold:
    if plotpoint:
      plot(asarray([longitude]), asarray([latitude]),'b'+symbol)
    return 0
  elif 2.0*time_threshold >= delta_t_rms > time_threshold: #and delta_t_rms < 2.0* time_threshold:  #changed > to >=; these points should be yellow, right?
    if plotpoint:
      plot(asarray([longitude]), asarray([latitude]),'y'+symbol)
    return 2
  elif delta_t_rms <= time_threshold:
    if plotpoint:
      plot(asarray([longitude]), asarray([latitude]),'r'+symbol) 
    return 1
  else:
    return -1

def gridsky(resolution):
  latitude = 0.0
  longitude = pi
  ds = pi*sqrt(2.0)*resolution/180.0
  points = [numpy.asarray([latitude-0.5*pi, longitude])]
  while latitude <= pi:
    #print "Got here"
    latitude += ds
    longitude = 0.0
    points.append(numpy.asarray([latitude-0.5*pi, longitude]))
    while longitude <= 2.0*pi:
      #print "Got here %f, %f" % (abs(sin(latitude)), longitude)
      longitude += ds / abs(sin(latitude))
      points.append(numpy.asarray([latitude-0.5*pi, longitude]))
  return points

#grid a small portion of the sky
def gridspot(coarse_res,fine_res,latmin,latmax,lonmin,lonmax,wrap_lat,wrap_lon):
  points = []
  ds = pi*sqrt(2.0)*fine_res/180.0
  epsilon = pi*sqrt(2.0)*coarse_res/180.0
  #divide the sphere into up to four grids to do thing the right way
  #each element of the following will be a list of [min,max] pairs
  lat_grids = []
  lon_grids = []

#  latmin += pi/2 - box_err
#  latmax += pi/2 + box_err
#  lonmin -= box_err
#  lonmax += box_err
#  if latmin < 0:
#    latmin = 0
#  if latmax > pi:
#    latmax = pi
#  if lonmin < 0:
#    lonmin = 0
#  if lonmax > 2*pi:
#    lonmax = 2*pi

#  latitude = latmin
#  longitude = lonmin
#  while latitude <= latmax:
#    points.append(numpy.asarray([latitude-pi/2,longitude]))
#    while longitude <= lonmax:
#      longitude += ds / abs(sin(latitude))
#      points.append(numpy.asarray([latitude-pi/2,longitude]))
#    latitude += ds
#    longitude = lonmin
  #make latitude run from 0 to pi, to avoid gridding problems at the equator
  latmin += 0.5*pi
  latmax += 0.5*pi
  #latdiff = latmax - latmin 
  #londiff = lonmax - lonmin 
  if wrap_lat: #latdiff > 0.5*pi :
    lat_grids.append([latmax-epsilon,pi])
    lat_grids.append([0,latmin+epsilon])
  else:
    if (latmin - epsilon > 0) and (latmax + epsilon < pi):
      lat_grids.append([latmin-epsilon,latmax+epsilon])
    elif (latmin - epsilon < 0) and (latmax + epsilon > pi):
      lat_grids.append([0,pi])
    elif latmin - epsilon < 0 :
      lat_grids.append([0,latmax+epsilon])
      lat_grids.append([pi+latmin-epsilon,pi])
    elif latmax + epsilon > pi:
      lat_grids.append([latmin-epsilon,pi])
      lat_grids.append([0,latmax+epsilon-pi])
    else:
      raise ValueError, "this should never happen"#, latmin, latmax
  if wrap_lon:#londiff > pi:
    lon_grids.append([lonmax-epsilon,2*pi])
    lon_grids.append([0,lonmin+epsilon])
  else:
    if (lonmin - epsilon > 0) and (lonmax + epsilon < 2*pi):
      lon_grids.append([lonmin-epsilon,lonmax+epsilon])
    elif (lonmin - epsilon < 0) and (lonmax + epsilon > 2*pi):
      lon_grids.append([0,2*pi])
    elif lonmin - epsilon < 0:
      lon_grids.append([0,lonmax+epsilon])
      lon_grids.append([2*pi+lonmin-epsilon,2*pi])
    elif lonmax + epsilon > 2*pi:
      lon_grids.append([lonmin-epsilon,2*pi])
      lon_grids.append([0,lonmax+epsilon-2*pi])
    else:
      raise ValueError, "this should never happen"#, lonmin, lonmax

  for latgrid in lat_grids:
    for longrid in lon_grids:

      latitude = latgrid[0]
      longitude = longrid[0]

      points.append(numpy.asarray([latitude-0.5*pi,longitude]))
      while latitude <= latgrid[1]:
        latitude += ds
        longitude = longrid[0]
        points.append(numpy.asarray([latitude-0.5*pi,longitude]))
        while longitude <= longrid[1]:
          longitude += ds / abs(sin(latitude))
          points.append(numpy.asarray([latitude-0.5*pi,longitude]))
      

  #deal with periodic grid issues by always starting at (0,0) and then translating back to the original position
  #latdiff = latmax - latmin 
  #londiff = lonmax - lonmin 
  #if latdiff > 0.5*pi :
  #  d_lat = latmax - epsilon
  #  grid_latmax = periodic(2*epsilon-latdiff,0,pi)
  #else:
  #  d_lat = latmin - epsilon
  #  grid_latmax = latdiff + 2*epsilon
  #if londiff > pi:
  #  d_lon = lonmax - epsilon
  #  grid_lonmax = periodic(2*epsilon-londiff,0,2*pi)
  #else:
  #  d_lon = lonmin - epsilon
  #  grid_lonmax = londiff + 2*epsilon

  #latitude = 0
  #longitude = 0
  #points = [numpy.asarray([periodic(latitude+d_lat,-0.5*pi,0.5*pi),periodic(longitude+d_lon,0,2*pi)])] 
  #while latitude <= grid_latmax:
  #  latitude += ds
  #  longitude = 0
  #  points.append(numpy.asarray([periodic(latitude+d_lat,-0.5*pi,0.5*pi),periodic(longitude+d_lon,0,2*pi)]))
  #  while longitude <= grid_lonmax:
  #    longitude += ds / abs(sin(latitude))
  #    points.append(numpy.asarray([periodic(latitude+d_lat,-0.5*pi,0.5*pi),periodic(longitude+d_lon,0,2*pi)]))

  print "latmin", latmin
  print "latmax", latmax
  print "lonmin", lonmin
  print "lonmax", lonmax
  print "wrap lat", wrap_lat
  print "wrap_lon", wrap_lon
  print "######"

  #print points
  return points

#enforce periodic boundary conditions on things
#this helps avoid ambiguities in gridding and convex hull finding that arise when working on the surface of the 2-sphere

def periodic(x,xmin,xmax):
  if x < xmin:
    return x + xmax
  if x >= xmax:
    return x - xmax
  return x

# distance on the sphere
def sphdist(p1,p2):

  cos_lat_plus = cos(p1[0]+p2[0])
  cos_lat_minus = cos(p1[0]-p2[0])
  cos_lon_minus = cos(p1[1]-p2[1])

  return arccos(0.5*(cos_lat_plus*(cos_lon_minus-1)+cos_lat_minus*(cos_lon_minus+1)))

# compute distance between clusters
def clus_dist(clus1,clus2,pdists):
  clusdmin = 999

  for c1 in clus1:
    for c2 in clus2:
      clusd = pdists[(c1,c2)]
      if (clusd < clusdmin):
        clusdmin = clusd
        
  return clusdmin

#find clusters of points on the 2-sphere
#stops clustering when the separataion of the closest points is greater than max_d
def find_clusters(points, max_d):
  # dictionary of distances between hotspots
  dist_dict = {}

  for pt1 in points:
    for pt2 in points:
      dist_dict[(pt1,pt2)] = sphdist(pt1,pt2)
      
  # begin by declaring each point a cluster
  clusters = [[pt] for pt in points]

  while 1:
    # location of the closest clusters
    loc1, loc2 = 0, 0
    # variable used in find minimum distance between clusters
    dtemp = 99999
      
    for i in xrange(len(clusters)):
      for j in xrange(i+1, len(clusters)):
        dij = clus_dist(clusters[i],clusters[j],dist_dict)
        if dij < max_d < dtemp: #and (dij < dtemp):
          dtemp = dij
          loc1, loc2 = i, j
            
    if (loc1 == 0) and (loc2 == 0):
      return clusters

    clusters.append(clusters[loc1]+clusters[loc2])
    # i think this is a bug in python, but if you switch loc2 and loc1 in the next two lines things get screwed up
    clusters.remove(clusters[loc2])
    clusters.remove(clusters[loc1])
  
def signal_duration(mass1,mass2,nuStart):
  M = mass1+mass2
  mu = mass1*mass2/M
  eta = mu/M
  chirpM = pow(mu*mu*mu*M*M,1./5.)
  M = M*4.92549095e-6
  mu = mu*4.92549095e-6
  chirpM = chirpM*4.92549095e-6
  tau0 = 5./256. * pow(chirpM,-5./3.) * pow(pi*nuStart,-8./3.)
  tau1 = 5./(192.*mu*pi*pi*nuStart*nuStart) * (743./336. + 11./4.*eta)
  tau1p5 = 1./(8.*mu) * pow(M/(pi*pi*pow(nuStart,5.)),1./3.)
  tau2 = 5./(128.*mu) * pow(M/(pi*pi*nuStart*nuStart),2./3.)\
         *(3058673./1016064. + 5429./1008.*eta + 617./144.*eta*eta)        
  duration = tau0 + tau1 - tau1p5 + tau2
  return(duration)


def mkdirsafe( directory, nag = False ):
  """
  Create a directory if it does not already exist.
  Optionally, nag if it already exists.
  """
  try:
     os.makedirs(directory)
  except OSError, (errno, strerror):
    if errno == 17 and nag:
      raise OSError, "Directory '%s' already exists, all files "\
            "contained will be included in summary file, "\
            "although not related to THIS summary!" \
            " Suggestion: rename directory '%s'." % \
            (directory, directory)
    if errno!=17:
      raise

def write_file(root_dir, filename, content):
  """
  Writes a file to disk.
  @param root_dir: directory where to write the file
  @param filename: name of the file
  @param content: contents of the file
  """

  f = open(root_dir+'/'+filename,'w')
  f.write(content)
  f.close()

#stole this stuff from plotgrbl
#thanks, nick!
class always_equal(object):
    def __eq__(self, other):
        return True

def make_html_table(two_dim_seq, header_row=None):
    """
    Given a sequence of sequences (2-D array works), make an HTML table out
    of it.  If header_row is provided, make it the table header.
    """
    last_len = always_equal()
    html = ["<table  border=\"1\" cellspacing=\"0\">"]
    if header_row is not None:
        html.append("  <tr><th>" + "</th><th>".join(map(str, header_row)) \
            + "</th></tr>")
        last_len = len(header_row)
    for row in two_dim_seq:
        if len(row) != last_len:
            raise ValueError, "header and row lengths must all be consistent."
        last_len = len(row)
        html.append("  <tr><td>" + "</td><td>".join(map(str, row)) \
            + "</td></tr>")
    html.append("</table><br>")
    return "\n".join(html)

#
# templates with which to fill in our Google Sky page
#

left_content_template = \
"""  <h2>Galaxies Within Confidence Region</h2>   
    <form>
      macrogalaxybuttons
    </form>
  <hr/>
  <h2>Points With Highest Confidence</h2>
    <form>
      macropointbuttons
    </form>
  <hr/>
    <form>
      %s
    </form>""" % googlesky.html_clear_button

galaxy_description_template = \
"""        <p> Position (ra,dec): (macrolon,macrolat)</p>
        <p> Distance: macrodistance kpc </p>
        <p> Luminosity: macrolum mwes </p>"""

point_description_template = \
"""        <p> Position (ra,dec): (macrolon,macrolat)</p>
        <p> Confidence: macroconfidence</p>"""

#
# KMLDocument subclasses make Google Sky integration easy
#

class GalaxyKMLDocument(googlesky.KMLDocument):
  """
  Represent a KML file for a pylal.galaxyutils.galaxy object.
  """
  def __init__(self, url, label, galaxy=None, color="yellow"):
    googlesky.KMLDocument.__init__(self, url, label)
    if galaxy is not None:
      self.add_galaxy(galaxy, color)

  def add_galaxy(self, galaxy, color="yellow"):
    descr_html = galaxy_description_template\
        .replace("macrolon", str(180 / pi * galaxy.ra))\
        .replace("macrolat", str(180 / pi * galaxy.dec))\
        .replace("macrodistance", str(galaxy.distance_kpc))\
        .replace("macrolum", str(galaxy.luminosity_mwe))
    self.add_placemark(googlesky.Placemark(id=galaxy.name, name=galaxy.name,
        description_html=descr_html, fov_rad=None,
        point_rad=(galaxy.ra, galaxy.dec), point_color_str=color))

class PointingKMLDocument(googlesky.KMLDocument):
  """
  Represent a single telescope pointing for a galaxy object.
  """
  def __init__(self, url, label, gps_time, rank, lon, lat, confidence,
    color="blue"):
    googlesky.KMLDocument.__init__(self, url, label)
    self.id = gps_time + "_" + rank
    self.name = gps_time + ' number ' + rank
    self.add_pointing(gps_time, rank, lon, lat, confidence, color)

  def add_pointing(self, gps_time, rank, lon, lat, confidence, color="blue"):
    descr_html = point_description_template\
        .replace("macrolon", str(lon))\
        .replace("macrolat", str(lat))\
        .replace("macroconfidence", str(confidence))
    self.add_placemark(googlesky.Placemark(id=self.id, name=self.name,
        description_html=descr_html, fov_rad=None,
        point_rad=(lon, lat), point_color_str=color))

def make_googlesky_summary(gps_time, galaxy_buttons, pointing_buttons, key):
  """
  create google sky summary page
  """
  left_nav_html = left_content_template\
    .replace('macrotitle',gps_time)\
    .replace('macrogalaxybuttons', galaxy_buttons)\
    .replace('macropointbuttons', pointing_buttons)
  html = googlesky.html_template\
    .replace("macrokey", key)\
    .replace("macroleftcontent", left_nav_html)
  return html

# What we want to do:
# read in the coinc
# extract the GPS time for each trigger
# loop over random sky points
#   determine the geo centric time for each and compute rms difference
# those points that are "good enough" then get subjected to a
# threshold on the ratios of their measured effective distances

##############################################################################
usage = """
usage: %prog [options] 

Estimate the sky position from a coincident trigger.

"""


def parse_command_line():
  """
  Parser function dedicated
  """
  parser = OptionParser( usage=usage, version="%prog CVS $Id$ " )

  # options related to input and output
  parser.add_option("-g","--glob",action="store",type="string",\
      default=None, metavar=" GLOB",help="GLOB of thinca files to read" )
  parser.add_option("-I", "--cache-file", \
      help="read thinca filenames from cache input file")  
  parser.add_option("-a","--time-threshold",action="store",type="float",\
      default=0.001, metavar=" TIME_THRESHOLD",help="threshold on rms time difference" )
  parser.add_option("-b","--n-sky",action="store",type="int",\
      default=1000, metavar=" N_SKY",help="number of sky points to throw" )
#  parser.add_option("-c","--resolution",action="store",type="float",\
#      default=1.0, metavar=" RESOLUTION",help="number of sky points to throw" )
  parser.add_option("-c","--coarse-resolution",action="store",type="float",\
      default=4.0, metavar=" COARSE_RESOLUTION",help="number of sky points to throw in round one" )
  parser.add_option("-i","--fine-resolution",action="store",type="float",\
      default=0.5, metavar=" RESOLUTION",help="number of sky points to throw in round two" )
  parser.add_option("-d","--plotpoints",action="store_true",\
      default=False, help="make a color coded plot of the sky" )
  parser.add_option("-V","--verbose",action="store_true",\
      default=False, help="be verbose in the output messages" )
  parser.add_option("-S","--statistic",action="store",default='snr',\
      type="string",\
      help="choice of statistic used in making plots, valid arguments are: "
            "snr (DEFAULT), snr_over_chi, effective_snr, " 
            "bitten_l, bitten_lsq")
  parser.add_option("-C","--plotgalaxies",action="store_true",\
      default=False, help="plot the galaxies within the confidence region" )
  parser.add_option("-u","--usecatalog",action="store",type="string",\
      default=None, metavar=" CATALOG_NAME", help="galaxy catalog to use; must be specified if --listgalaxies option is used")
  parser.add_option("-D","--Deffcut",action="store_true",\
      default=False,help="only consider galaxies from here to the minimum effective distance measured. this is a very strong cut!") 
  #parser.add_option("-r","--use-reference-time",action="store_true",\
  #                  default=False, help="use time at reference frequency instead of end time" )
  parser.add_option("-f","--reference-frequency",action="store",type="float",\
                    default=0, metavar=" REFERENCE_FREQUENCY",help="reference frequency for signal timing" )
  #this one doesn't work generally yet because of issues with keys from google, etc.
  parser.add_option("--enable-google-sky-output", action="store_true", default=False, help="enable google sky output")
  parser.add_option("--google-map-key", metavar="KEY",
    help="the Google-issued API key specific to the URL from which your "\
    "page will be hosted")

  # InspiralUtils compatibility
  #parser.add_option("--gps-start-time", type="int", help="GPS start time of data analyzed")
  #parser.add_option("--gps-end-time", type="int", help="GPS end time of data analyzed")
  #parser.add_option("--ifo-tag", help="IFO coincidence time analyzed")
  parser.add_option("--user-tag", help="a tag to label your plots")
  parser.add_option("--output-path", help="root of the HTML output")
  parser.add_option("--enable-output", action="store_true", default=False, help="enable plots and HTML output")
  parser.add_option("--write-summary-plots", action="store_true", default=False, \
                    help="write the summary plots to an HTML page (for injection runs)")
  parser.add_option("--write-inj-data", action="store_true", default=False, \
                    help="create a file with data from injections")
  
  parser.add_option("--show-plot", action="store_true", default=False, \
                    help="display the plots to screen if an X11 display is available")


  (options,args) = parser.parse_args()

  if options.enable_google_sky_output and (options.google_map_key is None):
    raise ValueError, "if --enable-google-sky-output is specified, require "\
        "--google-map-key as well."

  return options, sys.argv[1:]



#####################################################################
# -- get command line arguments
opts, args = parse_command_line()

if not opts.show_plot:
  import matplotlib
  matplotlib.use("Agg")
from pylab import *
rc('text', usetex=True)

#####################################################################
figure_number = 0  # used for the figure label (showplot)
fnameList = []   # use for the cache file
tagList= []   # use for the cache file

####################################################################
statistic = CoincInspiralUtils.coincStatistic( opts.statistic, None, None)
    
plotsymbols = ['r+','bx','ko','g1']
hanfordsym = ['b+','bx','r1']
addsym = ['k+','kx','k1']

xlow = 20
xhigh = 0

####################################################################
# load galaxy catalog

if opts.plotgalaxies:
  if opts.usecatalog is not None:
    gal_columns =["name","distance_kpc","ra","dec","luminosity_mwe"]
    catalog = galaxyutils.GalaxyCatalog.from_file(open(opts.usecatalog), load_columns=gal_columns)
  else:
    print >>sys.stdout, "no galaxy catalog specified"
####################################################################
# stupidity check

if opts.fine_resolution > opts.coarse_resolution:
  raise ValueError, "fine resolution is greater than coarse resolution" 

#####################################################################
# glob the list of files to read in

slidefiles = []
coincfiles = []
offsourcefiles = []


if opts.glob is not None:
  allfiles = []
  for gl in opts.glob.split(" "):
    allfiles.extend(glob.glob(gl))
  if len(allfiles) < 1:
    print >>sys.stderr, "The glob for " + opts.glob + " returned no files" 
    sys.exit(1)
  else:
    for file in allfiles:
      if 'SLIDE' in file:
        slidefiles.append(file)
      else:
        coincfiles.append(file)

  # check if the file lists are not empty
  if not (coincfiles or slidefiles):
    print >>sys.stdout, "No files match your description."
    sys.exit(0)

  
#####################################################################
# read in coinc triggers

inspTriggers = None
coincTriggers = CoincInspiralUtils.coincInspiralTable()

meaninjdelta_t_rms = 0.
meanpointings_narrow = 0.
meanpointings_wide = 0.
ninj = 0
if coincfiles:
  inspTriggers = SnglInspiralUtils.\
                 ReadSnglInspiralFromFiles(coincfiles,
                                           mangle_event_id = True,
                                           verbose=None)
  inspInj = SimInspiralUtils.ReadSimInspiralFromFiles(coincfiles)
  
  # construct the coincs
  coincTriggers = CoincInspiralUtils.coincInspiralTable(inspTriggers,statistic)
  coincTriggers.add_sim_inspirals(inspInj)

detector_locations = {}
detector_locations["L1"] =tools.cached_detector["LLO_4k"].location   
detector_locations["H1"] =tools.cached_detector["LHO_4k"].location 
detector_locations["V1"] =tools.cached_detector["VIRGO"].location

#get detector response
detector_response = {}
detector_response["L1"] = tools.cached_detector["LLO_4k"].response
detector_response["H1"] = tools.cached_detector["LHO_4k"].response
detector_response["V1"] = tools.cached_detector["VIRGO"].response

#set the time threshold
time_threshold = opts.time_threshold

#set the reference frequency
ref_freq = opts.reference_frequency
if opts.verbose:
  print "Reference frequency is %.1f Hz" % ref_freq
  
# arrays to build statistics
asnr = []
asnrH1 = []
asnrL1 = []
asnrV1 = []

adelta_t = []
adelta_D = []
adelta_comb_stat = []
adelta_comb_stat_coarse = []
apoints = []
afound = []

adel_t_inj_sq = []
adel_D_inj_sq = []
adel_t = []
adel_D = []
adel_t_sq = []
adel_D_sq = []

askydist = []

if opts.plotgalaxies:
  agalpoints = []

#distance threshhold for clustering
#if opts.plotgalaxies:
#  pt_step = pi*sqrt(2.0)*opts.resolution/180.0
#  dmax = sphdist((0,0), (pt_step,pt_step))

if opts.write_inj_data:
  inj_data = ""
 
for coinc in coincTriggers:

  # a few counting parameters
  count = zeros(3)
  
  # print out some information about the trigger
  if opts.verbose:
    print "The snr is %f" % coinc.stat
    print "The H1 snr is %f" % getattr(coinc,"H1").snr
    print "The L1 snr is %f" % getattr(coinc,"L1").snr
    print "The V1 snr is %f" % getattr(coinc,"V1").snr

   
  # get gps times of events

  # following line suggested by nick as an alternative to
  # modifying library code

  gps = dict((trig.ifo,trig.get_end()) for trig in coinc)
  mass1 = dict((trig.ifo,getattr(coinc,trig.ifo).mass1)  for trig in coinc)
  mass2 = dict((trig.ifo,getattr(coinc,trig.ifo).mass2)  for trig in coinc)

  # gps = coinc.get_gps_times()

  #take the parameters from the injection
  effD_inj = {}
  effD_inj["H1"] = getattr(coinc, "sim").eff_dist_h
  effD_inj["L1"] = getattr(coinc, "sim").eff_dist_l
  effD_inj["V1"] = getattr(coinc, "sim").eff_dist_v
 
  # extract ifos that gave this
  (coinc_type, ifo_list) = coinc.get_ifos()

  if ( coinc_type != "H1L1V1" and coinc_type != "H1H2L1V1" ):
    if opts.verbose:
      print "Not possible to locate on sky"
    continue
  else:
    if opts.plotpoints:
      figure()
      
  H1snr = getattr(coinc,"H1").snr
  L1snr = getattr(coinc,"L1").snr
  V1snr = getattr(coinc,"V1").snr
  asnrH1.append(H1snr)
  asnrL1.append(L1snr)
  asnrV1.append(V1snr)


  #remove H2 if it's there
  ifo_list = [ifo for ifo in ifo_list if ifo != "H2"]
 
  # get the list of pairs
  ifo_coincs = []
  ifo_coincs.extend(list(glue.iterutils.choices(ifo_list, 2)))
  
  # grid the sky
  # skypoints = gridsky(opts.resolution)
 
  #grid the sky coarsely for now
  coarsegrid = gridsky(opts.coarse_resolution,)
  if opts.verbose:
    print "The number of sky points to consider is %f" % len(coarsegrid)
    #print "The number of sky points to consider is %f" % len(skypoints)

  #
  coarse_confidence = []

  # parameters from the injection
  injlong = getattr(coinc,"sim").longitude
  injlat = getattr(coinc,"sim").latitude
  if opts.reference_frequency:
    injdelta_t_rms = compute_delta_t_rms_ref(gps,mass1,mass2,ref_freq,injlong,injlat,ifo_list,\
                                       ifo_coincs,detector_locations)
  else:
    injdelta_t_rms = compute_delta_t_rms(gps,injlong,injlat,ifo_list,\
                                   ifo_coincs,detector_locations)

  injdelta_D_rms= compute_delta_D_rms(gps,injlong,injlat,ifo_list, \
                                      ifo_coincs,effD_inj,detector_response)
  adelta_t.append(injdelta_t_rms)
  adelta_D.append(injdelta_D_rms)
  
   
  meaninjdelta_t_rms = meaninjdelta_t_rms+injdelta_t_rms
  ninj = ninj + 1
  if opts.verbose:
    print "The injection had delta_t_rms %f seconds" % injdelta_t_rms
  #time_threshold=injdelta_t_rms+1.0e-6
  countindex = skyplot(injdelta_t_rms, time_threshold, injlong, injlat,\
      'o', opts.plotpoints)
  afound.append(countindex)

  

  # lists to gather hotspots (points within time-threshold),
  # warmspots (points within twice the time-threshold) and clusters
#  if opts.plotgalaxies:
#  hotspots = []
#  warmspots = []
#  hs_clusters = []
#  ws_clusters = []

 #create a dictionary of measured effective distances
  effective_distances = {}
  effective_distances["H1"] = getattr(coinc, "H1").eff_distance
  effective_distances["L1"] = getattr(coinc, "L1").eff_distance
  effective_distances["V1"] = getattr(coinc, "V1").eff_distance

  
  # search the sky
  #for point in skypoints:
  for point in coarsegrid:
    count[0] += 1
  
    # extract sky position
    latitude = point[0]
    longitude = point[1]

    if opts.reference_frequency:
      delta_t_rms = compute_delta_t_rms_ref(gps,mass1,mass2,ref_freq,longitude,latitude,ifo_list,\
                                      ifo_coincs,detector_locations)
    else:
      delta_t_rms = compute_delta_t_rms(gps,longitude,latitude,ifo_list,\
                                  ifo_coincs,detector_locations)

 #   countindex =skyplot(delta_t_rms, time_threshold, longitude, latitude,\
 #     '+', opts.plotpoints)

 #   if countindex:
 #     count[countindex] += 1.0
 #     if (int(countindex) == 1): #and (opts.plotgalaxies):
 #       hotspots.append((point[0],point[1]))
 #     elif (int(countindex) == 2): #and (opts.plotgalaxies):
 #       warmspots.append((point[0],point[1]))
    coarse_confidence.append([(point[0],point[1]),delta_t_rms/time_threshold \
                              + compute_delta_D_rms(gps,longitude,latitude,ifo_list, \
                                 ifo_coincs,effective_distances,detector_response)])
      
      
 #   if ( not (count[0] % 1000) and opts.verbose):
 #     print count[0]

 # narrowcount=count[1]
 # widecount=count[2]
 # meanpointings_narrow = meanpointings_narrow + narrowcount
 # meanpointings_wide = meanpointings_wide + widecount
 # if opts.verbose:
 #   print "Narrow field volume: %i" % (narrowcount)
 #   print "Wide field volume: %i" % (widecount)
 # else:
 #   asnr.append(coinc.stat)
 #   adelta_t.append(injdelta_t_rms)
 #   apoints.append(narrowcount)
 #   adel_D_inj.append(injdelta_D_rms)
 #   adel_t_inj_sq.append(injdelta_t_rms*injdelta_t_rms)
 #   adel_D_inj_sq.append(injdelta_D_rms*injdelta_D_rms)
  #  adel_D2.append(injdelta_D_rms2)
 # print "%f %f %i %i %f" % (coinc.stat, injdelta_t_rms, narrowcount,\
 #       afound[-1], getattr(coinc,"sim").distance)


####################################################################
  # cluster the hotspots and warmspots
  #if opts.plotgalaxies:
  #  hs_clusters = find_clusters(hotspots, dmax)
  #  ws_clusters = find_clusters(warmspots, dmax)

####################################################################
  #create a dictionary of measured effective distances
  effective_distances = {}
  effective_distances["H1"] = getattr(coinc, "H1").eff_distance
  effective_distances["L1"] = getattr(coinc, "L1").eff_distance
  effective_distances["V1"] = getattr(coinc, "V1").eff_distance

  #goodspots = []
  #for pt in hotspots:
  #  goodspots.append(pt)
 # for pt in warmspots:
 #   goodspots.append(pt)

#  for pt in delta_dict:
#    delta_dict[pt].append(compute_delta_D_rms2(gps,pt[1],pt[0],ifo_list, \
#                                     ifo_coincs,effective_distances,detector_response))
#  for pt in coarse_confidence:
#    pt[1] += compute_delta_D_rms(gps,pt[0][1],pt[0][0],ifo_list, \
#                                 ifo_coincs,effective_distances,detector_response)

  coarse_confidence.sort(key = lambda x: x[1])

  pt_step = pi*sqrt(2.0)*2*opts.coarse_resolution/180.0
  dmax = sphdist((0,0), (pt_step,pt_step))

  coarse_hotspots =[pt[0] for pt in coarse_confidence if pt[1] <= 3*coarse_confidence[0][1]]
  for pt in coarse_confidence:
    if pt[1] > 3*coarse_confidence[0][1] and (opts.plotpoints or opts.enable_output):
      plot(asarray([pt[0][1]]), asarray([pt[0][0]]),'bx')
  #[pt[0] for pt in coarse_confidence[:10]]
  coarse_hs_clusters = find_clusters(coarse_hotspots,dmax)

  Linj = (injdelta_t_rms/time_threshold+injdelta_D_rms)
  Linj_coarse_norm = Linj/coarse_confidence[0][1]
  adelta_comb_stat_coarse.append(Linj_coarse_norm)
  
  #list to hold each cluster and its confidence values
  final_confidences = []

  #keep track of which points are in each cluster 
  if opts.plotgalaxies:
    num_clusts = len(coarse_hs_clusters)
    clust_count = 0
    
  for cluster in coarse_hs_clusters:

    lats = [pt[0] for pt in cluster]
    lons = [pt[1] for pt in cluster]
    latmin = min(lats)
    latmax = max(lats)
    lonmin = min(lons)
    lonmax = max(lons)


    #if latmax-latmin > pi or lonmin-lonmax > pi/2 check to see whether
    #grids are oriented to wrap around the short (wrap_x = 1) or long (wrap_x = 0) way
    wrap_lat = 0
    wrap_lon = 0

    if (latmax - latmin > 0.5*pi) or (lonmax-lonmin > pi):
      for pt in cluster:
        if not (latmax >= pt[0] >= latmin):
          wrap_lat = 1
          print "latwrap point", pt[0]
        if not (lonmax >= pt[1] >= lonmin):
          wrap_lon = 1
          print "lonwrap point", pt[1]
        if (wrap_lat == 1) and (wrap_lon == 1):
          break

    finegrid = gridspot(opts.coarse_resolution,opts.fine_resolution,latmin,latmax,lonmin,lonmax,wrap_lat,wrap_lon)

    fine_confidence = []
  
    for point in finegrid:
      latitude = point[0]
      longitude = point[1]

      if opts.reference_frequency:
        delta_t_rms = compute_delta_t_rms_ref(gps,mass1,mass2,ref_freq,longitude,latitude,ifo_list,\
                                              ifo_coincs,detector_locations)
      else:
        delta_t_rms = compute_delta_t_rms(gps,longitude,latitude,ifo_list,\
                                          ifo_coincs,detector_locations)
      if opts.plotgalaxies:
        fine_confidence.append([(point[0],point[1]),delta_t_rms/time_threshold \
                                + compute_delta_D_rms(gps,longitude,latitude,ifo_list, \
                                                      ifo_coincs,effective_distances, \
                                                      detector_response),clust_count])
    
    
      else:
        fine_confidence.append([(point[0],point[1]),delta_t_rms/time_threshold \
                                + compute_delta_D_rms(gps,longitude,latitude,ifo_list, \
                                                      ifo_coincs,effective_distances, \
                                                     detector_response)])
      if opts.plotgalaxies:
        clust_count += 1
    
  fine_confidence.sort(key = lambda x: x[1])
  
  if (opts.plotpoints or opts.enable_output):
    plot(asarray([fine_confidence[0][0][1]]), asarray([fine_confidence[0][0][0]]),'rs')

  best_confidence = fine_confidence[0][1]

  Linj_fine_norm = Linj/best_confidence
  
  adelta_comb_stat.append(Linj_fine_norm)

  narrowcount = 0.0
  widecount = 0.0 
  if opts.plotgalaxies:
    best_points = []
    
  for pt in fine_confidence:
    if 4*best_confidence >= pt[1] >= 2*best_confidence:
      if (opts.plotpoints or opts.enable_output):
        plot(asarray([pt[0][1]]), asarray([pt[0][0]]), 'yx')
      widecount += 1.0
      if opts.plotgalaxies:
        best_points.append(pt)
    elif pt[1] < 2*best_confidence:
      if (opts.plotpoints or opts.enable_output):
        plot(asarray([pt[0][1]]), asarray([pt[0][0]]), 'rx')
      narrowcount += 1.0
      if opts.plotgalaxies:
        best_points.append(pt)

  apoints.append(narrowcount)
  combsnr = coinc.stat
  asnr.append(combsnr)
  if (opts.plotpoints or opts.enable_output):
    axis(asarray([0.0, 2.0*pi, -pi/2.0, pi/2.0]))
    annotate_plot("Right Ascension (radians)", "Declination (radians)",\
                  "Reconstructed sky position")
  
  if opts.plotgalaxies:
    if opts.Deffcut:
      max_dist = 1000*min(effective_distances[ifo] for ifo in ifo_list)
    else:
      # this is farther than we can see, so it should encompass everything
      # if done this way, it's only a single if statement
      max_dist = 1000000

    galaxies = []
    galaxy_counter = {}
    total_num_gals = 0 

    # draw rectangles around the hotspots and count the number of galaxies in that rectangle
    # also restric to galaxies between here and the effective distance measured in the detectors (turns out to be a strong cut)
    for i in xrange(num_clusts):
      
      lats = [pt[0][0] for pt in best_points if pt[2] == i]
      if lats:
        latmin = min(lats)
        latmax = max(lats)

      if latmax - latmin < 0.001:
        latmin -= 0.001
        latmax += 0.001
      
      lons = [pt[0][1] for pt in best_points if pt[2] == i]
      if lons:
        lonmin = min(lons)
        lonmax = max(lons)

      if lonmax - lonmin < 0.001:
        lonmin -= 0.001
        lonmax += 0.001
      
      if (latmin < 0) and (latmax > 0):
        galaxies = catalog.within_distances(0,max_dist).within_polygon( \
          numpy.array([(lonmin,latmin),(lonmax,latmin),(lonmin,0), (lonmax,0)])) \
          + catalog.within_distances(0,max_dist).within_polygon( \
          numpy.array([(lonmin,0),(lonmax,0),(lonmin,latmax), (lonmax,latmax)]))
      else:
        galaxies = catalog.within_distances(0,max_dist).within_polygon( \
          numpy.array([(lonmin,latmin),(lonmax,latmin),(lonmin,latmax), (lonmax,latmax)]))

      if galaxies and (opts.plotpoints or opts.enable_output):
        for gal in galaxies:
          plot(asarray([gal.ra]), asarray([gal.dec]), color = (0.5,0,0.5), marker = '^')
        axis(asarray([0.0, 2.0*pi, -pi/2.0, pi/2.0]))
        annotate_plot("Right Ascension (radians)", "Declination (radians)",\
                      "Reconstructed sky position")
 
      galaxy_counter[i] = len(galaxies)
       
    for i in galaxy_counter:
      total_num_gals += galaxy_counter[i]
      
    agalpoints.append(total_num_gals)

  #if opts.plotpoints:
  if opts.enable_output and opts.plotpoints:

    # plot the spot with the most galaxies as purple
    #if opts.plotgalaxies:
    #  min_num_gals = -1
    #  for i in galaxy_counter:
    #    if galaxy_counter[i] > min_num_gals:
    #      this_one = i
    #      min_num_gals = galaxy_counter[i]
    #  if min_num_gals > 0:
    #    for pt in best_points:
    #      if pt[2] == this_one:
    #        pass
    #        plot(asarray([pt[0][1]]), asarray([pt[0][0]]), color = (0.5,0,0.5), marker = 'x')
          
    axis(asarray([0.0, 2.0*pi, -pi/2.0, pi/2.0]))
    annotate_plot("Right Ascension (radians)", "Declination (radians)",\
        "Reconstructed sky position")
    #####################################################################
    # HTML initialization
    opts.ifo_tag = coinc_type
    opts.gps_start_time =  min(coinc.get_gps_times()[ifo] for ifo in coinc.get_gps_times())
    opts.gps_end_time =  max(coinc.get_gps_times()[ifo] for ifo in coinc.get_gps_times())
    InspiralUtils.initialise(opts, __prog__, __version__)
    html_footer = ""
    text = "Reconstructed sky position"
    fname = InspiralUtils.set_figure_name(opts, "sky_position")
    fname_thumb = InspiralUtils.savefig_pylal(filename=fname)
#    fnameList.append(fname)
#    tagList.append(text)

    html_footer += "Ten best points:<br><br>\n"
    best_pts_columns = ['rank', 'ra', 'dec', 'confidence']
    ten_best_pts = []
    for i in range(10):
      ten_best_pts.append([i+1,fine_confidence[i][0][1],fine_confidence[i][0][0],fine_confidence[i][1]])
    html_footer += make_html_table(ten_best_pts,best_pts_columns)
    html_footer += "\n\n"
    
    if opts.plotgalaxies:
      #write out a table of galaxies, if there are any
      html_footer += "Summary of galaxies in confidence region:<br><br>\n"
      if galaxies:
        html_footer += make_html_table([str(gal).split() for gal in galaxies], gal_columns)
      else:
        html_footer += "No galaxies there!<br><br>\n"

    if opts.enable_google_sky_output:
      #now put in a link to the google sky output page
      html_footer += '\n\n <a href=\"' + str(opts.gps_start_time) + '/' \
        + str(opts.gps_start_time) + \
        '_plotskypoints_summary.html\">Google Sky Summary</a><br><br>\n'

    html_filename=InspiralUtils.write_html_output(opts, sys.argv[1:],\
                     [fname], [text], comment=html_footer)
    if not opts.show_plot:
      close()
    #next create the google sky output

    if opts.enable_google_sky_output:
      gsky_root_dir = opts.output_path + str(opts.gps_start_time) + '/'
      kml_root_dir = gsky_root_dir + '/kml/'
      mkdirsafe(gsky_root_dir)
      mkdirsafe(kml_root_dir)

      galaxy_buttons = []
      pointing_buttons = []

      if opts.plotgalaxies:
        start_time = str(opts.gps_start_time)
        for galaxy in galaxies:
          galaxy_kml_url = 'kml/' + galaxy.name + ".kml"
          galaxy_kml = GalaxyKMLDocument(galaxy_kml_url, galaxy.name, galaxy)
          write_file(kml_root_dir, galaxy.name + '.kml', str(galaxy_kml))
          galaxy_buttons.append(galaxy_kml.get_button_html())

        for pt in ten_best_pts:
          pointing_filename = start_time + "_" + str(pt[0]) + ".kml"
          pointing_url = 'kml/' + pointing_filename
          pointing_kml = PointingKMLDocument(pointing_url,
            "number " + str(pt[0]), start_time, str(pt[0]), pt[1], pt[2],
            str(pt[3]))
          write_file(kml_root_dir, pointing_filename, str(pointing_kml))
          pointing_buttons.append(pointing_kml.get_button_html())

      gsky_summary = make_googlesky_summary(start_time,
        "\n      ".join(galaxy_buttons), "\n      ".join(pointing_buttons),
        opts.google_map_key)
      write_file(gsky_root_dir, start_time + '_plotskypoints_summary.html',
                 gsky_summary)
      
  if opts.write_inj_data:
    if not opts.plotgalaxies:
      total_num_gals = 'NA'
    inj_data += str(combsnr) + '\t' + str(H1snr) + '\t' + str(L1snr) + '\t' + str(V1snr) + '\t'  \
                + str(injdelta_t_rms) + '\t' + str(injdelta_D_rms) + '\t' + str(Linj) + '\t' \
                + str(Linj_coarse_norm) + '\t' + str(Linj_fine_norm) + '\t' \
                + str(widecount*pi*opts.fine_resolution*opts.fine_resolution) + '\t' \
                + str(narrowcount*pi*opts.fine_resolution*opts.fine_resolution) + '\t' \
                + str(total_num_gals) + '\n' 

if opts.enable_output and opts.write_summary_plots:
  InspiralUtils.initialise(opts, __prog__, __version__)
  html_footer = ""
  fnameList = []
  tagList = []

if not opts.show_plot:
  close()

figure()
plot(asarray(asnr), asarray(adelta_t),'ro') 
annotate_plot(r"$\rho$", "$\Delta t_{rms}$ (sec)","Timing accuracy")
if opts.write_summary_plots:
  text = "Timing Accuracy"
  fname = InspiralUtils.set_figure_name(opts, "timing_accuracy")
  fname_thumb = InspiralUtils.savefig_pylal(filename=fname)
  fnameList.append(fname)
  tagList.append(text)
if not opts.show_plot:
  close()
  
figure()
plot(asarray(asnr), asarray(adelta_D),'ro') 
annotate_plot(r"$\rho$", "$\Delta D_{rms}$ ","$D_{eff}$ measure  accuracy")
if opts.write_summary_plots:
  text = "D_eff measure accuracy"
  fname = InspiralUtils.set_figure_name(opts, "D_eff_accuracy")
  fname_thumb = InspiralUtils.savefig_pylal(filename=fname)
  fnameList.append(fname)
  tagList.append(text)
if not opts.show_plot:
  close()

figure()
hist(asarray(adelta_t),bins=20)
annotate_plot("number of signals", "timing", ("timing accuracy histogram"))
if opts.write_summary_plots:
  text = "Timing Accuracy Histogram"
  fname = InspiralUtils.set_figure_name(opts, "timing_accuracy_histogram")
  fname_thumb = InspiralUtils.savefig_pylal(filename=fname)
  fnameList.append(fname)
  tagList.append(text)
if not opts.show_plot:
  close()
  
figure()
hist(asarray(adelta_D),bins=20)
annotate_plot("number of signals", "Deff measure accuracy", ("$D_{eff}$ measure accuracy histogram"))
if opts.write_summary_plots:
  text = "D_eff Accuracy Histogram"
  fname = InspiralUtils.set_figure_name(opts, "D_eff_accuracy_histogram")
  fname_thumb = InspiralUtils.savefig_pylal(filename=fname)
  fnameList.append(fname)
  tagList.append(text)
if not opts.show_plot:
  close()

figure()
plot(asarray(asnr), asarray(adelta_comb_stat),'ro') 
annotate_plot(r"$\rho$", "Confidence","L Accuracy")
if opts.write_summary_plots:
  text = "L Accuracy"
  fname = InspiralUtils.set_figure_name(opts, "L_accuracy")
  fname_thumb = InspiralUtils.savefig_pylal(filename=fname)
  fnameList.append(fname)
  tagList.append(text)
if not opts.show_plot:
  close()
  
figure()
hist(asarray(adelta_comb_stat),bins=20)
annotate_plot("normalized L on the fine grid", "number of signals in bin", ("L histogram for the fine grid"))
if opts.write_summary_plots:
  text = "L histogram (fine grid)"
  fname = InspiralUtils.set_figure_name(opts, "L_histogram_fine_grid")
  fname_thumb = InspiralUtils.savefig_pylal(filename=fname)
  fnameList.append(fname)
  tagList.append(text)
if not opts.show_plot:
  close()
  
figure()
hist(asarray(adelta_comb_stat_coarse),bins=20)
annotate_plot("normalized L on the coarse grid ", "number of signals in bin", ("L histogram for the coarse grid"))
if opts.write_summary_plots:
  text = "L histogram (coarse grid)"
  fname = InspiralUtils.set_figure_name(opts, "L_histogram_coarse_grid")
  fname_thumb = InspiralUtils.savefig_pylal(filename=fname)
  fnameList.append(fname)
  tagList.append(text)
if not opts.show_plot:
  close()
  
figure()
plot(asarray(asnr), asarray(apoints),'bo')
hlines(average(asarray(apoints)),0, max(asnr))
vlines(average(asnr),0,max(apoints))
annotate_plot(r"$\rho$", "No. of Pointings",("Pointings with radius %f degrees as a function of combined snr" % opts.fine_resolution))
if opts.write_summary_plots:
  text = "Pointings vs combined snr"
  fname = InspiralUtils.set_figure_name(opts, "pointings_vs_combined_snr")
  fname_thumb = InspiralUtils.savefig_pylal(filename=fname)
  fnameList.append(fname)
  tagList.append(text)
if not opts.show_plot:
  close()

figure()
plot(asarray(asnrH1), asarray(apoints),'bo') 
annotate_plot(r"$\rho$", "No. of Pointings",("Pointings with radius %f degrees as a function of H1 snr" % opts.fine_resolution))
if opts.write_summary_plots:
  text = "Pointings vs H1 snr"
  fname = InspiralUtils.set_figure_name(opts, "pointings_vs_H1_snr")
  fname_thumb = InspiralUtils.savefig_pylal(filename=fname)
  fnameList.append(fname)
  tagList.append(text)
if not opts.show_plot:
  close()
  
figure()
plot(asarray(asnrL1), asarray(apoints),'bo') 
annotate_plot(r"$\rho$", "No. of Pointings",("Pointings with radius %f degrees as a function of L1 snr" % opts.fine_resolution))
if opts.write_summary_plots:
  text = "Pointings vs L1 snr"
  fname = InspiralUtils.set_figure_name(opts, "pointings_vs_L1_snr")
  fname_thumb = InspiralUtils.savefig_pylal(filename=fname)
  fnameList.append(fname)
  tagList.append(text)
if not opts.show_plot:
  close()
  
figure()
plot(asarray(asnrV1), asarray(apoints),'bo') 
annotate_plot(r"$\rho$", "No. of Pointings",("Pointings with radius %f degrees as a function of V1 snr" % opts.fine_resolution))
if opts.write_summary_plots:
  text = "Pointings vs V1 snr"
  fname = InspiralUtils.set_figure_name(opts, "pointings_vs_V1_snr")
  fname_thumb = InspiralUtils.savefig_pylal(filename=fname)
  fnameList.append(fname)
  tagList.append(text)
if not opts.show_plot:
  close()

figure()
hist(asarray(apoints),bins=500)
annotate_plot("No. of Pointings","No. of signals in bin", ("Histogram of Pointings"))
if opts.write_summary_plots:
  text = "Histogram od pointings"
  fname = InspiralUtils.set_figure_name(opts, "pointings_histogram")
  fname_thumb = InspiralUtils.savefig_pylal(filename=fname)
  fnameList.append(fname)
  tagList.append(text)
if not opts.show_plot:
  close()

if opts.plotgalaxies:
  figure()
  plot(asarray(asnr), asarray(agalpoints), 'go')
  annotate_plot(r"$\rho_{\rm eff}$", "No. of Galaxies", ("Number of Galaxies"))
  if opts.write_summary_plots:
    text = "Number of galaxies"
    fname = InspiralUtils.set_figure_name(opts, "number_galaxies")
    fname_thumb = InspiralUtils.savefig_pylal(filename=fname)
    fnameList.append(fname)
    tagList.append(text)
  if not opts.show_plot:
    close()

meaninjdelta_t_rms = meaninjdelta_t_rms/ninj
meanpointings_narrow = meanpointings_narrow/ninj
meanpointings_wide = meanpointings_wide/ninj
print "Number of injections", ninj
print "Mean timing accuracy %f" % meaninjdelta_t_rms
print "Mean pointings (narrow) %f" % meanpointings_narrow
print "Mean pointings (wide) %f" % meanpointings_wide


if opts.write_summary_plots:
  html_footer += "Number of injections " + str(ninj) + "<br>"
  html_footer += "Mean timing accuracy " + str(meaninjdelta_t_rms) + "<br>"
#  html_footer += "Mean pointings (narrow) " + str(meanpointings_narrow) + "<br>"
#  html_footer += "Mean pointings (wide) " + str(meanpointings_wide) + "<br>"
  html_filename=InspiralUtils.write_html_output(opts, sys.argv[1:],\
                                                fnameList, tagList, comment=html_footer)
if opts.write_inj_data:
  if opts.output_path:
    write_file(opts.output_path, "plotskypoints_inj_data.dat", inj_data)
  else:
    write_file(os.curdir, "plotskypoints_inj_data.dat", inj_data)

#############################################################################
# Generate HTML and cache file
#if opts.enable_output:
#    html_filename = InspiralUtils.write_html_output(opts, sys.argv[1:],\
#                     fnameList, tagList, comment=html_footer)
#    InspiralUtils.write_cache_output(opts, html_filename, fnameList)

if opts.show_plot:
    show()

