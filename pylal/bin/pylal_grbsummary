#!/usr/bin/env python
"""
GRB Summary Information

Generate a set of summary information and plot for on-source and off-source
segments around a GRB trigger.  Output is placed in the current directory.

TODO: respect usertag, test injections (support nominally present)
"""
from __future__ import division

__author__ = "Nickolas Fotopoulos <nvf@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]

import glob
import itertools
import optparse
import os
import os.path as p
import re
import sys
import urlparse

from glue import lal
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils

from glue import segmentsUtils
from pylal import SnglInspiralUtils, CoincInspiralUtils

##############################################################################
# Utility functions
##############################################################################

def get_options():
    """
    Parse user input and return opts.
    """
    parser = optparse.OptionParser(usage=__doc__,
        version="%prog CVS $Id$")
    
    # always required parameters
    parser.add_option("-f", "--full-segfile",
        help="segfile containing the full analysis time (on-source + off-source)")
    parser.add_option("-o", "--on-source-segfile",
        help="segfile containing the on-source segment")
    parser.add_option("-O", "--off-source-segfile",
        help="segfile containing the off-source segments (the file will be "\
        "created if it does not exist)")
    
    # mode parameters - their presence turns on a feature
    parser.add_option("-I", "--inspiral-glob", action="append",
        dest="inspiral_globs", help="generate inspiral plots for files in "\
        "INSPIRAL_GLOB; provide multiple globs for multiple IFOs")
    parser.add_option("-T", "--thinca-glob",
        help="generate thinca/ethinca plots with files in THINCA_GLOB")
    parser.add_option("-J", "--injection-glob",
        help="generate injection plots with files in INJECTION_GLOB")
    parser.add_option("-S", "--slide-glob",
        help="generate timeslide plots with thinca files in SLIDE_GLOB")
    parser.add_option("-s", "--sire-inspiral", action="store_true",
        default=False, help="call lalapps_sire on inspiral triggers")
    parser.add_option("-C", "--coire-thinca", action="store_true",
        default=False, help="call lalapps_coire on thinca coincidences")
    parser.add_option("-n", "--figure-name", help="tag for plot output")
    
    # auxiliary parameters
    parser.add_option("-t", "--injection-window-ms", type="float",
        help="coincidence window to associate an injection with a trigger")
    parser.add_option("-c", "--cluster-time-ms", type="float",
        help="cluster-time to pass to sire and coire")
    parser.add_option("-N", "--num-slides", type="int",
        help="number of timeslides")
    parser.add_option("-u", "--usertag",
        help="the usertag, if any, specified in the ini file")
    
    (opts, args) = parser.parse_args()
    
    # error checking
    if opts.full_segfile is None:
        print >>sys.stderr, "Error: Must specify --full-segfile"
        sys.exit(2)
    if opts.on_source_segfile is None:
        print >>sys.stderr, "Error: Must specify --on-source-segfile"
        sys.exit(2)
    if opts.off_source_segfile is None:
        print >>sys.stderr, "Error: Must specify --off-source-segfile"
        sys.exit(2)
    if opts.slide_glob is not None and opts.num_slides is None:
        print >>sys.stderr, "Error: If slide-glob is specified, num-slide "\
            "must also be specified."
        sys.exit(2)
    if not opts.figure_name:
        print >>sys.stderr, "Warning: no --figure-name specified. No plots "\
            "will be written."
    
    # expand segfile paths
    opts.full_segfile = p.expanduser(opts.full_segfile)
    opts.on_source_segfile = p.expanduser(opts.on_source_segfile)
    
    # expand ~ in globs and expand globs
    if opts.inspiral_globs is not None:
        opts.inspiral_globs = [p.expanduser(g) for g in opts.inspiral_globs]
    for s in ["thinca", "injection", "slide"]:
        myglob = getattr(opts, "%s_glob" % s)
        if myglob is not None:
            myglob = p.expanduser(myglob)
            setattr(opts, "%s_glob" % s, myglob)
    
    return opts

_second_stage_regex = re.compile(r"_((\w\d)+)")
def is_second_stage(filename):
    """
    Determine if a filename comes from a second-stage INSPIRAL, THINCA, etc.
    """
    return (_second_stage_regex.search(filename) is not None)

def ifos_start_dur_from_files(files):
    """
    Extract list of IFOs, earliest start, and total duration from a list of
    files
    """
    # IFOs
    ifocombos = CoincInspiralUtils.uniq([p.split(name)[1].split('-')[0] for \
        name in files])
    ifos = CoincInspiralUtils.uniq(reduce(list.__add__,
        [["".join(ifocombo[2*i:2*i+2]) for i in range(len(ifocombo)//2)] \
        for ifocombo in ifocombos], []))
    
    # start time and duration
    time_coverage = segmentsUtils.fromfilenames(files).extent()
    start = time_coverage[0]
    dur = abs(time_coverage)
    
    return ifos, start, dur

def write_lal_cache(cache_file, filenames):
    """
    Write the list of files in filenames to the file cache_file. if we are
    passed a file object, write to it.  Else, create a new one.  The file
    format is that of a LAL cache.
    """
    if not hasattr(cache_file, 'write'):
        cache_file = open(cache_file, 'w')
    for f in filenames:
        basedir, ifos, tag, extratag, start, dur, ext = filename_to_tuple(f)
        url = urlparse.urljoin("file://localhost", f)
        cache_file.write(' '.join([ifos, 'GRB', str(start), str(dur), url]) + '\n')

def read_lal_cache(input_file):
    """
    Read a list of files from the file input_file.  If we are passed a file
    object, read from it.  Else, create a new one.
    """
    if not hasattr(input_file, 'read'):
        input_file = open(input_file, 'r')
    return [lal.CacheEntry(line).path() for line in input_file]

def make_external_call(command, show_stdout=False):
    """
    Run a program on the shell and print informative messages on failure.
    """
    stdin, out, err = os.popen3(command)
    pid, status = os.wait()
    
    if status != 0:
        print >>sys.stderr, "External call failed."
        print >>sys.stderr, "  status: %d" % status
        print >>sys.stderr, "  stdout: %s" % out.read()
        print >>sys.stderr, "  stderr: %s" % err.read()
        print >>sys.stderr, "  command: %s" % command
        #sys.exit(status)
    elif show_stdout:
        print out.read()
    stdin.close()
    out.close()
    err.close()

def filename_to_tuple(path):
    """
    Return tuple of (basedir, ifos, basetag, extratag, start, duration, extension).
    If there is no basedir, take PWD from the environment.
    start and dur are cast to ints.
    Ex: 
    """
    basedir, name = p.split(path)
    basedir = p.expanduser(basedir) or os.environ['PWD']
    
    name, ext = p.splitext(name)
    name, ext2 = p.splitext(name)
    ext += ext2  # in case we have double-extensions like .xml.gz
    
    ifos, tag, start, dur = name.split('-')
    
    index = tag.find('_')
    if index > -1:
        tag, extratag = tag[:index], tag[index:]
    else:
        extratag = ""
    
    start = int(start)
    dur = int(dur)
    
    return (basedir, ifos, tag, extratag, start, dur, ext)

def tuple_to_filename(tup):
    """
    Return reconstructed filename from a tuple of (basedir, ifos, tag,
    extratag, start, duration, extension)
    """
    return "%s/%s-%s%s-%d-%d%s" % tup

def lal_cache_name_from_files(files):
    """
    Return a good name for a lal cache containing these files.
    We assume that all files share basedir, tag, and extension.
    """
    if files is None or len(files) == 0:
        return
    basedir, ifos, tag, extratag, start, dur, ext = filename_to_tuple(files[0])
    ifolist, start, dur = ifos_start_dur_from_files(files)
    
    return tuple_to_filename((basedir, "".join(ifolist), tag, extratag, start, dur, ".input"))

##############################################################################
# Call external programs
##############################################################################

def call_sire(inspiral_globs, cluster_time_ms=None, injection_glob=None,
    injection_window_ms=None):
    """
    Call sire on each glob in inspiral_globs and return sire output filenames.
    """
    # separate by ifo and call helper function on each set
    sire_outputs = []
    for g in inspiral_globs:
        sire_outputs.append(_sire_by_ifo(g, cluster_time_ms, injection_glob,
            injection_window_ms))
    return sire_outputs

def _sire_by_ifo(inspiral_glob, cluster_time_ms=None, injection_glob=None,
    injection_window_ms=None):
    """
    Call sire on inspiral_glob and return output filename for a single IFO.
    TODO: support injection files
    """
    print "* Running lalapps_sire on each file in the glob \"%s\"" % inspiral_glob
    inspiral_files = glob.glob(inspiral_glob)
    ifolist, start, dur = ifos_start_dur_from_files(inspiral_files)
    assert len(ifolist) == 1
    ifo = ifolist[0]
    
    args = ["lalapps_sire", "--data-type=all_data"]
    if cluster_time_ms is not None:
        args.extend(["--cluster-algorithm=snr", 
                     "--cluster-time=%d" % cluster_time_ms])
    if injection_glob is not None:
        injection_files = glob.glob(injection_glob)
        assert len(injection_files) == len(thinca_files)
        args += ["--injection-window=%d" % injection_window_ms]
    else:  # no injection files
        injection_files = itertools.repeat(None)  # endless stream of None
    
    output_files = []
    for f, inj in zip(inspiral_files, injection_files):
        tempargs = ["--glob=\"%s\"" % f]
        
        # handle injections
        if inj is not None: tempargs += ["--injection-file=%s" % inj]
        
        # determine output file
        basedir, ifos, tag, extratag, start, dur, ext = filename_to_tuple(f)
        output_file = tuple_to_filename((basedir, ifos, "SIRE", extratag, start, dur, ext))
        tempargs += ["--output=%s" % output_file]
        
        # make the call
        make_external_call(" ".join(args + tempargs))
        
        # record output file
        output_files += [output_file]
    return output_files

def call_coire(thinca_glob, cluster_time_ms=None, injection_glob=None,
    injection_window_ms=None, num_slides=None):
    """
    Call coire on files in inspiral_globs and return coire output filenames.
    """
    print "* Running lalapps_coire on each file in \"%s\"" % thinca_glob
    thinca_files = glob.glob(thinca_glob)
    
    # common to all coire calls
    args = ["lalapps_coire", "--data-type=all_data"]
    if cluster_time_ms is not None:
        args += ["--coinc-stat=snrsq"]
        args += ["--cluster-time=%d" % cluster_time_ms]
    if injection_glob is not None:
        injection_files = glob.glob(injection_glob)
        assert len(injection_files) == len(thinca_files)
        args += ["--injection-window=%d" % injection_window_ms]
    else:  # no injection files
        injection_files = itertools.repeat(None)  # endless stream of None
    
    # determine per-call options
    output_files = []
    for f,inj in zip(thinca_files, injection_files):
        tempargs = ["--glob=\"%s\"" % f]
        
        # handle injections
        if inj is not None: tempargs += ["--injection-file=%s" % inj]
        
        # handle slides
        if "SLIDE" in f: tempargs += ["--num-slides=%d" % num_slides]
        
        # determine output file
        basedir, ifos, tag, extratag, start, dur, ext = filename_to_tuple(f)
        output_file = tuple_to_filename((basedir, ifos, "COIRE", extratag, start, dur, ext))
        tempargs += ["--output=%s" % output_file]
        
        # make the call
        make_external_call(" ".join(args + tempargs))
        
        # record output file
        output_files += [output_file]
    return output_files

def call_add_inspiral(thinca_cache):
    """
    Call ligolw_add_inspiral on files in thinca_globs and return the combined
    output filename.
    """
    print "* Running ligolw_add_inspiral on the input file \"%s\"" \
        % thinca_cache
    
    args = ["ligolw_add_inspiral", "--input=\"%s\"" % thinca_cache]
    
    # output file
    basedir, ifos, tag, extratag, start, dur, ext = filename_to_tuple(thinca_cache)
    output_file = tuple_to_filename((basedir, ifos, tag, extratag, start, dur, ".xml"))
    args += ["--output=%s" % output_file]
    
    make_external_call(" ".join(args))
    return output_file
    
def call_plotinspiral(inspiral_caches, vetofile=None, figure_name=None):
    """
    Based on what information is available, produce plotinspiral plots of
    interest.
    TODO: HTML markup (<a href=""><img src="" alt=""></a>), first vs second
          stage
    """
    args = ["plotinspiral", "--snr-time"]
    
    if vetofile is not None:
        args += ["--veto-file=%s" % vetofile]
    if figure_name is not None:
        args += ["--figure-name=%s" % figure_name]
    
    for g in inspiral_caches:
        print "* Running plotinspiral on the files in the glob %s" % g
        make_external_call(" ".join(args + ["--input=%s" % g]))

def call_plotthinca(thinca_file, vetofile=None, figure_name=None):
    """
    Based on what information is available, produce plotthinca plots of
    interest.
    TODO: HTML markup (<a href=""><img src="" alt=""></a>)
    """
    print "* Running plotthinca on the file \"%s\"" % thinca_file
    basedir, ifos, tag, extratag, start, dur, ext = filename_to_tuple(thinca_file)
    
    args = ["plotthinca", "--snr-snr", "--snr-dist",
        "--glob=%s" % thinca_file]
    
    for ifo in ["".join(ifos[2*i:2*i+2]) for i in range(len(ifos)//2)]:
        args += ["--%s-triggers" % ifo.lower()]
    if vetofile is not None:
        args += ["--veto-file=%s" % vetofile]
    if figure_name is not None:
        args += ["--figure-name=%s" % figure_name]
    if is_second_stage(extratag):
        args += ["--statistic=effective_snr"]
    else:
        args += ["--statistic=snr"]
    
    make_external_call(" ".join(args))

def call_plotethinca(thinca_file, vetofile=None, figure_name=None):
    """
    Based on what information is available, produce plotethinca plots of
    interest.
    """
    print "* Running plotethinca on the file \"%s\"" % thinca_file
    basedir, ifos, tag, extratag, start, dur, ext = filename_to_tuple(thinca_file)
    
    args = ["plotethinca", "--ethinca-vs-stat", "--x-value=snr",
        "--x-value=mchirp", "--x-value=eta", "--hist",
        "--glob=%s" % thinca_file]
    
    for ifo in ["".join(ifos[2*i:2*i+2]) for i in range(len(ifos)//2)]:
        args += ["--ifo=%s" % ifo]
    if vetofile is not None:
        args += ["--veto-file=%s" % vetofile]
    if figure_name is not None:
        args += ["--figure-name=%s" % figure_name]
    if is_second_stage(extratag):
        args += ["--statistic=effective_snr"]
    else:
        args += ["--statistic=snr"]
    
    make_external_call(" ".join(args))

def call_plotthincaslide(slide_file, num_slides, vetofile=None,
    figure_name=None):
    """
    Based on what information is available, produce plotthinca plots of
    interest.
    TODO: HTML markup (<a href=""><img src="" alt=""></a>)
    """
    print "* Running plotthinca on the file \"%s\"" % slide_file
    basedir, ifos, tag, extratag, start, dur, ext = filename_to_tuple(slide_file)
    
    args = ["plotthinca", "--statistic=snr", "--snr-dist", "--slide-snr",
        "--slide-dist", "--hist-slide", "--plot-slide",
        "--num-slide=%d" % num_slides, "--glob=%s" % slide_file]
    
    for ifo in ["".join(ifos[2*i:2*i+2]) for i in range(len(ifos)//2)]:
        args += ["--%s-triggers" % ifo.lower()]
    if vetofile is not None:
        args += ["--veto-file=%s" % vetofile]
    if figure_name is not None:
        args += ["--figure-name=%s" % figure_name]
    if is_second_stage(slide_file):
        args += ["--statistic=effective_snr"]
    else:
        args += ["--statistic=snr"]
    
    make_external_call(" ".join(args))

def call_timeslide_stats(slide_file):
    """
    Determine the mean number of triggers per slide per (n seconds / 180 seconds)
    """
    print "* Running pylal_grbtimeslide_stats"
    
    args = ["pylal_grbtimeslide_stats", "--glob=%s" % slide_file,
        "--fold-time=180"]
    
    make_external_call(" ".join(args), show_stdout=True)

##############################################################################
# Main
##############################################################################

if __name__ == "__main__":
    # parse input
    opts = get_options()
    
    # create an off-source segfile if necessary
    if not p.exists(opts.off_source_segfile):
        print "Writing an off-source segfile"
        full_segs = segmentsUtils.fromsegwizard(open(opts.full_segfile))
        on_source_segs = segmentsUtils.fromsegwizard(open(opts.on_source_segfile))
        off_source_segs = full_segs - on_source_segs
        segmentsUtils.tosegwizard(open(opts.off_source_segfile, 'w'),
            off_source_segs)
    
    # inspiral
    if opts.inspiral_globs is not None:
        # sire together as necessary
        if opts.sire_inspiral:
            inspiral_filegroups = call_sire(opts.inspiral_globs,
                opts.cluster_time_ms, opts.injection_glob,
                opts.injection_window_ms)
        else:
            inspiral_filegroups = [glob.glob(g) for g in opts.inspiral_globs]
        
        # write lal caches
        inspiral_caches = [lal_cache_name_from_files(g) for g in inspiral_filegroups]
        for cachefile, g in zip(inspiral_caches, inspiral_filegroups):
            write_lal_cache(cachefile, g)
        
        # plot each inspiral file
        if opts.figure_name is not None:
            call_plotinspiral(inspiral_caches, opts.on_source_segfile,
                "%s_off" % opts.figure_name)
            call_plotinspiral(inspiral_caches, opts.off_source_segfile,
                "%s_on" % opts.figure_name)
    
    # thinca
    if opts.thinca_glob is not None:
        # cluster triggers file by file; either way, create input file 
        if opts.coire_thinca:
            thinca_files = call_coire(opts.thinca_glob, opts.cluster_time_ms,
                opts.injection_glob, opts.injection_window_ms)
        else:
            thinca_files = glob.glob(opts.thinca_glob)
        
        # write lal cache
        thinca_cache = lal_cache_name_from_files(thinca_files)
        write_lal_cache(thinca_cache, thinca_files)
        
        # add coincs, handling inspid business; overwrite input file
        new_thinca_file = call_add_inspiral(thinca_cache)
        
        # plot
        if opts.figure_name is not None:
            call_plotthinca(new_thinca_file, opts.on_source_segfile,
                "%s_off" % opts.figure_name)
            call_plotthinca(new_thinca_file, opts.off_source_segfile,
                "%s_on" % opts.figure_name)
            call_plotethinca(new_thinca_file, opts.on_source_segfile,
                "%s_off" % opts.figure_name)
            call_plotethinca(new_thinca_file, opts.off_source_segfile,
                "%s_on" % opts.figure_name)
    
    # thinca slide
    if opts.slide_glob is not None:
        # cluster triggers file by file; either way, create input file
        if opts.coire_thinca:
            slide_files = call_coire(opts.slide_glob, opts.cluster_time_ms,
                opts.injection_glob, opts.injection_window_ms,
                opts.num_slides)
        else:
            slide_files = glob.glob(slide_glob)
        
        # write lal cache
        slide_cache = lal_cache_name_from_files(slide_files)
        write_lal_cache(slide_cache, slide_files)
        
        # add coincs, handling inspid business; overwrite input file
        new_slide_file = call_add_inspiral(slide_cache)
        
        # first, a summary
        call_timeslide_stats(new_slide_file)
        
        # plot
        if opts.figure_name is not None:
            call_plotthincaslide(new_slide_file, opts.num_slides,
                opts.on_source_segfile, "%s_off" % opts.figure_name)
            call_plotthincaslide(new_slide_file, opts.num_slides,
                opts.off_source_segfile, "%s_on" % opts.figure_name)