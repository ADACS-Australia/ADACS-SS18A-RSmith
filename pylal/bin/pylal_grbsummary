#!/usr/bin/env python
"""
GRB Summary Information

Generate a set of summary information and plot for on-source and off-source
segments around a GRB trigger.  Output is placed in the current directory.

TODO: respect usertag, test injections (support nominally present)
"""
from __future__ import division

__author__ = "Nickolas Fotopoulos <nvf@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]

import glob
import itertools
import optparse
import os
import os.path as p
import re
import sys
import urlparse

from glue import lal
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils

from glue import segmentsUtils
from pylal import SnglInspiralUtils, CoincInspiralUtils

##############################################################################
# Utility functions
##############################################################################

def get_options():
    """
    Parse user input and return opts.
    """
    parser = optparse.OptionParser(usage=__doc__, version="%prog CVS $Id$")
    
    # always required parameters
    parser.add_option("-f", "--full-segfile",
        help="segfile containing the full analysis time (on-source + off-source)")
    parser.add_option("-o", "--on-source-segfile",
        help="segfile containing the on-source segment")
    parser.add_option("-O", "--off-source-segfile",
        help="segfile containing the off-source segments (the file will be "\
        "created if it does not exist)")
    
    # mode parameters - their presence turns on a feature
    parser.add_option("-I", "--inspiral-glob", action="append",
        dest="inspiral_globs", help="generate inspiral plots for files in "\
        "INSPIRAL_GLOB; provide multiple globs for multiple IFOs")
    parser.add_option("-T", "--thinca-glob",
        help="generate thinca/ethinca plots with files in THINCA_GLOB")
    parser.add_option("-J", "--injection-glob",
        help="generate injection plots with files in INJECTION_GLOB")
    parser.add_option("-S", "--slide-glob",
        help="generate timeslide plots with thinca files in SLIDE_GLOB")
    parser.add_option("-s", "--sire-inspiral", action="store_true",
        default=False, help="call lalapps_sire on inspiral triggers")
    parser.add_option("-C", "--coire-thinca", action="store_true",
        default=False, help="call lalapps_coire on thinca coincidences")
    
    # auxiliary parameters
    parser.add_option("-t", "--injection-window-ms", type="float",
        help="coincidence window to associate an injection with a trigger")
    parser.add_option("-c", "--cluster-time-ms", type="float",
        help="cluster-time to pass to sire and coire")
    parser.add_option("-N", "--num-slides", type="int",
        help="number of timeslides")
    parser.add_option("-u", "--usertag",
        help="the usertag, if any, specified in the ini file")
    parser.add_option("-n", "--figure-name", help="tag for plot output")
    
    (opts, args) = parser.parse_args()
    
    # error checking
    if opts.full_segfile is None:
        print >>sys.stderr, "Error: Must specify --full-segfile"
        sys.exit(2)
    if opts.on_source_segfile is None:
        print >>sys.stderr, "Error: Must specify --on-source-segfile"
        sys.exit(2)
    if opts.off_source_segfile is None:
        print >>sys.stderr, "Error: Must specify --off-source-segfile"
        sys.exit(2)
    if opts.slide_glob is not None and opts.num_slides is None:
        print >>sys.stderr, "Error: If slide-glob is specified, num-slide "\
            "must also be specified."
        sys.exit(2)
    if not opts.figure_name:
        print >>sys.stderr, "Warning: no --figure-name specified. No plots "\
            "will be written."
    
    # expand segfile paths
    opts.full_segfile = p.expanduser(opts.full_segfile)
    opts.on_source_segfile = p.expanduser(opts.on_source_segfile)
    
    # expand ~ in globs
    if opts.inspiral_globs is not None:
        opts.inspiral_globs = [p.expanduser(g) for g in opts.inspiral_globs]
        opts.inspiral_files = [glob.glob(g) for g in opts.inspiral_globs]
    for s in ["thinca", "injection", "slide"]:
        myglob = getattr(opts, "%s_glob" % s)
        if myglob is not None:
            myglob = p.expanduser(myglob)
            setattr(opts, "%s_glob" % s, myglob)
            setattr(opts, "%s_files" % s, glob.glob(myglob))
        else:
            setattr(opts, "%s_files" % s, None)
    
    return opts

_second_stage_regex = re.compile(r"_((\w\d)+)-")
def is_second_stage(filename):
    """
    Determine if a filename comes from a second-stage INSPIRAL, THINCA, etc.
    """
    return (_second_stage_regex.search(filename) is not None)

def expand_globs(exps):
    """
    Expand each glob in a list of glob expressions and join the results.
    """
    return reduce(list.__add__, [glob.glob(e) for e in exps])

def ifos_start_dur_from_files(files):
    """
    Extract list of IFOs, earliest start, and total duration from a list of
    files
    """
    # IFOs
    ifocombos = CoincInspiralUtils.uniq([p.split(name)[1].split('-')[0] for \
        name in files])
    ifos = CoincInspiralUtils.uniq(reduce(list.__add__,
        [["".join(ifocombo[2*i:2*i+2]) for i in range(len(ifocombo)//2)] \
        for ifocombo in ifocombos], []))
    
    # start time and duration
    time_coverage = segmentsUtils.fromfilenames(files).extent()
    start = time_coverage[0]
    dur = abs(time_coverage)
    
    return ifos, start, dur

def write_lal_cache(input_file, filenames):
    """
    Write the list of files in filenames to the file input_file. if we are
    passed a file object, write to it.  Else, create a new one.  The file
    format is that of a LAL cache.
    """
    if not hasattr(input_file, 'write'):
        input_file = open(input_file, 'w')
    for f in filenames:
        ifos, start, dur = ifos_start_dur_from_files([f])
        url = urlparse.urljoin("file://localhost", f)
        input_file.write(' '.join(["".join(ifos), 'GRB', str(start), str(dur), url]) + '\n')

def read_lal_cache(input_file):
    """
    Read a list of files from the file input_file.  If we are passed a file
    object, read from it.  Else, create a new one.
    """
    if not hasattr(input_file, 'read'):
        input_file = open(input_file, 'r')
    return [lal.CacheEntry(line).path() for line in input_file]

def make_external_call(command, show_stdout=False):
    """
    Run a program on the shell and print informative messages on failure.
    """
    stdin, out, err = os.popen3(command)
    pid, status = os.wait()
    
    if status != 0:
        print >>sys.stderr, "External call failed."
        print >>sys.stderr, "  status: %d" % status
        print >>sys.stderr, "  stdout: %s" % out.read()
        print >>sys.stderr, "  stderr: %s" % err.read()
        print >>sys.stderr, "  command: %s" % command
        #sys.exit(status)
    elif show_stdout:
        print out.read()

def basedir_from_file(filename):
    """
    Determine basedir from file if possible.  Else, take PWD from the
    environment.
    """
    return p.abspath(p.split(filename)[0]) or os.environ['PWD']

##############################################################################
# Call external programs
##############################################################################

def call_sire(inspiral_globs, cluster_time_ms=None, injection_files=None):
    """
    Call sire on each glob in inspiral_globs and return sire output filenames.
    """
    # separate by ifo and call helper function on each set
    sire_outputs = []
    for g in inspiral_globs:
        sire_outputs.append(_sire_by_ifo(g, cluster_time_ms, injection_files))
    return sire_outputs

def _sire_by_ifo(inspiral_glob, cluster_time_ms=None, injection_files=None):
    """
    Call sire on inspiral_glob and return output filename for a single IFO.
    TODO: support injection files
    """
    print "* Running lalapps_sire on the glob \"%s\"" % inspiral_glob
    inspiral_files = glob.glob(inspiral_glob)
    
    ifos, start, dur = ifos_start_dur_from_files(inspiral_files)
    assert len(ifos) == 1
    ifo = ifos[0]
    
    args = ["lalapps_sire", "--data-type=all_data"]
    if cluster_time_ms is not None:
        args.extend(["--cluster-algorithm=snr", 
                     "--cluster-time=%d" % cluster_time_ms])
    args += ["--glob=\"%s\"" % inspiral_glob]
    
    # output file; TODO: respect usertag
    tag = "SIRE"
    if is_second_stage(inspiral_files[0]): tag += "2"
    basedir = basedir_from_file(inspiral_files[0])
    output_file = "%s/%s-%s-%d-%d.xml" % (basedir, ifo, tag, start, dur)
    args += ["--output=%s" % output_file]
    
    make_external_call(" ".join(args))
    return output_file

def call_coire(thinca_glob, cluster_time_ms=None, injection_files=None,
    injection_window_ms=None, num_slides=None):
    """
    Call sire on files in inspiral_globs and return sire output filenames.
    """
    print "* Running lalapps_coire on each file in \"%s\"" % thinca_glob
    thinca_files = glob.glob(thinca_glob)
    ifos, start, dur = ifos_start_dur_from_files(thinca_files)
    
    # common to all coire calls
    args = ["lalapps_coire", "--data-type=all_data"]
    if cluster_time_ms is not None:
        args += ["--coinc-stat=snrsq"]
        args += ["--cluster-time=%d" % cluster_time_ms]
    if injection_files is not None:
        assert len(injection_files) == len(thinca_files)
        args += ["--injection-window=%d" % injection_window_ms]
    else:  # no injection files
        injection_files = itertools.repeat(None)  # endless stream of None
    
    # determine per-call options
    output_files = []
    for f,inj in zip(thinca_files, injection_files):
        tempargs = ["--glob=\"%s\"" % f]
        
        # handle injections
        if inj is not None:
            tempargs += ["--injection-file=%s" % inj]
        
        # determine output file
        tag = "COIRE"
        if is_second_stage(f): tag += "_" + "".join(ifos)
        if "SLIDE" in f:
            tag += "_SLIDE"
            tempargs += ["--num-slides=%d" % num_slides]

        basedir = basedir_from_file(f)
        ifos, start, dur = ifos_start_dur_from_files([f])

        output_file = "%s/%s-%s-%d-%d.xml" % (basedir, "".join(ifos), tag, start, dur)
        tempargs += ["--output=%s" % output_file]
        
        # make the call
        make_external_call(" ".join(args + tempargs))
        
        # record output file
        output_files += [output_file]
    return output_files

def call_add_inspiral(thinca_cache):
    """
    Call ligolw_add_inspiral on files in thinca_globs and return the combined
    output filename.
    """
    print "* Running ligolw_add_inspiral on the input file \"%s\"" \
        % thinca_cache
    thinca_files = read_lal_cache(thinca_cache)
    ifos, start, dur = ifos_start_dur_from_files(thinca_files)
    
    args = ["ligolw_add_inspiral", "--input=\"%s\"" % thinca_cache]
    
    # output file; TODO: respect usertag
    basedir = basedir_from_file(thinca_files[0])
    if "COIRE" in thinca_files[0]:
        tag = "COIRE"
    else:
        tag = "THINCA"
    if "SLIDE" in thinca_files[0]:
        tag += "_SLIDE"
    if is_second_stage(thinca_files[0]): tag += "_" + "".join(ifos)
    output_file = "%s/%s-%s-%d-%d.xml" % (basedir, "".join(ifos), tag, start, dur)
    args += ["--output=%s" % output_file]
    
    make_external_call(" ".join(args))
    return output_file
    
def call_plotinspiral(inspiral_globs, vetofile=None, figure_name=None,
    ):
    """
    Based on what information is available, produce plotinspiral plots of
    interest.
    TODO: HTML markup (<a href=""><img src="" alt=""></a>), first vs second
          stage
    """
    args = ["plotinspiral", "--snr-time"]
    
    if vetofile is not None:
        args += ["--veto-file=%s" % vetofile]
    if figure_name is not None:
        args += ["--figure-name=%s" % figure_name]
    
    for g in inspiral_globs:
        print "* Running plotinspiral on the files in the glob %s" % g
        make_external_call(" ".join(args + ["--glob=%s" % g]))

def call_plotthinca(thinca_cache, vetofile=None, figure_name=None):
    """
    Based on what information is available, produce plotinspiral plots of
    interest.
    TODO: HTML markup (<a href=""><img src="" alt=""></a>)
    """
    print "* Running plotthinca on the input file \"%s\"" % thinca_cache
    thinca_files = read_lal_cache(thinca_cache)
    ifos, start, dur = ifos_start_dur_from_files(thinca_files)
    
    args = ["plotthinca", "--snr-snr", "--snr-dist",
        "--input=%s" % thinca_cache]
    
    for ifo in ifos:
        args += ["--%s-triggers" % ifo.lower()]
    if vetofile is not None:
        args += ["--veto-file=%s" % vetofile]
    if figure_name is not None:
        args += ["--figure-name=%s" % figure_name]
    if is_second_stage(thinca_files[0]):
        args += ["--statistic=effective_snr"]
    else:
        args += ["--statistic=snr"]
    
    make_external_call(" ".join(args))

def call_plotthincaslide(slide_cache, num_slides, vetofile=None,
    figure_name=None):
    """
    Based on what information is available, produce plotinspiral plots of
    interest.
    TODO: HTML markup (<a href=""><img src="" alt=""></a>)
    """
    print "* Running plotthinca on the input file \"%s\"" % slide_cache
    slide_files = read_lal_cache(slide_cache)
    ifos, start, dur = ifos_start_dur_from_files(slide_files)
    
    args = ["plotthinca", "--statistic=snr", "--snr-dist", "--slide-snr",
        "--slide-dist", "--hist-slide", "--plot-slide",
        "--num-slide=%d" % num_slides, "--input=%s" % slide_cache]
    
    for ifo in ifos:
        args += ["--%s-triggers" % ifo.lower()]
    if vetofile is not None:
        args += ["--veto-file=%s" % vetofile]
    if figure_name is not None:
        args += ["--figure-name=%s" % figure_name]
    if is_second_stage(slide_files[0]):
        args += ["--statistic=effective_snr"]
    else:
        args += ["--statistic=snr"]
    
    make_external_call(" ".join(args))

def call_timeslide_stats(slide_cache):
    """
    Determine the mean number of triggers per slide per (n seconds / 180 seconds)
    """
    print "* Running pylal_grbtimeslide_stats"
    
    args = ["pylal_grbtimeslide_stats", "--input=%s" % slide_cache,
        "--fold-time=180"]
    
    make_external_call(" ".join(args), show_stdout=True)

##############################################################################
# Main
##############################################################################

if __name__ == "__main__":
    # parse input
    opts = get_options()
    
    # create an off-source segfile
    if not p.exists(opts.off_source_segfile):
        print "Writing an off-source segfile"
        full_segs = segmentsUtils.fromsegwizard(open(opts.full_segfile))
        on_source_segs = segmentsUtils.fromsegwizard(open(opts.on_source_segfile))
        off_source_segs = full_segs - on_source_segs
        segmentsUtils.tosegwizard(open(opts.off_source_segfile, 'w'),
            off_source_segs)
    
    # inspiral
    if opts.inspiral_globs is not None:
        # sire as necessary
        if opts.sire_inspiral:
            opts.inspiral_globs = call_sire(opts.inspiral_globs, opts.cluster_time_ms, opts.injection_files)
            opts.inspiral_files = expand_globs(opts.inspiral_globs)
        
        # plot each inspiral file
        if opts.figure_name is not None:
            call_plotinspiral(opts.inspiral_globs, opts.on_source_segfile,
                "%s_off" % opts.figure_name)
            call_plotinspiral(opts.inspiral_globs, opts.off_source_segfile,
                "%s_on" % opts.figure_name)
    
    # thinca
    if opts.thinca_glob is not None:
        ifos, start, dur = ifos_start_dur_from_files(opts.thinca_files)
        basedir = basedir_from_file(opts.thinca_files[0])
        
        # cluster triggers file by file; either way, create input file 
        if opts.coire_thinca:
            tag = "COIRE"
            thinca_files = call_coire(opts.thinca_glob, opts.cluster_time_ms,
                opts.injection_files, opts.injection_window_ms, opts.num_slides)
        else:
            tag = "THINCA"
            thinca_files = opts.thinca_files
        if is_second_stage(thinca_files[0]): tag += "_" + "".join(ifos)
        thinca_cache = "%s/%s-%s-%d-%d.input" % (basedir, "".join(ifos), tag, start, dur)
        write_lal_cache(thinca_cache, thinca_files)
        
        # add coincs, handling inspid business; overwrite input file
        new_thinca_file = call_add_inspiral(thinca_cache)
        write_lal_cache(thinca_cache, [new_thinca_file])
        
        # plot
        if opts.figure_name is not None:
            call_plotthinca(thinca_cache, opts.on_source_segfile,
                "%s_off" % opts.figure_name)
            call_plotthinca(thinca_cache, opts.off_source_segfile,
                "%s_on" % opts.figure_name)
    
    # thinca slide
    if opts.slide_glob is not None:
        ifos, start, dur = ifos_start_dur_from_files(opts.slide_files)
        basedir = basedir_from_file(opts.slide_files[0])
        
        # cluster triggers file by file; either way, create input file
        if opts.coire_thinca:
            tag = "COIRE_SLIDE"
            slide_files = call_coire(opts.slide_glob, opts.cluster_time_ms,
                opts.injection_files, opts.injection_window_ms, opts.num_slides)
        else:
            tag = "THINCA_SLIDE"
            slide_files = opts.slide_files
        if is_second_stage(slide_files[0]): tag += "_" + "".join(ifos)
        slide_cache = "%s/%s-%s-%d-%d.input" % (basedir, "".join(ifos), tag, start, dur)
        write_lal_cache(slide_cache, slide_files)
        
        # add coincs, handling inspid business; overwrite input file
        new_slide_file = call_add_inspiral(slide_cache)
        write_lal_cache(slide_cache, [new_slide_file])
        
        # first, a summary
        call_timeslide_stats(slide_cache)
        
        # plot
        if opts.figure_name is not None:
            call_plotthincaslide(slide_cache, opts.num_slides,
                opts.on_source_segfile, "%s_off" % opts.figure_name)
            call_plotthincaslide(slide_cache, opts.num_slides,
                opts.off_source_segfile, "%s_on" % opts.figure_name)