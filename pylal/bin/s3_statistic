#!/usr/bin/python

import sys
import os
from optparse import *
import re
import exceptions
import glob
from types import *
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils

from pylab import *
from pylal import SnglInspiralUtils
from pylal import SimInspiralUtils
from pylal import CoincInspiralUtils

from pylal import viz
from numarray.random_array import *

##############################################################################
# helper functions
def square_axis():
  tmpv = asarray(axis())
  xmax = max([tmpv[1], tmpv[3]])
  xmin = min([tmpv[0], tmpv[2]])
  axis([xmin, xmax, xmin, xmax])

##############################################################################
def plotstat(coincInspiral, symbols, description = None, plot_type = 'linear'):
  """
  function to plot the s3 statistic for an input coincInspiral list
  @param coincInspiral: list of coincInspirals
  @param symbols: list of the 3 symbols to use when making the plots
  @param description: text describing plots to be added to legend
  """
  
  # h1-h2
  h1h2_coinc = coincInspiral.coinctype(['H1','H2'])
  h1_val = h1h2_coinc.getsngls('H1').get_column(opts.statistic)
  h2_val = h1h2_coinc.getsngls('H2').get_column(opts.statistic)
 
  if description:
    my_label = description + ': H1-H2'
  else:
    my_label = 'H1-H2'
  if len(h1_val):
    if plot_type == 'log':
      loglog(h1_val, h2_val, symbols[0], markersize=12, markeredgewidth=1,\
        markerfacecolor='None', label=my_label)
    else:
      plot(h1_val, h2_val, symbols[0], markersize=12, markeredgewidth=1,\
        markerfacecolor='None', label=my_label)
     

  # h1-l1
  h1l1_coinc = coincInspiral.coinctype(['H1','L1'])
  h1_val = h1l1_coinc.getsngls('H1').get_column(opts.statistic)
  l1_val = h1l1_coinc.getsngls('L1').get_column(opts.statistic)
  
  if description:
    my_label = description + ': H1-L1'
  else:
    my_label = 'H1-L1'
  if len(h1_val):
    if plot_type == 'log':
      loglog(h1_val, l1_val, symbols[1], markersize=12, markeredgewidth=1,\
          markerfacecolor='None', label=my_label)
    else:
      plot(h1_val, l1_val, symbols[1], markersize=12, markeredgewidth=1,\
          markerfacecolor='None', label=my_label)

  # h2-l1
  h2l1_coinc = coincInspiral.coinctype(['H2','L1'])
  h2_val = h2l1_coinc.getsngls('H2').get_column(opts.statistic)
  l1_val = h2l1_coinc.getsngls('L1').get_column(opts.statistic)
  
  if description:
    my_label = description + ': H2-L1'
  else:
    my_label = 'H2-L1'
  if len(h2_val):
    if plot_type == 'log':
      loglog(h2_val, l1_val, symbols[2], markersize=12, markeredgewidth=1,\
          markerfacecolor='None', label=my_label)
    else:
      plot(h2_val, l1_val, symbols[2], markersize=12, markeredgewidth=1,\
          markerfacecolor='None', label=my_label)


  # h1-h2-l1
  h1h2l1_coinc = coincInspiral.coinctype(['H1','H2','L1'])
  h1_val = h1h2l1_coinc.getsngls('H1').get_column(opts.statistic)
  h2_val = h1h2l1_coinc.getsngls('H2').get_column(opts.statistic)
  l1_val = h1h2l1_coinc.getsngls('L1').get_column(opts.statistic)
  if opts.statistic == 'effective_snr':
    h2_l1_val = sqrt(h2_val**2 + l1_val**2)
  else:
    h2_l1_val = h2_val + l1_val

  if description:
    my_label = description + ': H1-H2-L1'
  else:
    my_label = 'H1-H2-L1'
  if len(h1_val):
    if plot_type == 'log':
      loglog(h1_val, h2_l1_val, symbols[3], markersize=12, \
          markeredgewidth=1, label=my_label)
    else:
      plot(h1_val, h2_l1_val, symbols[3], markersize=12, \
          markeredgewidth=1, label=my_label)

  xlabel('H1/H2 ' + opts.statistic.replace("_"," "), size='x-large')
  ylabel('H2/L1 ' + opts.statistic.replace("_"," "), size='x-large')



##############################################################################
usage = """
usage: %prog [options] 

Script to get S3 result

The code expects at least one of:

a)  A zero-lag list of files
b)  A time-slide list of files
c)  An injection list of files

The code keeps all H1-H2, H1-L1 and H1-H2-L1 coincidences, discarding H2-L1.
It then clusters the triggers over the specified interval.  For slides, the
triggers are clustered per slide and then reassembled to one list.

It generates the following plots

1)  A plot of the statistic for H1 vs other, where other is H2, L1 or H2-L1
   - for slides only
   - for zero-lag only
   - for injections only
   - for slide + injections
   - for slides + zero-lag
   - for zero-lag + injections

2)  A distribution of the events as a function of the statistic
   - for slides only
   - for slides + zero-lag

3)  An efficiency plot, as a function of the combined statistic.

4)  An efficiency plot, for all found injections louder than the loudest 
    event.  This can be plotted against any column in the sim_inspiral table
    by specifying --eff-vs-col for the desired columns.  
"""

parser = OptionParser( usage )
parser.add_option("-v","--version",action="store_true",default=False,\
    help="display version information " )
    
parser.add_option("-z","--zero-glob",action="store",type="string",\
    default=None, \
    metavar=" ZERO_GLOB",help="GLOB of zero-lag thinca files to read" )
    
parser.add_option("-s","--slide-glob",action="store",type="string",\
    default=None, \
    metavar=" SLIDE_GLOB",help="GLOB of thinca slide files to read" )
    
parser.add_option("-i","--inj-glob",action="store",type="string",\
    default=None, metavar=" INJ_GLOB", \
    help="GLOB of injection thinca files to read" )

parser.add_option("-x","--missed-glob",action="store",type="string",\
    default=None, metavar=" MISSED_GLOB", \
    help="GLOB of missed injection files to read" )

parser.add_option("-A","--allow-h2-l1",action="store_true",default=False,\
    help="keep H2-L1 triggers not seen in H1")

parser.add_option("-W","--cluster-window",action="store",type="int",default=0,\
    metavar=" SEC", help="length of time over which to cluster triggers" )
    
parser.add_option("-F","--figure-name",action="store",type="string",\
    default=None, metavar=" FNAME",\
    help="generate png figures with name FNAME-fig.png" )

parser.add_option("-L","--loudest-events",action="store",type="int", \
    default=0,metavar="NUM", help="print details of NUM loudest events" )

parser.add_option("-l","--loudest-file",action="store",type="string", \
    default=0,metavar="FILE", help="print details of loudest events to FILE" )

parser.add_option("-S","--show-plot",action="store_true",default=False,\
    help="display the figures on the terminal" )

parser.add_option("-a","--slide-stat",action="store_true",default=False,\
    help="plot the H1 stat vs other for time slides" )
    
parser.add_option("-b","--slide-zero-stat",action="store_true",default=False,\
    help="plot the H1 stat vs other for time slides + zero lag" )
   
parser.add_option("-c","--zero-stat",action="store_true",default=False,\
    help="plot the H1 stat vs other for zero lag" )

parser.add_option("-d","--inj-stat",action="store_true",default=False,\
    help="plot the H1 stat vs other for injections" )

parser.add_option("-e","--slide-inj-stat",action="store_true",default=False,\
    help="plot the H1 stat vs other for time slides + injections" )

parser.add_option("-f","--zero-inj-stat",action="store_true",default=False,\
    help="plot the H1 stat vs other for zero lag + injections" )

parser.add_option("-I","--inj-plot-type",action="store",default="linear",\
    help="plot on either a log or linear scale" )

parser.add_option("-m","--plot-min",action="store",default=None,\
    type="float",help="minimum value to put on plot" )

parser.add_option("-M","--plot-max",action="store",default=None,\
    type="float",help="maximum value to put on plot" )
    
parser.add_option("-g","--slide-dist",action="store_true",default=False,\
    help="plot the distribution of slide triggers" )
    
parser.add_option("-j","--slide-zero-dist",action="store_true",default=False,\
    help="plot the distribution of slide triggers + zero lag" )

parser.add_option("-p","--slide-poisson-dist",action="store_true",
    default=False, 
    help="plot the distribution with Poisson distributed error bars" )

parser.add_option("-D","--distribution",action="store",type="string",
    default="cumulative",
    help="plot either 'cumulative' or 'non-cumulative' distributions" )

parser.add_option("-q","--hist-slide-value",action="append",
    type="float",dest="stat_values",metavar=" VAL",
    help="make histogram of slide events at VAL (add to list)")

parser.add_option("-r","--plot-cum-loudest",action="store_true",
    default=False,
    help="plot the cumulative distribution of slide loudest events")

parser.add_option("-t","--plot-pdf-loudest",action="store_true",
    default=False,
    help="plot the non-cumulative distribution of slide loudest events")

parser.add_option("-k","--efficiency",action="store_true",default=False,\
    help="plot efficiency as a function of the statistic")

parser.add_option("-w","--pdf-efficiency",action="store_true",default=False,\
    help="plot efficiency derivative as a function of the statistic")

parser.add_option("-T","--statistic",action="store",default="effective_snr",\
    type="string",\
    help="choice of statistic used in making plots, valid arguments are: "
         "snr, snr_over_chi, effective_snr")

parser.add_option("-K","--eff-vs-col",action="append",
    type="string",dest="eff_cols",metavar=" COL",
    help="add COL to list of cols for which to plot efficiency")
 
parser.add_option("-P","--eff-plot-type",action="store",default="linear",\
    type="string", metavar=" PLOT_TYPE",\
    help="make either log or linear efficiency plots")

parser.add_option("-N","--mass-window-boundary",action="append",\
    type="float",dest="mass_windows",metavar="BDRY",\
    help="mass value, used to split the injections")
    
parser.add_option("-Z","--num-slides",action="store",type="int",default=0,\
    metavar=" NUM_SLIDES",help="number of time slides performed" )
  
parser.add_option("-n","--num-bins",action="store",type="int",default=10,\
    metavar=" NUM_BINS", \
    help="number of bins for plotting statistic (default 10)" )

(opts,args) = parser.parse_args()

#######################################################################
#
# Check the validity of the arguments
#
#######################################################################


# if --version flagged
if opts.version:
  sys.exit(0)
  
# if doing any zero lag plots:  
if (opts.slide_zero_stat or opts.zero_inj_stat or opts.slide_zero_dist) \
    and not opts.zero_glob:
  print >>sys.stderr, "Must specify a ZERO_GLOB of files to read"
  print >>sys.stderr, "Enter 's3_statistic --help' for usage"
  sys.exit(1)

# if doing any slide plots:
if (opts.slide_stat or opts.slide_zero_stat or opts.slide_inj_stat \
    or opts.slide_dist or opts.slide_zero_dist) and not opts.slide_glob:
  print >>sys.stderr, "Must specify a SLIDE_GLOB of files to read"
  print >>sys.stderr, "Enter 's3_statistic --help' for usage"
  sys.exit(1)

# if doing any slide plots:
if opts.slide_glob and not opts.num_slides:
  print >>sys.stderr, "--num-slides must be specified if"
  print >>sys.stderr, "--slide-glob is"
  sys.exit(1)

# if doing any injection plots:
if (opts.slide_inj_stat or opts.zero_inj_stat or opts.efficiency) \
    and not opts.inj_glob:
  print >>sys.stderr, "Must specify an INJ_GLOB of files to read"
  print >>sys.stderr, "Enter 's3_statistic --help' for usage"
  sys.exit(1)

# if doing any missed injection plots:
if (opts.efficiency or opts.eff_cols) and not opts.missed_glob:
  print >>sys.stderr, "Must specify a MISSED_GLOB of files to read"
  print >>sys.stderr, "Enter 's3_statistic --help' for usage"
  sys.exit(1)

#######################################################################
#
# Read in the triggers: zero, slide, inj, missed
#
#######################################################################

statistic = CoincInspiralUtils.coincStatistic(opts.statistic)


###################################
# glob the list of files to read in
if opts.zero_glob:  
  zeroFiles = glob.glob(opts.zero_glob)

  if not zeroFiles:
    print >>sys.stderr, "The glob for " + opts.zero_glob + " returned no files"
    sys.exit(1)

  inspTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(zeroFiles)
  coincTriggers = CoincInspiralUtils.coincInspiralTable(inspTriggers,statistic)
  
  if not opts.allow_h2_l1:
    # coincs MUST have H1 trigger:
    coincTriggers = coincTriggers.coincinclude(["H1"])
  
  # cluster them
  if opts.cluster_window:
    coincTriggers = coincTriggers.cluster(opts.cluster_window)

  # extract the statistic from the coincTriggers
  coincTriggers.sort()
  coincStat = coincTriggers.getstat()

############################################
# glob the list of slide triggers to read in
if opts.slide_glob:
  slideFiles = glob.glob(opts.slide_glob)
  slideMax = 0

  slideStat = []
  slideTriggers = CoincInspiralUtils.coincInspiralTable(stat = statistic)

  if not slideFiles:
    print >>sys.stderr, "The glob for " + opts.slide_glob + " returned no files"
    sys.exit(1)

  inspSlide = SnglInspiralUtils.ReadSnglInspiralFromFiles(slideFiles)
  
  slide_num = range(1 , opts.num_slides + 1)
  slide_num.extend(range(-opts.num_slides, 0))
  slideLoudest = []
  for slide in slide_num:
    this_slide = {}
    this_slide["slide_num"] = slide
    this_slide["sngl_trigs"] = inspSlide.getslide(slide)

    # make coincs
    this_slide["coinc_trigs"] = \
        CoincInspiralUtils.coincInspiralTable(this_slide["sngl_trigs"],\
        statistic )
   
    if not opts.allow_h2_l1:
      # coincs MUST include an H1 trigger
      this_slide["coinc_trigs"] = \
          this_slide["coinc_trigs"].coincinclude(["H1"])

    # cluster triggers
    if opts.cluster_window:
      this_slide["coinc_trigs"] = \
        this_slide["coinc_trigs"].cluster(opts.cluster_window)  
    
    # extract the statistic from the this_slide
    thisSlideStat = this_slide["coinc_trigs"].getstat()
    slideStat.append( thisSlideStat )
    if len(thisSlideStat):
      slideLoudest.append(max(thisSlideStat))
    else:
      slideLoudest.append(0)


    # add slide to list
    slideTriggers.extend(this_slide["coinc_trigs"])

  slideLoudest = asarray(slideLoudest)
  slideMax = max(slideLoudest)

#######################################
# glob the list of inj files to read in
if opts.inj_glob:  
  injFiles = glob.glob(opts.inj_glob)

  if not injFiles:
    print >>sys.stderr, "The glob for " + opts.inj_glob + " returned no files"
    sys.exit(1)

  injTriggers = CoincInspiralUtils.coincInspiralTable()
  for file in injFiles:
    thisInjSngl = SnglInspiralUtils.ReadSnglInspiralFromFiles([file])
    thisInj = CoincInspiralUtils.coincInspiralTable(thisInjSngl, statistic)

    if opts.eff_cols:
      thisSim = SimInspiralUtils.ReadSimInspiralFromFiles([file])
      if len(thisInj) != len(thisSim):
        print >>sys.stderr, "Different number of coincs and injections in " + \
          file
        sys.exit(1)
      else:
        for coinc in thisInj:
          coinc.sim = thisSim.pop(0)
   
    if not opts.allow_h2_l1:
      # coincs MUST include an H1 trigger
      thisInj = thisInj.coincinclude(["H1"])
    injTriggers.extend(thisInj)

  # extract the statistic from the injTriggers
  injTriggers.sort()

  injStat = injTriggers.getstat()

##########################################
# glob the list of missed files to read in
if opts.missed_glob:  
  missedFiles = glob.glob(opts.missed_glob)

  if not missedFiles:
    print >>sys.stderr, "The glob for " + opts.missed_glob + " was empty"
    sys.exit(1)

  missedInj = SimInspiralUtils.ReadSimInspiralFromFiles(missedFiles)


#######################################################################
#
# Print details of loudest events
#
#######################################################################

if opts.zero_glob and len(coincStat):
  loudestEvent = coincStat[0]
else:
  loudestEvent = 0

if opts.loudest_events:
  if opts.loudest_events > len(coincTriggers):
     opts.loudest_events = len(coincTriggers)
     
  if opts.loudest_file:
    loud_file = open( opts.loudest_file , "w")
     
    loud_file.write( "Loudest Events\n")
    loud_file.write( "Time\t Stat\t  H1 snr\t H1 effective snr\t H2 snr\t" +\
        "H2 effective snr\t" + "L1 snr\t L1 effective snr\n")
  else:
    print "Loudest Events"
    print "Time\t Stat\t  H1 snr\t H1 effective snr\t H2 snr\t" +\
        " H2 effective snr\t L1 snr\t L1 effective snr"
  

  
  for j in range(opts.loudest_events):
    snr = {}
    effective_snr = {}
    for ifo in ['H1','H2','L1']:
      try:
        snr[ifo] = getattr(coincTriggers[j],ifo).snr
        effective_snr[ifo] = getattr(coincTriggers[j],ifo).get_effective_snr()
        time = getattr(coincTriggers[j],ifo).end_time
      except:
        snr[ifo] = 0
        effective_snr[ifo] = 0
    if opts.loudest_file:
      loud_file.write(str(time) + \
          '\t%5.3f\t%5.3f\t%5.3f\t%5.3f\t%5.3f\t%5.3f\t%5.3f\n' % \
          (coincTriggers[j].stat, snr['H1'], effective_snr['H1'], \
          snr['H2'], effective_snr['H2'], snr['L1'], effective_snr['L1'] ) )
    else:
      print str(time) + \
          '\t%5.3f\t%5.3f\t%5.3f\t%5.3f\t%5.3f\t%5.3f\t%5.3f' % \
          (coincTriggers[j].stat, snr['H1'], effective_snr['H1'], \
          snr['H2'], effective_snr['H2'], snr['L1'], effective_snr['L1'] )
  
  if opts.loudest_file:
    loud_file.close()

 

#######################################################################
#
# Make plots of H1 vs other statistic value
#
#######################################################################

fig_num = 0

#################
# for slides only
if opts.slide_stat:
  fig_num += 1
  figure(fig_num)
  hold(True)
  
  plotstat(slideTriggers, ['kx','b+','g1','ro'])
  if len(slideTriggers): legend()
  grid()

  if opts.plot_min:
    ylim(ymin=opts.plot_min)
    xlim(xmin=opts.plot_min)
  if opts.plot_max:
    ylim(ymax=opts.plot_max)
    xlim(xmax=opts.plot_max)
  else:
    square_axis()

  title('Slide Statistic')
  if opts.figure_name:
      savefig(opts.figure_name + "_slide_" + opts.statistic + ".png")


###################
# for slides + zero 
if opts.slide_zero_stat:
  fig_num += 1
  figure(fig_num)
  hold(True)
  
  plotstat(slideTriggers, ['kx','k+','k1','ko'],'slide')
  plotstat(coincTriggers, ['rx','r+','r1','ro'],'zero-lag')
  if len(slideTriggers) or len(coincTriggers): legend()
  grid()

  if opts.plot_min:
    ylim(ymin=opts.plot_min)
    xlim(xmin=opts.plot_min)
  if opts.plot_max:
    ylim(ymax=opts.plot_max)
    xlim(xmax=opts.plot_max)
  else:
    square_axis()

  title('Slide + Zero Lag Statistic')
  if opts.figure_name:
      savefig(opts.figure_name + "_slide_zero_lag_" + opts.statistic + ".png")


#########################
# for slides + injections 
if opts.slide_inj_stat:
  fig_num += 1
  figure(fig_num)
  hold(True)
  
  plotstat(slideTriggers, ['kx','k+','k1','ko'],'slide',opts.inj_plot_type)
  plotstat(injTriggers, ['rx','r+','r1','ro'],'inj',opts.inj_plot_type)
  if len(slideTriggers) or len(injTriggers): legend()
  grid()

  if opts.plot_min:
    ylim(ymin=opts.plot_min)
    xlim(xmin=opts.plot_min)
  if opts.plot_max:
    ylim(ymax=opts.plot_max)
    xlim(xmax=opts.plot_max)
  else:
    square_axis()

  title('Slide + Injection Statistic')
  if opts.figure_name:
      savefig(opts.figure_name + "_slide_injection_" + opts.statistic + ".png")

#####################
# for injections only
if opts.inj_stat:
  fig_num += 1
  figure(fig_num)
  hold(True)
  
  plotstat(injTriggers, ['kx','b+','g1','ro'],None,opts.inj_plot_type)
  if len(injTriggers): legend()
  grid()

  if opts.plot_min:
    ylim(ymin=opts.plot_min)
    xlim(xmin=opts.plot_min)
  if opts.plot_max:
    ylim(ymax=opts.plot_max)
    xlim(xmax=opts.plot_max)
  else:
    square_axis()

  title('Injection Statistic')
  if opts.figure_name:
      savefig(opts.figure_name + "_injection_" + opts.statistic + ".png")

###################
# for zero lag only
if opts.zero_stat:
  fig_num += 1
  figure(fig_num)
  hold(True)
  
  plotstat(coincTriggers, ['kx','b+','g1','ro'])
  if len(coincTriggers): legend()
  grid()
  
  if opts.plot_min:
    ylim(ymin=opts.plot_min)
    xlim(xmin=opts.plot_min)
  if opts.plot_max:
    ylim(ymax=opts.plot_max)
    xlim(xmax=opts.plot_max)
  else:
    square_axis()

  title('Zero Lag Statistic')
  if opts.figure_name:
      savefig(opts.figure_name + "_zero_lag_" + opts.statistic + ".png")

##############################
# for zero lag plus injections 
if opts.zero_inj_stat:
  fig_num += 1
  figure(fig_num)
  hold(True)
  
  plotstat(coincTriggers, ['kx','k+','k1','ko'],'zero lag',opts.inj_plot_type)
  plotstat(injTriggers, ['rx','r+','r1','ro'],'injections',opts.inj_plot_type)
  if len(coincTriggers) or len(injTriggers): legend(loc=2)
  grid()

  if opts.plot_min:
    ylim(ymin=opts.plot_min)
    xlim(xmin=opts.plot_min)
  if opts.plot_max:
    ylim(ymax=opts.plot_max)
    xlim(xmax=opts.plot_max)
  else:
    square_axis()

  title('Zero Lag + Injection Statistic')
  if opts.figure_name:
      savefig(opts.figure_name + "_zero_inj_" + opts.statistic + ".png")


#######################################################################
#
# Make plots of the distribution of statistic values
#
#######################################################################

#############################################
# Determine the cumulative slide distribution
if opts.slide_dist or opts.slide_zero_dist:
  slideDist = []
  distSlides = []

  figure(100)
  if opts.plot_min:
    binMin = opts.plot_min
  else:
    binMin = 0.0

  if opts.plot_max:
    binMax = opts.plot_max
  elif slideMax:
    binMax = slideMax
  else:
    binMax = 1.0
    
  bins = arange(binMin, binMax, (binMax - binMin)/opts.num_bins )

  for thisSlide in slideStat:
    [thisDist,bin,info] = hist(thisSlide,bins)
    
    if opts.distribution == 'cumulative':
      cumSlide = [sum(thisDist)]
      cumSlide.extend(sum(thisDist) - cumsum(thisDist))
      cumSlide.pop()
      thisDist = cumSlide
      
    distSlides.append(thisDist)
    
  distSlides = reshape(array(distSlides), \
      (len(slideStat),opts.num_bins))

  slideMean = mean(distSlides)
  slideStd = std(distSlides)
  
  
  # make sure we don't plot log of zero
  slideMin = []
  for i in range( len(slideMean) ):
    slideMin.append( max(slideMean[i] - slideStd[i], 0.0001) )
    slideMean[i] = max(slideMean[i], 0.0001)

  if opts.slide_poisson_dist:
    poissonMin = []
    for i in range( len(slideMean) ):
      poissonMin.append( max(slideMean[i] - sqrt(slideMean[i]), 0.0001 ))

  # get the zero lag information
  if opts.slide_zero_dist:
    [zeroDist,bin,info] = hist(coincStat,bins)
    zeroDist = array(zeroDist,'f')

    if opts.distribution == 'cumulative':
      cumZero = [sum(zeroDist)]
      cumZero.extend(sum(zeroDist) - cumsum(zeroDist))
      cumZero.pop()
      zeroDist = cumZero

    for i in range( len(zeroDist) ):
      zeroDist[i] = max(zeroDist[i], 0.0001)
  
  clf()


################################################
# make the plot of slide cumulative distribution
if opts.slide_dist:
  fig_num += 1
  figure(fig_num)
  hold(True)
  errorbar(bins,log10(slideMean), [log10(slideMean) - log10(slideMin), 
      log10(slideMean + slideStd) - log10(slideMean)], markersize=12,
      markeredgewidth=1, linewidth=1)

  if opts.slide_poisson_dist:
    errorbar(bins,log10(slideMean), [log10(slideMean) - log10(poissonMin), 
        log10(slideMean + sqrt(slideMean)) - log10(slideMean)], 
        markersize=12, markeredgewidth=1, linewidth=1, color='k')

     
  xlabel('Combined ' + opts.statistic.replace("_"," "), size='x-large')
  ylabel('Log Number of events', size='x-large')
  if opts.distribution == 'cumulative':
    title_text = 'Cumulative histogram of Number of events vs statistic'
  else:
    title_text = 'Histogram of Number of events vs statistic'

  title(title_text, size='x-large')
  
  ylim(ymin=log10((1./(2*opts.num_slides))))

  if opts.plot_min:
    xlim(xmin=opts.plot_min)
  if opts.plot_max:
    xlim(xmax=opts.plot_max)

  if opts.figure_name:
    if opts.distribution == 'cumulative':
      savefig(opts.figure_name + "_slide_distribution.png")
    else:
      savefig(opts.figure_name + "_nc_slide_distribution.png")


############################################################
# make the plot of slide and zerolag cumulative distribution
if opts.slide_zero_dist:
  fig_num += 1
  figure(fig_num)

  plot(bins,log10(zeroDist),'rx',markeredgewidth=1, markersize=12,linewidth=1)
  errorbar(bins,log10(slideMean), [log10(slideMean) - log10(slideMin), 
      log10(slideMean + slideStd) - log10(slideMean)], markersize=12,
      markeredgewidth=1, linewidth=1)

  if opts.slide_poisson_dist:
    errorbar(bins,log10(slideMean), [log10(slideMean) - log10(poissonMin), 
        log10(slideMean + sqrt(slideMean)) - log10(slideMean)], 
        markersize=12, markeredgewidth=1, linewidth=1, color='k')

  xlabel('Combined ' + opts.statistic.replace("_"," "), size='x-large')
  ylabel('Log Number of events', size='x-large')
  if opts.distribution == 'cumulative':
    title_text = 'Cumulative histogram of Number of events vs statistic'
  else: 
    title_text = 'Histogram of Number of events vs statistic'

  title(title_text, size='x-large')
  ylim(ymin=log10((1./(2*opts.num_slides))))

  if opts.plot_min:
    xlim(xmin=opts.plot_min)
  if opts.plot_max:
    xlim(xmax=opts.plot_max)

  if opts.figure_name:
    if opts.distribution == 'cumulative':
      savefig(opts.figure_name + "_slide_zero_distribution.png")
    else:
      savefig(opts.figure_name + "_nc_slide_zero_distribution.png")

####################################################################
# make the plot of number of events per slide at a given stat value:
if opts.stat_values:
  for value in opts.stat_values:
    fig_num += 1
    figure(fig_num)
    hold(True)
   
    bin =  int ( (value - bins[0]) / (bins[1] - bins[0]) )
    number = distSlides[:,bin]
    numBins = min(max(number) + 1, opts.num_bins)
    numSl,binSl,junk = hist(number, numBins)

    if opts.slide_poisson_dist:
      poissonNum = poisson(mean(number), 2* opts.num_slides)
      numPoisson,binS,junk = hist(poissonNum,binSl)
      clf()
      step = binSl[1] - binSl[0]
      bar(binSl, numPoisson, (2.0 * step) / 3.0, color='r')
      bar(binSl + step / 3.0 , numSl, (2.0 * step) / 3.0, color='b')
          
    xlabel('Number of events in slide at ' + opts.statistic.replace("_"," ") \
        + ' ' + str(value), size='x-large')
    ylabel('Number of occurrences', size='x-large')
    if opts.figure_name:
      savefig(opts.figure_name + "_slide_dist_at_" + str(value) + ".png")


####################################
# make plots of slide loudest events

if opts.plot_cum_loudest or opts.plot_pdf_loudest:
  minSnr = 0.95 * min(slideLoudest)
  maxSnr = 1.05 * max(slideLoudest)
  snrArray = arange(minSnr, maxSnr, (maxSnr - minSnr) / (2 * opts.num_slides) )
  x = arange(2 * opts.num_slides)
  
if opts.plot_cum_loudest:
  fig_num += 1
  figure(fig_num)
  numBelow = []
  for snrValue in snrArray:
    numBelow.append(sum(slideLoudest < snrValue))
  numBelow = asarray(numBelow,'f') / (2 * opts.num_slides)
  plot(snrArray,numBelow,linewidth=2,label="slide dist")
  if opts.zero_glob:
    axvline(loudestEvent,linewidth=2,color='r',label="zero lag")
    P_b = sum(slideLoudest < loudestEvent) * 1./ (2 * opts.num_slides)
    print 'pdf P_b at loudest event is ' + str(P_b)

  grid()
  xlabel(opts.statistic.replace("_"," "), size='x-large')
  ylabel('Probability loudest event < value', size='x-large')
  legend()
  if opts.figure_name:
      savefig(opts.figure_name + "_cumulative_loudest.png")

if opts.plot_pdf_loudest:
  fig_num += 1
  figure(fig_num)
  hold(True)

  # plot a smoothed probability distribution
  num,snrArray,crap = hist(slideLoudest,snrArray,normed = 1)
  clf()
  num = asarray(num)
  # gaussian average over 5 points
  width = 5.0
  gauss = exp(- arange(- 1.0* (opts.num_slides - 1) /width, 
      1.0 * opts.num_slides / width,
      1.0/width )**2 / 2) / sqrt(2.0 * pi) /width
  smooth_pb = convolve(num,gauss,mode=1)
  plot(snrArray, smooth_pb, 'k',linewidth=2,label="smoothed pdf")

  # and the zero lag line
  if opts.zero_glob:
    axvline(loudestEvent,linewidth=2,color='r',label="zero lag")
    p_b = 0.5 * (smooth_pb[max(x[snrArray < loudestEvent])] + \
                 smooth_pb[min(x[snrArray > loudestEvent])] )
    print 'pdf p_b at loudest event is ' + str(p_b)

  xlabel(opts.statistic.replace("_"," "), size='x-large')
  ylabel('pdf of loudest event', size='x-large')
  legend()
  grid()
  if opts.figure_name:
      savefig(opts.figure_name + "_loudest_pdf.png")


#######################################################################
#
# Make efficiency plots
#
#######################################################################

##########################
# make the efficiency plot 
if opts.efficiency:
  fig_num += 1
  figure(fig_num)

  if opts.plot_min:
    min_val = opts.plot_min
  else:
    min_val = injStat[len(injStat)-1]

  if opts.plot_max:
    max_val = opts.plot_max
  else:
    max_val = injStat[0]

  values = arange(min_val, max_val, (max_val - min_val)/1000)
  
  num_above = zeros(len(values))
  injStat = asarray(injStat)
  for i in range(len(values)):
    num_above[i] = sum( injStat > values[i] )
 
  eff = num_above / float(len(injTriggers) + len(missedInj) )
  
  plot(values, eff, 'k-', linewidth = 2,label="efficiency")
  # and the zero lag line
  if opts.zero_glob:
    axvline(loudestEvent,linewidth=2,color='r',label="zero lag")


  xlabel('Combined Statistic', size='x-large')
  ylabel('Injection Efficiency', size='x-large')
  ylim(0,1)
  legend()

##########################
# make the pdf of efficiency plot 
if opts.pdf_efficiency:
  fig_num += 1
  figure(fig_num)

  if opts.plot_min:
    min_val = opts.plot_min
  else:
    min_val = injStat[len(injStat)-1]

  if opts.plot_max:
    max_val = opts.plot_max
  else:
    max_val = injStat[0]

  # histogram of efficiency deriv (coarse)
  step = (max_val - min_val)/opts.num_bins
  bins_coarse = arange(min_val, max_val + step, step)
  num_coarse,bins_coarse,crap = hist(injStat,bins_coarse)
  clf()
  num_coarse = 1.0 * num_coarse[:-1]
  bins_coarse = bins_coarse[:-1]

  # fine histogram which we gaussian average over 5 points
  step = (max_val - min_val)/(10*opts.num_bins)
  bbins = arange(min_val, max_val + step, step)
  num,bbins,crap = hist(injStat,bbins)
  clf()
  num = 1.0 * num[:-1]
  bbins = bbins[:-1]
  width = 10.0
  gauss = exp(- arange(- 10.0* opts.num_bins / (2.0 * width), 
      10.0 * opts.num_bins / (2.0  * width),
      1.0/width )**2 / 2) / sqrt(2.0 * pi) /width
  
  smooth_num = 10 * convolve(num,gauss,mode=1)
  plot(bbins, smooth_num, 'k',linewidth=2,label="smoothed pdf")

  # histogram of efficiency deriv
  bar(bins_coarse,num_coarse)

  # and the zero lag line
  if opts.zero_glob:
    axvline(loudestEvent,linewidth=2,color='r',label="zero lag")
    
  xlabel(opts.statistic.replace("_"," "), size='x-large')
  ylabel('derivative of efficiency', size='x-large')
  grid()
  if opts.figure_name:
      savefig(opts.figure_name + "_efficiency_deriv_" + str(value) + ".png")


######################################
# make the mass windows
windows = []
if opts.mass_windows and len(opts.mass_windows) > 1:
  for i in range(len(opts.mass_windows) - 1):
    windows.append([opts.mass_windows[i], opts.mass_windows[i+1]])

######################################
# make the efficiency vs distance plot 
if opts.eff_cols:
  # all injections with stat < loudest event go in missed.
  foundInj = lsctables.New(lsctables.SimInspiralTable)
  # if no zero lag, then find efficiency at loudest slide:
  if loudestEvent:
    title_text = 'Above zero lag loudest, '
  elif loudestEvent == 0 and opts.num_slides:
    loudestEvent = max(slideLoudest)
    title_text = 'Above slide loudest, '
  else:
    title_text = ''

  for injCoinc in injTriggers:
    if injCoinc.stat < loudestEvent:
      missedInj.append(injCoinc.sim)
    else:
      foundInj.append(injCoinc.sim)
  
  if windows:
    for win1 in windows:
      for win2 in windows:
        if win2 >= win1:
          foundWin = lsctables.New(lsctables.SimInspiralTable)
          missedWin = lsctables.New(lsctables.SimInspiralTable)

          for found in foundInj:
            m_low = min(found.mass1, found.mass2)
            m_high = max(found.mass1, found.mass2)
            if m_low > win1[0] and m_low < win1[1] and \
               m_high > win2[0] and m_high < win2[1]:
              foundWin.table.append(found)

          for missed in missedInj.table:
            m_low = min(missed.mass1, missed.mass2)
            m_high = max(missed.mass1, missed.mass2)
            if m_low > win1[0] and m_low < win1[1] and \
               m_high > win2[0] and m_high < win2[1]:
              missedWin.table.append(missed)

          for col in opts.eff_cols:
            fig_num += 1
            figure(fig_num)
            title_text += 'Mass range ' + str(win1) + ' ' + str(win2)
            viz.efficiencyplot(foundWin, missedWin, col, ifo=None, 
                plot_type = opts.eff_plot_type, nbins = 20, plotsym = 'k-', 
                errors = True,title_string=title_text)
            if opts.figure_name:
              savefig(opts.figure_name + '_'+ col + '_'\
                  + str(win1[0]) + '_' + str(win1[1]) + '_and_' \
                  + str(win2[0]) + '_'+ str(win2[1]) \
                  +  "_efficiency.png")
    

  else:
    for col in opts.eff_cols:
      fig_num += 1
      figure(fig_num)
      viz.efficiencyplot(foundInj, missedInj, col, ifo=None, 
          plot_type = opts.eff_plot_type, nbins = 20, plotsym = 'k-', 
          errors = True, title_string = title_text)
      if opts.figure_name:
        savefig(opts.figure_name + '_' + col + "_efficiency.png")
    
################
# show the plots
if opts.show_plot:
  show()
