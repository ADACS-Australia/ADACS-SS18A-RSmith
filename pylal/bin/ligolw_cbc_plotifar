#!/usr/bin/python


# ============================================================================
#
#                               Preamble
#
# ============================================================================


__author__ = "Collin Capano <cdcapano@physics.syr.edu>"
__version__ = "$Revision$"
__date__ = "$Date$"
__prog__ = "ligolw_cbc_plotifar"
__Id__ = "$Id$"

from optparse import OptionParser
try:
    import sqlite3
except ImportError:
    # pre 2.5.x
    from pysqlite2 import dbapi2 as sqlite3
import sys,os
import copy
import bisect

from glue.ligolw import lsctables
from glue.ligolw import dbtables
import glue.iterutils

from pylal import InspiralUtils
from pylal import followup_trigger
from numpy import histogram

import itertools
import numpy
import operator
import matplotlib.mlab as mlab

from pylal import ligolw_sqlutils as sqlutils

usage =  """
"""
# ============================================================================
# def poly_between; needed if using older version of matplotlib
def poly_between(x, ylower, yupper):
    """
    given a sequence of x, ylower and yupper, return the polygon that
    fills the regions between them.  ylower or yupper can be scalar or
    iterable.  If they are iterable, they must be equal in length to x

    return value is x, y arrays for use with Axes.fill
    """
    Nx = len(x)
    if not iterable(ylower):
      ylower = ylower*numpy.ones(Nx)

    if not iterable(yupper):
      yupper = yupper*numpy.ones(Nx)

    x = numpy.concatenate( (x,x[::-1]) )
    y = numpy.concatenate( (yupper, ylower[::-1]) )
    return x,y
# ============================================================================


# ============================================================================
#
#                               Set Options
#
# ============================================================================

def parse_command_line():
    """
    Parser function dedicated
    """

    parser = OptionParser( usage = usage, version = "%prog CVS $Id$ " )
    # following are related to file input and output naming
    parser.add_option( "-i", "--input", action = "store", type = "string", default = None,
        help = 
            "Input database to read. Can only input one at a time."
        )
    parser.add_option( "-t", "--tmp-space", action = "store", type = "string", default = None,
        metavar = "PATH",
        help = 
            "Location of local disk on which to do work. This is optional; " +
            "it is only used to enhance performance in a networked " +
            "environment. "
        )
    parser.add_option( "-P", "--output-path", action = "store", type = "string", \
        default = os.getcwd(), metavar = "PATH", \
        help = 
            "Optional. Path where the figures should be stored. Default is current directory." 
        )
    parser.add_option( "-O", "--enable-output", action = "store_true", \
        default =  False, metavar = "OUTPUT", \
        help = 
            "enable the generation of html and cache documents" 
        )
    parser.add_option( "-s", "--show-plot", action = "store_true", default = False, \
        help = 
            "display the plots on the terminal" 
        )
    parser.add_option( "-v", "--verbose", action = "store_true", default = False, \
        help = 
            "print information to stdout" 
        )
    parser.add_option( "-D", "--debug", action = "store_true", default = False,
        help =
            "Print SQLite queries used and the approximate time taken to run each one." 
        )

    parser.add_option( "-u", "--user-tag", action = "store", type = "string",
        default = None, metavar = "USERTAG",
        help = 
            "Add a tag in the name of the figures" 
        )
    parser.add_option("", "--plot-slides", action = "store_true", default = False,
        help = 
            "If this is specified, will have the world famous " +
            "lightning-bolt plots."
        ) 
    parser.add_option( "", "--param-name", action = "store", default = None,
        metavar = "PARAMETER", 
        help = 
            "Can be any parameter in the coinc_inspiral table. " + 
            "Specifying this and param-ranges defines the bins " +
            "which the uncombined_fars are calculated will be " +
            "plotted in. The bins should be the same as " +
            "whatever was used when calculating the uncombined false " +
            "alarm rate."
             )
    parser.add_option( "", "--param-ranges", action = "store", default = None,
        metavar = " [ LOW1, HIGH1 ); ( LOW2, HIGH2]; etc.",
        help = 
            "Requires --param-name. Specify the parameter ranges " +
            "to bin the triggers in. A '(' or ')' implies an open " +
            "boundary, a '[' or ']' a closed boundary. To specify " +
            "multiple ranges, separate each range by a ';'."
            )
    #FIXME: should these be changed to units of IFAR?
    parser.add_option( "", "--x-min", action = "store", type = "float",
        default = None, metavar = "",
        help = 
            "minimum x value to plot, in terms of IFAN " +
            "(for IFAR plots this will be normalized automatically)" 
        )
    parser.add_option( "", "--x-max", action = "store", type = "float",
        default = None, metavar = "",
        help = 
            "maximum x value to plot, in terms of IFAN " +
            "(for IFAR plots this will be normalized automatically)" 
        )
    parser.add_option( "", "--y-min", action = "store", type = "float",
        default = None, metavar = "",
        help = 
            "minimum y value to plot, must be greater than 0"
        )
    parser.add_option("", "--y-max", action = "store", type = "float",
        default = None, metavar = "",
        help = 
            "maximum y value to plot"
        ) 
    parser.add_option( "", "--ifar-dist", action = "store_true", default = False,
        help = 
            "plot a cumulative histogram of IFAR (in units of years)" 
        )
    #FIXME: Can plot combined ifan-dist?
#    parser.add_option( "", "--ifan-dist", action = "store_true", default = False,
#        help = 
#            "plot a cumulative histogram of uncombined IFAR*analysis time (the " +
#            "inverse false alarm number)."
#        )
    parser.add_option( "", "--show-min-bkg", action = "store_true", default = False,
        help = 
            "put a vertical line indicating where the background begins for some " +
            "category."
        )
    parser.add_option( "", "--show-max-bkg", action = "store_true", default = False,
        help = 
            "put a vertical line indicating where the background ends for some " +
            "category." 
        )
    parser.add_option( "", "--show-two-sigma-error", action = "store_true", default = False,
        help = 
            "plot background out to two sigma" 
        )
    parser.add_option( "", "--plot-uncombined", action = "store_true", default = False,
        help = 
            "make an uncombined plot of however many categories there are" 
        )
    parser.add_option( "", "--plot-combined", action = "store_true", default = False,
        help = "Plot combined IFARs on a cumulative histogram." 
        )
    parser.add_option( "", "--group-by-ifos", action = "store_true", default = False, 
        help = 
          "Turning on will cause triggers to be grouped by coincident ifos when plotting " +
          "combined FAR."
            )
    parser.add_option( "", "--datatype", action = "store", type = "string",
        default = None, metavar = "all_data, playground, or exclude_play",
        help = 
            "Requried. Can either be 'all_data', 'playground', or 'exclude_play'. " +
            "Specifies what type of zero-lag data to plot." 
        )
    # The following are needed to run followup_missed.py
    # FIXME: these won't work with new sqlite infrastructure
#    parser.add_option( "", "--do-followup", action = "store_true", default = False, \
#        help = 
#            "Followup loudest events." 
#        )
#    parser.add_option( "", "--ihope-cache", action = "store", type = "string",
#        default = None, metavar = " IHOPE_CACHE",
#        help = 
#            "Location of the ihope.cache file, needed for followups." 
#        )
   
    (options,args) = parser.parse_args()

    #check if required options specified and for self-consistency
    if not options.input:
        raise ValueError, "--input must be specified"
    if options.y_min and options.y_min <= 0.:
        raise ValueError, "y-min must be greater than 0"
    if options.y_max and (options.y_min >= options.y_max):
        raise ValueError, "y-min must be less than y-max"
    if (options.x_min and options.x_max) and (options.x_min >= options.x_max):
        raise ValueError, "x-min must be less than x-max"
    return options, sys.argv[1:]


# =============================================================================
#
#                       Function Definitions
#
# =============================================================================

def convert_to_yrs( duration ):
    """
    Uses sqlutils.convert_duration to automatically convert the frg_durs
    to years. 
    """
    return sqlutils.convert_duration( duration, 'yr' )
                   
# ============================================================================
#
#                                 Main
#
# ============================================================================

#
#   Generic Initialization
#

# parse command line
opts, args = parse_command_line()

# get input database filename
filename = opts.input
if not os.path.isfile( filename ):
    raise ValueError, "The input file, %s, cannot be found." % filename

# Setup working databases and connections
if opts.verbose: 
    print >> sys.stdout, "Creating a database connection..."
working_filename = dbtables.get_connection_filename( 
    filename, tmp_path = opts.tmp_space, verbose = opts.verbose )
connection = sqlite3.connect( working_filename )
dbtables.DBTable_set_connection( connection )

#
#   Plotting Initialization
#

# Change to Agg back-end if show() will not be called 
# thus avoiding display problem
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from pylal import viz
from numpy import histogram
rc('text', usetex=True)

#
#   Program-specific Initialization
#

# Get param and param-ranges if specified, and set ranges (for legend), symbols, and 
# linestyles for plotting based on param_ranges. This plotting info is stored to the
# param_ranges_legend, which has the following form:
# param_ranges_legend[(param_name, group_number)]: {'range': string }, {'marker': marker}, {'linestyle': linestyle}
param_ranges_legend = {}
trigsymbols = itertools.cycle(( '^', 'o', 's' ))
linestyles = itertools.cycle(( ':', '-.', '--' ))
if opts.param_name:
    param_parser = sqlutils.parse_param_ranges( 'coinc_inspiral', opts.param_name,
        opts.param_ranges, verbose = opts.verbose )
    param_name = param_parser.param.split('.')[1]
    connection.create_function("group_by_param", 1, param_parser.group_by_param_range)
    param_grouping = ''.join([ 'group_by_param(', param_parser.param, ')' ])
    for (n, (low, high)), marker, linestyle in zip( enumerate(param_parser.param_ranges), trigsymbols, linestyles ):
        if low[0] == '>=':
            lowbnd = '['
        elif low[0] == '>':
            lowbnd = '('
        if high[0] == '<=':
            highbnd = ']'
        elif high[0] == '<':
            highbnd = ')'
        param_ranges_legend[(param_name, n)] = {}
        param_ranges_legend[(param_name, n)]['range'] = \
            ''.join([lowbnd, str(low[1]), ',', str(high[1]), highbnd])
        param_ranges_legend[(param_name, n)]['marker'] = \
            marker
        param_ranges_legend[(param_name, n)]['linestyle'] = \
            linestyle

else:
    param_grouping = '0'
    param_name = 'No binning'
    param_ranges_legend[(param_name, 0 )] = {}
    param_ranges_legend[(param_name, 0 )]['range'] = ''
    param_ranges_legend[(param_name, 0 )]['marker'] = '^'
    param_ranges_legend[(param_name, 0 )]['linestyle'] = '--'


# we'll use the Summaries class from sqlutils to store and manage
# needed info such as durations, background durations, max_bkg_fars (if
# they are to be plotted), etc.
background = sqlutils.Summaries()

# sqlitize convert_to_yrs
connection.create_function( 'convert_to_yrs', 1, convert_to_yrs )

# get datatype
plot_datatype = opts.datatype.strip().lower()
if plot_datatype not in lsctables.ExperimentSummaryTable.datatypes:
    raise ValueError, "Unrecognized datatype %s specified." % opts.datatype
if plot_datatype == "slide" or plot_datatype == "simulation":
    raise ValueError, "--datatype must be either all_data, playground, or exclude_play"
# get all the available experiments from the experiment table, along
# with each's associated experiment_summ_ids and durations from the 
# experiment summary table
if opts.verbose:
    print >> sys.stdout, "Getting information about all available experiments..."
experiment_ids = {}
frg_durs = {}
sqlquery = """
    SELECT
        experiment.experiment_id,
        experiment.instruments,
        experiment.gps_start_time,
        experiment.gps_end_time,
        experiment_summary.experiment_summ_id,
        convert_to_yrs(experiment_summary.duration),
        experiment_summary.datatype
    FROM
        experiment
    JOIN
        experiment_summary ON (
        experiment.experiment_id == experiment_summary.experiment_id )
    WHERE
        experiment_summary.datatype == "slide"
        OR experiment_summary.datatype == ?
        """
for eid, on_inst, exp_start_time, exp_end_time, esid, duration, datatype in connection.cursor().execute( sqlquery, (plot_datatype,) ):
    if duration == 0.:
        continue
    on_inst = frozenset(lsctables.instrument_set_from_ifos(on_inst))
    if (eid, exp_start_time, exp_end_time, on_inst) not in experiment_ids:
        experiment_ids[ (eid, exp_start_time, exp_end_time, on_inst) ] = {}
    if esid not in experiment_ids[ (eid, exp_start_time, exp_end_time, on_inst) ]:
        experiment_ids[ (eid, exp_start_time, exp_end_time, on_inst) ][ esid ] = []
    if datatype != "slide":
        background.append_zero_lag_id( eid, esid, datatype )
        frg_durs[eid] = duration
    background.append_duration(eid, esid, duration)

# calculate the background durations
background.calc_bkg_durs()

# FIXME: This should only be collected one at a time for the experiment to conserve on memory
# get info about all the triggers
if opts.verbose:
    print >> sys.stdout, "Getting FARs of triggers..."
sqlquery = ''.join([ """
    SELECT
        experiment.experiment_id,
        experiment.gps_start_time,
        experiment.gps_end_time,
        experiment.instruments,
        experiment_summary.experiment_summ_id,
        coinc_inspiral.false_alarm_rate,
        coinc_inspiral.combined_far,
        coinc_inspiral.ifos,
        """,
        param_grouping, """
    FROM 
        coinc_inspiral
    JOIN 
        experiment, experiment_summary, experiment_map ON (
            experiment.experiment_id == experiment_summary.experiment_id
            AND experiment_summary.experiment_summ_id == experiment_map.experiment_summ_id
            AND experiment_map.coinc_event_id == coinc_inspiral.coinc_event_id)
    WHERE 
        experiment_summary.datatype == "slide"
        OR experiment_summary.datatype == ? """])

uncombined_fars = {}
combined_fars = {}
num_comb_cats = {}

if opts.debug:
    import time
    print >> sys.stderr, sqlquery
    print >> sys.stderr, time.localtime()[3], time.localtime()[4], time.localtime()[5]
for eid, exp_start_time, exp_end_time, on_inst, esid, ufar, cfar, ifos, param_group in connection.cursor().execute(sqlquery, (plot_datatype,)):
    on_inst = frozenset( lsctables.instrument_set_from_ifos(on_inst) )
    ifos = frozenset( lsctables.instrument_set_from_ifos(ifos) )
    if ifos not in experiment_ids[ (eid, exp_start_time, exp_end_time, on_inst) ][ esid ]:
        experiment_ids[ (eid, exp_start_time, exp_end_time, on_inst) ][ esid ].append(ifos)
    # store uncombined_fars
    if eid not in uncombined_fars:
        uncombined_fars[ eid ] = {}
    if esid not in uncombined_fars[ eid ]:
        uncombined_fars[ eid ][ esid ] = {}
    if (ifos, param_group) not in uncombined_fars[ eid ][ esid ]:
        uncombined_fars[ eid ][ esid ][ (ifos, param_group) ] = []
    uncombined_fars[ eid ][ esid ][ (ifos, param_group) ].append(ufar)
    # store combined_fars
    if not opts.group_by_ifos:
        ifo_group = 'ALL_IFOS'
    else:
        ifo_group = ifos
    if eid not in combined_fars:
        combined_fars[ eid ] = {}
    if esid not in combined_fars[ eid ]:
        combined_fars[ eid ][ esid ] = {}
    if ifo_group not in combined_fars[ eid ][ esid ]:
        combined_fars[ eid ][ esid ][ ifo_group ] = []
    combined_fars[ eid ][ esid ][ ifo_group ].append(cfar)
    if (eid, esid, ifo_group) not in num_comb_cats and ufar != 0.:
        num_comb_cats[(eid,esid,ifo_group)] = cfar/ufar
    elif ufar != 0. and cfar/ufar > num_comb_cats[(eid,esid,ifo_group)]:
        num_comb_cats[(eid,esid,ifo_group)] = cfar/ufar

if opts.debug:
    print >> sys.stderr, time.localtime()[3], time.localtime()[4], time.localtime()[5]

# Calculate max_bkg_fars for the foreground, which are used for plotting
# and setting ifo colors in the legend.
# The max_bkg_far is the total number of background triggers in each category
# divided by the background duration for that slide.
if opts.verbose:
    print >> sys.stdout, "Calculating minimum background IFARs..."
for eid in background.zero_lag_ids:
    if eid not in uncombined_fars:
        continue
    for zero_esid in background.zero_lag_ids[eid].values():
        total_bkg_trigs = {}
        for esid in uncombined_fars[ eid ]:
            if esid == zero_esid:
                continue
            for (ifos, param_group), ufarlist in uncombined_fars[eid][esid].items():
                if (ifos, param_group) not in  total_bkg_trigs:
                    total_bkg_trigs[(ifos, param_group)] = 0
                total_bkg_trigs[(ifos, param_group)] += len(ufarlist)
        # To store the max_bkg_far, we'll use the max_bkg_fars list in the Summaries class; however,
        # since this does not store the param group in it, we'll store the max_bkg_far in the
        # list as a tuple of param_group and max_bkg_far
        for (ifos, param_group), N_bkg_trigs in total_bkg_trigs.items():
            background.append_max_bkg_far( zero_esid, ifos, (param_group, N_bkg_trigs / background.bkg_durs[zero_esid]) )

# calculate min_bkg_ufar in every time_slide in every experiment; 
# this is just 1/background_duration for each experiment_summ_id
min_bkg_ufar = {}
if opts.verbose:
    print >> sys.stdout, "Calculating maximum background IFARs..."
for esid, bkg_dur in background.bkg_durs.items():
    min_bkg_ufar[esid] = 1./bkg_dur


# sort and calculate cumulative historgram values for each
# uncombined_far list in uncombined_fars
if opts.plot_uncombined:
    uncombined_cumnum = {}
    uncomb_zero_cumnum = {}
    for eid in uncombined_fars:
        for esid in uncombined_fars[ eid ]:
            for category, ufarlist in uncombined_fars[ eid ][ esid ].items():
                ufarlist.sort()
                uncombined_cumnum[ (eid, esid, category) ] = \
                    [ bisect.bisect_right(ufarlist, ufar) for ufar in ufarlist ]
                # replace zeroes with min_bkg_ufar for this category and
                # count how many there are to ensure that the arrow that will be 
                # plotted has the correct y-value; following loop takes 
                # advantage of ufarlist being sorted from smallest to largest
                for n, ufar in enumerate(ufarlist):
                    if ufar != 0.:
                        break
                    uncomb_zero_cumnum[ (eid, esid, category) ] = n + 1
                    ufarlist[n] = min_bkg_ufar[esid]
                # reverse sort ufarlist and uncombined_cumnum so loudest trigs will
                # be plotted first 
                uncombined_cumnum[ (eid, esid, category) ].sort(reverse = True)
                ufarlist.sort(reverse = True)
                # turn ufarlist into an array for easy inverse calculation
                uncombined_fars[ eid ][ esid ][ category ] = array( ufarlist )

# do the same for combined far
if opts.plot_combined:
    combined_cumnum = {}
    comb_zero_cumnum = {}
    for eid in combined_fars:
        for esid in combined_fars[ eid ]:
            for ifo_group, cfarlist in combined_fars[ eid ][ esid ].items():
                cfarlist.sort()
                combined_cumnum[ (eid, esid, ifo_group) ] = \
                    [ bisect.bisect_right(cfarlist, cfar) for cfar in cfarlist ]
                for n, cfar in enumerate( cfarlist ):
                    if cfar != 0.:
                        break
                    comb_zero_cumnum[ (eid, esid, ifo_group) ] = n + 1
                    cfarlist[n] = min_bkg_ufar[esid] * num_comb_cats[(eid, esid, ifo_group)]
                cfarlist.sort(reverse = True)
                combined_fars[ eid ][ esid ][ ifo_group ] = array( cfarlist ) 
                combined_cumnum[ (eid, esid, ifo_group) ].sort(reverse = True)

        
#
#   Plot
#

# Cycle over experiment_ids, creating a new page of plots for each
# experiment
if opts.user_tag:
    opts.user_tag = '_'.join([ opts.user_tag, plot_datatype.upper()])
else:
    opts.user_tag = plot_datatype.upper()

for (eid, exp_start_time, exp_end_time, on_inst) in experiment_ids:

    if opts.verbose:
        print >> sys.stdout, "Creating plots for %s time..." % lsctables.ifos_from_instrument_set(on_inst)

    # FIXME: The following should be done more elegantly, but requires changes to 
    # InspiralUtils.py
    # Add gps-start-time, gps-end-time, on_inst to opts to get them in the file names
    opts.gps_start_time = exp_start_time
    opts.gps_end_time = exp_end_time
    opts.ifo_times = ''.join(sorted(on_inst))
    opts.ifo_tag = ''

    # set InspiralUtils options for file and plot naming
    InspiralUtilsOpts = InspiralUtils.initialise( opts, __prog__, __version__ )
    # set the proper color code and symbols
    figure_number = 0 # used for the figure label (showplot)
    fnameList = [] # used for the html cache file
    tagList = [] # ditto

    # check that there's something to plot
    if eid not in uncombined_fars:
        # FIXME: make empty plot
        continue

    # get the esid of the zero-lag for this eid
    zero_esid = background.zero_lag_ids[ eid ].values()[0]
    
    #
    #   Plot Uncombined IFAR
    #

    if opts.plot_uncombined:
        if opts.ifar_dist:
            if opts.verbose:
                print >> sys.stdout, "\tGenerating uncombined IFAR plot..."
            figure(figure_number)
            figure_number += 1
            xmin = numpy.inf
            xmax = -numpy.inf
            ymin = 0.8
            ymax = 0

            #
            #   Plot lightning bolts
            #
            if opts.plot_slides:
                if plot_datatype == "playground":
                    bkg_correction = 0.1
                if plot_datatype == "exclude_play":
                    bkg_correction = 0.9
                if plot_datatype == "all_data":
                    bkg_correction = 1.
                for esid in uncombined_fars[eid]:
                    # skip the zero-lag
                    if esid == zero_esid:
                        continue
                    # plot the rest as gray lines
                    for category in uncombined_fars[eid][esid]:
                        loglog( bkg_correction/uncombined_fars[eid][esid][category], 
                                uncombined_cumnum[ (eid, esid, category) ],
                                color = 'gray',
                                linestyle = '-',
                                alpha = 0.4,
                                label = '_nolegend_' )
                        # reset xmax to include loudest background trigger
                        if xmax < 1./uncombined_fars[eid][esid][category][-1]:
                            xmax = 1./uncombined_fars[eid][esid][category][-1]

            #
            #   Plot the expected background
            #

            xbkg = numpy.logspace( -8, 2, num=100, endpoint=True, base=10.0 )
            ybkg = frg_durs[eid] / xbkg
            loglog( xbkg, ybkg, 'k--', linewidth = 2, label = 'Expected Background' )
            
            # plot error
            bkgplus = ybkg + sqrt(ybkg)
            bkgminus = ybkg - sqrt(ybkg)
            bkgminus = where( bkgminus<=0, 1e-5, bkgminus ) # prevent (-) values
            xs, ys = poly_between( xbkg, bkgminus, bkgplus )
            fill( xs, ys, facecolor='y', alpha=0.4, label='$N^{1/2}$ errors' )
            if opts.show_two_sigma_error:
                bkgplus = ybkg + 2*sqrt(ybkg)
                bkgminus = ybkg - 2*sqrt(ybkg)
                bkgminus = where( bkgminus<=0, 1e-5, bkgminus ) # prevent (-) values
                xs, ys = poly_between( xbkg, bkgminus, bkgplus )
                fill( xs, ys, facecolor='y', alpha=0.2, label='$2N^{1/2}$ errors' )

            #
            #   Plot the foreground
            #

            if zero_esid in uncombined_fars[eid]:
                for (ifos, param_group) in uncombined_fars[eid][zero_esid]:
                    loglog( 1./uncombined_fars[eid][zero_esid][(ifos, param_group)],
                            uncombined_cumnum[ (eid, zero_esid, (ifos, param_group)) ],
                            marker = param_ranges_legend[(param_name, param_group)]['marker'],
                            markerfacecolor = InspiralUtils.get_coinc_ifo_colors( ifos ),
                            markeredgecolor = 'k',
                            linestyle = 'None',
                            alpha = 0.9,
                            label = '_nolegend_' )
                    # if any FARs were zero, stick an arrow on their marker
                    if (eid, zero_esid, (ifos, param_group)) in uncomb_zero_cumnum:
                        xval = 1. / min_bkg_ufar[ zero_esid ]
                        yval = uncomb_zero_cumnum[ (eid, zero_esid, (ifos, param_group)) ]
                        text( xval, yval, '$\Rightarrow$', ha = 'left', va = 'center', 
                            color = 'k', label='_nolegend_' )
                    # reset xmin, xmax, ymax
                    if xmin > 1./uncombined_fars[eid][zero_esid][(ifos, param_group)][0]:
                        xmin = 1./uncombined_fars[eid][zero_esid][(ifos, param_group)][0]
                    if xmax < 1./uncombined_fars[eid][zero_esid][(ifos, param_group)][-1]:
                        xmax = 1./uncombined_fars[eid][zero_esid][(ifos, param_group)][-1]
                    if ymax < uncombined_cumnum[eid, zero_esid, (ifos, param_group)][0]:
                        ymax = uncombined_cumnum[eid, zero_esid, (ifos, param_group)][0]
            # FIXME: make empty plot if no foreground


            #
            #   Plot min/max bkg fars
            #

            # plot min bkg ifar line (same as max bkg far)
            if opts.show_min_bkg:
                for (esid, ifos) in background.max_bkg_fars:
                    if esid == zero_esid:
                        for (param_group, max_bkg_far) in background.max_bkg_fars[(esid,ifos)]: 
                            xminbkg = 1./max_bkg_far 
                            loglog( [xminbkg,xminbkg], [0.1,10000],
                                color = InspiralUtils.get_coinc_ifo_colors( ifos ), 
                                linestyle = param_ranges_legend[(param_name, param_group)]['linestyle'],
                                linewidth = 2,
                                label='_nolegend_' )
                            if xmin > xminbkg:
                                xmin = xminbkg
            # plot max bkg ifar line (same as min bkg ufar) 
            if opts.show_max_bkg:
                xmaxbkg = 1./min_bkg_ufar[zero_esid]
                loglog( [xmaxbkg,xmaxbkg], [ymin,ymax*1.2],
                    color = 'k',
                    linestyle = '-',
                    linewidth = 1,
                    label='_nolegend_' )
                if xmax < xmaxbkg:
                    xmax = xmaxbkg


            #
            #   Finalize plot limits
            #

            # check if xmin, xmax, ymax are still original values; if so, set to
            # arbitrary values (can happen if no foreground trigs and no show min/max
            # bkg)
            if xmin == numpy.inf: xmin = 0.001
            if xmax == -numpy.inf: xmax = 100.
            if ymax == 0.: ymax = 1000.
            # Re-set xmin and ymax to be slightly smaller/larger
            xmin = xmin * 0.8
            xmax = xmax * 1.4
            ymax = ymax * 1.2
            # if plot limits specified on command line, override values to whatever was specified
            # and check for consistency
            if opts.x_min: 
                xmin = opts.x_min
                if xmin >= xmax:
                    raise ValueError, "specified x-min greater than (auto) x-max; Nothing to plot!"
            if opts.x_max: 
                xmax = opts.x_max
                if xmax <= xmin:
                    raise ValueError, "specified x-max greater than (auto) x-min; Nothing to plot!"
            if opts.y_min: 
                ymin = opts.y_min
                if ymin >= ymax:
                    raise ValueError, "specified y-min greater than (auto) y-max; Nothing to plot!"
            if opts.y_max: 
                ymax = opts.y_max
                if ymax <= ymin:
                    raise ValueError, "specified y-max greater than (auto) y-min; Nothing to plot!"
            
            #
            #   Make Legend
            #

            # The legend just shows what colors correspond to what ifos
            # and what symbols correspond to what mass-bins. This is done by making
            # dummy plots out of the range of the plots strictly for the sake of the
            # legend. This is done as opposed to just giving labels for each plot
            # because it was found that doing the former caused the legend to be so
            # large it went off the plot.
            
            # set dummy coordinates
            xdum = 0.01*xmin
            ydum = 0.01*ymin

            # Set the ifo colors:
            # use the ifos listed in the max_bkg_fars to get the ifo colors
            lgnd = dict([ [ifos, InspiralUtils.get_coinc_ifo_colors(ifos)] \
                for (esid, ifos) in background.max_bkg_fars if esid == zero_esid])
            # if any ifos are in the foreground but not in the background, add those also
            if zero_esid in uncombined_fars[eid]:
                for (ifos, param_group) in uncombined_fars[eid][zero_esid]:
                    if ifos not in lgnd:
                        lgnd[ ifos ] = InspiralUtils.get_coinc_ifo_colors(ifos)
            # add the ifo colors to the legend
            for ifos, ifos_color  in lgnd.items():
                loglog( [xdum,xdum], [ydum,ydum],
                    color = ifos_color,
                    linewidth = 5,
                    label = ''.join(sorted(ifos)) )

            # Set the mass bin symbols and linestyles using param_ranges_legend
            for thisrange in param_ranges_legend:
                loglog( [xdum,xdum], [ydum,ydum],
                    color = 'k',
                    marker = param_ranges_legend[thisrange]['marker'],
                    linestyle = param_ranges_legend[thisrange]['linestyle'],
                    label = ' '.join([ thisrange[0], param_ranges_legend[thisrange]['range'] ]) )

            # make the legend
            legend()

            #
            #   Make the Plot
            #

            xlim(xmin,xmax)
            ylim(ymin,ymax)
            xlabel( r"Uncombined Inverse False Alarm Rate (yr)", size='x-large' )
            ylabel( r"Cumulative \#", size='x-large' )

            if opts.enable_output:
                name = "cumhist_uncombined_ifar"
                txt = "Cumulative Histogram of Uncombined IFAR"
                fname = InspiralUtils.set_figure_name(InspiralUtilsOpts, name)
                fname_thumb = InspiralUtils.savefig_pylal( filename=fname )
                fnameList.append(fname)
                tagList.append(txt)


    #
    #   Plot Combined IFAR
    #

    # plotting method is similar as uncombined plots; 
    # except that all triggers are plotted as triangles.
    # If combining across ifo groups (combine-fars in ligolw_cbc_cfar
    # was set to across_all) all triggers are blue. If not combining
    # across ifo groups (combine-fars was set to across_param_only)
    # the color of the triggers will correspond to what coinc ifos generated
    # them

    if opts.plot_combined:
        if opts.ifar_dist:
            if opts.verbose:
                print >> sys.stdout, "\tGenerating combined IFAR plot..."
            figure(figure_number)
            figure_number += 1
            xmin = numpy.inf
            xmax = -numpy.inf
            ymin = 0.8
            ymax = 0

            #
            #   Plot lightning bolts
            #
            if opts.plot_slides:
                if plot_datatype == "playground":
                    bkg_correction = 0.1
                if plot_datatype == "exclude_play":
                    bkg_correction = 0.9
                if plot_datatype == "all_data":
                    bkg_correction = 1.
                for esid in combined_fars[eid]:
                    # skip the zero-lag
                    if esid == zero_esid:
                        continue
                    # plot the rest as gray lines
                    for ifo_group in combined_fars[eid][esid]:
                        loglog( bkg_correction/combined_fars[eid][esid][ifo_group], 
                                combined_cumnum[ (eid, esid, ifo_group) ],
                                color = 'gray',
                                linestyle = '-',
                                alpha = 0.4,
                                label = '_nolegend_' )
                        # reset xmax to include loudest background trigger
                        if xmax < 1./combined_fars[eid][esid][ifo_group][-1]:
                            xmax = 1./combined_fars[eid][esid][ifo_group][-1]

            #
            #   Plot the expected background
            #

            xbkg = numpy.logspace( -8, 2, num=100, endpoint=True, base=10.0 )
            ybkg = frg_durs[eid] / xbkg
            loglog( xbkg, ybkg, 'k--', linewidth = 2, label = 'Expected Background' )
            
            # plot error
            bkgplus = ybkg + sqrt(ybkg)
            bkgminus = ybkg - sqrt(ybkg)
            bkgminus = where( bkgminus<=0, 1e-5, bkgminus ) # prevent (-) values
            xs, ys = poly_between( xbkg, bkgminus, bkgplus )
            fill( xs, ys, facecolor='y', alpha=0.4, label='$N^{1/2}$ errors' )
            if opts.show_two_sigma_error:
                bkgplus = ybkg + 2*sqrt(ybkg)
                bkgminus = ybkg - 2*sqrt(ybkg)
                bkgminus = where( bkgminus<=0, 1e-5, bkgminus ) # prevent (-) values
                xs, ys = poly_between( xbkg, bkgminus, bkgplus )
                fill( xs, ys, facecolor='y', alpha=0.2, label='$2N^{1/2}$ errors' )

      
            #
            #   Plot the foreground
            #

            if zero_esid in combined_fars[eid]:
                for ifo_group in combined_fars[eid][zero_esid]:
                    if ifo_group == "ALL_IFOS":
                        trigcolor = 'b'
                        lbl = "Combined Coincs"
                    else:
                        trigcolor = InspiralUtils.get_coinc_ifo_colors( ifo_group )
                        lbl = ' '.join([ "Combined", ''.join(sorted(ifo_group)) ])
                    loglog( 1./combined_fars[eid][zero_esid][ifo_group],
                            combined_cumnum[ (eid, zero_esid, ifo_group) ],
                            marker = '^',
                            markerfacecolor = trigcolor,
                            markeredgecolor = 'k',
                            linestyle = 'None',
                            alpha = 0.9,
                            label = lbl )
                    # if any FARs were zero, stick an arrow on their marker
                    if (eid, zero_esid, ifo_group) in comb_zero_cumnum:
                        xval = 1. / (min_bkg_ufar[ zero_esid ] * num_comb_cats[(eid, zero_esid,ifo_group)])
                        yval = comb_zero_cumnum[ (eid, zero_esid, ifo_group) ]
                        text( xval, yval, '$\Rightarrow$', ha = 'left', va = 'center', 
                            color = 'k', label='_nolegend_' )
                    # reset xmin, xmax, ymax
                    if xmin > 1./combined_fars[eid][zero_esid][ifo_group][0]:
                        xmin = 1./combined_fars[eid][zero_esid][ifo_group][0]
                    if xmax < 1./combined_fars[eid][zero_esid][ifo_group][-1]:
                        xmax = 1./combined_fars[eid][zero_esid][ifo_group][-1]
                    if ymax < combined_cumnum[(eid, zero_esid, ifo_group)][0]:
                        ymax = combined_cumnum[(eid, zero_esid, ifo_group)][0]
            # FIXME: make empty plot if no foreground


            #
            #   Finalize plot limits
            #

            # check if xmin, xmax, ymax are still original values; if so, set to
            # arbitrary values (can happen if no foreground trigs) 
            if xmin == numpy.inf: xmin = 0.001
            if xmax == -numpy.inf: xmax = 100.
            if ymax == 0.: ymax = 1000.
            # Re-set xmin and ymax to be slightly smaller/larger
            xmin = xmin * 0.8
            xmax = xmax * 1.4
            ymax = ymax * 1.2
            # if plot limits specified on command line, override values to whatever was specified
            # and check for consistency
            if opts.x_min: 
                xmin = opts.x_min
                if xmin >= xmax:
                    raise ValueError, "specified x-min greater than (auto) x-max; Nothing to plot!"
            if opts.x_max: 
                xmax = opts.x_max
                if xmax <= xmin:
                    raise ValueError, "specified x-max greater than (auto) x-min; Nothing to plot!"
            if opts.y_min: 
                ymin = opts.y_min
                if ymin >= ymax:
                    raise ValueError, "specified y-min greater than (auto) y-max; Nothing to plot!"
            if opts.y_max: 
                ymax = opts.y_max
                if ymax <= ymin:
                    raise ValueError, "specified y-max greater than (auto) y-min; Nothing to plot!"
                    
            xlim(xmin,xmax)
            ylim(ymin,ymax)
            xlabel( r"Inverse False Alarm Rate (yr)", size='x-large' )
            ylabel( r"Cumulative \#", size='x-large' )

            # Make the legend
            legend()

            #
            #   Make the Plot
            #

            if opts.enable_output:
                name = "cumhist_combined_ifar"
                txt = "Cumulative Histogram of Combined IFAR"
                fname = InspiralUtils.set_figure_name(InspiralUtilsOpts, name)
                fname_thumb = InspiralUtils.savefig_pylal( filename=fname )
                fnameList.append(fname)
                tagList.append(txt)

    #
    #   Create the html page for this experiment id
    #
    
    if opts.enable_output:
        if opts.verbose:
            print >> sys.stdout, "\tWriting html file and cache..."
        # FIXME: Add summary table to html output and followup once it's fixed
        html_filename = InspiralUtils.write_html_output( InspiralUtilsOpts, args, fnameList, tagList )
        InspiralUtils.write_cache_output( InspiralUtilsOpts, html_filename, fnameList )
    
    if opts.show_plot:
        show()

    #
    # Close the figures and go on to the next instrument time
    #

    for number in range(figure_number):
        close(number)


#
#   Finished cycling over experiments; exit
#
if opts.verbose:
    print >> sys.stdout, "Finished!"
sys.exit(0)

