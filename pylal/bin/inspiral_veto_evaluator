#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2008  Jake Slutsky, Chad Hanna, Kipp Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


"""
???
"""


import math
from optparse import OptionParser
import ConfigParser
import sys


import matplotlib
matplotlib.rcParams.update({
	"font.size": 8.0,
	"axes.titlesize": 10.0,
	"axes.labelsize": 10.0,
	"xtick.labelsize": 8.0,
	"ytick.labelsize": 8.0,
	"legend.fontsize": 8.0,
	"figure.dpi": 300,
	"savefig.dpi": 300,
	"text.usetex": True	# render all text with TeX
})
from matplotlib import figure
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas


from glue import lal
from glue import segments
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from glue.ligolw.utils import ligolw_add
from pylal import llwapp
from pylal.xlal.date import LIGOTimeGPS
from pylal import dqutils


__author__ = ""
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Speed Hacks
#
# =============================================================================
#


#
# replace Glue's pure Python LIGOTimeGPS class with pyLAL's C version
#


lsctables.LIGOTimeGPS = LIGOTimeGPS


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog [options] [file ...]",
		description = "This program probably does something useful."
	)
	parser.add_option("--clustered-trigger-cache", metavar = "filename", help = "Set the name of the LAL cache of the clustered trigger files (required).")
	parser.add_option("--snr-thresholds", metavar = "snr[,snr...]", help = "Comma-delimited list of SNR break-points (required).")
	parser.add_option("-c", "--config-file", metavar = "filename", help = "Specify the ihope .ini file from which to obtain configuration information (required).")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, filenames = parser.parse_args()

	if not options.clustered_trigger_cache:
		raise ValueError, "missing required option --clustered-trigger-cache"
	if not options.config_file:
		raise ValueError, "missing required option --config-file"
	if not options.snr_thresholds:
		raise ValueError, "missing required option --snr-thresholds"

	# Jake:  this probably needs to be changed to suit your needs
	options.clustered_trigger_cache = lal.Cache.fromfilenames([options.clustered_trigger_cache]).sieve(description = "SIRE_FIRST_FULL_DATA")

	options.snr_thresholds = map(float, options.snr_thresholds.split(","))

	return options, (filenames or [None])


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#


#
# get trigger list and analyzed segments from trigger files.  the
# program_name is the name of the program whose search_summary rows will be
# used to define the "analyzed_segments".  For lalapps_inspiral output the
# string is "inspiral", for lalapps_sire output the string is "sire".
#


def load_trigger_files(urls, program_name = "inspiral", verbose = False):
	#
	# load trigger files
	#


	clustered_xmldoc = ligolw_add.ligolw_add(ligolw.Document(), urls, verbose = verbose)


	#
	# find the sngl_inspiral table
	#


	sngl_inspiral_table = table.get_table(clustered_xmldoc, lsctables.SnglInspiralTable.tableName)


	#
	# extract set of unique instrument names from trigger list
	#


	instruments = set(sngl_inspiral_table.getColumnByName("ifo"))


	#
	# extract search summary "out" segments for lalapps_inspiral jobs
	#


	analyzed_segs = llwapp.segmentlistdict_fromsearchsummary(clustered_xmldoc, program = program_name).coalesce()


	#
	# check that the search_summary table has segments for all the
	# instruments represented in the trigger list
	#


	if set(sngl_inspiral_table.getColumnByName("ifo")) not in set(analyzed_segs.keys()):
		raise ValueError, "trigger table contains triggers for instruments not listed in the search_summary table"


	#
	# done
	#


	return sngl_inspiral_table, analyzed_segs


#
# get veto segment lists.  the return value is a giant nested dictionary.
# the outer-most dictionary's keys are instrument names, inside those are
# dictionaries of categories, insde those are glue.segments.segmentlistdict
# objects whose keys are data quality flag names and whose values are
# glue.segments.segmentlist objects.  like this:
#
#	return {
#		"H1": {
#			1: segments.segmentlistdict({
#				"OUT_OF_LOCK":
#					segments.segmentlist([])
#			}),
#			2: segments.segmentlistdict({
#			}),
#			3: segments.segmentlistdict({
#			}),
#			4: segments.segmentlistdict({
#			})
#		}
#	}
#


def load_vetos(options, verbose = False):
	# This is a hack!  Namely the ifos and categories are hardcoded.  
	# Should these parameters be
	# command line arguments or are they derived from something else?

	if verbose:
		print >>sys.stderr, "loading veto segments ...",

	cp = ConfigParser.ConfigParser()
	cp.read(options.config_file) 
	ifolist = ['H1','H2','L1']
	catlist = [1, 2, 3, 4]
	output = {}
	for ifo in ifolist:
		if verbose:
			print >>sys.stderr, ifo,
		output[ifo] = {}
		dqfilepath = dqutils.get_dq_file(ifo)
		dqfile = open(dqfilepath,'r')
		dqseglistdict = dqutils.fromDQsegments(dqfile)
		for cat in catlist:
			dqflagsfile = open(cp.get('segments',ifo.lower()+'-cat-'+str(cat)+'-veto-file'),'r')
			dqwindows = dqutils.from_veto_file(dqflagsfile,flags_have_ifo_colon=True)
			output[ifo][cat] = dqutils.apply_veto_windows(dqseglistdict,dqwindows)

	if verbose:
		print >>sys.stderr

	return output


#
# =============================================================================
#
#                                  Arithmetic
#
# =============================================================================
#


#
# intersect veto segments with analyzed segments
#


def trim_vetos(vetos, analyzed_segments):
	"""
	Performs an in-place intersection of each veto segment list with
	the list of analyzed segments from the same instrument.  Any list
	of veto segments for instruments that were not analyzed are
	removed.
	"""
	for veto_instrument, veto_categories in vetos.items():
		if veto_instrument not in analyzed_segments:
			del vetos[veto_instrument]
			continue
		for veto_category, veto_seglistdict in veto_categories.items():
			for veto_flag, veto_seglist in veto_seglistdict.items():
				veto_seglist &= analyzed_segments[veto_instrument]
	return vetos


#
# Blah blah blah.
#


def get_triggers(triggers, instrument, min_snr):
	return [trigger for trigger in triggers if trigger.ifo == instrument and trigger.snr >= min_snr]


def veto_triggers(triggers, vetosegs):
	vetoed = []
	nonvetoed = []
	for trigger in triggers:
		if trigger.get_end() in vetosegs:
			vetoed.append(trigger)
		else:
			nonvetoed.append(trigger)
	return vetoed, nonvetoed


def veto_efficiency(triggers, vetosegs):
	n = 0
	for trigger in triggers:
		if trigger.get_end() in vetosegs:
			n += 1
	# "or 1" --> efficiency is 0% when there are no triggers
	return float(n) / (len(triggers) or 1)


def veto_use_fraction(triggers, vetosegs):
	# make a copy so we can modify it
	vetosegs = segments.segmentlist(vetosegs)

	N = len(vetosegs)
	for trigger in triggers:
		try:
			del vetosegs[vetosegs.find(trigger.get_end())]
		except ValueError:
			pass
	# "or 1" --> use fraction is 0% when there are no veto segments
	return float(N - len(vetosegs)) / (N or 1)


def veto_dead_time_fraction(veto_seglist, analyzed_seglist):
	return abs(veto_seglist) / abs(analyzed_seglist)


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#


#
# A place to store results for a single ifo, a single veto category, a
# single veto flag.
#


class Results(object):
	def __init__(self, snr_thresholds, veto_seglist, analyzed_seglist, triggers):
		self.snr_thresholds = snr_thresholds
		self.dead_time_fraction = veto_dead_time_fraction(veto_seglist, analyzed_seglist)
		self.efficiency = []
		self.use_fraction = []
		for snr_threshold in snr_thresholds:
			selected_triggers = [trigger for trigger in triggers if trigger.snr >= snr_threshold]
			self.efficiency.append(veto_efficiency(selected_triggers, veto_seglist))
			self.use_fraction.append(veto_use_fraction(selected_triggers, veto_seglist))


#
# plot
#


class Plot(object):
	def __init__(self, x_label, y_label):
		self.fig = figure.Figure()
		FigureCanvas(self.fig)
		# 6.5" wide, golden ratio high
		self.fig.set_size_inches(6.5, 6.5 / ((1 + math.sqrt(5)) / 2))
		self.axes = self.fig.gca()
		self.axes.grid(True)
		self.axes.set_xlabel(x_label)
		self.axes.set_ylabel(y_label)


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


#
# command line
#


options, filenames = parse_command_line()


#
# input
#


sngl_inspiral_table, analyzed_segments = load_trigger_files([cache_entry.url for cache_entry in options.clustered_trigger_cache], program_name = "sire", verbose = options.verbose)


vetos = load_vetos(options, verbose = options.verbose)


#
# intersect the veto segments with the analyzed segments
#


if options.verbose:
	print >>sys.stderr, "intersecting vetos with analyzed segments ..."
trim_vetos(vetos, analyzed_segments)


#
# loops.  the "results" thing is really friggin ugly.  it's a nested
# dictionary of instances of the Results class.  For example
#
#	results["H1"][1]["OUT_OF_SCIENCE"]
#
# is the Results instance for the H1, category 1, "OUT_OF_SCIENCE" flag.
#


results = {}

for veto_instrument, veto_categories in vetos.items():

	triggers = [trigger for trigger in sngl_inspiral_table if trigger.ifo == veto_instrument]

	results[veto_instrument] = {}

	for veto_category, veto_seglistdict in veto_categories.items():

		results[veto_instrument][veto_category] = {}

		efficiency_plot = Plot("SNR Threshold", "Veto Efficiency")

		for veto_flag, veto_seglist in veto_seglistdict.items():
			if options.verbose:
				print >>sys.stderr, "%s, category %d, %s" % (veto_instrument, veto_category, veto_flag)

			results[veto_instrument][veto_category][veto_flag] = Results(options.snr_thresholds, veto_seglist, analyzed_segments[veto_instrument], triggers)

			x = results[veto_instrument][veto_category][veto_flag].snr_thresholds
			y = results[veto_instrument][veto_category][veto_flag].efficiency
			efficiency_plot.axes.plot(x, y)

		efficiency_plot.axes.legend([s.replace("_", "\_") for s in veto_seglistdict.keys()])
		efficiency_plot.axes.set_ylim((0.0, 1.0))

		efficiency_plot.fig.savefig("veto_efficiency_%s_%d.png" % (veto_instrument, veto_category))
