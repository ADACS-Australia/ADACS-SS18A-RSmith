#!/usr/bin/env python

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


usage = \
'''
Prints the largest triggers in either foreground or background along with
relevant statistics and parameters to stdout.
'''

from optparse import OptionParser
try:
    import sqlite3
except ImportError:
    # pre 2.5.x
    from pysqlite2 import dbapi2 as sqlite3
import sys
import os

from glue.ligolw import dbtables
from glue.ligolw.utils.ligolw_sqlite import extract

from pylal import ligolw_sqlutils as sqlutils

__author__ = "Collin Capano <cdcapano@physics.syr.edu>"
__date__ = "$Date$" 
__version__ = "$Revision$"

# =============================================================================
#
#                                   Set Options
#
# =============================================================================


def parse_command_line():
    """
    Parse the command line, return options and check for consistency among the
    options.
    """
    parser = OptionParser( version = "", usage = usage )

    # following are related to file input and output naming
    parser.add_option( "-i", "--input", action = "store", type = "string",
        default = None,                  
        help = 
            "Input database to read. Can only input one at a time." 
            )
    parser.add_option( "-t", "--temp-space", action = "store", type = "string",
        default = None, metavar = "path",
        help = 
            "Location of local disk on which to do work. " +
            "This is used to enhance performance in a networked " +
            "environment. As this program doesn't make any changes to " +
            "the database, this isn't needed if using in a local environment." 
            )
    parser.add_option( "-v", "--verbose", action = "store_true", default = False,
        help = 
            "Print the SQLite query that is used to stdout." 
            )
    # following are generic inspiral_sql options
    parser.add_option( "", "--param-name", metavar = "PARAMETER",
        action = "store", default = None,
        help = 
            "Can be any parameter in the coinc_inspiral table. " +
            "Specifying this and param-ranges will only select " +
            "triggers that fall within the parameter ranges. " 
            )
    parser.add_option( "", "--param-ranges", action = "store", default = None,
        metavar = " [ LOW1, HIGH1 ); ( LOW2, HIGH2]; etc.",
        help = 
            "Requires --param-name. Specify the parameter ranges " +
            "to select triggers in. A '(' or ')' implies an open " +
            "boundary, a '[' or ']' a closed boundary. To specify " +
            "multiple ranges, separate each range by a ';'. If " +
            "multiple ranges are specified, the triggers picked for " +
            "ranking will come from the union of the ranges."
            )
    parser.add_option( "", "--exclude-coincs", action = "store", type = "string", default = None,
        metavar = " [COINC_INSTRUMENTS1 + COINC_INSTRUMENTS2 in INSTRUMENTS_ON1];"
            "[ALL in INSTRUMENTS_ON2]; etc.",
        help = 
            "Exclude coincident types in specified detector times, " +
            "e.g., '[H2,L1 in H1,H2,L1]'. Some rules: " +
                "* Coinc-types and detector time must be separated by " +
                "an ' in '. When specifying a coinc_type or detector " +
                "time, detectors and/or ifos must be separated by " +
                "commas, e.g. 'H1,L1' not 'H1L1'. " +
                "* To specify multiple coinc-types in one type of time, " +
                "separate each coinc-type by a '+', e.g., " +
                "'[H1,H2 + H2,L1 in H1,H2,L1]'. " +
                "* To exclude all coincs in a specified detector time " +
                "or specific coinc-type in all times, use 'ALL'. E.g., " +
                "to exclude all H1,H2 triggers, use '[H1,H2 in ALL]' " +
                "or to exclude all H2,L1 time use '[ALL in H2,L1]'. " + 
                "* To specify multiple exclusions, separate each " +
                "bracket by a ';'. " +
                "* Order of the instruments nor case of the letters " +
                "matter. So if your pinky is broken and you're " +
                "dyslexic you can type '[h2,h1 in all]' without a " +
                "problem." 
            )
    parser.add_option( "", "--include-only-coincs", action = "store", type = "string", default = None,
        metavar = " [COINC_INSTRUMENTS1 + COINC_INSTRUMENTS2 in INSTRUMENTS_ON1];" +
            "[ALL in INSTRUMENTS_ON2]; etc.",
        help =
            "Opposite of --exclude-coincs: only rank the specified coinc types. " +
            "To avoid confusing overlaps, cannot specify both --exclude-coincs " +
            "and --include-only-coincs." 
            )
    # following are options specific to this program
    parser.add_option("", "--trigger-type", action = "store", type = "string", default = None,
        metavar = "zero_lag OR time_slide",
        help =
            "Required.  Options are 'zero_lag' or 'time_slide'. " +
            "Specify whether want to print triggers from " +
            "zero-lag or time-slides." 
            )
    parser.add_option( "", "--ranking-stat", action = "store", type = "string", default = None,
        help =
            "Requried. Statistic to rank by (can be any column " +
            "in the coinc_inspiral table)." 
            )
    parser.add_option( "", "--rank-by", action = "store", type = "string", default = None, 
        metavar = "ASC or DESC",
        help = 
            "Requried. Options are ASC or DESC. " +
            "This specifies whether to rank triggers by ascending (ASC) or " +
            "descending (DESC) stat value." 
            )
    parser.add_option( "", "--limit", action = "store", type = "int", default = 10,
        help =
            "Specify how many triggers to print. Default is 10. "
            )
    parser.add_option( "", "--convert-duration", action = "store", type = "string", default = "s",
        metavar = "s, min, hr, d, OR yr",
        help =
            "Convert the duration from seconds to a different unit of time. Options are: " +
            "s (seconds), min (minutes), hr (hours), d (days), or yr (years). " +
            "(Setting to s is the equivalent of a no-op.)"
            )

    (options, args) = parser.parse_args()

    # check for required options and for self-consistency
    if not options.input:
        raise ValueError, "No input specified."
    if not options.ranking_stat:
        raise ValueError, "No ranking stat specified."
    if not (options.rank_by.upper() == 'ASC' or options.rank_by.upper() == 'DESC'):
        raise ValueError, "--rank-by must be specified and set to either ASC or DESC."
    if options.exclude_coincs and options.include_only_coincs:
        raise ValueError, "Cannot specify both --exclude-coincs and --include-only-coincs."
    if not (options.trigger_type.lower() == 'zero_lag' or options.trigger_type.lower() == 'time_slide'):
        raise ValueError, "--trigger-type must be specified and to either zero_lag or time_slide."
    if not (options.convert_duration == "s" or options.convert_duration == "min" or 
        options.convert_duration == "hr" or options.convert_duration == "d" or
        options.convert_duration == "yr"):
        raise ValueError, "--convert-duration must be either 's', 'min', 'hr', 'd', or 'yr'"


    return options, sys.argv[1:]

# =============================================================================
#
#                                     Main
#
# =============================================================================

opts, args = parse_command_line()

# get input database filename
filename = opts.input
if not os.path.isfile( filename ):
    raise ValueError, "The input file, %s, cannot be found." % filename

#
#   Set filter
#

# Set whether looking at foreground or background
if opts.trigger_type.lower() == 'zero_lag':
    opts.trigger_type = str(1)
else:
    opts.trigger_type = str(0)

in_this_filter = ' '.join([ 'experiment_summary.zero_lag ==', opts.trigger_type ])

# Get param and param-ranges if specified
if opts.param_name:
    param_filters = sqlutils.parse_param_ranges( 'coinc_inspiral', opts.param_name, 
        opts.param_ranges, verbose = opts.verbose ).get_param_filters()
    # since want triggers that fall within all the parameters, concatenate
    # all param ranges
    param_filters = [ ''.join([ '(', filter, ')' ]) for filter in param_filters ]
    param_filters = ' OR '.join( param_filters )
    in_this_filter = ' AND '.join([ in_this_filter, param_filters ])

# Get exclude_coincs list if specified
if opts.exclude_coincs:
    exclude_coinc_filters = sqlutils.parse_coinc_options( opts.exclude_coincs, 
        verbose = opts.verbose ).get_coinc_filters()
    # concatenate exclude_coinc_filters
    exclude_coinc_filters = ' AND '.join( exclude_coinc_filters )
    # add to in_this_filter
    in_this_filter = ' AND NOT '.join([ in_this_filter, exclude_coinc_filters ])

# Or get include_only_coincs list if specified
if opts.include_only_coincs:
    include_coinc_filters = sqlutils.parse_coinc_options( opts.include_only_coincs, 
        verbose = opts.verbose ).get_coinc_filters()
    # concatenate include_coinc_filters
    include_coinc_filters = ' AND '.join( include_coinc_filters )
    # add to in_this_filter
    in_this_filter = ' AND '.join([ in_this_filter, include_coinc_filters ])


# Setup working databases and connections

if opts.verbose and opts.temp_space: 
    print >> sys.stdout, "Setting up temp. database..."

working_filename = dbtables.get_connection_filename( 
    filename, tmp_path = opts.temp_space, verbose = opts.verbose )
connection = sqlite3.connect( working_filename )
dbtables.DBTable_set_connection( connection )

# join experiment tables to coinc_inspiral table
join_conditions = sqlutils.join_experiment_tables_to_coinc_inspiral()

# append coinc_inpsiral table name to ranking stat
opts.ranking_stat = '.'.join([ 'coinc_inspiral', opts.ranking_stat ])

# establish what units will be converting duration to; this has to be done
# by defining a function which calls sqlutils.convert_duration with the desired
# conversion. This function is then sqlitized so that it just takes one argument,
# the duration, and automatically converts. We do this because we cannot set the
# appropiate conversion flag from within the sql statement

def convert_duration( duration ):
    return sqlutils.convert_duration( duration, opts.convert_duration )
connection.create_function( 'convert_duration', 1, convert_duration )
    
# Set up sqlquery
sqlquery = ' '.join([
        'SELECT experiment.instruments, convert_duration(experiment_summary.duration), coinc_inspiral.*',
        'FROM coinc_inspiral',
        join_conditions,
        'WHERE', in_this_filter,
        'ORDER BY', opts.ranking_stat, opts.rank_by.upper(), 
        'LIMIT', `opts.limit` ])

if opts.verbose:
    print >> sys.stdout, "\tSqlite query is:"
    print >> sys.stdout, sqlquery
    print >> sys.stdout, "\tResults are:"

info = connection.cursor().execute( sqlquery ).fetchall()

# Get list of column names from coinc_inspiral table
column_names = ' || '.join( sqlutils.get_column_names_from_table( connection, 'coinc_inspiral' ) )

# append experiment.instruments and duration to column names
if opts.trigger_type == str(1):
    durname = 'zero-lag duration (' + opts.convert_duration + ')'
else:
    durname = 'slide duration (' + opts.convert_duration + ')'

column_names = ' '.join([ '||', 'instruments_on', '||', durname, '||', column_names, '||' ])
print >> sys.stdout, column_names

# print data
for row in info:
    row = ' || '.join(str(data) for data in row)
    print >> sys.stdout, "|| %s ||" % row

# close connection and exit
connection.close()
# discard the working_filename; if a temporary database was not
# created in temp_space (opts.tmp_space), this will do nothing. If a temporary database
# was created, however, this will delete it. (see dbtables.py for more info)
dbtables.discard_connection_filename( filename, working_filename, verbose = opts.verbose)

if opts.verbose and opts.temp_space:
    print >> sys.stdout, "Finshed!"

sys.exit(0)
