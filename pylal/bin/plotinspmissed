#!/usr/bin/python

__Id__ = "$Id$"
__author__ = "Darren Woods and Stephen Fairhurst <sfairhurs@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]
__name__ = "plotinspmissed"
__title__ = "Found and Missed plots for triggers"

import sys, os, re, glob, exceptions
from types    import *
from optparse import *
from matplotlib.ticker import FormatStrFormatter
from glue import segments
from glue import segmentsUtils
from glue import lal
from glue.ligolw import lsctables
from pylal import SnglInspiralUtils
from pylal import CoincInspiralUtils
from pylal import SimInspiralUtils
from pylal import InspiralUtils
import numpy
from pylal import followup_missed

#######################################################################
def isSummValue(name, attrs):
  return lsctables.IsTableProperties(lsctables.SummValueTable, name, attrs)

def readFiles(fList):
  """
  read in the SummInspiralTables from a list of files
  @param fList:       list of input files
  """
  output = {}
  if not fList:
    return output
  for thisFile in fList:
    doc = ligolw.Document()
    # read in SummValueTable
    ligolw.make_parser(ligolw.PartialLIGOLWContentHandler(doc, \
        isSummValue)).parse(file(thisFile))
    for row in doc.childNodes[0]:
      if row.name == 'inspiral_effective_distance':
        if not output.has_key(row.ifo):
          output[row.ifo] = lsctables.New(lsctables.SummValueTable)
        output[row.ifo].append(row)
  return output


def printMissed( misDict, ifo=None):

  print "\nMissed Distance in " + ifo + " is " + \
        str(misDict.eff_dist_h)+ ' Mpc'
  print "GPS time: %9d.%9d" % \
        (misDict.geocent_end_time, misDict.geocent_end_time_ns)
  print "L/H Distance ratio is " + \
        str(misDict.eff_dist_l/misDict.eff_dist_h)
  print "Chirp mass is %.2f" % (misDict.mchirp)
  print "Mass-pair is %.2f + %.2f " % (misDict.mass1, misDict.mass2)


##############################
def createPlot( foundx, foundy, missedx, missedy, \
                titleText, xlabelText, ylabelText):

  figure()
  plot( foundx, foundy, \
        'bo', markerfacecolor='None',\
        markeredgecolor='b',markersize=10, markeredgewidth=1)

  plot( missedx, missedy, \
        'ro', markerfacecolor='None',\
        markeredgecolor='r',markersize=10, markeredgewidth=1)
  
  if inspiralFiles:
    semilogy(startTime, horizon, 'g.', label='Horizon (Mpc)',
             linewidth=1)

  if opts.y_min:
    ylim(ymin=opts.y_min)
  if opts.y_max:
    ylim(ymax=opts.y_max)
    

  title(titleText, size='x-large')
  xlabel(xlabelText, size='x-large')
  ylabel(ylabelText, size='x-large')
  grid(True)


def getData( table, xname, yname, ifo  ):

  if xname=='time':
    xp= [ t-opts.time_offset \
          for t in viz.timeindays(viz.readcol( table,"end_time", ifo)) ]
    legx = "End time (in days)"
  elif xname == 'mtotal':    
    xp = viz.readcol( table,"mass1")+viz.readcol( table,"mass2")
    legx = "Total mass"
  else:
    xp = viz.readcol( table,xname)
    legx = xname
  

  if yname == 'eff_dist':
    yp = viz.readcol( table,"eff_dist", ifo )
    legy = "Effective distance"
  else:
    yp = viz.readcol( table,yname)
    legy = yname

  return xp, yp, legx, legy

def savePlot(opts, filePart, tag ):
       
  fname = InspiralUtils.set_figure_name(opts, filePart)
  fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
                                            dpi_thumb=opts.figure_resolution)
  fnameList.append(fname)
  tagList.append( tag )

def createImageMap(opts, missedInj, ifo, filename):
  """
  This function will do a followup on some or all missed injections
  by using the class FollowupMissed in followup_missed.py.
  This will create a html page containing informations and trigger-time series
  of the missed injection. Also, this function adds an ImageMap to the
  main html file
  @param missedInj: sim_inspiral table of a missed injection that might be followed up
  @param ifo: The IFO corresponding to this missed injection
  @param axes: The axes from the main picture to get the coordinates right
  @param filename: The original filename; used to create the ImageMap picture
  @param description: The tag of the injction run
  """

  # reset the number and the tag
  followup.reset()
  followup.setTag( filename )
  
  # create the name of the ImageMap
  picname = "Images/"+opts.prefix + "_"+filename +"_map"+\
            opts.suffix + ".png"

  # create a mapDist
  mapDict ={'object':picname, \
            'text':'Click on a filled circle to go to the followup page',\
            'xCoords':[], 'yCoords':[], 'links': []}

  ## get the scaling right
  # coordinates of the actual picture in the image
  boundFigX = [100.0,720.0]
  boundFigY = [540.0, 60.0]

  # limits on the axes for the image
  axes=gcf().axes[0]
  rangeFigX = axes.get_xlim()
  rangeFigY = log10( axes.get_ylim() )

  # calculating scaling factors
  slopeX = (boundFigX[1]-boundFigX[0])/(rangeFigX[1]-rangeFigX[0])
  interX = boundFigX[1] - slopeX*rangeFigX[1]
  slopeY = (boundFigY[1]-boundFigY[0])/(rangeFigY[1]-rangeFigY[0])
  interY = boundFigY[1] - slopeY*rangeFigY[1]

  # figure out the missed injections to be followed up
  if opts.followup_number:

    # get the distances and sort them
    distVector = viz.readcol( missedInj, 'eff_dist', ifo )
    index = distVector.argsort()
    n=min( len(distVector), opts.followup_number)
    missedInjUse = [missedInj[index[i]] for i in range(n)]
  else:
    # use the estimated distance curve
    missedInjUse = []
    for inj in missedInj:
      dist20 = getattr( opts, "followup_dist_%s" % ifo[0].lower() )
      estDist = followup.estimatedDistance( inj.mass1, inj.mass2, dist20)
      if getattr( inj, 'eff_dist_'+ifo[0].lower())<estDist:
        missedInjUse.append( inj )

  # loop over all missed injections
  for inj in missedInjUse:
    
    # do the followup and create the followup page
    followuphtml = followup.followup( inj, ifo , opts.followup_tag)
    # get the coordinates of this missed injection
    totalMass = inj.mass1+inj.mass2
    effDist = getattr( inj, 'eff_dist_'+ifo[0].lower())
    effDistLog = log10(effDist)
    px = int( interX+slopeX*totalMass )
    py = int( interY+slopeY*effDistLog )

    # highlight the clickable missed ones
    plot( [totalMass], [effDist], 'ro', markerfacecolor = 'r', markersize=10)

    # add the point and the link to the mapDict
    mapDict['xCoords'].append( px )
    mapDict['yCoords'].append( py )
    mapDict['links'].append( followuphtml )
    
  # save the figure (containing filled circles)
  savefig( opts.output_path+picname )

  # add mapDict to the map vector
  mapList.append( mapDict )


#################################################################

##############################################################################
# parse options and arguments
usage = """Usage: %prog [options] [trigs1 missed1 trigs2 missed2]

Generate found and missed trig plots

plotinspmissed --mtotal-dist-linear --verbose  --output-path plots/ --mchirp-dist-log  --time-dist  --gps-start-time 866088014 --mchirp-dist-linear --gps-end-time 866109614 --cache-file ihope.cache --enable-output  --mtotal-dist-log  --ifo H1 --legend --found-pattern COIRE_INJECTIONS_*_FOUND_SECOND_*_INJ* --missed-pattern COIRE_INJECTIONS_*_MISSED_SECOND_*_INJ*
"""


def parse_command_line():
  """
  Parser function dedicated
  """
  parser = OptionParser( usage=usage, \
      version= "%prog CVS\n" +
      "$Id$\n" +
      "$Name$\n")
# opts.eff_vs_eff_dist, opts.eff_vs_distance opts.eff_vs_snr:  opts.eff_vs_snr_chi
  parser = OptionParser( usage=usage, version="%prog CVS $Id$ \n" + "$Name$\n" )
  parser.add_option("-a","--time-dist",action="store_true",default=False,\
      help="plot dist v trig end time" )
  parser.add_option("-b","--mchirp-dist-log",action="store_true",default=False,\
      help="plot dist v mchirp (log dist axis)" )
  parser.add_option("-c","--mtotal-dist-log",action="store_true",default=False,\
      help="plot dist v mtotal (log dist axis)" )
  parser.add_option("-d","--mchirp-dist-linear",action="store_true",default=False,\
      help="plot dist v mchirp (linear dist axis)" )
  parser.add_option("-e","--mtotal-dist-linear",action="store_true",default=False,\
      help="plot dist v mtotal (linear dist axis)" )
  parser.add_option("-f","--eff-vs-eff-dist",action="store_true",default=False,\
      help="efficiency plot versus effective distance (logarithmic dist axis)" )
  parser.add_option("-g","--eff-vs-distance",action="store_true",default=False,\
      help="efficiency plot versus distance (logarithmic dist axis)" )
  parser.add_option("-T","--time-offset",action="store",type="float",\
      default=0.0,metavar=" TIME-OFFSET",\
      help="time offset when plotting times")
  parser.add_option("-s","--show-plot",action="store_true",default=False,\
      help="display the figures on the terminal" )
  parser.add_option("-t","--title",action="store",type="string",\
      default="", metavar=" TITLE", help="add more info to standard title" )
  parser.add_option("-l","--legend",action="store_true",default=False,\
      help="include legend on plot" )  
  parser.add_option("-u","--user-tag",action="store",type="string",\
      default=None, metavar=" USERTAG",\
      help="The user tag used in the name of the figures" )
  parser.add_option("","--ifo-tag",action="store",type="string",\
      default=None, metavar=" IFOTAG",\
      help="The ifo tag used in the name of the figures (e.g. SECOND_H1H2L1)")      
  parser.add_option("","--ifo-times",action="store",type="string",\
      default=None,metavar="IFOS",\
      help="sets ifo times for which plots will be made (e.g. H1H2L1)" )
  parser.add_option("-S","--same-symbol",action="store",type="string",\
      default=None,  metavar="SAME-SYMBOL",\
      help="enables the use of a same symbol")
  parser.add_option("-V","--veto-file",action="store",type="string",\
      default=None,metavar=" FNAME",\
      help="read in segments from FNAME (assumed segwizard format)")
  parser.add_option("-i","--ifo",action="store",type="string",default=None,\
      help="specify the ifo (otherwise will loop over all IFOs in ifo-times")
  parser.add_option("-M","--min-distance",action="store",type="int",\
      default=None, metavar=" MIN_DIST",\
      help="provide time and dist of all missed injections closer than MIN_DIST [Mpc]")
  parser.add_option("-r","--add-horizon",action="store",type="string",\
      default=None,metavar="INSP",\
      help="show the inspiral horizon obtained from files matching the glob INSP")
  parser.add_option("-p","--y-min",action="store",type="float",\
      default=None,metavar="YMIN",\
      help="set the y min range to YMIN")
  parser.add_option("-q","--y-max",action="store",type="float",\
      default=None,metavar="YMAX",\
      help="set the y max range to YMAX")
  parser.add_option("", "--found-pattern",
    help="sieve the cache for found injection files with this pattern")
  parser.add_option("", "--missed-pattern",
    help="sieve the cache for missed injection files with this pattern")
  parser.add_option("", "--cache-file", help="LAL cache of relevant files")
  parser.add_option("-P","--output-path",action="store",\
      type="string",default="",  metavar="PATH",\
      help="path where the figures would be stored")
  parser.add_option("-O","--enable-output",action="store_true",\
      default="false",  metavar="OUTPUT",\
        help="enable the generation of the html and cache documents")
  parser.add_option("","--gps-start-time",action="store",\
      type="int",  metavar="GPSSTARTTIME",\
      help="gps start time (for naming figure and output files")
  parser.add_option("","--gps-end-time",action="store",\
      type="int",  metavar=" GPSENDTIME",\
      help="gps end time (for naming figure and output files")
  parser.add_option("-v","--verbose",action="store_true",\
      default=False,help="print information" )
  parser.add_option("", "--figure-resolution",action="store",type="int",\
      default=50, metavar="resolution of the thumbnails (50 by default)", \
      help="read a file of a particular description  from cache file" )
  parser.add_option("","--do-followup",action="store_true",\
      default=False,help="activates the followup of missed injections" )
  parser.add_option("","--followup-dist-l",action="store",\
      type="float",default=None,  metavar="FOLLOWUPDISTL",\
      help="distance for a binary with 20 Solarmasses in L")
  parser.add_option("","--followup-dist-h",action="store",\
      type="float",default=None,  metavar="FOLLOWUPDISTH",\
      help="distance for a binary with 20 Solarmasses in H")
  parser.add_option("","--followup-dist-g",action="store",\
      type="float",default=None,  metavar="FOLLOWUPDISTG",\
      help="distance for a binary with 20 Solarmasses in G")
  parser.add_option("","--followup-dist-v",action="store",\
      type="float",default=None,  metavar="FOLLOWUPDISTV",\
      help="distance for a binary with 20 Solarmasses in V")
  parser.add_option("","--followup-number",\
      type="int",default=None,  metavar="FOLLOWUPNUMBER",\
      help="number of closest missed injections to be followed up")
  parser.add_option("","--followup-flow",action="store",\
      type="float",default=40.0,  metavar="FOLLOWUPFLOW",\
      help="specifies the lower cutoff frequency")
  parser.add_option("","--followup-exttrig",action="store_true",\
      default=False,help="set the exttrig flag for followup" )
  parser.add_option("","--followup-vetofile-l1",action="store",\
      type="string",default=None,  metavar="FOLLOWUPVETOL1",\
      help="vetofile containing veto times for L1")
  parser.add_option("","--followup-vetofile-h1",action="store",\
      type="string",default=None,  metavar="FOLLOWUPVETOH1",\
      help="vetofile containing veto times for H1")
  parser.add_option("","--followup-vetofile-h2",action="store",\
      type="string",default=None,  metavar="FOLLOWUPVETOH2",\
      help="vetofile containing veto times for H2")
  parser.add_option("","--followup-vetofile-g1",action="store",\
      type="string",default=None,  metavar="FOLLOWUPVETOG1",\
      help="vetofile containing veto times for G1")
  parser.add_option("","--followup-vetofile-v1",action="store",\
      type="string",default=None,  metavar="FOLLOWUPVETOV1",\
      help="vetofile containing veto times for V1")
  parser.add_option("","--followup-tag",action="store",\
      type="string",default=None,  metavar="FOLLOWUPTAG",\
      help="a tag to select the proper xml files in a cache fie. Should be the injecion tag ideally.")
  parser.add_option("", "--html-for-cbcweb",action="store",\
      default=False, metavar = "CVS DIRECTORY", help="publish the html "\
      "output in a format that can be directly published on the cbc webpage "\
      "or in CVS. This only works IF --enable-output is also specified. The "\
      "argument should be the cvs directory where the html file will be placed "\
      "Example: --html-for-cbcweb protected/projects/s5/yourprojectdir")
    
  
  command_line = sys.argv[1:]
  (options,args) = parser.parse_args()

  # test the input options
  if not options.ifo_times:
    raise ValueError, "--ifo-times must be provided"

  return options, sys.argv[1:]


# ============================================================================
# -- get command line arguments
opts, args = parse_command_line()

# Initialise: add prefix and suffix to the opts strucutre. To be used for filenames
opts = InspiralUtils.initialise(opts, __name__, __version__)

# -- set the proper color code
colors = InspiralUtils.colors
figure_number = 0  # used for the figure label (showplot)
fnameList = []   # use for the cache file
tagList= []   # use for the cache file
mapList = []  # vector containing data for creating maps

# to avoid  display problem when show plot is not used
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from pylal import viz


# do something if a title was given
if opts.title != "":
  opts.title += ": "
  
# check at least one trig file was specified
if opts.cache_file:
  cache = lal.Cache.fromfile(open(opts.cache_file))
  injcache = cache.sieve(description = opts.found_pattern).sieve(ifos=opts.ifo_times, exact_match=True)
  miscache = cache.sieve(description = opts.missed_pattern).sieve(ifos=opts.ifo_times, exact_match=True)
  injFiles = injcache.checkfilesexist()[0].pfnlist()
  misFiles = miscache.checkfilesexist()[0].pfnlist()

  if opts.verbose:
    print "\n"+__name__+"... reading the following found files" 
    for file in injFiles:
      print file
    print "\n"+__name__+"... reading the following missed files \n"
    for file in misFiles:
      print file
  if len(injFiles) == 0:
    print >>sys.stderr, "no found files match sieve pattern"
    sys.exit(1)
  
else:

  if not args:
    print >>sys.stderr, "One trig-file must be specified at least"
    print >>sys.stderr, "Enter 'plotinspmissed --help' for usage"
    sys.exit(1)
    
  # check if trig and missed inj files are paired
  # then fill lists of injection and missed injection files
  if len(args)<2:
    print >>sys.stderr, "At least one trigger file and one missed"\
          " file must be specified"
    print >>sys.stderr, "Enter 'plotinspmissed --help' for usage"
    print usage
    sys.exit(1)

  elif len(args)%2:
    print >>sys.stderr, "The number of files specified must be even"
    print >>sys.stderr, "Enter 'plotinspmissed --help' for usage"
    print usage
    sys.exit(1)
  
  else:
    injFiles = []
    misFiles = []
    # create the list of found and missed files
    for i in range(len(args)):
      if i%2:
        misFiles.append(args[i])
      else:
        injFiles.append(args[i])


# create the ifoList
ifoList = []
for i in range(len(opts.ifo_times)/2):
  ifoList.append(opts.ifo_times[2*i:2*i+2])


# check the followup input parameters
if opts.do_followup:
  if not opts.followup_number:
    for ifo in ifoList:
      if not getattr( opts, "followup_dist_%s" % ifo[0].lower() ):
        print >>sys.stderr, "ERROR: If --followup-number is not given "
        print >>sys.stderr, "--followup-dist-%s must be specified \n" %\
              ifo[0].lower() 
        print usage
        sys.exit(1)

# selecet one IFO if required
if opts.ifo:
  ifoList=[opts.ifo]

  
#######################################################################
# identify the inspiral files if we want the horizon
inspiralFiles = None
if opts.add_horizon:
  inspiralFiles = glob.glob(opts.add_horizon)
  if not inspiralFiles:
    print >>sys.stderr, "The glob for " + \
          opts.inspiral_horizon + \
          " returned no files"
    sys.exit(1)

##############################################################################
# read in tables into dictionaries of paired sets
# each dictionary contains the data for a different 'type'
# type e.g. H1H2, H1L1, H2L1, H1H2L1 in H1H2L1 ifo-times

foundInj  = dict()
foundTrig = dict()
missedInj = lsctables.New(lsctables.SimInspiralTable)
allFoundTrig = lsctables.New(lsctables.SnglInspiralTable)
allFoundInj = lsctables.New(lsctables.SimInspiralTable) 


## read the found injections
for entry, injfile in zip(injcache,injFiles):

  # read the found injections and get the coincidences
  sims =  SimInspiralUtils.ReadSimInspiralFromFiles([injfile])
  snglInspiralTable = SnglInspiralUtils.ReadSnglInspiralFromFiles([injfile])
  triggers = CoincInspiralUtils.coincInspiralTable(
    snglInspiralTable,CoincInspiralUtils.coincStatistic( "snr") )

  # check if there are any sims here
  if not sims:
    continue

  # loop over each sim, trigger
  for sim, trigger in zip(sims, triggers):

    # get the IFOs in which the trigger was recovered
    ifos, dummyList= trigger.get_ifos()

    if ifos not in foundInj:
      foundInj[ifos]  = lsctables.New(lsctables.SimInspiralTable)
      foundTrig[ifos] = lsctables.New(lsctables.SnglInspiralTable)

    foundInj[ifos].append( sim )
    foundTrig[ifos].append(trigger)
    allFoundTrig.append( trigger )
    allFoundInj.append( sim )

## read the missed injections
for misentry, misfile in zip(miscache,misFiles):
  
  # fill the dictionary    
  sims =   SimInspiralUtils.ReadSimInspiralFromFiles([misfile])
  if sims:
    missedInj.extend( sims )

# initialize the followup class
if opts.do_followup:
  followup = followup_missed.FollowupMissed( cache, miscache, opts)
 


##############################################################################
# read in the range if desired
if inspiralFiles:
  inspiralSumm = readFiles(inspiralFiles)
  if not opts.ifo:
    print >> sys.stderr, "Must specify --ifo for --show-horizon"
    sys.exit(1)
  
  horizon = inspiralSumm[opts.ifo].getColumnByName('value').asarray()
  startTime = viz.timeindays(inspiralSumm[opts.ifo].getColumnByName('start_time').asarray())

##############################################################################
# set lists of plot symbols
plot1symbol=['bx','bo','b+','b^','b>','b<']
plot2symbol=['rx','ro','r+','r^','r>','r<']
allsymbols=['^','v','<','>','s','+','x','D','d','1','2','3','4','h','H','p']

# GEO tags missing...
foundSymbol = {'H1H2':'x', 'H1L1':'^', 'H2L1':'+', 'H1V1':'v', 'H2L1':'<','L1V1':'>', \
               'H1H2L1':'s', 'H1H2V1':'D', 'H2L1V1':'d', 'H1L1V1':'1',\
               'H1H2L1V1':'p'}
foundSymbols = ['','','','','','','','' ]

gpsDigits = "9"
xmajorFormatter = FormatStrFormatter("%"+gpsDigits+"d")  
##############################################################################
# Create all the plots

xplot=['mchirp']
yplot=['distance']
yscale = ['lin']
if opts.time_dist:
  xplot.append('time')
  yplot.append('eff_dist')
  yscale.append('log')
if opts.mchirp_dist_linear:
  xplot.append('mchirp')
  yplot.append('eff_dist')
  yscale.append('lin')
if  opts.mchirp_dist_log:
  xplot.append('mchirp')
  yplot.append('eff_dist')
  yscale.append('log')
if opts.mtotal_dist_linear:
  xplot.append('mtotal')
  yplot.append('eff_dist')
  yscale.append('lin')
if opts.mtotal_dist_log:
  xplot.append('mtotal')
  yplot.append('eff_dist')
  yscale.append('log')


# loop over all the plotting types
for xname, yname, ys in zip( xplot, yplot, yscale):

  # create a plot for each ifo in the list
  for ifo in ifoList:

    figure()
    sym = 0

    # loop over the different types for found injections
    for type in foundInj.keys():

      if ifo in type:
        col = 'b'
      else:
        col = 'm'

      px, py, legx, legy = getData( foundInj[type], xname, yname, ifo )
      plot( px, py, col+foundSymbol[type], markerfacecolor='None',\
        markeredgecolor=col, label = type, markersize=10, markeredgewidth=1)

    # plot the missed ones
    px, py, legx, legy = getData( missedInj, xname, yname, ifo )
    plot( px, py, 'ro', markerfacecolor='None',label='missed',\
          markeredgecolor='r',markersize=10, markeredgewidth=1)
    
    if inspiralFiles:
      semilogy(startTime, horizon, 'g.', label='Horizon (Mpc)',
               linewidth=1)

    titleText = legx+' vs '+legy +' '+ifo
    title( opts.title + ' '+titleText+' in '+opts.ifo_times+' times', size='x-large')
    xlabel(legx, size='x-large')
    ylabel(legy+' '+ifo+' [Mpc]', size='x-large')
    grid(True)
    legend()

    if opts.enable_output:
      if ys=='lin':
        savePlot( opts, xname+'-'+yname+'-lin-'+ifo, titleText )
      if ys=='log':
        axes().set_yscale('log')    
        filename = xname+'-'+yname+'-log-'+ifo
        savePlot( opts, filename, titleText)
        
        # include followup links
        if xname=="mtotal" and yname=="eff_dist" and opts.do_followup:
          createImageMap(opts, missedInj, ifo,  filename)


    
##########################################
# plot of efficiency vs different values

# put together what efficiency plots we need
valueList = [ 'eff_dist_h', \
              'distance']
nameList = ["efficiency-eff_dist", "efficiency_dist"]
tagnameList = ["Efficiency versus distance", "Efficiency versus distance"]

indexPlots = []
if opts.eff_vs_eff_dist:
  indexPlots.append(0)
if opts.eff_vs_distance:
  indexPlots.append(1)

# loop over the IFOs' in the list
for ifo in ifoList:
  
  # create the efficiency plots
  for index in indexPlots:
  
    figure()
    viz.efficiencyplot( allFoundInj, missedInj, valueList[index],ifo=ifo,\
                        plot_type = 'log', \
                        nbins = 20, output_name = None, errors=True )

    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, ifo+'-'+nameList[index])
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
                                                dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append(tagnameList[index]+ifo)




# ============================================================================
# final step: html, cache file generation
if opts.enable_output is True:
  html_filename = InspiralUtils.write_html_output(opts, args, \
                                                  fnameList, tagList,\
                                                  doThumb=True,\
                                                  mapList=mapList)
  InspiralUtils.write_cache_output(opts, html_filename, fnameList)

  if opts.html_for_cbcweb:
    html_filename_publish = InspiralUtils.write_html_output(opts, args, fnameList, tagList, cbcweb=True)
  if opts.do_followup:
     fnameList.extend( followup.fnameDict.values() )
  InspiralUtils.write_cache_output(opts, html_filename, fnameList)

#########################################################################
if opts.show_plot:
  show()
