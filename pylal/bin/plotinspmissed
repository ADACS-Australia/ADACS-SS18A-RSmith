#!/usr/bin/python
# $Id$
#
# Copyright (C) 2006  Alexander Dietz
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
__Id__ = "$Id$"
__author__ = "Darren Woods and Stephen Fairhurst <sfairhurs@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]
__name__ = "plotinspmissed"
__title__ = "Found and Missed plots for triggers"

import sys, os, re, glob, exceptions
from types    import *
from optparse import *
from matplotlib.ticker import FormatStrFormatter
from glue import segments
from glue import segmentsUtils
from glue import lal
from glue.ligolw import lsctables
from pylal import SnglInspiralUtils
from pylal import CoincInspiralUtils
from pylal import SimInspiralUtils
from pylal import InspiralUtils
import numpy
from pylal import followup_missed

#######################################################################
def isSummValue(name, attrs):
  return lsctables.IsTableProperties(lsctables.SummValueTable, name, attrs)

#######################################################################
def readFiles(fList):
  """
  read in the SummInspiralTables from a list of files
  @param fList:  list of input files
  """
  output = {}
  if not fList:
    return output
  for thisFile in fList:
    doc = ligolw.Document()
    # read in SummValueTable
    ligolw.make_parser(ligolw.PartialLIGOLWContentHandler(doc, \
        isSummValue)).parse(file(thisFile))
    for row in doc.childNodes[0]:
      if row.name == 'inspiral_effective_distance':
        if not output.has_key(row.ifo):
          output[row.ifo] = lsctables.New(lsctables.SummValueTable)
        output[row.ifo].append(row)
  return output

#######################################################################
def getData( table, xname, yname, ifo  ):
  """
  Retrieves data from a table, including non-table entries
  such as 'mtotal' and 'time'
  @param table: the table with the data
  @param xname: the x-value
  @param yname: the y-value
  @param ifo  : the ifo for which the time or distance is returned
  """

  if xname=='time':
    xp= [ t-opts.time_offset \
          for t in viz.timeindays(viz.readcol( table,"end_time", ifo)) ]
    legx = "End time (in days)"
  elif xname == 'mtotal':    
    xp = viz.readcol( table,"mass1")+viz.readcol( table,"mass2")
    legx = "Total mass"
  else:
    xp = viz.readcol( table,xname)
    legx = xname
  

  if yname == 'eff_dist':
    yp = viz.readcol( table,"eff_dist", ifo )
    legy = "Effective distance"
  else:
    yp = viz.readcol( table,yname)
    legy = yname

  return xp, yp, legx, legy

#######################################################################
def savePlot(opts, filename, tag, keep=False):
  """
  This is a helper function to save a plot.
  @param filename: name of the plot
  @param tag:      tag for the plot
  @param keep:     whether to close plot (boolean, default=False)
  """
       
  fname = InspiralUtils.set_figure_name(opts, filename)
  fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
                                            dpi_thumb=opts.figure_resolution)
  fnameList.append(fname)
  tagList.append( tag )
  if not opts.show_plot and not keep:
    close()
  return fname

#######################################################################
def createImageMap(opts, missedInj, ifo, tag):
  """
  This function will do a followup on some or all missed injections
  by using the class FollowupMissed in followup_missed.py.
  This will create a html page containing informations about the missed
  trigger(s) and containing plots of time series around the missed injection(s).
  Also, this function adds an ImageMap to the main html file.
  @param missedInj: a sim_inspiral table of a missed injection that might be followed up
  @param ifo:       the IFO corresponding to this missed injection
  @param tag:       the tag which is added to the created filenames
  """

  # reset the number and set the tag
  followup.reset()
  followup.setTag( tag )
  
  # create a mapDist
  mapDict ={'object':'', \
            'text':'Click on a filled circle to go to the followup page',\
            'xCoords':[], 'yCoords':[], 'links': []}

  # coordinates of the actual picture in the image
  # TODO: These numbers might change for different solutions,
  # image types...
  boundFigX = [100.0,720.0]
  boundFigY = [540.0, 60.0]

  # limits on the axes for the image
  axes=gcf().axes[0]
  rangeFigX = axes.get_xlim()
  rangeFigY = log10( axes.get_ylim() )

  # calculating scaling factors
  slopeX = (boundFigX[1]-boundFigX[0])/(rangeFigX[1]-rangeFigX[0])
  interX = boundFigX[1] - slopeX*rangeFigX[1]
  slopeY = (boundFigY[1]-boundFigY[0])/(rangeFigY[1]-rangeFigY[0])
  interY = boundFigY[1] - slopeY*rangeFigY[1]

  # figure out the missed injections to be followed up
  if opts.followup_number:

    # get the distances and sort them
    distVector = viz.readcol( missedInj, 'eff_dist', ifo )
    index = argsort(distVector)
    n=min( len(distVector), opts.followup_number)
    missedInjUse = [missedInj[index[i]] for i in range(n)]

  else:
    # use the estimated distance curve
    missedInjUse = []
    for inj in missedInj:
      dist20 = getattr( opts, "followup_dist_%s" % ifo[0].lower() )
      estDist = followup.estimatedDistance( inj.mass1, inj.mass2, dist20)
      if getattr( inj, 'eff_dist_'+ifo[0].lower())<estDist:
        missedInjUse.append( inj )

  # loop over all missed injections
  for inj in missedInjUse:
    
    # do the followup and create the followup page
    followuphtml = followup.followup( inj, ifo, opts.followup_tag )
    
    # get the coordinates of this missed injection
    totalMass = inj.mass1+inj.mass2
    effDist = getattr( inj, 'eff_dist_'+ifo[0].lower())
    effDistLog = log10(effDist)
    px = int( interX+slopeX*totalMass )
    py = int( interY+slopeY*effDistLog )

    # highlight the clickable missed ones
    plot( [totalMass], [effDist], 'ro', markerfacecolor = 'r', markersize=10)

    # add the point and the link to the mapDict
    mapDict['xCoords'].append( px )
    mapDict['yCoords'].append( py )
    mapDict['links'].append( followuphtml )
    
  # save the figure (containing filled circles)
  if opts.enable_output:

    # save the figure and add it to the list of maps
    # after removal of the first directory...
    filename = savePlot( opts, tag+"_map", "test" )
    index=filename.index('/')+1 
    mapDict['object']=filename[index:]
    mapList.append( mapDict )


#################################################################

##############################################################################
# parse options and arguments
usage = """Usage: %prog [options] [trigs1 missed1 trigs2 missed2]

Generate found and missed trig plots

plotinspmissed --mtotal-dist-linear --verbose  --output-path plots/ --mchirp-dist-log  --time-dist  --gps-start-time 866088014 --mchirp-dist-linear --gps-end-time 866109614 --cache-file ihope.cache --enable-output  --mtotal-dist-log  --ifo H1 --legend --found-pattern COIRE_INJECTIONS_*_FOUND_SECOND_*_INJ* --missed-pattern COIRE_INJECTIONS_*_MISSED_SECOND_*_INJ*
"""


def parse_command_line():
  """
  Parser function dedicated
  """
  parser = OptionParser( usage=usage, \
      version= "%prog CVS\n" +
      "$Id$\n" +
      "$Name$\n")
  parser.add_option("-a","--time-dist",action="store_true",default=False,\
      help="plot dist v trig end time" )
  parser.add_option("-b","--mchirp-dist-log",action="store_true",default=False,\
      help="plot dist v mchirp (log dist axis)" )
  parser.add_option("-c","--mtotal-dist-log",action="store_true",default=False,\
      help="plot dist v mtotal (log dist axis)" )
  parser.add_option("-d","--mchirp-dist-linear",action="store_true",default=False,\
      help="plot dist v mchirp (linear dist axis)" )
  parser.add_option("-e","--mtotal-dist-linear",action="store_true",default=False,\
      help="plot dist v mtotal (linear dist axis)" )
  parser.add_option("-f","--eff-vs-eff-dist",action="store_true",default=False,\
      help="efficiency plot versus effective distance (logarithmic dist axis)" )
  parser.add_option("-g","--eff-vs-distance",action="store_true",default=False,\
      help="efficiency plot versus distance (logarithmic dist axis)" )
  parser.add_option("-j","--mchirp-distance-lin",action="store_true",default=False,\
       help="plot distance v mchirp (linear dist axis)" )
  parser.add_option("-T","--time-offset",action="store",type="float",\
      default=0.0,metavar=" TIME-OFFSET",\
      help="time offset when plotting times")
  parser.add_option("-s","--show-plot",action="store_true",default=False,\
      help="display the figures on the terminal" )
  parser.add_option("-t","--title",action="store",type="string",\
      default="", metavar=" TITLE", help="add more info to standard title" )
  parser.add_option("-l","--legend",action="store_true",default=False,\
      help="include legend on plot" )  
  parser.add_option("-u","--user-tag",action="store",type="string",\
      default=None, metavar=" USERTAG",\
      help="The user tag used in the name of the figures" )
  parser.add_option("","--ifo-tag",action="store",type="string",\
      default=None, metavar=" IFOTAG",\
      help="The ifo tag used in the name of the figures (e.g. SECOND_H1H2L1)")      
  parser.add_option("","--ifo-times",action="store",type="string",\
      default=None,metavar="IFOS",\
      help="sets ifo times for which plots will be made (e.g. H1H2L1)" )
  parser.add_option("-S","--same-symbol",action="store",type="string",\
      default=None,  metavar="SAME-SYMBOL",\
      help="enables the use of a same symbol")
  parser.add_option("-V","--veto-file",action="store",type="string",\
      default=None,metavar=" FNAME",\
      help="read in segments from FNAME (assumed segwizard format)")
  parser.add_option("-i","--ifo",action="store",type="string",default=None,\
      help="specify the ifo (otherwise will loop over all IFOs in ifo-times")
  parser.add_option("-M","--min-distance",action="store",type="int",\
      default=None, metavar=" MIN_DIST",\
      help="provide time and dist of all missed injections closer than MIN_DIST [Mpc]")
  parser.add_option("-r","--add-horizon",action="store",type="string",\
      default=None,metavar="INSP",\
      help="show the inspiral horizon obtained from files matching the glob INSP")
  parser.add_option("-p","--y-min",action="store",type="float",\
      default=None,metavar="YMIN",\
      help="set the y min range to YMIN")
  parser.add_option("-q","--y-max",action="store",type="float",\
      default=None,metavar="YMAX",\
      help="set the y max range to YMAX")
  parser.add_option("", "--found-pattern",
    help="sieve the cache for found injection files with this pattern")
  parser.add_option("", "--missed-pattern",
    help="sieve the cache for missed injection files with this pattern")
  parser.add_option("", "--cache-file", help="LAL cache of relevant files")
  parser.add_option("", "--sire",action="store_true",\
       default=False, help="Indicating the use of single-trigger sire files")
  parser.add_option("-P","--output-path",action="store",\
      type="string",default="",  metavar="PATH",\
      help="path where the figures would be stored")
  parser.add_option("-O","--enable-output",action="store_true",\
      default=False,  metavar="OUTPUT",\
        help="enable the generation of the html and cache documents")
  parser.add_option("","--gps-start-time",action="store",\
      type="int",  metavar="GPSSTARTTIME",\
      help="gps start time (for naming figure and output files")
  parser.add_option("","--gps-end-time",action="store",\
      type="int",  metavar=" GPSENDTIME",\
      help="gps end time (for naming figure and output files")
  parser.add_option("-v","--verbose",action="store_true",\
      default=False,help="print information" )
  parser.add_option("", "--figure-resolution",action="store",type="int",\
      default=50, metavar="resolution of the thumbnails (50 by default)", \
      help="read a file of a particular description  from cache file" )
  parser.add_option("","--do-followup",action="store_true",\
      default=False,help="activates the followup of missed injections" )
  parser.add_option("","--followup-dist-l",action="store",\
      type="float",default=None,  metavar="FOLLOWUPDISTL",\
      help="distance for a binary with 20 Solarmasses in L")
  parser.add_option("","--followup-dist-h",action="store",\
      type="float",default=None,  metavar="FOLLOWUPDISTH",\
      help="distance for a binary with 20 Solarmasses in H")
  parser.add_option("","--followup-dist-g",action="store",\
      type="float",default=None,  metavar="FOLLOWUPDISTG",\
      help="distance for a binary with 20 Solarmasses in G")
  parser.add_option("","--followup-dist-v",action="store",\
      type="float",default=None,  metavar="FOLLOWUPDISTV",\
      help="distance for a binary with 20 Solarmasses in V")
  parser.add_option("","--followup-number",\
      type="int",default=None,  metavar="FOLLOWUPNUMBER",\
      help="number of closest missed injections to be followed up")
  parser.add_option("","--followup-flow",action="store",\
      type="float",default=40.0,  metavar="FOLLOWUPFLOW",\
      help="specifies the lower cutoff frequency")
  parser.add_option("","--followup-exttrig",action="store_true",\
      default=False,help="set the exttrig flag for followup" )
  parser.add_option("","--followup-vetofile-l1",action="store",\
      type="string",default=None,  metavar="FOLLOWUPVETOL1",\
      help="vetofile containing veto times for L1")
  parser.add_option("","--followup-vetofile-h1",action="store",\
      type="string",default=None,  metavar="FOLLOWUPVETOH1",\
      help="vetofile containing veto times for H1")
  parser.add_option("","--followup-vetofile-h2",action="store",\
      type="string",default=None,  metavar="FOLLOWUPVETOH2",\
      help="vetofile containing veto times for H2")
  parser.add_option("","--followup-vetofile-g1",action="store",\
      type="string",default=None,  metavar="FOLLOWUPVETOG1",\
      help="vetofile containing veto times for G1")
  parser.add_option("","--followup-vetofile-v1",action="store",\
      type="string",default=None,  metavar="FOLLOWUPVETOV1",\
      help="vetofile containing veto times for V1")
  parser.add_option("","--followup-tag",action="store",\
      type="string",default=None,  metavar="FOLLOWUPTAG",\
      help="a tag to select the proper xml files in a cache file. Should be the injecion tag ideally.")
  parser.add_option("","--followup-time-window",action="store",\
      type="float",default=20.0,  metavar="FOLLOWUPTIMEWINDOW",\
      help="time-window to be plotted in the followup [in seconds]")
  parser.add_option("", "--html-for-cbcweb",action="store",\
      default=False, metavar = "CVS DIRECTORY", help="publish the html "\
      "output in a format that can be directly published on the cbc webpage "\
      "or in CVS. This only works IF --enable-output is also specified. The "\
      "argument should be the cvs directory where the html file will be placed "\
      "Example: --html-for-cbcweb protected/projects/s5/yourprojectdir")
    
  
  command_line = sys.argv[1:]
  (options,args) = parser.parse_args()

  # test the input options
  if not options.ifo_times:
    raise ValueError, "--ifo-times must be provided"

  return options, sys.argv[1:]


# ============================================================================
# -- get command line arguments
opts, args = parse_command_line()
comments = ""

# Initialise: add prefix and suffix to the opts strucutre. To be used for filenames
opts = InspiralUtils.initialise(opts, __name__, __version__)

# -- set the proper color code
colors = InspiralUtils.colors
figure_number = 0  # used for the figure label (showplot)
fnameList = []   # use for the cache file
tagList= []   # use for the cache file
mapList = []  # vector containing data for creating maps

# to avoid  display problem when show plot is not used
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from pylal import viz


# do something if a title was given
if opts.title != "":
  opts.title += ": "
  
# check at least one trig file was specified
if opts.cache_file:
  cache = lal.Cache.fromfile(open(opts.cache_file))
  injcache = cache.sieve(description = opts.found_pattern).sieve(ifos=opts.ifo_times, exact_match=True)
  miscache = cache.sieve(description = opts.missed_pattern).sieve(ifos=opts.ifo_times, exact_match=True)
  injFiles = injcache.checkfilesexist()[0].pfnlist()
  misFiles = miscache.checkfilesexist()[0].pfnlist()

  if opts.verbose:
    print "\n"+__name__+"... reading the following found files" 
    for file in injFiles:
      print file
    print "\n"+__name__+"... reading the following missed files \n"
    for file in misFiles:
      print file
  if len(injFiles) == 0:
    err_msg = opts.cache_file + " contains no files with " + \
              opts.found_pattern + " description"
    print >>sys.stderr, err_msg
    comments += InspiralUtils.message(opts, err_msg)
    if opts.enable_output is True: 
      html_filename = InspiralUtils.write_html_output(opts, args, fnameList, \
                                                      tagList, comment=comments)
      InspiralUtils.write_cache_output(opts, html_filename, fnameList)
      if opts.show_plot:
        sys.exit(1)
      else:
        sys.exit(0)
  
else:

  if not args:
    print >>sys.stderr, "One trig-file must be specified at least"
    print >>sys.stderr, "Enter 'plotinspmissed --help' for usage"
    sys.exit(1)
    
  # check if trig and missed inj files are paired
  # then fill lists of injection and missed injection files
  if len(args)<2:
    print >>sys.stderr, "At least one trigger file and one missed"\
          " file must be specified"
    print >>sys.stderr, "Enter 'plotinspmissed --help' for usage"
    print usage
    sys.exit(1)

  elif len(args)%2:
    print >>sys.stderr, "The number of files specified must be even"
    print >>sys.stderr, "Enter 'plotinspmissed --help' for usage"
    print usage
    sys.exit(1)
  
  else:
    injFiles = []
    misFiles = []
    # create the list of found and missed files
    for i in range(len(args)):
      if i%2:
        misFiles.append(args[i])
      else:
        injFiles.append(args[i])


# create the ifoList
ifoList = []
for i in range(len(opts.ifo_times)/2):
  ifoList.append(opts.ifo_times[2*i:2*i+2])


# check the followup input parameters
if opts.do_followup:
  if not opts.followup_number:
    for ifo in ifoList:
      if not getattr( opts, "followup_dist_%s" % ifo[0].lower() ):
        print >>sys.stderr, "ERROR: If --followup-number is not given "
        print >>sys.stderr, "--followup-dist-%s must be specified \n" %\
              ifo[0].lower() 
        print usage
        sys.exit(1)

# selecet one IFO if required
if opts.ifo:
  ifoList=[opts.ifo]

  
#######################################################################
# identify the inspiral files if we want the horizon
inspiralFiles = None
if opts.add_horizon:
  inspiralFiles = glob.glob(opts.add_horizon)
  if not inspiralFiles:
    print >>sys.stderr, "The glob for " + \
          opts.inspiral_horizon + \
          " returned no files"
    sys.exit(1)

##############################################################################
# read in tables into dictionaries of paired sets
# each dictionary contains the data for a different 'type'
# type e.g. H1H2, H1L1, H2L1, H1H2L1 in H1H2L1 ifo-times

foundInj  = dict()
foundTrig = dict()
missedInj = lsctables.New(lsctables.SimInspiralTable)
allFoundTrig = lsctables.New(lsctables.SnglInspiralTable)
allFoundInj = lsctables.New(lsctables.SimInspiralTable) 


## read the found injections
for entry, injfile in zip(injcache,injFiles):

  # read the found injections and get the coincidences
  sims =  SimInspiralUtils.ReadSimInspiralFromFiles([injfile])
  snglInspiralTable = SnglInspiralUtils.ReadSnglInspiralFromFiles([injfile])

  # mange event_id's by hand for sire triggers 	 
  if snglInspiralTable and opts.sire: 	 
    for i in range(len(snglInspiralTable)): 	 
      snglInspiralTable[i].event_id=i

  triggers = CoincInspiralUtils.coincInspiralTable(
    snglInspiralTable,CoincInspiralUtils.coincStatistic( "snr") )

  # check if there are any sims here
  if sims is None:
    continue

  if opts.sire: 	 
     if not opts.ifo in foundInj: 	 
       foundInj[opts.ifo]  = lsctables.New(lsctables.SimInspiralTable) 	 
       foundTrig[opts.ifo] = lsctables.New(lsctables.SnglInspiralTable) 	 
  	 
     for sim, trigger in zip(sims, snglInspiralTable): 	 
       foundInj[opts.ifo].append( sim ) 	 
       foundTrig[opts.ifo].append(trigger) 	 
       allFoundTrig.append( trigger ) 	 
       allFoundInj.append( sim ) 	 
  	 
  else:
    # loop over each sim, trigger
    for sim, trigger in zip(sims, triggers):

      # get the IFOs in which the trigger was recovered
      ifos, dummyList= trigger.get_ifos()

      if ifos not in foundInj:
        foundInj[ifos]  = lsctables.New(lsctables.SimInspiralTable)
        foundTrig[ifos] = lsctables.New(lsctables.SnglInspiralTable)

      foundInj[ifos].append( sim )
      foundTrig[ifos].append(trigger)
      allFoundTrig.append( trigger )
      allFoundInj.append( sim )

## read the missed injections
for misentry, misfile in zip(miscache,misFiles):
# fill the dictionary    
  sims =   SimInspiralUtils.ReadSimInspiralFromFiles([misfile])
  if sims:
    missedInj.extend( sims )

# initialize the followup class
if opts.do_followup:
  followup = followup_missed.FollowupMissed( cache, miscache, opts)
 


##############################################################################
# read in the range if desired
if inspiralFiles:
  inspiralSumm = readFiles(inspiralFiles)
  if not opts.ifo:
    print >> sys.stderr, "Must specify --ifo for --show-horizon"
    sys.exit(1)
  
  horizon = inspiralSumm[opts.ifo].getColumnByName('value').asarray()
  startTime = viz.timeindays(inspiralSumm[opts.ifo].getColumnByName('start_time').asarray())

##############################################################################
# set lists of plot symbols
plot1symbol=['bx','bo','b+','b^','b>','b<']
plot2symbol=['rx','ro','r+','r^','r>','r<']
allsymbols=['^','v','<','>','s','+','x','D','d','1','2','3','4','h','H','p']

# GEO tags missing...
foundSymbol = {'H1H2':'x', 'H1L1':'^', 'H2L1':'+', 'H1V1':'v', 'H2V1':'<','L1V1':'>',\
               'H1H2L1':'s', 'H1H2V1':'D', 'H2L1V1':'d', 'H1L1V1':'1',\
               'H1H2L1V1':'p', 'H1':'x', 'H2':'x', 'L1':'x', 'V1':'x'}
foundSymbols = ['','','','','','','','' ]

gpsDigits = "9"
xmajorFormatter = FormatStrFormatter("%"+gpsDigits+"d")  
##############################################################################
# Create all the plots

xplot=[]
yplot=[]
yscale = []
if opts.time_dist:
  xplot.append('time')
  yplot.append('eff_dist')
  yscale.append('log')
if opts.mchirp_dist_linear:
  xplot.append('mchirp')
  yplot.append('eff_dist')
  yscale.append('lin')
if  opts.mchirp_dist_log:
  xplot.append('mchirp')
  yplot.append('eff_dist')
  yscale.append('log')
if opts.mtotal_dist_linear:
  xplot.append('mtotal')
  yplot.append('eff_dist')
  yscale.append('lin')
if opts.mtotal_dist_log:
  xplot.append('mtotal')
  yplot.append('eff_dist')
  yscale.append('log')
if opts.mchirp_distance_lin: 	 
   xplot.append('mchirp') 	 
   yplot.append('distance') 	 
   yscale.append('lin')

# loop over all the plotting types
for xname, yname, ys in zip( xplot, yplot, yscale):

  # create a plot for each ifo in the list
  for ifo in ifoList:

    figure()
    sym = 0

    # loop over the different types for found injections
    for type in foundInj.keys():

      if ifo in type:
        col = 'b'
      else:
        col = 'm'

      px, py, legx, legy = getData( foundInj[type], xname, yname, ifo )
      plot( px, py, col+foundSymbol[type], markerfacecolor='None',\
        markeredgecolor=col, label = type, markersize=10, markeredgewidth=1)
      
    # plot the missed ones
    px, py, legx, legy = getData( missedInj, xname, yname, ifo )
    plot( px, py, 'ro', markerfacecolor='None',label='missed',\
          markeredgecolor='r',markersize=10, markeredgewidth=1)

    if inspiralFiles:
      semilogy(startTime, horizon, 'g.', label='Horizon (Mpc)',
               linewidth=1)

    titleText = legx+' vs '+legy +' '+ifo
    title( opts.title + ' '+titleText+' in '+opts.ifo_times+' times', size='x-large')
    xlabel(legx, size='x-large')
    ylabel(legy+' '+ifo+' [Mpc]', size='x-large')
    grid(True)
    legend()

    if opts.enable_output:
      if ys=='lin':
        savePlot( opts, xname+'-'+yname+'-lin-'+ifo, titleText )
      if ys=='log':
        axes().set_yscale('log')    
        filename = xname+'-'+yname+'-log-'+ifo
        savePlot( opts, filename, titleText, keep=True)
        
        # include followup links
        if xname=="mtotal" and yname=="eff_dist" and opts.do_followup:
          createImageMap(opts, missedInj, ifo,  filename)

        if not opts.show_plot:
          close()

    
##########################################
# plot of efficiency vs different values

# put together what efficiency plots we need
valueList = [ 'eff_dist', \
              'distance']
nameList = ["efficiency-eff_dist", "efficiency_dist"]
tagnameList = ["Efficiency versus distance", "Efficiency versus distance"]

indexPlots = []
if opts.eff_vs_eff_dist:
  indexPlots.append(0)
if opts.eff_vs_distance:
  indexPlots.append(1)

# loop over the IFOs' in the list
for ifo in ifoList:
  
  # create the efficiency plots
  for index in indexPlots:
  
    figure()
    viz.efficiencyplot( allFoundInj, missedInj, valueList[index],ifo=ifo,\
                        plot_type = 'log', \
                        nbins = 20, output_name = None, errors=True,\
                        title_string = opts.title)

    if opts.enable_output:
      fname = InspiralUtils.set_figure_name(opts, ifo+'-'+nameList[index])
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, \
                                                dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append(tagnameList[index]+ifo)
    if not opts.show_plot:
      close()




# ============================================================================
# final step: html, cache file generation
if opts.enable_output is True:
  html_filename = \
      InspiralUtils.write_html_output(opts, args, fnameList, tagList,\
                                      doThumb=True, mapList=mapList)
  InspiralUtils.write_cache_output(opts, html_filename, fnameList)

  if opts.html_for_cbcweb:
    html_filename_publish = \
         InspiralUtils.write_html_output(opts, args, fnameList, tagList, cbcweb=True)

  # create the cache-file
  if opts.do_followup:
    fnameList.extend( followup.fnameList )
  InspiralUtils.write_cache_output(opts, html_filename, fnameList)

#########################################################################
if opts.show_plot:
  show()
