#!/usr/bin/env python
#
# Copyright (C) 2008  Nickolas Fotopoulos
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
"""
paste_triggers takes SnglInspiral triggers from one document and pastes
them into another.
"""

__author__ = "Nickolas Fotopoulos <nvf@gravity.phys.uwm.edu>"

import optparse
import sys

from glue import iterutils
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from glue.ligolw.utils import ligolw_add
from glue.ligolw.utils import process as ligolw_process
from glue.segments import segment, segmentlist
from pylal import git_version
from pylal.xlal.datatypes.ligotimegps import LIGOTimeGPS

lsctables.LIGOTimeGPS = LIGOTimeGPS

#
# ligolw helper functions
#

def extract_seglist(doc):
    """
    Return the segmentlist formed from the out segment of the search_summary
    table of doc.
    """
    summ_table = table.get_table(doc, lsctables.SearchSummaryTable.tableName)
    segs = segmentlist([summary.get_out() for summary in summ_table])
    segs.coalesce()
    return segs

def create_sngl_inspiral_table_if_missing(doc1, doc2):
    """
    If there is no sngl_inspiral table in doc1 or doc2, create an empty one
    that is compatible with the other and attach it.  If both are missing
    tables, create the default one.

    FIXME: On the cbc_s5_1yr_20070129 branch, lalapps_inspiral omits
    the sngl_inspiral table if there are no triggers.  When no analysis
    will use this code with documents from the branch, remove this function.
    """
    tables1 = table.getTablesByName(doc1, lsctables.SnglInspiralTable.tableName)
    tables2 = table.getTablesByName(doc2, lsctables.SnglInspiralTable.tableName)

    # will want to append tables to the LIGO_LW tags of the documents
    ligolw1 = doc1.childNodes[-1]
    ligolw2 = doc2.childNodes[-1]

    if len(tables1) > 1 or len(tables2) > 1:
        raise ValueError, "why is there more than one sngl_inspiral table?"
    if len(tables1) == 1 and len(tables2) == 1:
        pass
    elif len(tables1) == 0 and len(tables2) == 0:
        ligolw1.appendChild(lsctables.New(lsctables.SnglInspiralTable))
        ligolw2.appendChild(lsctables.New(lsctables.SnglInspiralTable))
    elif len(tables1) == 0:
        ligolw1.appendChild(table.new_from_template(tables2[0]))
    else:
        ligolw2.appendChild(table.new_from_template(tables1[0]))
    return

def delete_triggers_in_region(doc, target_seglist):
    """
    Delete triggers in doc that lie in target_seglist.
    """
    def keep_condition(trig):
        """ Keep only those triggers outside target_seglist. """
        return (trig.get_end() not in target_seglist)
    triggers = table.get_table(doc, lsctables.SnglInspiralTable.tableName)
    iterutils.inplace_filter(keep_condition, triggers)

def shift_triggers(doc, shift):
    """
    Shift each SnglInspiral trigger in doc by an amount shift.
    """
    triggers = table.get_table(doc, lsctables.SnglInspiralTable.tableName)
    for trig in triggers:
        trig.set_end(trig.get_end() + shift)

def paste_triggers_into(source_doc, dest_doc, verbose=False):
    """
    Take triggers from source_doc and paste them into dest_doc.
    """
    # get source triggers, process, and process_params
    trigs = table.get_table(source_doc, lsctables.SnglInspiralTable.tableName)
    process = table.get_table(source_doc, lsctables.ProcessTable.tableName)
    params = table.get_table(source_doc, lsctables.ProcessParamsTable.tableName)

    # merge documents
    dest_doc.appendChild(trigs)
    dest_doc.appendChild(process)
    dest_doc.appendChild(params)
    ligolw_add.reassign_ids(dest_doc, verbose=verbose)
    ligolw_add.merge_compatible_tables(dest_doc)

    # finally, sort triggers by end time
    new_trigs = table.get_table(dest_doc, lsctables.SnglInspiralTable.tableName)
    new_trigs.sort(key=lsctables.SnglInspiral.get_end)

def parse_args():
    parser = optparse.OptionParser(version=git_version.verbose_msg)
    parser.add_option("--source", metavar="SRC",
        help="file from which triggers are taken")
    parser.add_option("--destination", metavar="DEST",
        help="file into which to paste triggers")
    parser.add_option("--paste-strategy", choices=("delete_all",
        "delete_overlapping", "do_nothing"), help="what to do with triggers "\
        "already present in DEST; options are {delete_all, "\
        "delete_overlapping, do_nothing}")
    parser.add_option("--output-filename", help="file to which to send output")

    parser.add_option("--shift-triggers", metavar="OFFSET",
        help="apply OFFSET to source triggers before pasting "\
        "(also before time restriction)")
    parser.add_option("--restrict-source-times", action="store_true",
        default=False, help="only take triggers from the source lying in the "\
        "destination analyzed times")
    parser.add_option("--take-offsource-trial", type="int", metavar="TRIAL_NUM",
        help="For the GRB analysis, it is instructive to take one of the "\
        "off-source trials and treat it as an on-source trial.  This option " \
        "basically fills in --shift-triggers and --restrict-source-times for "\
        "you.  It assumes that SRC is the offsource and DEST is onsource.")

    parser.add_option("--event-id-type", default="ilwd:char",
        choices=("int_8s", "ilwd:char"),
        help="the type of the event_id; options are {int_8s, ilwd:char}.")
    parser.add_option("--verbose", action="store_true", default=False,
        help="increase verbosity")

    options, arguments = parser.parse_args()

    for opt in ("source", "destination", "paste_strategy", "output_filename"):
        if getattr(options, opt) is None:
            raise ValueError, opt + " is a required option"

    if (options.take_offsource_trial is not None) \
        and (options.shift_triggers is not None):
        raise ValueError, "cannot specify --take-offsource-trial and "\
            "--shift-triggers at the same time"

    return options, arguments

#
# main
#

opts, args = parse_args()

# backwards compatibility with old documents
if opts.event_id_type == "int_8s":
    lsctables.SnglInspiralTable.validcolumns["event_id"] = u"int_8s"
    lsctables.SnglInspiralID = int

# load source document
src_doc = utils.load_filename(opts.source, opts.verbose,
                              gz=opts.source.endswith(".gz"))
source_segs = extract_seglist(src_doc)

# load destination document
dest_doc = utils.load_filename(opts.destination, opts.verbose,
                               gz=opts.destination.endswith(".gz"))
process_table = ligolw_process.register_to_xmldoc(dest_doc,
    "paste_insp_triggers", opts.__dict__,
    version=git_version.tag or git_version.id,
    cvs_repository="lalsuite", cvs_entry_time=git_version.date)
dest_segs = extract_seglist(dest_doc)

# FIXME: must create a compatible table if it's missing
create_sngl_inspiral_table_if_missing(src_doc, dest_doc)

# if this is an off-source trial we're preparing, set shift and restriction
# source = offsource, dest = onsource
if opts.take_offsource_trial is not None:
    if abs(source_segs) % abs(dest_segs) != 0:
        sys.stderr.write("The length of off-source is not commensurate with "\
            "length of on-source.  Did you specify the right files?\n")
    if opts.take_offsource_trial < 0 \
        or opts.take_offsource_trial > \
        (abs(source_segs) / float(abs(dest_segs))):
        raise ValueError, "not a valid trial number"
    opts.shift_triggers = \
        dest_segs[0][0] - (source_segs[0][0] + (opts.take_offsource_trial - 1)*abs(dest_segs))
    opts.restrict_source_times = True

# shift source triggers as appropriate
if opts.shift_triggers is not None:
    shift_time = LIGOTimeGPS(opts.shift_triggers)
    shift_triggers(src_doc, shift_time)

# delete source triggers as appropriate; tighten source_segs
if opts.restrict_source_times:
    old_trigs = table.get_table(src_doc, lsctables.SnglInspiralTable.tableName)
    delete_triggers_in_region(src_doc, ~dest_segs)
    source_segs = dest_segs

# delete destination triggers as appropriate
if opts.paste_strategy == "delete_all":
    old_trigs = table.get_table(dest_doc, lsctables.SnglInspiralTable.tableName)
    del old_trigs[:]
elif opts.paste_strategy == "delete_overlapping":
    delete_triggers_in_region(dest_doc, source_segs)
elif opts.paste_strategy == "do_nothing":
    pass
else:
    raise ValueError, "Someone forgot to update parse_args() to validate "\
        "the current possibilities for opts.parse_strategy."

# sanity check
if source_segs not in dest_segs:
    sys.stderr.write("warning: source is not completely contained in dest\n")

# paste triggers
paste_triggers_into(src_doc, dest_doc, verbose=opts.verbose)

# close out metadata
ligolw_process.set_process_end_time(process_table)

# write file to disk
utils.write_filename(dest_doc, opts.output_filename, opts.verbose,
                     gz=opts.output_filename.endswith(".gz"))

if opts.verbose:
    triggers = table.get_table(dest_doc, lsctables.SnglInspiralTable.tableName)
    sys.stdout.write("%d triggers written.\n" % len(triggers))

