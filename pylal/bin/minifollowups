#!/usr/bin/python
"""
routine to follow triggers from new style coinc xml tables
"""
# $Id$

from __future__ import division

__author__ = "Ian Harry <ian.harry@astro.cf.ac.uk>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]
__prog__="minifollowups"
__Id__ = "$Id$"

import sys,os
from optparse import *
from glue import lal
from pylal import SnglInspiralUtils
from pylal import CoincInspiralUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from glue.ligolw.utils import print_tables
import matplotlib
matplotlib.use('Agg')
from pylal import followup_trigger

def organize_coincs(new_coincs,sngls,coinc_map):
# This function takes a (new style) coinc table and sngl table along with
# the experiment map and returns a list of [coinc,[sngls]].
  coinc_list = []
  i = 0
  for coinc in new_coincs:
    coinc_list.append([])
    coinc_list[i].append(coinc)
    snglEventIds = []
    for map in coinc_map:
      if coinc.coinc_event_id == map.coinc_event_id:
        snglEventIds.append(map.event_id)
    snglList = []
    for sngl in sngls:
       if sngl.event_id in snglEventIds:
         snglList.append(sngl)
    coinc_list[i].append(snglList)
    i += 1
  return coinc_list

usage = """%prog [options]

Minifollowup is a code designed to run followups on new style xml files with
coinc_inspiral_tables in them. It can also take in the html table files output
by printlc and add the mini followup to it for write_ihope_page usage.
"""

parser = OptionParser( usage=usage)
parser.add_option("-g","--cache-string",action="store",type="string",\
      default=None, metavar=" USERTAG",\
      help="This is used to parse the cache file. Only files with this string in them will be used" )
parser.add_option("-c", "--cache-file", action="store", type="string", default=None, metavar="CACHEFILE",\
      help="The ihope cache file to be used")
parser.add_option("-p","--prefix",action="store",type="string",\
      default=None, metavar=" PREFIX",\
      help="Used to prefix the plot names" )
parser.add_option("-s","--suffix",action="store",type="string",\
      default=None, metavar=" SUFFIX",\
      help="Used as a suffix in the plot names" )
parser.add_option("-o","--output-path",action="store",type="string",\
      default=".", metavar=" PATH",\
      help="The output path for the plots" )
parser.add_option("-x","--input-xml",action="store",type="string",\
      default=None, metavar=" INPUTXML",\
      help="The input xml file location" )
parser.add_option("-t","--input-xml-summary",action="store",type="string",\
      default=None, metavar=" INPXMLSUMMTABLE",\
      help="The input xml summary table (if you want to add mini followup location to this table" )
parser.add_option("-T","--output-html-table",action="store",type="string",\
      default=None, metavar=" INPXMLSUMMTABLE",\
      help="The output html summary table file name (only if you give an input xml summary)" )
parser.add_option("","--max-followups",action="store",\
      type="int",  metavar="MAXFOLLOWUPS",default = 15,\
      help="Only followup this number of files.")
parser.add_option("-v","--verbose",action="store_true",\
      default=False,help="print information" )

(opts,args) = parser.parse_args()

# Followup_trigger needs the following options to be set

opts.followup_exttrig = False
opts.followup_flow = 40.0
opts.figure_resolution = 50
opts.output_path = opts.output_path + '/'
opts.suffix = '_' + opts.suffix
opts.verbose = True
opts.followup_time_window = 10
opts.user_tag = opts.cache_string

if not os.path.isdir('Images'):
  os.mkdir('Images')

# Sieve the ihope cache file
cache = lal.Cache.fromfile( open( opts.cache_file ) )
temp_cache = cache.sieve (description = opts.cache_string )
followup = followup_trigger.FollowupTrigger( temp_cache, opts, False )

# Read in the new style coinc xml file
xmldoc = utils.load_filename( opts.input_xml,gz = opts.input_xml.endswith("gz"))
coincT = table.get_table(xmldoc, lsctables.CoincInspiralTable.tableName)
coincMap = table.get_table(xmldoc, lsctables.CoincMapTable.tableName)
sngls = table.get_table(xmldoc, lsctables.SnglInspiralTable.tableName)
coincTable = organize_coincs(coincT,sngls,coincMap)

# Run the followups on each of the coincs. coinc[0] is the coinc itself
# coinc[1] is a list of its sngls (created by organize_coincs)
page = []
numF = 0
for coinc in coincTable:
  if numF < opts.max_followups:
    page.append( followup.from_new_coinc( coinc[0],coinc[1] ) )
    numF += 1

# If opts.html_table is used we read in the table add the followup to the
# table and write it out again
if opts.input_xml_summary:
  xmlSummary = utils.load_filename(opts.input_xml_summary,\
                 gz = opts.input_xml_summary.endswith("gz")) 
  summTable = table.get_table(xmlSummary,"loudest_events:table")

  for event in summTable:
    for coinc,p in zip(coincTable,page):
      if event.coinc_event_id == coinc[0].coinc_event_id:
        event.mini_followup = '''<a href = "pipedown/''' + p + '''" rel="external"> link </a>''' 
  if opts.output_html_table is not None:
    output = open(opts.output_html_table,'w')
    tableList = ['loudest_events']
    columnList = ['rank', 'combined_far', 'false_alarm_rate', 'snr', 'end_time', 'end_time_ns', 'mass', 'mchirp', 'ifos', 'instruments_on', 'duration']
    print_tables.print_tables(summTable, output, "html",\
        tableList = tableList,columnList = columnList,round_floats = True, \
        decimal_places = 2, title = None,print_table_names = False)
    output.close()

  for event in summTable:
    for coinc,p in zip(coincTable,page):
      if event.coinc_event_id == coinc[0].coinc_event_id:
        event.mini_followup = p
  utils.write_filename(xmlSummary,opts.input_xml_summary,xsl_file='ligolw.xsl')

