#!/usr/bin/python
"""
routine to follow triggers from new style coinc xml tables
"""
# $Id$

from __future__ import division

__author__ = "Ian Harry <ian.harry@astro.cf.ac.uk>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]
__prog__="minifollowups"
__Id__ = "$Id$"

import sys,os
from optparse import *
from glue import lal
from pylal import SnglInspiralUtils
from pylal import CoincInspiralUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from glue.ligolw.utils import print_tables
import matplotlib
matplotlib.use('Agg')
from pylal import followup_trigger

def organize_coincs(new_coincs,sngls,coinc_map):
# This function takes a (new style) coinc table and sngl table along with
# the experiment map and returns a list of [coinc,[sngls]].
  coinc_list = []
  i = 0
  for coinc in new_coincs:
    coinc_list.append([])
    coinc_list[i].append(coinc)
    snglEventIds = []
    for map in coinc_map:
      if coinc.coinc_event_id == map.coinc_event_id:
        snglEventIds.append(map.event_id)
    snglList = []
    for sngl in sngls:
       if sngl.event_id in snglEventIds:
         snglList.append(sngl)
    coinc_list[i].append(snglList)
    i += 1
  return coinc_list

def organize_found_injs(summTable,sims):
# This function associates a sim inspiral to a "selected found injection"
  injList = []
  i = 0
  for event in summTable:
    injList.append([])
    injList[i].append(event)
    for sim in sims:
      if sim.simulation_id == event.simulation_id:
        injList[i].append(sim)
    i += 1
  return injList

def get_column_list(tableName):
  if tableName == "loudest_events":
    columnList = []
  elif tableName == "close_missed_injections":
    columnList = ['rank', 'decisive_distance', 'end_time', 'end_time_ns', 'end_time_utc__Px_click_for_daily_ihope_xP_', 'elogs', 'mini_followup']
  elif tableName == 'selected_found_injections':
    columnList = ['recovered_combined_far','recovered_snr','injected_end_time','injected_end_time_utc__Px_click_for_daily_ihope_xP_','elogs','mini_followup','injected_mass1','injected_mass2','injected_distance']
  return columnList

usage = """%prog [options]

Minifollowup is a code designed to run followups on new style xml files with
coinc_inspiral_tables in them. It can also take in the html table files output
by printlc and add the mini followup to it for write_ihope_page usage.
"""

parser = OptionParser( usage=usage)
parser.add_option("-g","--cache-string",action="store",type="string",\
      default=None, metavar=" USERTAG",\
      help="This is used to parse the cache file. Only files with this string in them will be used" )
parser.add_option("-c", "--cache-file", action="store", type="string", default=None, metavar="CACHEFILE",\
      help="The ihope cache file to be used")
parser.add_option("-p","--prefix",action="store",type="string",\
      default=None, metavar=" PREFIX",\
      help="Used to prefix the plot names" )
parser.add_option("-s","--suffix",action="store",type="string",\
      default=None, metavar=" SUFFIX",\
      help="Used as a suffix in the plot names" )
parser.add_option("-o","--output-path",action="store",type="string",\
      default=".", metavar=" PATH",\
      help="The output path for the plots" )
parser.add_option("-x","--input-xml",action="store",type="string",\
      default=None, metavar=" INPUTXML",\
      help="The input xml file containing the relevant events for followup" )
parser.add_option("-N","--table-name",action="store",type="string",\
      default=None, metavar="INJTABNAME",\
      help="The table we want to add followups to. Currently can be 'loudest_events' 'close_missed_injection' or 'selected_found_injections'" )
parser.add_option("-t","--input-xml-summary",action="store",type="string",\
      default=None, metavar=" INPXMLSUMMTABLE",\
      help="The input xml summary table (needed for quiet found injections and coinc triggers if you want to add the followups to these tables)" )
parser.add_option("-T","--output-html-table",action="store",type="string",\
      default=None, metavar=" INPXMLSUMMTABLE",\
      help="The output html summary table file name." )
parser.add_option("","--max-followups",action="store",\
      type="int",  metavar="MAXFOLLOWUPS",default = 15,\
      help="Only followup this number of files.")
parser.add_option("-v","--verbose",action="store_true",\
      default=False,help="print information" )

(opts,args) = parser.parse_args()

if opts.table_name == 'loudest_events':
  FUPtype = 'LE'
elif opts.table_name == 'close_missed_injections':
  FUPtype = 'CMI'
elif opts.table_name == 'selected_found_injections':
  FUPtype = 'SFI'
else:
  print >>sys.stderr, "--table-name is not a recognized table name. Run --help."
  sys.exit(0)

# Followup_trigger needs the following options to be set

opts.followup_exttrig = False
opts.followup_flow = 40.0
opts.figure_resolution = 50
opts.output_path = opts.output_path + '/'
opts.suffix = '_' + opts.suffix
opts.verbose = True
opts.followup_time_window = 10
opts.user_tag = opts.cache_string

if not os.path.isdir('Images'):
  os.mkdir('Images')

# Sieve the ihope cache file
cache = lal.Cache.fromfile( open( opts.cache_file ) )
temp_cache = cache.sieve (description = opts.cache_string )
followup = followup_trigger.FollowupTrigger( temp_cache, opts, False )

# Read in the xml file
xmldoc = utils.load_filename( opts.input_xml,
    gz = opts.input_xml.endswith("gz"))
if FUPtype == 'LE':
  coincT = table.get_table(xmldoc, lsctables.CoincInspiralTable.tableName)
  coincMap = table.get_table(xmldoc, lsctables.CoincMapTable.tableName)
  sngls = table.get_table(xmldoc, lsctables.SnglInspiralTable.tableName)
  coincTable = organize_coincs(coincT,sngls,coincMap)
  xmlSummary = utils.load_filename(opts.input_xml_summary,\
                 gz = opts.input_xml_summary.endswith("gz"))  
  summTable = table.get_table(xmlSummary,opts.table_name + ":table")
elif FUPtype == 'CMI':
  summTable = table.get_table(xmldoc,opts.table_name + ":table")
elif FUPtype == 'SFI':
  xmlSummary = utils.load_filename(opts.input_xml_summary,\
                   gz = opts.input_xml_summary.endswith("gz"))
  summTable = table.get_table(xmlSummary,opts.table_name + ":table")
  sims = table.get_table(xmldoc,lsctables.SimInspiralTable.tableName)
  simTable = organize_found_injs(summTable,sims)
  
  


# Run the followups on each of the coincs. coinc[0] is the coinc itself
# coinc[1] is a list of its sngls (created by organize_coincs)
page = []
numF = 0
if FUPtype == 'CMI':
  for inj in summTable:
    if numF < opts.max_followups:
      page.append( followup.from_injection( inj,more_infos=True ) )
      numF += 1
elif FUPtype == 'LE':
  for coinc in coincTable:
    if numF < opts.max_followups:
      page.append( followup.from_new_coinc( coinc[0],coinc[1] ) )
      numF += 1
elif FUPtype == 'SFI':
  for event in simTable:
    if numF < opts.max_followups:
      page.append( followup.from_injection( event[1],more_infos=True))
      numF += 1

# If opts.html_table is used we read in the table add the followup to the
# table and write it out again

if FUPtype == 'LE':
  for event in summTable:
    for coinc,p in zip(coincTable,page):
      if event.coinc_event_id == coinc[0].coinc_event_id:
        event.mini_followup = '''<a href = "pipedown/''' + p + '''" rel="external"> link </a>''' 
elif FUPtype == 'CMI' or FUPtype == 'SFI':
  for event,p in zip(summTable,page):
    event.mini_followup = '''<a href = "pipedown/''' + p + '''" rel="external"> link </a>'''

if opts.output_html_table is not None:
  output = open(opts.output_html_table,'w')
  tableList = [opts.table_name]
  columnList = get_column_list(opts.table_name)
  print_tables.print_tables(summTable, output, "html",\
      tableList = tableList,columnList = columnList,round_floats = True, \
      decimal_places = 2, title = None,print_table_names = False)
  output.close()

if FUPtype == 'LE':
  for event in summTable:
    for coinc,p in zip(coincTable,page):
      if event.coinc_event_id == coinc[0].coinc_event_id:
        event.mini_followup = p
  utils.write_filename(xmlSummary,opts.input_xml_summary,xsl_file='ligolw.xsl')
else:
  for event,p in zip(summTable,page):
    event.mini_followup = p 
  utils.write_filename(xmldoc,opts.input_xml,xsl_file='ligolw.xsl')


