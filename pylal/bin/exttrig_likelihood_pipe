#!/usr/bin/env python
"""
exttrig_likelihood_pope - generates steps to test likelihood or to open the box

$Id$

This script generates a condor DAG(?) for the last step of the 
inspiral exttrig pipeline, which is either to create likelihood plots
with a fake onsource trial or to open the box with the real onsource data.
"""

__author__ = 'Alexander Dietz <Alexander.Dietz@lapp.in2p3.fr>'
__date__ = '$Date$'
__version__ = '$Revision$'[11:-2]

##############################################################################
# import standard modules and append the lalapps prefix to the python path
import sys
import os
from optparse import *
import ConfigParser

##############################################################################
# import the modules we need to build the pipeline
from glue import segmentsUtils
from glue import segments
from glue import lal
from pylal import SimInspiralUtils

############################################
def check_exist_file( file ):
   """
   Checks the existance of the given file
   """
   check_exist = True
   try:
     f = open( file )
   except IOError:
     check_exist = False
   return check_exist

############################################
def create_list_veto_files(opts, categories):
  """
  Creates a list of veto files to be used to discard
  triggers from vetoed times.
  @param opts: the options structure
  @param: categories: A list of categories which should be included
  """
   
  # split the used IFO's
  ifos = [opts.ifo_tag[2*i:2*i+2] for i in range(len(opts.ifo_tag)/2)]
  
  # loop over the used IFO's and used categories
  veto_files = ''
  for cat in categories:
     for ifo in ifos:
        veto_files += ',../../%s_cat%d_vetoed_segments.txt' % \
                      (ifo, cat)

  return veto_files


############################################
def create_relic_call(cp, opts, onsource_file=None):
  """
  Create the call to pylal_relic in order to procude files that are 
  being used by the likelihood call later
  """ 

  # extract useful information from the ini-file
  cache_file = cp.get('common','cache-file')
  input_user_tag = cp.get('pipeline','input-user-tag')

  # put together the relic call
  call = './executables/pylal_relic'
  call+= ' --cache-file '+cache_file
  if onsource_file is None:
    # create offsource and injections pickle files
    call+= ' --inj-coinc-pattern '+opts.inj_coinc_pattern
    call+= ' --injection-pattern '+opts.injection_pattern
    call+= ' --user-tag '+input_user_tag
    call+= ' --write-offsource --write-injections'
  else:
    # create the onsource pickle files
    call+= ' --onsource-glob ' +onsource_file 
    call+= ' --write-onsource'
    call+= ' --user-tag '+input_user_tag+'_'+opts.user_tag
    
  # create veto file containing offsource overlaping vetoes
  veto_files = create_list_veto_files(opts, [2])

  # set common options
  call+= ' --offsource-pattern THINCA_SECOND*OFFSOURCE_CATEGORY_1'
  call+= ' --statistic '+cp.get('plotthinca','statistic')
  call+= ' --veto-segfiles ../bufferSeg.txt%s --onsource-seg ../onSourceSeg.txt' % \
         (veto_files)
  call+= ' --m2-min 1 --m2-max 40 --m2-nbins 13'
  call+= ' --D-min 0.5 --D-max 50 --D-nbins 40'
  call+= ' --mc-boundaries '+cp.get('grbtimeslidestats','mc-boundaries')
  call+= ' --verbose'

  return call
 
 
############################################
def create_paste_call(cp, opts):
  """
  Create the call to paste_insp_triggers in order to 
  create a fake onsource trial (either from offsource of injections)
  """

  # get the cache-file
  cache_file = cp.get('common','cache-file')
  cache = lal.Cache.fromfile(open(cache_file))

  #sieve the onsource file
  pattern = 'THINCA_SECOND*'+cp.get('pipeline','zerolag-suffix')
  dest_cache = cache.sieve(description = pattern)
  if len(dest_cache)!=1:
    raise ValueError, "One onsource file expected, %d files found: %s" %\
             (len(dest_cache), dest_cache.pfnlist())

  # sieve the fake file
  if opts.fake=='offsource':  
    pattern = 'THINCA_SECOND*'+cp.get('pipeline','offsource-suffix')
    source_cache = cache.sieve(description = pattern)
  else:
    inj_pattern = 'INJECTION*'+opts.inj_run+'_'+str(opts.inj_id)
    inj_cache = cache.sieve(description = inj_pattern).sieve(ifos='HL')

    pattern = 'THINCA_SECOND*'+opts.inj_run+'_'+str(opts.inj_id)
    source_cache = cache.sieve(description = pattern)

  source_filename = source_cache.pfnlist()[0]

  # create the output file name
  dest_filename = dest_cache.pfnlist()[0]
  ifo_times = os.path.basename(dest_filename).split('-')[0]
  segment = dest_cache[0].segment

  input_user_tag = cp.get('pipeline','input-user-tag')
  output_filename = ifo_times+'-THINCA_SECOND_'+input_user_tag+'_'+opts.user_tag+\
     '_ONSOURCE_FAKE-'+str(segment[0])+'-'+str(abs(segment))+'.xml'

  # create the function call
  call='./executables/paste_insp_triggers'
  call+=' --source '+ source_filename
  call+=' --destination '+dest_filename
  call+=' --paste-strategy delete_all'
  call+=' --output-filename '   +output_filename
  call+=' --event-id-type int_8s --restrict-source-times --verbose'

  if opts.fake=='offsource':
    call+= ' --take-offsource-trial '+str(opts.trial)
  else:
    # read the siminspiral table, take the first injection
    inj_filename = inj_cache.pfnlist()[0]
    sims = SimInspiralUtils.ReadSimInspiralFromFiles([inj_filename])
    on_segs = segmentsUtils.fromsegwizard(open('../onSourceSeg.txt'),
                                                    coltype=int)
   
    # compute the time-shift 
    shift = on_segs[0][0] + 3.0 - sims[0].geocent_end_time - sims[0].geocent_end_time_ns*1.0e-9
    call+= ' --shift-triggers '+str(shift)

  return (call, output_filename)

############################################
def create_likelihood_call(cp, opts):
  input_user_tag = cp.get('pipeline', 'input-user-tag')

  # create the code-call
  call = './executables/pylal_grblikelihood'
  call += ' --relic-offsource ' + namePickleOffsource
  call += ' --relic-injections ' + namePickleInjections
  call += ' --user-tag ' + input_user_tag + '_' + opts.user_tag

  if opts.stage=='OPENBOX':
    dir = cp.get('common', 'output-path') + 'OPENBOX'
    if not os.path.isdir(dir):
      os.mkdir(dir)
    call += ' --relic-onsource ' + namePickleOPENBOX
  else:
    call += ' --relic-onsource ' + namePickleOnsource
    call += ' --verbose'

  return call

def create_plotgrbl_call(cp, opts):
  
  input_user_tag = cp.get('pipeline', 'input-user-tag')

  # create the code-call
  call = './executables/plotgrbl'
  call += ' --relic-offsource ' + namePickleOffsource
  call += ' --relic-injections ' + namePickleInjections
  call += ' --grblikelihood-offsource ' + namePickleOffsource\
    .replace("relic", "grblikelihood")\
    .replace(".pickle", '_' + opts.user_tag + ".pickle")
  call += ' --grblikelihood-injections ' + namePickleInjections\
    .replace("relic", "grblikelihood")\
    .replace(".pickle", '_' + opts.user_tag + ".pickle")

  call += ' --gps-start-time ' + cp.get('common', 'gps-start-time')
  call += ' --gps-end-time ' + cp.get('common', 'gps-end-time')
  call += ' --ifo-tag ' + opts.ifo_tag
  call += ' --user-tag ' + input_user_tag + '_' + opts.user_tag
  call += ' --enable-output'

  if opts.stage=='OPENBOX':
    dir = cp.get('common','output-path')+'OPENBOX'
    if not os.path.isdir(dir):
      os.mkdir(dir)
    
    call+=' --relic-onsource '+namePickleOPENBOX
    call += ' --grblikelihood-onsource ' \
        + namePickleOPENBOX.replace("relic", "grblikelihood")
    call+=' --output-path '+ dir
  else:
    call+=' --relic-onsource '+namePickleOnsource
    call += ' --grblikelihood-onsource ' \
        + namePickleOnsource.replace("relic", "grblikelihood")
    call+=' --output-path '+ cp.get('common','output-path')
    call+=' --verbose'

  return call

def create_grbUL_call(cp, opts):
  
  input_user_tag = cp.get('pipeline', 'input-user-tag')

  # create the code-call
  call = './executables/pylal_grbUL'
  call += ' --relic-offsource ' + namePickleOffsource
  call += ' --relic-injections ' + namePickleInjections
  call += ' --grblikelihood-offsource ' + namePickleOffsource\
    .replace("relic", "grblikelihood")\
    .replace(".pickle", '_' + opts.user_tag + ".pickle")
  call += ' --grblikelihood-injections ' + namePickleInjections\
    .replace("relic", "grblikelihood")\
    .replace(".pickle", '_' + opts.user_tag + ".pickle")

  call += ' --gps-start-time ' + cp.get('common', 'gps-start-time')
  call += ' --gps-end-time ' + cp.get('common', 'gps-end-time')
  call += ' --ifo-tag ' + opts.ifo_tag
  call += ' --user-tag ' + input_user_tag + '_' + opts.user_tag
  call += ' --enable-output'
  call += ' --calib-factor 0.306'
  call += ' --likelihood-threshold 1'
  call += ' --nonuniform-smoothing-D 0.025'
  call += ' --include-MC-error 1.28'

  if opts.stage=='OPENBOX':
    dir = cp.get('common','output-path')+'OPENBOX'
    if not os.path.isdir(dir):
      os.mkdir(dir)
    
    call+=' --relic-onsource '+namePickleOPENBOX
    call += ' --grblikelihood-onsource ' \
        + namePickleOPENBOX.replace("relic", "grblikelihood")
    call+=' --output-path '+ dir
  else:
    call+=' --relic-onsource '+namePickleOnsource
    call += ' --grblikelihood-onsource ' \
        + namePickleOnsource.replace("relic", "grblikelihood")
    call+=' --output-path '+ cp.get('common','output-path')
    call+=' --verbose'

  return call

def create_summary_call(cp, opts):
  input_user_tag = cp.get('pipeline', 'input-user-tag')

  filename = 'pylal_exttrig_summary-' + input_user_tag + '_' +\
             opts.user_tag + '.tar'
  
  # create the code-call
  call = './executables/pylal_exttrig_summary'
  call += ' --plot-config-file ' + opts.config_file
  call += ' --ifo-times ' + opts.ifo_tag
  call += ' --type ' + opts.user_tag
  call += ' --output-file ' + filename

  if opts.publish_path:
     call += ' --output-path-html ' + opts.publish_path
  
  return call

#
##############################################################################
usage = """usage: %prog [options] 
"""

parser = OptionParser( usage )

parser.add_option("-v", "--version",action="store_true",default=False,\
    help="print version information and exit")
    
parser.add_option("-u", "--user-tag",action="store",type="string",\
    default='',metavar=" USERTAG",\
    help="tag the jobs with USERTAG (overrides value in ini file)")

parser.add_option("-t", "--ifo-tag",action="store",type="string",\
    default='',metavar=" IFOTAG",\
    help="specify the IFO tag ")

parser.add_option("-c", "--inj-coinc-pattern",action="store",type="string",\
    default=None,metavar=" INJCOINCPATTERN",\
    help="specify the inj-coinc-pattern (for relic)")

parser.add_option("-i", "--injection-pattern",action="store",type="string",\
    default=None,metavar=" INJECTIONPATTERN",\
    help="specify the injECTION-pattern (for relic)")

parser.add_option("-f", "--config-file",action="store",type="string",\
    metavar=" FILE",help="use configuration file FILE")

parser.add_option("-p", "--log-path",action="store",type="string",\
    metavar=" PATH",help="directory to write condor log file")

parser.add_option("-w", "--write-script", action="store_true", default=False,
      help="write the workflow to a locally executable script")

parser.add_option("-s", "--stage",action="store",type="string",\
    metavar=" STAGE",help="specified the stage to run (relic, fake, OPENBOX)")

parser.add_option("-F", "--fake",action="store",type="string",\
    metavar=" FAKE",help="specifies how to fake the onsource (one of {offsource,injection})")

parser.add_option("-T", "--trial",action="store",type="int",\
    metavar=" TRIAL",help="specified the stage to run (relic, fake, OPENBOX)")

parser.add_option("-I", "--inj-run",action="store",type="string",\
    metavar=" INJRUN",help="specifies from what injection run to choose the injection")

parser.add_option("-D", "--inj-id",action="store",type="int",\
    metavar=" INJID",help="specifies the injection ID to use ")

parser.add_option("-P", "--publish-path",action="store",type="string",\
    default=None, help="specifies a directory where to publish the summary page")


command_line = sys.argv[1:]
(opts,args) = parser.parse_args()

#################################
#ALPHABETS USED IN THIS CODE.

#################################
# if --version flagged
if opts.version:
  print "$Id$"
  sys.exit(0)


#################################
# Sanity check of input arguments
################################

# Checks for config file
if not opts.config_file:
  print >> sys.stderr, "No configuration file specified."
  print >> sys.stderr, "Use --config-file FILE to specify location."
  sys.exit(1)

# check the stage to run
allStages = ['relic','fake','OPENBOX']
if opts.stage not in allStages:
  print >>sys.stderr, "Must specify --stage [STAGE]"
  print >>sys.stderr, "with one of: {relic, fake, OPENBOX}"
  sys.exit(1)

#if opts.user_tag is None and opts.stage=='fake':
#  print >>sts.stderr, "Must specify --user-tag to specify "
if opts.stage=='fake':
  if opts.fake is None:
    print >>sys.stderr, "Must specify --fake [FAKE]"
    print >>sys.stderr, "with one of: {offsource, injection}"
    sys.exit(1)
  if opts.fake=='offsource' and opts.trial is None:
    print >>sys.stderr, "Must specify --trial trial_number if you want to"
    print >>sys.stderr, "create a fake onsource trial from the offsource."
    sys.exit(1)
  if opts.fake=='injection' and (opts.inj_run is None or opts.inj_id is None):
    print >>sys.stderr, "Must specify --inj-run and --inj-id if you want to"
    print >>sys.stderr, "create a fake onsource trial from an injection."
    sys.exit(1)
  if opts.user_tag is None:
    print >>sys.stderr, "Must specify --user-tag for stage fake"
    sys.exit(1)


if opts.stage=='relic':
  if opts.inj_coinc_pattern is None or opts.injection_pattern is None:
    print >>sys.stderr, "Must specify --inj-coinc-pattern and --injection-pattern if you want to"
    print >>sys.stderr, "run the relic-stage if this script."
    sys.exit(1)


if opts.stage=='OPENBOX':
  # security check
  s = raw_input('Really opening the box? (yes/no)--> ')
  print s
  if s!='yes':
    print >>sys.stderr, "Aborting code. Box is not being opened"
    sys.exit(0)
  else:
    print >>sys.stderr, "WARNING: Opening the box"
  opts.user_tag='OPENBOX'
  
##############################################################################
# create the config parser object and read in the ini file
cp = ConfigParser.ConfigParser()
cp.read(opts.config_file)

# Checks if input-user-tag is specified (mostly GRB name).
input_user_tag = cp.get('pipeline','input-user-tag')

# create the filenames of the relic files
namePickleOnsource = 'pylal_relic_onsource_'+input_user_tag+'_'+opts.user_tag+'.pickle'
namePickleOffsource = 'pylal_relic_offsource_'+input_user_tag+'.pickle'
namePickleInjections = 'pylal_relic_injections_'+input_user_tag+'.pickle'
namePickleOPENBOX = 'pylal_relic_onsource_'+input_user_tag+'_OPENBOX.pickle'

# check if the relic-files exist if the stage is not relic
if opts.stage!='relic':
  if (not check_exist_file(namePickleOffsource) ) or (not check_exist_file(namePickleInjections)):
    print >> sys.stderr, "Either the offsource-pickle file %s is missing"\
              " or the injections pickle-file %s. "\
              "You might want to run the relic stage..." % ( namePickleOffsource, namePickleInjections)
    sys.exit(1)


##############################################################################
# create the jobs that will be used 

# create the command script file
script_filename = 'runLikelihoodPipe_'+opts.stage+'.sh'
f = open(script_filename, 'w')


# relic:
if opts.stage=='relic':
 
  cmd = create_relic_call( cp, opts )
  print >>f, cmd

if opts.stage=='fake':
  
  cmd1, fake_file = create_paste_call( cp, opts )
  print >>f, cmd1
  cmd2 = create_relic_call( cp, opts, fake_file)
  print >>f, cmd2
  cmd3 = create_likelihood_call( cp, opts)
  print >>f, cmd3
  cmd4 = create_plotgrbl_call( cp, opts)
  print >>f, cmd4
  cmd5 = create_grbUL_call( cp, opts)
  print >>f, cmd5
  cmd6 = create_summary_call(cp, opts)
  print >>f, cmd6

if opts.stage=='OPENBOX':

  onsourceFiles = '../onsource/*THINCA_SECOND*'+cp.get('pipeline','zerolag-suffix')+'*.xml*'
  cmd1 = create_relic_call( cp, opts, onsourceFiles)
  print >>f, cmd1
  cmd3 = create_likelihood_call( cp, opts)
  print >>f, cmd3
  cmd4 = create_plotgrbl_call( cp, opts)
  print >>f, cmd4
  cmd5 = create_grbUL_call( cp, opts)
  print >>f, cmd5
  cmd6 = create_summary_call(cp, opts)
  print >>f, cmd6
  
f.close()
print "Created script '%s'" % script_filename
