#!/usr/bin/python

__version__ = "$Revision$"
__date__ = "$Date$"
__name__ = "plotinspiralrange"
__Id__ = "$Id$"

# $Source$


"""
Inspiral range plotting tool for TMPLTBANK/INSPIRAL files
"""

__title__ = "Inspiral Range Plots"

import sys
import glob
from optparse import *
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from glue import lal
#from pylal import readFiles


#######################################################################
class ContentHandler(ligolw.PartialLIGOLWContentHandler):
  def __init__(self, xmldoc):
    """
    New content handler that only reads in the SummValue table
    """
    def element_filter(name, attrs):
      """
      Return True if name and attrs describe a SummValueTable
      """
      return lsctables.IsTableProperties(lsctables.SummValueTable, name, attrs) 
    ligolw.PartialLIGOLWContentHandler.__init__(self, xmldoc, element_filter)

utils.ContentHandler = ContentHandler


def writeProcessParams(page, command_line): 
  """
  function to write out the process params that the code was called with
  """
  text = "Figures produced with "+ __name__+", "+__version__[1:len(__version__)-1]+", invoked with arguments:\n\n"+ __name__
 
  for arg in command_line:
    text += " " +  arg
  page.pre( text )
  return page


def readFiles(fList):
  """
  read in the SimInspiralTables from a list of files
  @param fList:       list of input files
  """
  output = {}
  massOutput = {}
  count=0
  if len(fList) == 0:
    return output
  for thisFile in fList:
    if opts.verbose:
      print str(count)+"/"+str(len(fList))+" " + thisFile
    count =count+1
    massNum = 0
    doc = utils.load_filename(thisFile, gz = thisFile.endswith(".gz"))
    for row in doc.childNodes[0]:
      if row.name == 'inspiral_effective_distance':
        if (row.comment == '1.40_1.40_8.00') or (row.comment == '1.4_1.4_8'):
          if not output.has_key(row.ifo):
            output[row.ifo] = lsctables.New(lsctables.SummValueTable)
          output[row.ifo].append(row)
    for row in doc.childNodes[0]:
      if row.name == 'inspiral_effective_distance':
        if not massOutput.has_key(row.ifo):
          massOutput[row.ifo] = [lsctables.New(lsctables.SummValueTable)]
        if len(massOutput[row.ifo]) < massNum + 1:
          massOutput[row.ifo].append(lsctables.New(lsctables.SummValueTable))
        massOutput[row.ifo][massNum].append(row)
        massNum += 1
  return output,massOutput


def stairs(xVal,yVal):
  """
  takes in x and y values you want to plot using stairs
  and returns the necessary values to use with plot()
  """
  xLen = 2*(len(xVal))
  for i in range(xLen):
    if i == 0:
      xStairs = [xVal[0]]
      yStairs = [yVal[0]]
    elif i == xLen-1:
      xStairs.append(xVal[len(xVal)-1])
      yStairs.append(yVal[len(yVal)-1])
    elif not i%2:
      xStairs.append(mean(xVal[i/2-1],xVal[i/2]))
      yStairs.append(yVal[i/2])
    else:
      xStairs.append(mean(xVal[(i-1)/2],xVal[(i+1)/2]))
      yStairs.append(yVal[(i-1)/2])
  return xStairs,yStairs

def create_output_name(opts):
  """
  
  """
  if not opts.user_tag: 
    prefix = opts.ifo_time +"-"+ __name__ + "_"
  else:
    prefix = opts.ifo_time +"-"+ __name__ + "_" + opts.user_tag + "_"
  if opts.gps_start_time and opts.gps_end_time :
    suffix = "-"+str(opts.gps_start_time)+"-"+str(opts.gps_end_time-opts.gps_start_time)
  else:
    suffix = "-unspecified-gpstime"
  
  return prefix, suffix

def init_page( opts):
  """

  """
  # Initialise the html output file
  if opts.enable_output is True:
    try:
      import markup
      from markup import oneliner as extra
    except: 
      raise ImportError("Require markup.py to generate the html page")

#    html_filename = prefix[0:len(prefix)-1] + suffix +".html"
#    html_file = file(html_filename, "w")
    page = markup.page()
    title = __title__
    page.init(title=title)
    
  return page, extra

def plotinspiralrange_histogram(opts, figure_number):
  """

  """
  
  prefix, suffix = create_output_name(opts)
  
  # iterate figure number 
  figure_number = figure_number + 1
  figure(figure_number)
  
  if opts.range_min < 0 or opts.range_max < 0:
    print >>sys.stderr, \
        "Must specify --range-min and --range-max for range hist"
    sys.exit(1)

  if opts.plot_type == 'log':
    opts.range_min = log10(opts.range_min)
    opts.range_max = log10(opts.range_max)

  bins = arange(opts.range_min,opts.range_max, \
      (opts.range_max - opts.range_min)/ opts.nbins)

  if opts.plot_type == 'log':
    bins = 10**bins
    opts.range_min = 10**(opts.range_min)
    opts.range_max = 10**(opts.range_max)

  num = {}
  for ifo in inspiralSumm.keys():
    Range = inspiralSumm[ifo].getColumnByName('value').asarray()
    startTimeSec = inspiralSumm[ifo].getColumnByName('start_time').asarray()
    style = colors[ifo]
    [num[ifo],bins,blah] = hist(Range,bins)

  clf()
  for ifo in inspiralSumm.keys():
    if opts.plot_type == 'log':
      semilogx(bins,num[ifo], colors[ifo], linewidth=2, label=ifo)
    elif opts.plot_type == 'linear':
      stairsX,stairsY = stairs(bins,num[ifo])
      plot(stairsX, stairsY, colors[ifo], linewidth=2, label=ifo)

  leg=legend()
  ltext=leg.get_texts()
  setp(ltext, fontsize='x-large')
  xlim(opts.range_min, opts.range_max)
  xticks(fontsize='x-large')
  yticks(fontsize='x-large')
  xlabel('Inspiral Horizon distance (Mpc)', size='x-large')
  ylabel('Number of 2048 sec. blocks', size='x-large')
  grid()
  
  if opts.enable_output is True:
    fname = prefix + "range_hist" + suffix + ".png"
    savefig(fname)
  else:
    fname = []
  
  return fname, figure_number

def plotinspiralrange_range_versus_time(opts, figure_number):
  """
 
  """

  prefix, suffix = create_output_name(opts)
  
  # iterate figure number 
  figure_number = figure_number + 1
  figure(figure_number)

  for ifo in inspiralSumm.keys():
    Range = inspiralSumm[ifo].getColumnByName('value').asarray()
    startTimeSec = inspiralSumm[ifo].getColumnByName('start_time').asarray()
    startTime = viz.timeindays(\
        inspiralSumm[ifo].getColumnByName('start_time').asarray())
    style = colors[ifo] + 'x'
    if opts.plot_type == 'linear':
      plot(startTime, Range, style, label=ifo,\
          markersize=12, markeredgewidth=1)
    elif opts.plot_type == 'log':
      semilogy(startTime, Range, style, label=ifo,\
          markersize=12, markeredgewidth=1)
  leg=legend()
  ltext=leg.get_texts()
  setp(ltext, fontsize='x-large')
  xlabel('Days after start of run', size='x-large')
  ylabel('Inspiral Horizon distance (Mpc)', size='x-large')
  grid()

  if opts.enable_output is True:
    fname = prefix + "range_plot" + suffix + ".png"
    savefig(fname)
  else:
    fname = []
  
  return fname, figure_number
   
def plotinspiralrange_range_versus_total_mass(opts, figure_number):
  """
  
  """
  prefix, suffix = create_output_name(opts)
  # iterate figure number 
  figure_number = figure_number + 1
  figure(figure_number)

  mass = {}
  massRange = {}
  massRangeError = {}

  for ifo in massInspiralSumm.keys():
    if not mass.has_key(ifo):
      mass[ifo] = []
      massRange[ifo] = []
      massRangeError[ifo] = []
    for massNum in range(len(massInspiralSumm[ifo])):
      Range = massInspiralSumm[ifo][massNum].getColumnByName('value').asarray()
      startTimeSec = \
          massInspiralSumm[ifo][massNum].getColumnByName('start_time').asarray()
      mass[ifo].append(2*(massNum+1))
      massRange[ifo].append(mean(Range))
      massRangeError[ifo].append(std(Range))
    if opts.verbose:
      print ifo
      print mass[ifo][4],massRange[ifo][4]
      print mass[ifo][9],massRange[ifo][9]
    errorbar(mass[ifo], massRange[ifo], massRangeError[ifo], \
      fmt='x', color=colors[ifo], label=ifo)
  currentAxes = axis()
  Axes = [currentAxes[0],currentAxes[1],currentAxes[2],currentAxes[3]]
  if opts.mass_max > 0:
    Axes[1] = opts.mass_max
  if opts.mass_min > 0:
    Axes[0] = opts.mass_min
  axis(Axes)
  lines=gca().get_lines()
  leg=legend(loc='upper left')
  ltext=leg.get_texts()
  setp(lines, linewidth=2, markeredgewidth=2, markersize=10)
  setp(ltext, fontsize='x-large')
  xticks(fontsize='x-large')
  yticks(fontsize='x-large')
  xlabel('Total Mass ($M_\odot$)', size='x-large')
  ylabel('Inspiral Horizon distance (Mpc)', size='x-large')
  grid()
  
  if opts.enable_output is True:
    fname = prefix + "range_mass" + suffix + ".png"
    savefig(fname)
  else:
    fname = []
  
  return fname, figure_number

def get_filelist(opts):
  """
  reads INSPIRAL and/or TMPLTBANK files
  """
  inspiralFiles = []
  if opts.inspiral_glob:
    inspiralFiles += glob.glob(opts.inspiral_glob)
  if opts.cache_file:
    inspiralFiles += [lal.CacheEntry(line).path() \
        for line in open(opts.cache_file) if "INSPIRAL" in line]
  if opts.cache_file:
    inspiralFiles += [lal.CacheEntry(line).path() \
        for line in open(opts.cache_file) if "TMPLTBANK" in line]

  return inspiralFiles


#################################################################
# help message
usage = """\
Usage: %prog [options]

  SUMMARY:  Program for plotting the range of the instruments over a given run.
            You can make two plots

         1) A plot of the range for each ifo vs time (in days after run start)
            (--range-vs-time)  
         
         2) A histogram of the number of blocks for which a given range 
            was achieved (--range-hist).

         3) Mean range versus total mass (--range-mass).
"""

#######################################################################
def parse_command_line():
  """
  Parser function dedicated to __name__
  """
  
  parser = OptionParser( usage=usage, \
      version= "%prog CVS\n" +
      "$Id$\n" +
      "$Name$\n")
  parser.add_option("-I","--inspiral-glob",action="store",type="string",\
      default=None,metavar="INSP",\
      help="glob for files containing the string INSP")
  parser.add_option("-c","--cache-file",action="store",type="string",\
      default=None,metavar="CACHE",\
      help="name of cache file with details if inspiral files")
  parser.add_option("-m","--range-min",action="store",type="float",\
      metavar="MIN", help="minimum value on range plots", default=-1 )
  parser.add_option("-M","--range-max",action="store",type="float",\
      metavar="MAX", help="maximum value on range plots", default=-1 )
  parser.add_option("-a","--range-vs-time",action="store_true",\
      default=False,help="make a plot of range vs time" )
  parser.add_option("-b","--range-hist",action="store_true",\
      default=False,help="make a histogram of the range" )
  parser.add_option("--range-mass",action="store_true",\
      default=False,help="make a plot of the range vs total mass" )
  parser.add_option("--mass-min",action="store",type="float",\
      metavar="MIN", help="minimum x-value on mass plots", default=-1 )
  parser.add_option("--mass-max",action="store",type="float",\
      metavar="MAX", help="maximum x-value on mass plots", default=-1 )
  parser.add_option("-t","--plot-type",action="store",type="string",\
      default="linear",metavar=" PLOT_TYPE", \
      help="make either linear or log or plots" )
  parser.add_option("-n","--nbins",action="store",type="int",\
      metavar="NBINS", help="number of bins for range hist (default 100)",
      default=100)
  parser.add_option("-s","--show-plot",action="store_true",default=False,\
      help="display the figures on the terminal" )
  parser.add_option("-u","--user-tag",action="store",type="string",\
      default=None, metavar=" FNAME",\
      help="" )
  parser.add_option("-i", "--ifo-time", action="store", type="string",\
      metavar=" FNAME", help="ifo times, also used as prefix " )
  parser.add_option("-C","--output-cache",action="store_true",\
      default=False, metavar="CACHE",\
      help="generate a cache file with the figure names")
  parser.add_option("-P","--output-path",action="store",\
      type="string",default="",  metavar="PATH",\
      help="path where the figures would be stored")
  parser.add_option("-o","--enable-output",action="store_true",\
      default="false",  metavar="OUTPUT",\
      help="enable the generation of the html and cache documents")
  parser.add_option("-S","--gps-start-time",action="store",\
      type="int",  metavar="GPSSTART",\
      help="gps start time (for naming figure and output files")
  parser.add_option("-E","--gps-end-time",action="store",\
      type="int",  metavar=" GPSEND",\
      help="gps end time (for naming figure and output files")
  parser.add_option("-v","--verbose",action="store_true",\
      default=False,help="print information" )
  

  command_line = sys.argv[1:]
  (options,args) = parser.parse_args()

  # test the input options
  if not options.ifo_time:
    raise ValueError, "--ifo-time (which ifos were analysed) must be provided"

  return options, args, command_line


# ============================================================================
# -- get command line arguments
opts, args, cmd = parse_command_line()
# -- some initialisation
figure_number = 0
output_name = []   # use for the cache file

# to avoid  display problem when show plot is not used
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from pylal import viz


# ============================================================================
# -- identify the inspiral files
inspiralFiles = get_filelist(opts)

# -- Read in the summ values from the inspirals
inspiralSumm,massInspiralSumm = readFiles(inspiralFiles)

colors = {'G1':'k','H1':'r','H2':'b','L1':'g','V1':'m'}

# ============================================================================
# Initialise 
prefix, suffix = create_output_name(opts)

if opts.enable_output is True:
  # -- initialise the web page calling init_page
  page, extra = init_page(opts)
  # -- filename 
  html_filename = prefix[0:len(prefix)-1] + suffix +".html"
  html_file = file(html_filename, "w")
  # set output_cache properly: make sure there is a slash 
  if len(opts.output_path)>1 :
    opts.output_path = opts.output_path +'/'


# ============================================================================
# Make plot of range vs time

if opts.range_vs_time is True:
  # create a text for the alt and title of html document
  text ="Inspiral horizon distance for a (1.4,1.4)"+\
      " solar mass system with SNR=8"
  # -- the plot itself --
  fname,figure_number = plotinspiralrange_range_versus_time(opts, figure_number)

  # -- save results in output files --
  if opts.enable_output is True:
    # -- create a link and image html tag
    page.a(extra.img(src=[opts.output_path +fname], width=400, \
        alt=text, border="2"), title=text, href=[opts.output_path + fname])

    # -- keep track of this filename 
    output_name.append(fname)

# ============================================================================
# Make histogram of range values
if opts.range_hist is True:
  # create a text for the alt and title of html document
  text = "Histogram of inspiral horizon distance for a (1.4,1.4) solar "+\
      "mass system with SNR = 8"
  # -- the plot itself --
  fname,figure_number = plotinspiralrange_histogram(opts, figure_number)
  
  # -- save results in output files --
  if opts.enable_output is True:
    # -- create a link and image html tag
    page.a(extra.img(src=[opts.output_path +fname], width=400, \
        alt=text, border="2"), title=text, href=[opts.output_path + fname])

    # -- keep track of this filename 
    output_name.append(fname)


# ============================================================================
# Make plot of mean range vs total mass

if opts.range_mass is True:
  # create a text for the alt and title of html document
  text = "Inspiral Horizon Distance versus Mass "+\
      "at a SNR = 8"
  # -- the plot itself --
  fname,figure_number = plotinspiralrange_range_versus_total_mass(opts, figure_number)
  # -- save results in output files --

  if opts.enable_output is True:
    # -- create a link and image html tag
    page.a(extra.img(src=[opts.output_path +fname], width=400, \
        alt=text, border="2"), title=text, href=[opts.output_path + fname])

    # -- keep track of this filename 
    output_name.append(fname)



# ============================================================================
# final step: html, cahe file generation
if opts.enable_output:
  page = writeProcessParams(page, cmd)
  html_file.write(page(False))
  html_file.close()

if opts.enable_output is True:
  output_cache_name = prefix[0:len(prefix)-1] + suffix +'.cache'
  this = open(output_cache_name, 'w')
  if opts.enable_output is True: 
    this.write(html_filename + '\n')
  for fname in output_name:
    this.write(fname + '\n')
  this.close()
  


if opts.show_plot:
  show()  
