#!/usr/bin/python

# =============================================================================
# Preamble
# =============================================================================

from __future__ import division

import os,matplotlib,copy
matplotlib.use('Agg' )
import pylab
from datetime import datetime
from math import pi,sqrt
import scipy.stats
from optparse import OptionParser
from glue import segments
from pylal import date
from pylal.dq import dqSegmentUtils
from pylal.xlal.datatypes.ligotimegps import LIGOTimeGPS
from glue.ligolw import table,lsctables,utils
from pylal.coh_PTF_pyutils import *

# =============================================================================
# Parse command line
# =============================================================================

def parse_command_line():

  usage = """usage: %prog [options] 
  
coh_PTF_sbv_plotter will calculate all signal based vetoes and the final detection statistics, whilst plotting a whole bunch of stuff. Required arguments

--trig-file
--grb-name
"""

  parser = OptionParser( usage )

  parser.add_option( "-v", "--verbose", action="store_true", default=False,\
                     help="verbose output, default: %default" )

  parser.add_option( "-t", "--trig-file", action="store", type="string",\
                     default=None, help="The location of the trigger file" )

  parser.add_option( "-I", "--inj-file", action="store", type="string",\
                     default=None, help="The location of the injection file" )

  parser.add_option( "-n", "--grb-name", action="store", type="string",\
                     default=None, help="Name of the GRB such as 090802" )

  parser.add_option( "-o", "--output-path", action="store", type="string",\
                     default=os.getcwd(), help="output directory, "+\
                                               "default: %default" )

  parser.add_option( "-Q", "--chisq-index", action="store", type="float",\
                     default=4.0, help="chisq_index for newSNR calculation, "+\
                                       "default: %default" )

  parser.add_option( "-N", "--chisq-nhigh", action="store", type="float",\
                     default=3.0, help="nhigh for newSNR calculation, "+\
                                       "default: %default" )

  parser.add_option( "-a", "--segment-dir", action="store", type="string",\
                     help="directory holding buffer, on and off source "+\
                          "segment files." )

  parser.add_option( "-A", "--null-snr-threshold", action="store",\
                     type="string", default="4.25,6",\
                     help="comma separated lower,higher null SNR thresholds, "+\
                          " for null SNR cut, default: \"%default\"" )

  parser.add_option( "-l", "--veto-directory",action="store",type="string",\
                     default=None,\
                     help="The location of the CAT2/3 veto files" )


  (opts,args) = parser.parse_args()

  if not opts.trig_file:
    parser.error( "must provide trig file" )

  if not opts.grb_name:
    parser.error( "must provide --grb-name" )

  if not opts.segment_dir:
    parser.error( "must provide --segment-dir" )

  return opts, args

# =============================================================================
# Main function
# =============================================================================

def main( trigFile, injFile, tag, outdir, segdir, chisq_index=4.0,\
          chisq_nhigh=3.0, null_thresh=[4.25,6],verbose=False,vetoFiles=[] ):
  
  # set output directory
  if not os.path.isdir(outdir):
    os.makedirs(outdir)
  
  # get rcParams
  makePaperPlots()
  
  if verbose:
    print >>sys.stdout
    print >>sys.stdout, 'Loading triggers...'

  # Construct veto list
  vetoes = segments.segmentlist()
  if vetoFiles:
    for file in vetoFiles:
      # This returns a coalesced list of the vetoes
      tmpVetoSegs = dqSegmentUtils.fromsegmentxml(open(file,'r'))
      for entry in tmpVetoSegs:
        vetoes.append(entry)
  vetoes.coalesce()
 
  # load triggers
  xmldoc = utils.load_filename( trigFile, gz=trigFile.endswith("gz" ) )
  trigs  = table.get_table( xmldoc, lsctables.MultiInspiralTable.tableName )
  searchSumm = table.get_table( xmldoc, lsctables.SearchSummaryTable.tableName )

  # extract variables
  ifos = sorted( map( str, searchSumm[0].get_ifos() ) )
  ifoAtt = { 'G1':'g', 'H1':'h1', 'H2':'h2', 'L1':'l', 'V1':'v', 'T1':'t' }

  if verbose:
    print >>sys.stdout
    print >>sys.stdout, 'Loading injections...'

  # load injections
  if injFile:
    xmldoc = utils.load_filename( injFile, gz=injFile.endswith("gz" ))
    injs = table.get_table( xmldoc, lsctables.MultiInspiralTable.tableName )

  if len(trigs)<1:
    print >>sys.stderr, 'WARNING: No triggers found.'

  if verbose:
    print >>sys.stdout
    print >>sys.stdout, 'Extracting and calculating parameters...'

  # initiate trigger lists
  trigTime      = []
  trigSNR       = []
  trigBestNR    = []
  trigNullstat  = []
  trigTraceSNR  = []
  trigChiSquare = []
  trigBankVeto  = []
  trigAutoVeto  = []
  trigCoincSNR  = []
  trigFirstSNR  = []
  trigSecondSNR = []
  trigThirdSNR  = []
  # initiate injection lists
  injTime       = []
  injSNR        = []
  injBestNR     = []
  injNullstat   = []
  injTraceSNR   = []
  injChiSquare  = []
  injBankVeto   = []
  injAutoVeto   = []
  injCoincSNR   = []
  injFirstSNR   = []
  injSecondSNR  = []
  injThirdSNR   = []
  # initiate amplitude lists for 4 amplitudes
  numAmp  = 4
  amplitudes = xrange(1,numAmp+1)
  trigAmp = {}
  injAmp  = {}
  for amp in amplitudes:
    trigAmp[amp] = []
    injAmp[amp]  = []

  # initiate single IFO lists
  trigIfoSNR = {}
  trigSigma  = {}
  injIfoSNR  = {}
  injSigma   = {}
  for ifo in ifos:
    trigIfoSNR[ifo] = []
    trigSigma[ifo] = []
    injIfoSNR[ifo] = []
    injSigma[ifo] = []
  trigSigmaTot = []

  null_grad_snr = 20
 
  aPat  = {}
  fResp = {}
  for ifo in ifos:
    fResp[ifo] = [] 

  # get trigger parameters
  for trig in trigs:

    # Remove vetoed triggers
    if trig.get_end() in vetoes:
      continue

    # calculate fResp for each IFO is we haven't done so already
    trigPos = (trig.ra,trig.dec)
    if trigPos not in aPat.keys():
      ra  = trig.ra*180/pi
      dec = trig.dec*180/pi
      fPlus,fCross  = get_det_response( ra, dec, trig.get_end() )
      aPat[trigPos] = {}
      for ifo in ifos:
        aPat[trigPos][ifo] = fPlus[ifo]*fPlus[ifo] + fCross[ifo]*fCross[ifo]
    
    for ifo in ifos:
      fResp[ifo].append( aPat[trigPos][ifo] )

    # extract basic parameters
    trigTime.append(     trig.get_end() )
    trigSNR.append(      trig.snr )
    trigNullstat.append( trig.null_statistic )
    trigTraceSNR.append( trig.null_stat_degen )

    # extract single IFO SNRs and trig sigma
    sigmaTot = 0
    compsList = []
    for ifo in ifos:
      ifoSNR = getattr(trig,'snr_%s' % ifoAtt[ifo])
      trigIfoSNR[ifo].append( ifoSNR )
      compsList.append( ifoSNR )
      sig = getattr(trig,'sigmasq_%s' % ifoAtt[ifo])
      trigSigma[ifo].append( sig )
      sigmaTot += sig * aPat[trigPos][ifo]
    trigSigmaTot.append(sigmaTot)

    compsList.sort(reverse=True)
    trigFirstSNR.append( (compsList[0] ) )
    if len(ifos)>1:
      trigSecondSNR.append( (compsList[1]) )
    if len(ifos)>2:
      trigThirdSNR.append( (compsList[2])) 
    # calculate coinc SNR
    trigCoincSNR.append( sqrt(sum([ e**2 for e in compsList ])) )
  
    # get signal based tests
    if trig.chisq == 0:
      trigChiSquare.append( 0.0001 )
    else:
      trigChiSquare.append( trig.chisq )
    trigBankVeto.append( trig.bank_chisq )
    trigAutoVeto.append( trig.cont_chisq )

    for amp in amplitudes:
      a = getattr(trig,'amp_term_%d' % amp)
      if a == 0:
        a = 0.0001
      trigAmp[amp].append(a)

    bestNR = get_bestnr( trig, q=chisq_index, n=chisq_nhigh,\
                         null_thresh=null_thresh, fResp=aPat[trigPos])
    trigBestNR.append( bestNR )

  # get injection parameters 
  if injFile:
    for trig in injs:
      if trig.get_end() in vetoes:
        continue

      # calculate fResp for each IFO is we haven't done so already
      trigPos = (trig.ra,trig.dec)
      if trigPos not in aPat.keys():
        ra  = trig.ra*180/pi
        dec = trig.dec*180/pi
        fPlus,fCross   = get_det_response( ra, dec, trig.get_end() )
        aPat[trigPos] = {}
        for ifo in ifos:
          aPat[trigPos][ifo] = fPlus[ifo]*fPlus[ifo] + fCross[ifo]*fCross[ifo]

      # extract basic parameters
      injTime.append(     trig.get_end() )
      injSNR.append(      trig.snr )
      injNullstat.append( trig.null_statistic )
      injTraceSNR.append( trig.null_stat_degen )

      # extract single IFO SNRs
      compsList = []
      for ifo in ifos:
        ifoSNR = getattr(trig,'snr_%s' % ifoAtt[ifo])
        injIfoSNR[ifo].append( ifoSNR )
        compsList.append( ifoSNR )

      compsList.sort(reverse=True)
      injFirstSNR.append( (compsList[0] ) )
      if len(ifos)>1:
        injSecondSNR.append( (compsList[1]) )
      if len(ifos)>2:
        injThirdSNR.append( (compsList[2]))
      injCoincSNR.append( sqrt(sum([ e**2 for e in compsList ])) )

      if trig.chisq == 0:  
        injChiSquare.append( 0.0001 )
      else:
        injChiSquare.append( trig.chisq )
      injBankVeto.append( trig.bank_chisq )
      injAutoVeto.append( trig.cont_chisq )
      for amp in amplitudes:
        a = getattr(trig,'amp_term_%d' % amp)
        if a == 0:
          a = 0.0001
        injAmp[amp].append(a)

      bestNR = get_bestnr( trig, q=chisq_index, n=chisq_nhigh,\
                           null_thresh=null_thresh, fResp=aPat[trigPos])

      injBestNR.append( bestNR )

  # set arrays
  trigSNR       = pylab.asarray( trigSNR )
  trigBestNR = pylab.asarray( trigBestNR )
  trigChiSquare = pylab.asarray( trigChiSquare )
  trigNullstat  = pylab.asarray( trigNullstat )
  trigTraceSNR  = pylab.asarray( trigTraceSNR )
  trigCoincSNR  = pylab.asarray( trigCoincSNR )
  trigNullSNR = []
  for coincSNR,SNR in zip(trigCoincSNR,trigSNR):
    nullSNR = coincSNR**2 - SNR**2
    if nullSNR < 0:
      nullSNR = 0
    else:
      nullSNR = nullSNR**0.5
    trigNullSNR.append(nullSNR)
  trigNullSNR = pylab.asarray( trigNullSNR )
  for amp in amplitudes:
    trigAmp[amp]   = pylab.asarray( trigAmp[amp] )
  trigRelAmp1    = pylab.sqrt( ( trigAmp[1]**2 + trigAmp[2]**2)/\
                               ( trigAmp[3]**2 + trigAmp[4]**2) )
  trigGammaR     = trigAmp[1] - trigAmp[4]
  trigGammaI     = trigAmp[2] + trigAmp[3]
  trigDeltaR     = trigAmp[1] + trigAmp[4]
  trigDeltaI     = trigAmp[3] - trigAmp[2]
  trigNorm1      = trigDeltaR*trigDeltaR + trigDeltaI*trigDeltaI
  trigNorm2      = trigGammaR*trigGammaR + trigGammaI*trigGammaI
  trigNorm3      = (( trigNorm1**0.25) + (trigNorm2**0.25))**2
  trigAmpPlus    = ( trigNorm1)**0.5 + (trigNorm2)**0.5
  trigAmpCross   = (( trigNorm1)**0.5 - (trigNorm2)**0.5).__abs__()
  trigRelAmp2    = trigAmpPlus/trigAmpCross
  trigInclination = trigAmpCross/trigNorm3
  for ifo in ifos:
    fResp[ifo] = pylab.asarray(fResp[ifo]).mean()

  # normalise trigSigma
  for ifo in ifos:
    trigSigma[ifo] = pylab.asarray( trigSigma[ifo] )
  trigSigmaTot = numpy.array(trigSigmaTot)
  for ifo in ifos:
    trigSigma[ifo] /= trigSigmaTot

  if injFile:
    injSNR         = pylab.asarray( injSNR )
    injBestNR      = pylab.asarray( injBestNR )
    injChiSquare   = pylab.asarray( injChiSquare )
    injNullstat    = pylab.asarray( injNullstat )
    injTraceSNR    = pylab.asarray( injTraceSNR )
    injCoincSNR    = pylab.asarray( injCoincSNR )
    injNullSNR   = ( injCoincSNR**2 - injSNR**2)**0.5
    injNullSNR = []
    for coincSNR,SNR in zip(injCoincSNR,injSNR):
      nullSNR = coincSNR**2 - SNR**2
      if nullSNR < 0:
        nullSNR = 0
      else:
        nullSNR = nullSNR**0.5
      injNullSNR.append(nullSNR)
    injNullSNR = pylab.asarray( injNullSNR )

    for amp in amplitudes:
      injAmp[amp]  = pylab.asarray( injAmp[amp] )
    injRelAmp1     = pylab.sqrt( ( injAmp[1]**2 + injAmp[2]**2)/\
                                 ( injAmp[3]**2 + injAmp[4]**2) )
    injGammaR      = injAmp[1] - injAmp[4]
    injGammaI      = injAmp[2] + injAmp[3]
    injDeltaR      = injAmp[1] + injAmp[4]
    injDeltaI      = injAmp[3] - injAmp[2]
    injNorm1       = injDeltaR*injDeltaR + injDeltaI*injDeltaI
    injNorm2       = injGammaR*injGammaR + injGammaI*injGammaI
    injNorm3       = (( injNorm1**0.25) + (injNorm2**0.25))**2
    injAmpPlus     = ( injNorm1)**0.5 + (injNorm2)**0.5
    injAmpCross    = (( injNorm1)**0.5 - (injNorm2)**0.5).__abs__()
    injRelAmp2     = injAmpPlus/injAmpCross
    injInclination = injAmpCross/injNorm3
  
  trigSigmaMean = {}
  trigSigmaMax  = {}
  trigSigmaMin  = {}
  for ifo in ifos:
    try:
      trigSigmaMean[ifo] = trigSigma[ifo].mean()
      trigSigmaMax[ifo]  = trigSigma[ifo].max()
      trigSigmaMin[ifo]  = trigSigma[ifo].min()
    except ValueError:
      trigSigmaMean[ifo] = 0
      trigSigmaMax[ifo]  = 0
      trigSigmaMin[ifo]  = 0

  if verbose:
    print >>sys.stdout
    print >>sys.stdout, "Loudest trigger by SNR: %f" % trigSNR.max()
    print >>sys.stdout, "Loudest trigger by BestNR: %f" % trigBestNR.max()
  
  bank_conts, auto_conts,chi_conts,null_cont,snr_vals, colors =\
      calculate_contours( q=chisq_index, n=chisq_nhigh,\
                          null_thresh=null_thresh[-1],\
                          null_grad_snr=null_grad_snr )
  
  if verbose:
    print >>sys.stdout
    print >>sys.stdout, 'Plotting...'

  ptfcolormap = pylab.cm.spring
  ptfcolormap.set_over('g' )
       
  # reset times
  segs = readSegFiles(segdir)
  grbTime = segs['on'][1] - 1
  start = int(min(trigTime)) - grbTime
  end   = int(max(trigTime)) - grbTime
  duration = end-start
  start -= duration*0.05
  end += duration*0.05
  trigTime = [ t-grbTime for t in trigTime ]
  injTime  = [ t-grbTime for t in injTime ]
#  startString = datetime( *date.XLALGPSToUTC( LIGOTimeGPS( start ) )[:6] )\
#                    .strftime( "%B %d %Y, %H:%M:%S %ZUTC" )
 
  # plot time versus SNR
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigTime, trigSNR, 'bx' )
  ax.set_xlabel( "Time since %s" % grbTime )
  ax.set_xlim([ start, end ])
  ax.set_ylabel( "Coherent SNR" )
  #ax.set_ylim( [6,18])
  ax.grid()
  fig.savefig( '%s/%s_triggers_vs_time_noinj.png' % ( outdir, tag ),\
               bbox_inches='tight' )
  if injFile:
    ax.plot( injTime, injSNR, 'rx' )
    ax.set_xlim([ start, end ])
    fig.savefig( '%s/%s_triggers_vs_time.png' % ( outdir, tag ),\
               bbox_inches='tight' )

  # plot BestNR versus time
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigTime, trigBestNR, 'bx' )
  ax.set_xlabel( "Time since %s" % grbTime )
  ax.set_xlim([ start, end ])
  ax.set_ylabel( "BestNR" )
  #ax.set_ylim( [6,18])
  ax.grid()
  fig.savefig( '%s/%s_bestnr_vs_time_noinj.png' % ( outdir, tag ),\
               bbox_inches='tight' )
  if injFile:
    ax.plot( injTime, injBestNR, 'rx' )
    ax.set_xlim([ start, end ])
    fig.savefig( '%s/%s_bestnr_vs_time.png' % ( outdir, tag ),\
                 bbox_inches='tight' )
 
 
  # plot ifo time versus SNR
  for ifo in ifos:
    fig = pylab.figure()
    ax  = fig.gca()
    ax.plot( trigTime, trigIfoSNR[ifo], 'bx' )
    ax.set_xlabel( "Time since %s" % grbTime )
    ax.set_xlim([ start, end ])
    ax.set_ylabel( "%s SNR" % ifo )
    ax.grid()

    fig.savefig( '%s/%s_%s_triggers_vs_time_noinj.png'\
                 % ( outdir, tag, ifo ))
    if injFile:
      ax.plot( injTime, injIfoSNR[ifo], 'rx' )
      ax.set_xlim([ start, end ])
      fig.savefig( '%s/%s_%s_triggers_vs_time.png'\
                   % ( outdir, tag, ifo ) )
  
  # plot coherent SNR versus null stat
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigSNR, trigNullstat, 'bx' )
  ax.grid()
  if injFile:
    ax.plot( injSNR, injNullstat, 'rx' )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Null statistic" )
  ax.plot( snr_vals,null_cont, 'k-' )
  fig.savefig( "%s/%s_null_stat_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.plot( snr_vals, pylab.asarray(null_cont) - \
      (null_thresh[1] - null_thresh[0]), 'g-' )
  ax.plot( snr_vals, pylab.asarray(null_cont) - \
      (null_thresh[1] - null_thresh[0])+1,'m-' )
  ax.set_xlim( [6,30] )
  ax.set_ylim( [0,30] )
  fig.savefig( "%s/%s_null_stat_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot coherent SNR versus overwhitened null stat
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigSNR, trigNullSNR, 'bx' )
  ax.grid()
  if injFile:
    ax.plot( injSNR, injNullSNR, 'rx' )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Overwhitened null statistic" )
  ax.plot( snr_vals,null_cont, 'k-' )
  # Add shading to vetoed area
  limy = ax.get_ylim()[1]
  polyx = copy.deepcopy(snr_vals)
  polyy = copy.deepcopy(null_cont)
  polyx = pylab.append(polyx,[max(snr_vals), min(snr_vals)])
  polyy = pylab.append(polyy,[limy, limy])
  ax.fill(polyx, polyy, color = '#dddddd')

  fig.savefig( "%s/%s_null_stat2_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.plot( snr_vals, pylab.asarray(null_cont) - \
      (null_thresh[1] - null_thresh[0]), 'g-' )
  ax.plot( snr_vals, pylab.asarray(null_cont) - \
      (null_thresh[1] - null_thresh[0])+1,'m-' )
  ax.set_xlim( [6,30] )
  ax.set_ylim( [0,30] )
  fig.savefig( "%s/%s_null_stat2_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
 
  # plot coherent SNR versus coinc SNR
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigSNR, trigCoincSNR, 'bx' )
  ax.grid()
  if injFile:
    ax.plot( injSNR, injCoincSNR, 'rx' )
  ax.plot( [4,30], [4,30], 'g-' )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Coincidence SNR" )
  fig.savefig( "%s/%s_coinc_snr_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim( [6,30] )
  ax.set_ylim( [4,30] )
  fig.savefig( "%s/%s_coinc_snr_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  aT = [6,30]
  bT = [6,27.5]
  
  maxSNR = trigSNR.max()
  if injFile:
    if injSNR.max() > maxSNR:
      maxSNR = injSNR.max()
  zoomSNR = pylab.arange(0.01,maxSNR,0.01)
 
  # plot SNR versus traceSNR 
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigSNR, trigTraceSNR, 'bx' )
  ax.grid()
  if injFile:
    ax.plot( injSNR, injTraceSNR, 'rx' )
  ax.plot( aT, bT, 'g-' )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Trace SNR" )
  fig.savefig( "%s/%s_trace_snr_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim( [6,30] )
  ax.set_ylim( [4,30] )
  fig.savefig( "%s/%s_trace_snr_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot coinc SNR versus trace SNR
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigCoincSNR, trigTraceSNR, 'bx' )
  ax.grid()
  if injFile:
    ax.plot( injCoincSNR, injTraceSNR, 'rx' )
  ax.set_xlabel( "Coincidence SNR" )
  ax.set_ylabel( "Trace SNR" )
  fig.savefig( "%s/%s_trace_snr_vs_coinc_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim( [0,30] )
  ax.set_ylim( [0,30] )
  fig.savefig( "%s/%s_trace_snr_vs_coinc_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot SNR versus bank veto
  fig = pylab.figure()
  ax  = fig.gca()
  ax.loglog( trigSNR, trigBankVeto, 'bx' )
  ax.grid()
  if injFile:
    ax.loglog( injSNR, injBankVeto, 'rx' )
  plot_contours( ax, snr_vals,bank_conts, colors )
  # Add shading to vetoed area
  limy = ax.get_ylim()[1]
  polyx = copy.deepcopy(snr_vals)
  polyy = copy.deepcopy(bank_conts[1])
  polyx = pylab.append(polyx,[max(snr_vals), min(snr_vals)])
  polyy = pylab.append(polyy,[limy, limy])
  ax.fill(polyx, polyy, color = '#dddddd')
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Bank Veto" )
  ax.set_xlim( [6,1000] )
  fig.savefig( "%s/%s_bank_veto_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim( [6,50] )
  ax.set_ylim( [1,2000] )
  fig.savefig( "%s/%s_bank_veto_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot SNR versus chisq
  fig = pylab.figure()
  ax  = fig.gca()
  ax.loglog( trigSNR[trigBestNR != 0], trigChiSquare[trigBestNR != 0],\
             'bx' )
  ax.grid()
  if injFile:
    ax.loglog( injSNR[injBestNR != 0], injChiSquare[injBestNR != 0],\
               'rx' )
  plot_contours( ax, snr_vals,chi_conts, colors )
  # Add shading to vetoed area
  limy = ax.get_ylim()[1]
  polyx = copy.deepcopy(snr_vals)
  polyy = copy.deepcopy(chi_conts[1])
  polyx = pylab.append(polyx,[max(snr_vals), min(snr_vals)])
  polyy = pylab.append(polyy,[limy, limy])
  ax.fill(polyx, polyy, color = '#dddddd')
  ax.set_xlabel( "SNR" )
  ax.set_ylabel( "Chi Square" )
  ax.set_xlim( [6,1000] )
  fig.savefig( "%s/%s_chi_square_vs_snr.png" % ( outdir, tag ) )
  ax.set_xlim( [0,50] )
  ax.set_ylim( [1,2000] )
  fig.savefig( "%s/%s_chi_square_vs_snr_zoom.png" % ( outdir, tag ) )
  
  # plot SNR versus loudest SNR
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigSNR, trigFirstSNR, 'bx' )
  ax.grid()
  if injFile:
    ax.plot( injSNR, injFirstSNR, 'rx' )
  ax.plot( [0,50], [4,4], 'g-' )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "First loudest sngl SNR" )
  fig.savefig( "%s/%s_first_snr_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim( [6,50] )
  ax.set_ylim( [0,20] )
  fig.savefig( "%s/%s_first_snr_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot SNR versus second loudest
  if len(ifos)>1:
    fig = pylab.figure()
    ax  = fig.gca()
    ax.plot( trigSNR, trigSecondSNR, 'bx' )
    ax.grid()
    if injFile:
      ax.plot( injSNR, injSecondSNR, 'rx' )
    ax.plot( [6,10,50], [2.5,3.5,13.5], 'g-' )
    ax.set_xlabel( "Coherent SNR" )
    ax.set_ylabel( "Second loudest sngl SNR" )
    fig.savefig( "%s/%s_second_snr_vs_snr.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
    ax.set_xlim( [6,50] )
    ax.set_ylim( [0,20] )
    fig.savefig( "%s/%s_second_snr_vs_snr_zoom.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
  
  # plot SNR versus third loudest SNR
  if len(ifos)>2:
    fig = pylab.figure()
    ax  = fig.gca()
    ax.plot( trigSNR, trigThirdSNR, 'bx' )
    ax.grid()
    if injFile:
      ax.plot( injSNR, injThirdSNR, 'rx' )
    ax.plot( [0,50], [4,4], 'g-' )
    ax.set_xlabel( "Coherent SNR" )
    ax.set_ylabel( "Third loudest sngl SNR" )
    fig.savefig( "%s/%s_third_snr_vs_snr.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
    ax.set_xlim( [6,50] )
    ax.set_ylim( [0,20] )
    fig.savefig( "%s/%s_third_snr_vs_snr_zoom.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
  
  # plot SNR versus IFO SNR
  sens1 = None
  sens2 = None
  for ifo in ifos:
    if not sens1:
      sens1 = ifo
    elif not sens2:
      senstvty = fResp[ifo]*trigSigmaMean[ifo]
      if (fResp[ifo]*trigSigmaMean[ifo] > fResp[sens1]*trigSigmaMean[sens1]):
        sens2 = sens1
        sens1 = ifo
      else:
        sens2 = ifo
    else:
      if (fResp[ifo]*trigSigmaMean[ifo] > fResp[sens1]*trigSigmaMean[sens1]):
        sens2 = sens1
        sens1 = ifo
      elif (fResp[ifo]*trigSigmaMean[ifo] > fResp[sens2]*trigSigmaMean[sens2]):
        sens2 = ifo
  
  for ifo in ifos:

    fig = pylab.figure()
    ax  = fig.gca()
    ax.plot( trigSNR, trigIfoSNR[ifo], 'bx' )
    ax.grid()
    if injFile:
      ax.plot( injSNR, injIfoSNR[ifo], 'rx' )
    ax.plot( zoomSNR, ( (fResp[ifo]*trigSigmaMean[ifo])**0.5 ) * zoomSNR, 'g-' )
    ax.plot( zoomSNR, ( (fResp[ifo]*trigSigmaMin[ifo])**0.5 ) * zoomSNR, 'g-' )
    ax.plot( zoomSNR, ( (fResp[ifo]*trigSigmaMax[ifo])**0.5 ) * zoomSNR, 'g-' )
    ax.plot( zoomSNR, scipy.stats.ncx2.ppf( 0.0455/2., 2,\
                                            (fResp[ifo]*trigSigmaMin[ifo])*\
                                             zoomSNR**2)**0.5, 'm-' )
    ax.plot( zoomSNR, scipy.stats.ncx2.ppf( 1-0.0455/2., 2,\
                                            (fResp[ifo]*trigSigmaMax[ifo])*\
                                             zoomSNR**2)**0.5, 'm-' )
    ax.plot( zoomSNR, scipy.stats.ncx2.ppf( 0.00135/2., 2,\
                                            (fResp[ifo]*trigSigmaMin[ifo])*\
                                             zoomSNR**2)**0.5, 'c-' )
    ax.plot( zoomSNR, scipy.stats.ncx2.ppf( 1-0.00135/2., 2,\
                                            (fResp[ifo]*trigSigmaMax[ifo])*\
                                             zoomSNR**2)**0.5, 'c-' )
    ax.plot( [0,50], [4,4], 'k-' )
    if (ifo == sens1) or (ifo == sens2):
      # Shade vetoed area
      limy = ax.get_ylim()[0]
      polyx = [0,50]
      polyy = [4,4]
      polyx.extend([50,0])
      polyy.extend([limy, limy])
      ax.fill(polyx, polyy, color = '#dddddd')

    ax.set_xlabel( "Coherent SNR" )
    ax.set_ylabel( "%s sngl SNR" % ifo )
    fig.savefig( "%s/%s_%s_snr_vs_snr.png" % ( outdir, tag, ifo ),\
                 bbox_inches='tight' )
    ax.set_xlim( [6,50] )
    ax.set_ylim( [0,20] )
    fig.savefig( "%s/%s_%s_snr_vs_snr_zoom.png" % ( outdir, tag, ifo ),\
                 bbox_inches='tight' )
  
  # plot SNR versus auto veto 
  fig = pylab.figure()
  ax  = fig.gca()
  ax.loglog( trigSNR, trigAutoVeto, 'bx' )
  ax.grid()
  if injFile:
    ax.loglog( injSNR, injAutoVeto, 'rx' )
  plot_contours( ax, snr_vals, auto_conts, colors )
  # Add shading to vetoed area
  limy = ax.get_ylim()[1]
  polyx = copy.deepcopy(snr_vals)
  polyy = copy.deepcopy(auto_conts[1])
  polyx = pylab.append(polyx,[max(snr_vals), min(snr_vals)])
  polyy = pylab.append(polyy,[limy, limy])
  ax.fill(polyx, polyy, color = '#dddddd')
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Auto Veto" )
  fig.savefig( "%s/%s_auto_veto_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim( [6,30] )
  ax.set_ylim( [10,20000] )
  fig.savefig( "%s/%s_auto_veto_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot SNR versus SNR-traceSNR
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigSNR, trigSNR - trigTraceSNR, 'bx' )
  ax.grid()
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "SNR - Trace SNR" )
  fig.savefig( "%s/%s_tracediff_noinj.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  if injFile:
    ax.plot( injSNR, injSNR - injTraceSNR, 'rx' )
    fig.savefig( "%s/%s_trace_diff_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
    ax.set_xlim( [6,20] )
    ax.set_ylim( [-5,10] )
    fig.savefig( "%s/%s_trace_diff_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot time versus null stat
  fig = pylab.figure()
  ax  = fig.gca()
  ax.plot( trigTime, trigNullstat, 'bx' )
  ax.grid()
  if injFile:
    ax.plot( injTime, injNullstat, 'rx' )
  ax.set_xlabel( "Time since %s" % grbTime )
  ax.set_xlim([ start, end ])
  ax.set_ylabel( "Null SNR" )
  fig.savefig( "%s/%s_null_snr_vs_time.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot SNR versus rel amp
  fig = pylab.figure()
  ax  = fig.gca()
  ax.loglog( trigSNR, trigRelAmp1, 'bx' )
  ax.grid()
  if injFile:
    ax.loglog( injSNR, injRelAmp1, 'rx' )
  ax.set_xlabel( "Coherent SNR" )
  ax.set_ylabel( "Relative amplitude" )
  fig.savefig( "%s/%s_rel_amp_vs_snr.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  ax.set_xlim([ 6, 30 ])
  fig.savefig( "%s/%s_rel_amp_vs_snr_zoom.png" % ( outdir, tag ),\
               bbox_inches='tight' )
  
  # plot SNR versus rel amp 2
  try:
    fig = pylab.figure()
    ax  = fig.gca()
    ax.loglog( trigSNR, trigRelAmp2, 'bx' )
    ax.grid()
    if injFile:
      ax.loglog( injSNR, injRelAmp2, 'rx' )
    ax.set_xlabel( "Coherent SNR" )
    ax.set_ylabel( "Relative amplitude" )
    fig.savefig( "%s/%s_rel_amp2_vs_snr.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
    ax.set_xlim( [6,30] )
    fig.savefig( "%s/%s_rel_amp2_vs_snr_zoom.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
  except OverflowError:
    print >>sys.stderr, 'WARNING: Relative amplitude versus coherent SNR '+\
                        'failed with zeros in a loglog plot'

  # plot SNR versus norm 3
  try:
    fig = pylab.figure()
    ax  = fig.gca()
    ax.loglog( trigSNR, trigNorm3, 'bx' )
    ax.grid()
    if injFile:
      ax.loglog( injSNR, injNorm3, 'rx' )
    ax.set_xlabel( "Coherent SNR" )
    ax.set_ylabel( "Amplitude factor" )
    fig.savefig( "%s/%s_norm3_vs_snr.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
    ax.set_xlim( [6,30] )
    fig.savefig( "%s/%s_norm3_vs_snr_zoom.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
  except OverflowError:
    print >>sys.stderr, 'WARNING: Amplitude factor versus coherent SNR '+\
                        'failed with zeros in a loglog plot'
  
  # plot SNR versus inclination
  try:
    fig = pylab.figure()
    ax  = fig.gca()
    ax.loglog( trigSNR, trigInclination, 'bx' )
    ax.grid()
    if injFile:
      ax.loglog( injSNR, injInclination, 'rx' )
    ax.set_xlabel( "Coherent SNR" )
    ax.set_ylabel( "|cos inclination|" )
    fig.savefig( "%s/%s_inclination_vs_snr.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
    ax.set_xlim( [6,30] )
    fig.savefig( "%s/%s_inclination_vs_snr_zoom.png" % ( outdir, tag ),\
                 bbox_inches='tight' )
  except OverflowError:
    print >>sys.stderr, 'WARNING: cos(inclination) versus coherent SNR '+\
                        'failed with zeros in a loglog plot'
 
  # DONE
if __name__=='__main__':

  opts, args = parse_command_line()

  outdir    = os.path.abspath( opts.output_path )
  verbose   = opts.verbose
  trigFile  = os.path.abspath( opts.trig_file )
  injFile   = None
  if opts.inj_file:
    injFile = os.path.abspath( opts.inj_file )
  GRBnum    = 'GRB%s' % opts.grb_name
  q         = opts.chisq_index
  n         = opts.chisq_nhigh
  segdir    = opts.segment_dir
  nullt     = map( float, opts.null_snr_threshold.split(',') )
  vetoFiles = []
  if opts.veto_directory:
    vetoFiles = glob.glob(opts.veto_directory +'/*CAT[2,3]*.xml')


  main( trigFile, injFile, GRBnum, outdir, segdir, chisq_index=q,\
        chisq_nhigh=n,null_thresh = nullt, verbose=verbose,vetoFiles=vetoFiles )
 
