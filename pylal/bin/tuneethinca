#!/usr/bin/python
"""
program for tuning the ethinca parameter
"""

from __future__ import division

__author__ = "Alexander Dietz <Alexander.Dietz@astro.cf.ac.uk>"
__prog__="tuneethinca"

import itertools
import sys, os, re, glob, exceptions
from optparse import *
from types import *

from glue import lal
from glue import segmentsUtils
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from glue import iterutils
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils
from pylal import SimInspiralUtils
from pylal import InspiralUtils
from pylal import git_version
from pylal import tools


##############################################################################
def getInjectionID( filename ):
  basename = os.path.basename( filename )
  injectionString  = basename.split('-')[-3].split('_')[-1]
  return  int(float(injectionString))

##############################################################################
def getColumn( singles, sims, field, ifo = None ):

  if 'SIM' in field:
    # get data from sim tables
    column = field[:field.index('SIM')]
    list = []
    for sim in sims:
      if column == 'eff_dist':      
        list.append( getattr( sim, column+'_'+ ifo[0].lower()) )
      elif column == 'total_mass':
        list.append( getattr( sim, 'mass1') +getattr( sim, 'mass2') )
      else:    
        list.append( getattr( sim, field ) )
    return list
    
  else:
    # get data from trigger tables
    if field == 'total_mass':
      m1 = singles.get_column('mass1')
      m2 = singles.get_column('mass2')
      return m1+m2
    else:
      return singles.get_column( field )


##############################################################################
def createScatterPlotOnly(opts, fig_num, px, py, pz, text, xlab, ylab, \
                      xlimits, ylimits):

  fig_num+=1
  figure(fig_num)
  InspiralUtils.message(opts,"        "+ text)

  text = text.replace('_', r'\_')
  xlab = xlab.replace('_', r'\_')
  ylab = ylab.replace('_', r'\_')

  scatter( px, py, s=40, c=pz, faceted=False)
  ax = axes()
  if opts.log_x: ax.set_xscale('log')
  if opts.log_y: ax.set_yscale('log')
  colorbar()
  grid(True)
  xlabel( xlab )
  ylabel( ylab )
  title( text)
  xlim( xlimits )
  ylim( ylimits )

  return fig_num

##############################################################################
def saveFigure( opts, name, fnameList, tagList, text):
  
    
  if opts.enable_output:
    fname = InspiralUtils.set_figure_name(opts, name)
    fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True,\
                                              dpi_thumb=opts.figure_resolution)
    fnameList.append(fname)
    tagList.append(text)


##############################################################################
def createScatterPlot(opts, fig_num, px, py, pz, text, xlab, ylab, \
                      xlimits, ylimits, name, fnameList, tagList ):

  fig_num = createScatterPlotOnly(opts, fig_num, px, py, pz, text, xlab, ylab, \
                        xlimits, ylimits )
  saveFigure( opts, name, fnameList, tagList, text)

  return fig_num

##############################################################################
def performEthincaCut( injSims, injCoincs, combo, ethincaCut ):

  # define a CoincInspiral table
  coincsMaxStatAll   = CoincInspiralUtils.coincInspiralTable(stat=opts.statistic)
  coincsMaxStatKeep  = CoincInspiralUtils.coincInspiralTable(stat=opts.statistic)
  injFound  = lsctables.SimInspiralTable()
  injMissed = lsctables.SimInspiralTable()

  # loop over all sims
  for injID, inj in injSims.iteritems():
    
    # retrieve only coincidences which have the combination 'combo'
    coincs = injCoincs[injID].coincinclude( combo )

    # continue of no coincs for this injID
    if len( coincs )==0:
      injMissed.append( inj )
      continue

    coincMaxStatAll   = None
    coincMaxStatKeep  = None  
    maxStatAll  = 0
    maxStatKeep = 0

    # find the smallest ethinca, the largest SNR etc
    ethincaAll =  coincs.getEThincaValues(combo)
    for coinc, ethinca in zip(coincs, ethincaAll):

      # get the loudest coincidence
      if coinc.stat > maxStatAll:
        maxStatAll = coinc.stat
        coincMaxStatAll = coinc

      # impose a cut on ethinca
      if ethinca>ethincaCut:
        continue

      # get the loudest kept coincidence
      if coinc.stat > maxStatKeep:
        maxStatKeep = coinc.stat
        coincMaxStatKeep = coinc

    if coincMaxStatKeep:
      injFound.append(inj)
      coincsMaxStatAll.append( coincMaxStatAll )
      coincsMaxStatKeep.append( coincMaxStatKeep )
    else:
      injMissed.append( inj )

  return coincsMaxStatAll, coincsMaxStatKeep, injFound, injMissed
      
      
##############################################################################
usage = """%prog [options] 

EThinca Tuning and Plotting Function

Generate a set of summary plots from a list of thinca files.  First, specify
the ifos from which the triggers come using as many of --ifo options as
necessary.

If you wish to overlay different populations of triggers together, provide
multiple --glob options.

Generate plots of ethinca parameter vs time or mass or snr with --x-value
or histogram the ethinca values with --hist.
"""

##############################################################################
def parse_command_line():
  """
  Parser function dedicated
  """


  parser = OptionParser(usage=usage, version=git_version.verbose_msg)

  # options related to input and output
  parser.add_option("", "--cache-file", action="store", type="string", default=None, metavar="CACHEFILE",\
      help="specifies cache-file used to sieve for the required files")

  parser.add_option("","--coinc-pattern", action="store", type="string", default= None,metavar="COINCPATTERN",\
      help="specifies the sieve-pattern for the background (in general time-slides)")
  parser.add_option("","--slide-pattern", action="store", type="string", default= None,metavar="SLIDEPATTERN",\
      help="specifies the sieve-pattern for the background (in general time-slides)")
  parser.add_option("","--inj-pattern", action="store", type="string", default=None,metavar="INJPATTERN",\
      help="specifies the sieve-pattern for the foreground files")
        
  parser.add_option("-c","--coinc-glob", action="append", type="string", 
      default=None, metavar="GLOBCOINC",help="GLOB of foreground thinca files to read" )                   
  parser.add_option("-t","--slide-glob",action="append",type="string",\
      default=None, metavar=" GLOBSLIDE",help="GLOB of background thinca files to read (in general time-slides)" )
  parser.add_option("-g","--inj-glob",action="append",type="string",\
      default=None, metavar=" GLOBINJ",help="GLOB of injection files to read" )

  parser.add_option("-V","--veto-file",action="store",type="string",\
      default=None,metavar=" FNAME",\
      help="read in segments from FNAME (assumed segwizard format)")

  parser.add_option("-N","--num-slides",action="store",type="int",default=0,\
      metavar="NUM_SLIDES",help="number of time slides performed" )
  parser.add_option("","--h1-slide-time",action="store",type="int",default=None,\
      metavar="SEC",help="time slid for H1 per slide number" )
  parser.add_option("","--h2-slide-time",action="store",type="int",default=None,\
      metavar="SEC",help="time slid for H2 per slide number" )
  parser.add_option("","--l1-slide-time",action="store",type="int",default=None,\
      metavar="SEC",help="time slid for L1 per slide number" )
  
  parser.add_option("","--ifo-times",action="store",type="string",\
      default=None,metavar="IFOTIMES",\
      help="Specifies the IFO times which are being looked at (e.g. H1H2L1)" )
  parser.add_option("-i","--ifo-tag",action="store",type="string",metavar="IFOCOMBOS",\
      default=None, help="Specifies the IFO combination which are being looked at (e.g. H1H2L1). "\
                    "Default: All possible combinations (dreived from --ifo-times)." )

  parser.add_option("-S","--statistic",action="store",default='snr',\
      type="string",\
      help="choice of statistic used in making plots; valid arguments are: "
      "snr (DEFAULT), snr_over_chi, s3_snr_chi_stat, effective_snr,")
  
  parser.add_option("","--exttrig",action="store_true",\
      default=False,metavar="EXTTRIG",\
      help="enable the external-trigger mode" )

  # options related to the analysis
  parser.add_option("","--injection-window",action="store",type="float",\
      default=None,metavar="SEC",\
      help="injection window used for found injections" )
  
  parser.add_option("","--max-ethinca",action="store",type="float",\
      default=2.0,metavar="MAXETHINCA",\
      help="Max Ethinca value for the plotting range (default is 2.0) " )
     
  # options relates to output
  parser.add_option("-O","--enable-output",action="store_true",\
      default="false",  metavar="OUTPUT",\
      help="enable the generation of the html and cache documents")
  parser.add_option("-P","--output-path",action="store",\
      type="string",default=None,  metavar="PATH",\
      help="path where the figures would be stored")
  
  parser.add_option("-u","--user-tag",action="store",type="string",\
      default=None, metavar=" USERTAG",\
      help="The user tag used in the name of the figures" )

  parser.add_option("","--gps-start-time",action="store", type="int", metavar="GPSSTARTTIME",\
      help="gps start time used in the figure and output file names")

  parser.add_option("","--gps-end-time",action="store", type= "int", metavar="GPSENDTIME",\
      help="gps end time used in the figure and output file names")

  parser.add_option("-v","--verbose",action="store_true",\
      default=False,help="print information" )
  
  # options that sets parameters for ploting
  parser.add_option("-s","--show-plot",action="store_true",default=False,\
      help="display the figures on the terminal" )
 
  parser.add_option("", "--plot-ethinca-snr", action="store_true",default=False,\
       help="plot ethinca parameters vs SNR")
  parser.add_option("", "--plot-histogramm", action="store_true",default=False,\
       help="plot the histogram of relative found injections/background")
  parser.add_option("", "--plot-ethinca-sequence", action="store_true",default=False,\
       help="Making sequence plots for different ethinca cuts, inclusive the animated gif.")

  parser.add_option("-X", "--log-x", action="store_true",
      help="for ethinca vs ... make x axis log")
  parser.add_option("-Y", "--log-y", action="store_true",
      help="for ethinca vs ... make y axis log")

  parser.add_option("", "--figure-resolution",action="store",type="int",\
      default=50, metavar="FIGURERESOLUTION", \
      help="resolution of the thumbnails (50 by default)" )

  
  (options,args) = parser.parse_args()
  
  # test the input options
  if not options.ifo_times:
    raise ValueError, "--ifo-times (which ifos were analysed) must be provided"


  if not options.coinc_pattern and not options.coinc_glob:
    raise ValueError, "Foreground files must be specfied with either --coinc-pattern or --glob-coinc"
  if not options.slide_pattern and not options.slide_glob:
    raise ValueError, "Background files must be specfied with either --slide-pattern or --glob-slide"
  if not options.inj_pattern and not options.inj_glob:
    raise ValueError, "Injection files must be specfied with either --inj-pattern or --glob-inj"

  if options.num_slides and (not options.h1_slide_time \
                             or not options.h2_slide_time \
                             or not options.l1_slide_time):
    raise ValueError, "If --num-slides is specified all the slides-timkes must be"\
          "specified as well"

  if not options.num_slides:
    print "WARNING: Do not expect timeslide data, treating background triggers like offsource."

  if options.ifo_tag and len(options.ifo_tag)<4: 
    raise ValueError, "--ifo-tag must contain at least two IFO identifiers (from H1, H2, L1, V1, G1, T1)"   

  if options.exttrig and not options.user_tag:
    raise ValueError, "Must specify --user-tag when --exttrig is specified."       

  if not options.injection_window:
    raise ValueError, "--injection-window must be specified (e.g. 0.05)."           

  if options.plot_histogramm:
    options.plot_ethinca_sequence=True
    print "WARNING: For creating the histogram plots --plot-ethinca-sequence is required"
    print "--plot-ethinca-sequence has been activated..."

  return options, sys.argv[1:]


# ============================================================================
# ============================================================================
# -- get command line arguments
opts, args = parse_command_line()
InspiralUtils.message(opts, "Initialisation...")
opts = InspiralUtils.initialise(opts, __prog__, git_version.verbose_msg)

# -- set the proper color code
colors = InspiralUtils.colors
fnameList = []   # use for the cache file
tagList= []   # use for the cache file
fig_num = 1
comments =""

# define a maximum ethinca value
maxEThinca = opts.max_ethinca

# Change to Agg back-end if show() will not be called thus avoiding display problem
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from pylal import viz


rc('font', size='x-large')
if not opts.show_plot:
  rc('text', usetex=True)

# TODO Is that needed??
try:  bins = [i/opts.num_bins for i in range(opts.num_bins+1)]
except: ValueError, """ problems with opts.num_bins (set to zero ? )"""


# parse the ifos from the ifo tag; create the combos
temp_ifo_list = ['H1','H2','L1','G1','V1','T1']
opts.ifo_list = []
if opts.ifo_tag:
  for ifo in temp_ifo_list:
    if ifo in opts.ifo_tag:
      opts.ifo_list.append( ifo )

  test_combos = itertools.chain( iterutils.choices(opts.ifo_list, len(opts.ifo_list)) )

else:
  for ifo in temp_ifo_list:
    if ifo in opts.ifo_times:
      opts.ifo_list.append( ifo )

  # create a list of all possible combinations with at least two IFOs
  test_combos = itertools.chain( \
      *itertools.imap(lambda n: iterutils.choices(opts.ifo_list, n),
                      arange(len(opts.ifo_list), 1, -1)))

# use them as an ordinary list
useCombos = list( test_combos )
comments+=InspiralUtils.message(opts, "IFO times requested is "+opts.ifo_times +\
                                " and IFO combinations requested are " +str(useCombos)  )

#######################################################
## Part I: Reading the data
###############################################plot-ethinca-sequence########

# ============================================================================
# Create the file lists
InspiralUtils.message(opts, "Reading data...")

if opts.cache_file:
  InspiralUtils.message(opts, 'Reading cache')

  # open the master cache file
  if opts.cache_file:
    allfilesCache = lal.Cache.fromfile(open(opts.cache_file))

  # sieve for slide files
  slidefilelist = allfilesCache.sieve(ifos=opts.ifo_times, exact_match=True).\
                  sieve(description=opts.slide_pattern).\
                  checkfilesexist()[0].pfnlist()
  if not len(slidefilelist):
    print >>sys.stderr, opts.cache_file+ " contains no files that matches the pattern '" +\
          opts.slide_pattern + "'"
    sys.exit(1)
  else:
    comments += InspiralUtils.message(opts,  'Reading ' +str(len(slidefilelist)) +\
                                      ' files having the pattern '+opts.slide_pattern)

  # sieve for injection files
  injfilelist = allfilesCache.sieve(ifos='HL').sieve(description=opts.inj_pattern).\
                checkfilesexist()[0].pfnlist()
  if not len(injfilelist):
    print >>sys.stderr, opts.cache_file+ " contains no files that matches the pattern '" + \
          opts.inj_pattern + "'"
    sys.exit(1)
  else:
    comments += InspiralUtils.message(opts,  'Reading ' +str(len(injfilelist)) + \
                                      ' files having the pattern '+opts.inj_pattern)

  #sieve for coinc files
  coincfilelist = allfilesCache.sieve(ifos=opts.ifo_times, exact_match=True).\
                  sieve(description=opts.coinc_pattern).\
                  checkfilesexist()[0].pfnlist()
  if not len(coincfilelist):
    print >>sys.stderr, opts.cache_file+ " contains no files that matches the pattern '" \
          + opts.coinc_pattern + "'"
    sys.exit(1)
  else:
    comments += InspiralUtils.message(opts,  'Reading ' +str(len(coincfilelist)) + \
                                      ' files having the pattern '+opts.coinc_pattern)

else:
  # create the file lists from the globs specified
  slidefilelist = []
  coincfilelist = []
  injfilelist = []
  for g in opts.slide_glob: slidefilelist.extend( glob.glob(g) )
  for g in opts.coinc_glob: coincfilelist.extend( glob.glob(g) )
  for g in opts.inj_glob:   injfilelist.extend( glob.glob(g) )

  if not len(slidefilelist):
    print >>sys.stderr, "No files found for glob ",opts.slide_glob
    sys.exit(1)
  if not len(injfilelist):
    print >>sys.stderr, "No files found for glob ",opts.slide_glob
    sys.exit(1)
  if not len(coincfilelist):
    print >>sys.stderr, "No files found for glob ",opts.slide_glob
    sys.exit(1)

  if opts.verbose:
    print "Lists contain %d foreground files, %d background files and %d injection files" % \
          ( len(coincfilelist), len(slidefilelist), len(injfilelist))

# ============================================================================
# Read the data

# set the statistic
statistic = CoincInspiralUtils.coincStatistic(opts.statistic)

coincTriggersList = []
slideTriggersList = []
injTriggersList   = []

# retrieve veto segments
if opts.veto_file:
  vetosegs = segmentsUtils.fromsegwizard(open(opts.veto_file))

# split out the injectionID's
injFiles = dict()
coincFiles = dict()

if opts.exttrig:
  # need to split up the files (and the data) into distinctive injection runs
  # ... for the foreground ...
  for coincfile in coincfilelist:
    injID = getInjectionID( coincfile )
    #if injID>10: continue # TODO: take out
    if coincFiles.has_key(injID):
      coincFiles[injID].append(coincfile)
    else:
      coincFiles[injID]=[coincfile]

  # ... and for the injctions ...
  for injfile in injfilelist:
    injID = getInjectionID( injfile )
    #if injID>10: continue # TODO: take out    
    if injFiles.has_key(injID):
      injFiles[injID].append(injfile)
    else:
      injFiles[injID]=[injfile]

else:
  # just use one entry for any non-exttrig analysis
  coincFiles[0]=coincfilelist
  injFiles[0]=injfilelist


# check that the key lists are the same
setInj   = set( injFiles.keys() )
setCoinc = set( coincFiles.keys() )
if setInj!=setCoinc:
  print >>sys.stderr, "The injection ID's from the files provided are not the same:"
  print >>sys.stderr, "injection files: ", setInj
  print >>sys.stderr, "coinc files:  ", setCoinc
  sys.exit(1)


# read the background data
if opts.num_slides:
  inspTriggers = SnglInspiralUtils.ReadSnglInspiralSlidesFromFiles(\
    slidefilelist, opts, mangle_event_id=True)
else:
  inspTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(\
    slidefilelist, verbose=opts.verbose, mangle_event_id=True)

# veto if required
if opts.veto_file:
  inspTriggers = inspTriggers.veto(vetosegs)
  
# reconstruct the coincs
slideCoincs = CoincInspiralUtils.coincInspiralTable(inspTriggers, statistic)

# create dictioneries containing the final data
injCoincs = dict() # contains found coincident triggers
injSims   = dict() # contains the sim_inspiral table to which the
                   # found coincident triggers are associated
                   

## read the injection data and 'combine' them
# with the triggers found (via an unique injectionID)
injectionID = 0
for fileID in injFiles.keys():

  # read the background triggers and perform the veto
  simTriggers = SimInspiralUtils.ReadSimInspiralFromFiles(\
     injFiles[fileID], verbose=opts.verbose)
  if opts.veto_file:
    simTriggers = simTriggers.veto(vetosegs)

  # read the background triggers and perform the veto
  inspTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles( \
    coincFiles[fileID], verbose=opts.verbose, mangle_event_id=True)
  if opts.veto_file:
    inspTriggers = inspTriggers.veto(vetosegs)

  # now assign coincident triggers to an injection within some (big) injection window
  for sim in simTriggers:
    injectionID+=1
    if opts.verbose: sys.stdout.write("Examining the %dth injection... " % injectionID)
    snglTable = lsctables.SnglInspiralTable()
    
    for trigger in inspTriggers:
      time = trigger.end_time+trigger.end_time_ns*1.0e-9
      ifo = trigger.ifo[0].lower()
      simTime = getattr( sim, ifo+'_end_time')+getattr( sim, ifo+'_end_time_ns')*1.0e-9
      if time>simTime-opts.injection_window and time<simTime+opts.injection_window:
        snglTable.append( trigger )
    
    # reconstruct the coincs and store them 
    injCoincs[injectionID]= CoincInspiralUtils.coincInspiralTable(snglTable, statistic)
    injSims[injectionID]=sim
    
    if opts.verbose: sys.stdout.write(" found %d coincidences\n" % len( injCoincs[injectionID] ) )


#######################################################
## Part II: Analysis
#######################################################
if opts.verbose: print "\nStarting Analysis"

## major loop over the combinations to be analysed
for combo in useCombos:

  numberSims = 0

  # create a bunch of vectors that contain datas to plot later
  vectorNumberAll   = []     # number of coincs found per inj (all combinations)
  vectorNumberCombo = []     # number of coincs found per inj (this combination)
  vectorNumberTriggers = []  # number of all single triggers per inj

  # containing the coincs for the minimum/maxmimum ethinca/SNR value per inj
  coincsMinEthinca = CoincInspiralUtils.coincInspiralTable(stat=opts.statistic)
  coincsMaxSNR1    = CoincInspiralUtils.coincInspiralTable(stat=opts.statistic)
  coincsMaxSNR2    = CoincInspiralUtils.coincInspiralTable(stat=opts.statistic)
  coincsMaxStat    = CoincInspiralUtils.coincInspiralTable(stat=opts.statistic)
  simsKeep         = []  # injections to keep

  # TODO: choosing only doubles? better is that...
  if len(combo)>2:
    continue

  for injID in injSims.keys():
    if opts.verbose: print "Analyzing injection ", injID

    # retrieve only coincidences which have the combination 'combo'
    coincs = injCoincs[injID].coincinclude( combo )

    # number of coincs found for this injection
    numberFoundAll   = len( injCoincs[injID] )
    numberFoundCombo = len( coincs )

    # continue only if at least one coincidence is found 
    if numberFoundCombo==0:
      continue

    # retrieve the coresponding injection
    sim = injSims[injID]
    numberSims+=1

    # get all ethinca values
    ethincaAll =  coincs.getEThincaValues(combo)

    minEthinca = 2.0
    maxSNR1 = 0
    maxSNR2 = 0
    maxStat = 0    

    # find the smallest ethinca, the largest SNR etc
    numberFoundTriggers = 0
    for coinc, ethinca in zip(coincs, ethincaAll):
      numberFoundTriggers+=coinc.numifos
            
      trigger1 = getattr( coinc, combo[0] )
      trigger2 = getattr( coinc, combo[1] )    

      if ethinca<minEthinca:
        minEthinca = ethinca
        coincMinEthinca = coinc
      if trigger1.snr>maxSNR1:
        maxSNR1 = trigger1.snr
        coincMaxSNR1 = coinc
      if trigger2.snr>maxSNR2:
        maxSNR2 = trigger2.snr
        coincMaxSNR2 = coinc
      if coinc.stat > maxStat:
        maxStat = coinc.stat
        coincMaxStat = coinc

    # append the selected coincs to a seperate list
    coincsMinEthinca.append( coincMinEthinca )
    coincsMaxSNR1.append( coincMaxSNR1 )
    coincsMaxSNR2.append( coincMaxSNR2 )
    coincsMaxStat.append( coincMaxStat )
    simsKeep.append( sim )    

    # store the numbers
    vectorNumberAll.append( numberFoundAll )
    vectorNumberCombo.append( numberFoundCombo )
    vectorNumberTriggers.append( numberFoundTriggers )

  ## -----------------------------
  ## now create a bunch of plots
  ## -----------------------------
 
  ## -------------------------------------------
  ## plot 1: ethinca versus snr's

  combStr = "%s%s" % (combo[0], combo[1])

  if opts.plot_ethinca_snr:
    for ifo in combo:

      # get the corresponding single IFO triggers
      singles = coincsMinEthinca.getsngls(ifo)

      # TODO: allow differet fields to be analysed
      xfield = 'snr'
      colfield = 'eff_distSIM'
      numberFound = len( singles )

      px = getColumn( singles, simsKeep, xfield )
      py = coincsMinEthinca.getEThincaValues(combo)
      pz = getColumn( singles, simsKeep, colfield, ifo=ifo )

      fig_num=createScatterPlot(opts, fig_num, px, py, pz,\
                                "Ethinca versus SNR-%s (%s) found: %d [%s]" % \
                                (ifo, combStr, numberFound, colfield) ,\
                                "%s %s" % (xfield, ifo), \
                                "E-thinca parameter ", \
                                [3.0, max(px)],[0, maxEThinca],\
                                "%s_ethinca_vs_%s%s_and_%s" % ( combStr, xfield, ifo, colfield),\
                                fnameList, tagList ) 

    ## -------------------------------------------
    ## plot2:  the same picture wich the combined statistics  

    ifo = 'H1'  # IFO for the effective distance, choose H1
    px = coincsMinEthinca.getstat()
    py = coincsMinEthinca.getEThincaValues(combo)
    pz = getColumn( singles, simsKeep, colfield, ifo='H1' )

    fig_num=createScatterPlot(opts, fig_num, px, py, pz,\
                              "Ethinca versus combstat (%s) [%s-%s]" % (combStr, colfield, ifo) ,\
                              "combstat" , \
                              "E-thinca parameter ", \
                              [3.0, max(px)],[0, maxEThinca],\
                              "%s_ethinca_vs_combstat_and_%s" % ( combStr, colfield),\
                            fnameList, tagList )


  ## -------------------------------------------
  ## plot3: successive ethinca-stat plot

  if opts.plot_ethinca_sequence:

    vectorFound = []
    vectorFoundDistScaling = []
    vectorCut = []
    vectorBackground = []

    # get the ethinca values of the background triggers
    background = slideCoincs.coincinclude( combo )
    ethincaBG = background.getEThincaValues( combo )

    # find the injections that just were found above some ethinca cut
    listFoundInjections = []

    for ethincaCut in arange(0.1, 1.1, 0.1):

      # impose the ethinca cut
      coincsMaxStatAll, coincsMaxStatKeep, injFound, injMissed = performEthincaCut( \
        injSims, injCoincs, combo, ethincaCut )

      
      maxStatAll = coincsMaxStatAll.getstat()
      px = coincsMaxStatKeep.getstat()
      py = coincsMaxStatKeep.getEThincaValues( combo )
      pz = px / maxStatAll
      numberFound = len( coincsMaxStatKeep )

      text = "Ethinca versus stat (%s) cut%.1f found: %d [mismatch]" % \
             (combStr, ethincaCut, numberFound)
      fig_num=createScatterPlotOnly(opts, fig_num, px, py, pz, text, \
                                    "statistics %s" % (combStr), \
                                    "E-thinca parameter ", \
                                    [3.0, max(maxStatAll)],[0, maxEThinca])

      # check what of the injections has been found yet
      tx = []
      ty = []
      newListFoundInjections = []
      
      for injID, inj in injSims.iteritems():

        # continue of injection already found
        if injID in listFoundInjections:
          continue
        
        else:
          
          # look for the injection that was found
          for i in range(len(injFound)):
            foundInj = injFound[i]
            if inj.geocent_end_time==foundInj.geocent_end_time and \
                   inj.geocent_end_time_ns==foundInj.geocent_end_time_ns:

              listFoundInjections.append( injID )
              tx.append( px[i] )
              ty.append( py[i] )

      plot( tx, ty, 'ro', markersize=10, markerfacecolor=None)
      saveFigure( opts, "%s_ethinca_vs_statistics_and_mismatch-cut%.1f" % \
                  ( combStr, ethincaCut),\
                  fnameList, tagList, text )
          

      # store the number of found 'injections'
      vectorFound.append( sum(pz) )  # weight found inj by reduced SNR value (or statistic)
      vectorCut.append( ethincaCut ) # remember the cut value
      foundBG = filter(lambda x: x<ethincaCut, ethincaBG)
      vectorBackground.append( len(foundBG) )

      distScaling = sum( [ pow(inj.eff_dist_h,3) for inj in injFound])
      vectorFoundDistScaling.append( distScaling )

      ## create found/missed plots
      foundDist = [t.eff_dist_h for t in injFound]
      missedDist = [t.eff_dist_h for t in injMissed]
      foundMass = [t.mass1+t.mass2 for t in injFound]
      missedMass = [t.mass1+t.mass2 for t in injMissed]
      pz = coincsMaxStatKeep.getEThincaValues( combo )

      fig_num+=1
      figure(fig_num)

      scatter(  foundMass, foundDist, s=40, c=pz, faceted=False)
      colorbar()
      plot( missedMass, missedDist, 'rx')
      ax = axes()
      ax.set_yscale('log')
      grid(True)
      xlabel("total mass [Solarmasses]")
      ylabel("Effective distance H1 [Mpc] ")
      title("Found/missed plot for ethinca = %.1f  (%s%s triggers) [ethinca]" % \
            (ethincaCut, combo[0], combo[1])    )
      filename = 'Images/%s-tuneethinca-foundmissed_ethinca-%.1f.png' % ( combStr, ethincaCut)
      savefig( filename )


      fig_num+=1
      figure(fig_num)

      plot( foundMass, foundDist, 'bo')
      plot( missedMass, missedDist, 'rx')    
      ax = axes()
      ax.set_yscale('log')
      grid(True)
      xlabel("total mass [Solarmasses]")
      ylabel("Effective distance H1 [Mpc] ")
      title("Found/missed plot for ethinca = %.1f  (%s%s triggers) [ethinca]" % \
            (ethincaCut, combo[0], combo[1])    )
      filename = 'Images/%s-tuneethinca-foundmissed_%.1f' % ( combStr, ethincaCut)
      savefig( filename+'.png' )

      # convert the png to gif
      command = "convert %s.png %s.gif" % (filename, filename)
      os.system( command )

    # create the animated image
    filename=" Images/%s-tuneethinca-foundmissed-animated.gif" % combStr
    command = " gifsicle --delay=100 --loop Images/%s-tuneethinca-foundmissed_*.gif > %s" %\
              (combStr, filename)
    os.system( command )
    fnameList.append(filename)
    tagList.append('animated gif')
    
    # do the norming
    vectorFoundNorm = [float(v)/max(vectorFound) for v in vectorFound]
    vectorBackgroundNorm = [float(v)/max(vectorBackground) for v in vectorBackground]  
    vectorFoundDistScalingNorm =  [float(v)/max(vectorFoundDistScaling) \
                                   for v in vectorFoundDistScaling]

  
  ######################
  # create the histogram
  if opts.plot_histogramm:
    
    fig_num+=1
    figure(fig_num)

    plot( vectorCut, vectorFoundNorm, 'bo-', lw=3)
    plot( vectorCut, vectorBackgroundNorm, 'rx-', lw=3)  
    grid(True)
    legend(('injections','background'),loc = 'lower right')
    xlabel( 'ethinca parameter' )
    ylabel( 'found injections' )
    text = "Histogram of found 'injections' "
    InspiralUtils.message(opts,"        "+ text)
    title( text )     
    if opts.enable_output:
      name = "%s_hist-numberFound" % ( combStr )
      fname = InspiralUtils.set_figure_name(opts, name)
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append(text)


    fig_num+=1
    figure(fig_num)
    plot( vectorCut, vectorFoundDistScalingNorm, 'bo-', lw=3)
    plot( vectorCut, vectorBackgroundNorm, 'rx-', lw=3)  
    grid(True)
    legend(('injections','background'),loc = 'lower right')
    xlabel( 'ethinca parameter' )
    ylabel( 'found injections (with dist scaling)' )
    text = "Histogram of found 'injections' (DS)"
    InspiralUtils.message(opts,"        "+ text)
    title( text )     
    if opts.enable_output:
      name = "%s_hist-numberFoundDS" % ( combStr )
      fname = InspiralUtils.set_figure_name(opts, name)
      fname_thumb = InspiralUtils.savefig_pylal(filename=fname, doThumb=True, dpi_thumb=opts.figure_resolution)
      fnameList.append(fname)
      tagList.append(text)

  

# ============================================================================
# final step: html, cache file generation
if opts.enable_output is True:
  html_filename = InspiralUtils.write_html_output(opts, args, fnameList, tagList, comment=comments)
  InspiralUtils.write_cache_output(opts, html_filename, fnameList)

# ============================================================================

if opts.show_plot:
  show()
