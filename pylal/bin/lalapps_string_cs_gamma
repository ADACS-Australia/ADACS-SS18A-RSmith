#!/usr/bin/python
#
#  Copyright (C) 2007 Xavier Siemens
#  Copyright (C) 2010 Andrew Mergl
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with with program; see the file COPYING. If not, write to the
#  Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
#  MA  02111-1307  USA
#

#/*********************************************************************************/
#/*            Cosmic string burst rate computation code for small loops          */
#/*                                                                               */
#/*                  Xavier Siemens, Jolien Creighton, Irit Maor                  */
#/*                                                                               */
#/*                         UWM/Caltech - September 2006                          */
#/*********************************************************************************/

#Port to Python from the C program cs_gamma.c
#Original C source code by Xavier Seimens
#Port by Andrew Mergl, June 2010

import numpy
import math
from optparse import OptionParser
import sys

from pylal import git_version

from pylal import cs_gamma

#Constants from cs_lambda_cosmo.h
LAMBDA_Z_EQ = 5440.0
LAMBDA_H_0 = 2.27e-18
LAMBDA_OMEGA_M = 0.279
LAMBDA_OMEGA_R = 8.5e-5
LOOPS_RAD_POWER = 50.0
CUSPS_PER_LOOP = 1.0

Gamma = LOOPS_RAD_POWER
c = CUSPS_PER_LOOP



def parse_command_line():
    parser = OptionParser(
        version = "Name: %%prog\n%s" % git_version.verbose_msg
    )
    parser.add_option("-a", "--frequency", action="store", type="float", 
                      dest="frequency", help="Lowest frequency.")
    parser.add_option("-b", "--log-Gmustart", action="store", type="float",
                      dest="logGmustart", help="Lowest Gmu.")
    parser.add_option("-c", "--log-Gmuend", action="store", type="float",
                      dest="logGmuend", help="Largest Gmu.")
    parser.add_option("-d", "--nGmu", action="store", type="int",
                      dest="nGmu", help="Nubmer of Gmu bins to do.")
    parser.add_option("-e", "--log-epsilonstart", action="store", type="float",
                      dest="logepsilonstart", help="Lowest epsilon")
    parser.add_option("-f", "--log-epsilonend", action="store", type="float",
                      dest="logepsilonend", help="Largest epsilon.")
    parser.add_option("-g", "--nepsilon", action="store", type="int",
                      dest="nepsilon", help="Number of epsilon bins to do")
    parser.add_option("-i", "--index", action="store", type="float",
                      dest="index", help="Index for alpha as function of Gmu")
    parser.add_option("-j", "--log-pstart", action="store", type="float",
                      dest="logpstart", help="Lowest p")
    parser.add_option("-k", "--log-pend", action="store", type="float",
                      dest="logpend", help="Largest p")
    parser.add_option("-l", "--np", action="store", type="int",
                      dest="np", help="Number of p bins to do.")
    parser.add_option("-m", "--efficiency-file", action="store", type="string",
                      dest="efficiencyfile", 
                      help="File with efficiency values and errors.")
    options, filenames = parser.parse_args()
    
    if options.efficiencyfile is None:
        raise ValueError, "missing required option --efficiency-file"
    if options.frequency is None:
        raise ValueError, "No lowest frequency specified."
    if options.logGmustart is None:
        raise ValueError, "No lowest Gmu specified."
    if options.logGmuend is None:
        raise ValueError, "No highest Gmu specified."
    if options.nGmu is None:
        raise ValueError, "No number of Gmu bins specified."
    if options.logepsilonstart is None:
        raise ValueError, "No lowest epsilon specified."
    if options.logepsilonend is None:
        raise ValueError, "No highest epsilon specified."
    if options.nepsilon is None:
        raise ValueError, "No number of epsilon bins specified."
    if options.index is None:
        raise ValueError, "No index for alpha specified."
    if options.logpstart is None:
        raise ValueError, "No lowest p specified."
    if options.logpend is None:
        raise ValueError, "No highest p specified."
    if options.np is None:
        raise valueError, "No number of p bins specified."
    return options, (filenames or [None])

#------------------------------------------------------------------------------
#              Main
#------------------------------------------------------------------------------


ops, files = parse_command_line()

#Open the efficiency file and read the three columns into three arrays
amp, eff, Deff = numpy.loadtxt(ops.efficiencyfile, skiprows=1, dtype=float, unpack=True)
#The length of the arrays
Namp = len(amp)
#Make empty arrays the same shape and size as the loaded data arrays
zofA = numpy.empty_like(amp)
dRdz = numpy.empty_like(amp)

#Open the output file and print the header
outfile = open("gamma.dat", 'w')
outfile.write(
    '%     p           n           epsilon         Gmu       gammaAverage    gammaMin      gammaMax\n')
N = ops.nepsilon * ops.nGmu * ops.np
n = 1
for i in range(ops.nepsilon):
    epsilon=pow(10.0, ops.logepsilonstart + 
                i * (ops.logepsilonend - ops.logepsilonstart) / 
                (ops.nepsilon - 1))
    for j in range(ops.nGmu):
        Gmu=pow(10.0, ops.logGmustart+j * 
                (ops.logGmuend - ops.logGmustart) / 
                (ops.nGmu - 1))
        alpha = epsilon * pow(Gamma * Gmu, ops.index)
        #Call the C functions
        err=cs_gamma.findzofA(Gmu, alpha, Namp, zofA, amp) 
        if (err): raise Exception(err)
        err=cs_gamma.finddRdz(Gmu, alpha, ops.frequency, Gamma, Namp, zofA, dRdz)
        if (err): raise Exception(err)

        Dlnz = numpy.log(zofA[1:]) - numpy.log(zofA[:-1])
        for k in range(ops.np):
            p=pow(10.0, ops.logpstart + k*(ops.logpend - ops.logpstart) / ops.np)
            print "%.1f%%: computing effective rate for Gmu=%.4g, epsilon=%.4g, p=%.4g\r" % (100.0 * n / N, Gmu, epsilon, p),

            gammaAverage = sum(eff[:-1] * zofA[:-1] * dRdz[:-1] * -Dlnz) * c/p
            gammaMin = sum(numpy.clip(eff[:-1] - Deff[:-1], 0.0, +numpy.inf) * zofA[:-1] * dRdz[:-1] * -Dlnz) * c/p
            gammaMax = sum(numpy.clip(eff[:-1] + Deff[:-1], -numpy.inf, 1.0) * zofA[:-1] * dRdz[:-1] * -Dlnz) * c/p

            outfile.write("%.17g  %.17g  %.17g  %.17g  %.17g  %.17g  %.17g\n"
                %   (p, ops.index, epsilon, Gmu, gammaAverage, gammaMin, gammaMax))
            n += 1
print "100.0%%: computing effective rate for Gmu=%.4g, epsilon=%.4g, p=%.4g" % (Gmu, epsilon, p)
