#!/usr/bin/python

# $Id$

from __future__ import division

__author__ = "Stephen Fairhurst <sfairhur@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]
__name__="plotethinca"

import sys
import os
from optparse import *
import re
import exceptions
import glob
from types import *
import itertools   # This is Python's included itertools, not Pylal's

from glue import lal
from glue import segments
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils
from pylal import CoincInspiralUtils
from pylal import SnglInspiralUtils
from pylal import SearchSummaryUtils
from pylal import itertools as pylal_itertools
from pylal import InspiralUtils

##############################################################################
usage = """%prog [options] 

Thinca Triggers Plotting Function

Generate a set of summary plots from a list of thinca files.  First, specify
the ifos from which the triggers come using as many of --ifo options as
necessary.

If you wish to overlay different populations of triggers together, provide
multiple --glob options.

Generate plots of ethinca parameter vs time or mass or snr with --x-value
or histogram the ethinca values with --hist.
"""

parser = OptionParser( usage=usage, version="%prog CVS $Id$ " )
# options related to input and output
parser.add_option("-g","--inj-glob",action="append",type="string",\
  default=[], metavar=" GLOB",help="GLOB of injection thinca files to read" )

parser.add_option("-I", "--inj-input", action="append", default=[],
  help="read injection thinca filenames from input file")

parser.add_option("-t","--slide-glob",action="append",type="string",\
  default=[], metavar=" GLOB",help="GLOB of time slide thinca files to read" )

parser.add_option("-O","--enable-output",action="store_true",\
      default="false",  metavar="OUTPUT",\
      help="enable the generation of the html and cache documents")

parser.add_option("-u","--user-tag",action="store",type="string",\
      default=None, metavar=" USERTAG",\
      help="The user tag used in the name of the figures" )

parser.add_option("","--gps-start-time",action="store", type="int", metavar="GPSSTARTTIME",\
    help="gps start time used in the figure and output file names")

parser.add_option("","--gps-end-time",action="store", type= "int", metavar="GPSENDTIME",\
    help="gps end time used in the figure and output file names")

parser.add_option("-P","--output-path",action="store",\
      type="string",default="",  metavar="PATH",\
      help="path where the figures would be stored")

parser.add_option("","--ifo-times",action="store",type="string",\
  default=None,metavar="IFOS",\
  help="Which ifo times are being looked at for slides (e.g. H1H2L1)" )

parser.add_option("-V","--veto-file",action="store",type="string",\
  default=None,metavar=" FNAME",\
  help="read in segments from FNAME (assumed segwizard format)")

parser.add_option("", "--cache-input", action="store", type="string", default=None, metavar="CACHEFILE",\
    help="output cache file for injections, zerolag or playground  COIRE(THINCA) files")

parser.add_option("","--cache-description", action="store",type="string",\
    metavar="CACHEDESCRIPTION", default="COIRE_", help="description pattern the cache entries will be sieved with" )

parser.add_option("","--add-description", action="store",type="string",\
    metavar="ADDDESCRIPTION", default="SLIDE", help="additional description pattern the cache entries will be sieved with" )


parser.add_option("","--time-slides", action="store_true", default=False,\
    help="add time slides to the plots" )


parser.add_option("","--match", action="store", default=None,type="string",\
    metavar="MATCH",help="sieves exactly to a given pattern, if set True" )

parser.add_option("-s","--show-plot",action="store_true",default=False,\
  help="display the figures on the terminal" )

parser.add_option("-v","--verbose",action="store_true",\
      default=False,help="print information" )

# options that sets parameters for ploting
parser.add_option("-L","--cluster-window",action="store",type="int",default=0,\
  metavar=" SEC", help="length of time over which to cluster triggers" )

parser.add_option("-i","--ifo",action="append",type="string",\
  metavar="IFO",dest="ifo_list",\
  help="look at triggers for specified ifo (append to list)" )

parser.add_option("-e", "--ethinca-vs-stat", action="store_true",
  help="plot ethinca parameters vs the combined statistics")

parser.add_option("-x","--x-value",action="append",type="string",\
  metavar="COL_NAME", dest="columns", default=[], help=\
  "plot ethinca parameter against this sngl_inspiral column (add to list)" )

parser.add_option("-S","--statistic",action="store",default='snr',\
  type="string",\
  help="choice of statistic used in making plots, valid arguments are: "
    "snr (DEFAULT), snr_over_chi, s3_snr_chi_stat, effective_snr,")

parser.add_option("-X", "--log-x", action="store_true",
  help="for ethinca vs ... make x axis log")

parser.add_option("-H","--hist",action="store_true",default=False,\
  help="make a histogram of the e-thinca values" )

parser.add_option("","--hist-stat",action="store_true",default=False,\
  help="make a histogram of the combined statistics" )

parser.add_option("-n","--num-bins",action="store",type='int',\
  default=20, metavar=" NUM",\
  help="number of bins used in histogram" )

parser.add_option("-N","--num-slides",action="store",type="int",default=0,\
    metavar="NUM_SLIDES",help="number of time slides performed" )

parser.add_option("","--h1-slide-time",action="store",type="int",default=0,\
    metavar="SEC",help="time slid for H1 per slide number" )

parser.add_option("","--h2-slide-time",action="store",type="int",default=10,\
    metavar="SEC",help="time slid for H2 per slide number" )

parser.add_option("","--l1-slide-time",action="store",type="int",default=5,\
    metavar="SEC",help="time slid for L1 per slide number" )

parser.add_option("","--injection-window",action="store",type="float",\
    default=None,metavar="SEC",\
    help="injection window used for found injections" )

command_line = sys.argv[1:]

(opts,args) = parser.parse_args()

# test the input options
if not opts.ifo_times:
  raise ValueError, "--ifo-times (which ifos were analysed) must be provided"

if opts.cache_input and (opts.inj_glob or opts.slide_glob):
    raise ValueError, """ Use either the glob options(--inj-glob OR the cachefile options (--cache-input), not both at the same time.
"""

if len(opts.ifo_list) < 2:
  print >>sys.stderr, "Must specify at least 2 ifos with triggers"
  print >>sys.stderr, "Enter 'plotethinca --help' for usage"
  sys.exit(1)

if opts.slide_glob or opts.time_slides:
  if not opts.num_slides or not opts.ifo_times:
    print >>sys.stderr, "--num-slides and --ifo-times must be specified if"
    print >>sys.stderr, "working with time slides"
    sys.exit(1)
#################################################################################
# -- some initialisation
figure_number = 0  # used for the figure label (showplot)
output_cachefile_name = []   # use for the cache file

# If show() is not required, use Agg backend to prevent X display dependency
if not opts.show_plot:
  import matplotlib
  matplotlib.use('Agg')
from pylab import *
from numpy import histogram

# -- set the proper color code
colors = InspiralUtils.colors
# Initialise
prefix, suffix = InspiralUtils.create_output_name(opts, __name__)

if opts.enable_output is True:
  # -- initialise the web page calling init_page
  page, extra = InspiralUtils.init_markup_page(opts)
  # -- set output_cache properly: make sure there is a slash
  if len(opts.output_path)>1 :
    opts.output_path = opts.output_path +'/'
  # -- filename
  html_filename = prefix[0:len(prefix)-1] + suffix +".html"
  html_file = file(opts.output_path + html_filename, "w")
####################################################################

rc('font', size='x-large')
if not opts.show_plot:
  rc('text', usetex=True)

bins = [i/opts.num_bins for i in range(opts.num_bins+1)]

if opts.cache_input  is not None:
  allfilesCache = lal.Cache.fromfile(open(opts.cache_input))
  cache_allfilelist = []
  cache_allfilelist = allfilesCache.sieve(ifos = opts.ifo_times, exact_match = True).sieve(description = opts.cache_description, exact_match=opts.match).checkfilesexist()[0].pfnlist()
  if len(cache_allfilelist) < 1:
    print >>sys.stderr, "The file" + opts.cache_input + " contains no" + opts.cache_description + " files"
    sys.exit(1)

  cache_slidefilelist = []
  cache_coincfilelist = []
  cache_slidefilelist = allfilesCache.sieve(ifos = opts.ifo_times, exact_match = True).sieve(description = (opts.cache_description + opts.add_description)).checkfilesexist()[0].pfnlist()

  for file in cache_allfilelist:
    if file not in cache_slidefilelist:
      cache_coincfilelist.append(file)
  
 


if opts.inj_glob:
  filelists = [glob.glob(g) for g in opts.inj_glob]
elif opts.cache_input:
  filelists = [cache_coincfilelist]
  
if opts.slide_glob:
  slidefilelists = [glob.glob(g) for g in opts.slide_glob]
elif opts.time_slides:
  slidefilelists = [cache_slidefilelist]
else:
  slidefilelists = []
  
statistic = CoincInspiralUtils.coincStatistic(opts.statistic)

coincTriggersList = []
for filegroup in filelists:
  for file in filegroup:
    # read raw triggers
    inspTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles([file]) 
    # perform the veto
    if opts.veto_file is not None:
      seglist = segmentsUtils.fromsegwizard(open(opts.veto_file))
      inspTriggers = inspTriggers.veto(seglist)
  
    # reconstruct the coincs
    newCoincs = CoincInspiralUtils.coincInspiralTable(inspTriggers, statistic)
    # cluster them
    if opts.cluster_window:
      newCoincs = newCoincs.cluster(opts.cluster_window)

    # append them to our list
    coincTriggersList.append(newCoincs)
slideTriggersList = []
if slidefilelists:
  for filegroup in slidefilelists:
    # read raw triggers
    slideTriggers = SnglInspiralUtils.ReadSnglInspiralFromFiles(filegroup)

    segs = SearchSummaryUtils.GetSegListFromSearchSummaries(filegroup)

    slideTimeAnalyzed = 0
    for i in range(len(segs[opts.ifo_times])):
      slideTimeAnalyzed += segs[opts.ifo_times][i][1].seconds \
        - segs[opts.ifo_times][i][0].seconds

    # perform the veto
    if opts.veto_file is not None:
      seglist = segmentsUtils.fromsegwizard(open(opts.veto_file))
      slideTriggers = slideTriggers.veto(seglist)

    slide_num = range(1 , opts.num_slides + 1)
    slide_num.extend(range(-opts.num_slides, 0))

    for slide in slide_num:

      dtH1 = slide * opts.h1_slide_time
      dtH2 = slide * opts.h2_slide_time
      dtL1 = slide * opts.l1_slide_time

      this_slide = {}
      this_slide["slide_num"] = slide
      this_slide["sngl_trigs"] = slideTriggers.getslide(slide)

      # Add the slide times
      for i in this_slide["sngl_trigs"]:

        segListIdx=segs[opts.ifo_times].find(i.end_time)
        segStartTime=segs[opts.ifo_times][segListIdx][0].seconds
        segEndTime=segs[opts.ifo_times][segListIdx][1].seconds

        if i.ifo == 'H1':
          i.end_time += dtH1
        if i.ifo == 'H2':
          i.end_time += dtH2
        if i.ifo == 'L1':
          i.end_time += dtL1

        while i.end_time + i.end_time_ns * 1.0e-9 > segEndTime or \
              i.end_time < segStartTime:
          if i.end_time >= segEndTime:
            i.end_time = segStartTime + (i.end_time - segEndTime)
          elif i.end_time < segStartTime:
            i.end_time = segEndTime - (segStartTime - i.end_time)

    # make coincs
    newSlides = CoincInspiralUtils.coincInspiralTable(slideTriggers, statistic)

    # cluster triggers
    if opts.cluster_window:
      newSlides = newSlides.cluster(opts.cluster_window)

    slideTriggersList.append(newSlides)

# Plot
figure_numbers = itertools.count(1) # Infinite "list" of numbers starting at 1
symbol_list = ('rx', 'b+', 'k^', 'gv')
color_list = ('r', 'b', 'k', 'g')
symbol_slide_list = ('mx', 'c+', '0.5^', 'yv')
color_slide_list = ('m', 'c', '0.5', 'y')
if len(filelists) > min(len(symbol_list), len(color_list)):
  print >>sys.stderr, "Warning: Only the first %d globs being used.  Extend "\
    "symbol_list or color_list to handle more of them."

# For each pair of IFOs:
for ifos in pylal_itertools.choices(opts.ifo_list, 2):
  # Pick out relevant double coincs and calculate ethinca parameters
  coincs_list = [x.coincinclude(ifos) for x in coincTriggersList]
  numInjections = 0
  for coincs in coincs_list:
    numInjections += len(coincs)
  ethinca_list = [x.getEThincaValues(ifos) for x in coincs_list]
  if slideTriggersList:
    slides_list = [x.coincinclude(ifos) for x in slideTriggersList]
    ethinca_slide_list = [x.getEThincaValues(ifos) for x in slides_list]
  else:
    slides_list = []
    ethinca_slide_list = []

  for col in opts.columns:  # ethinca-param vs col
    for ifo in ifos:
      figure(figure_numbers.next())
      for coincs, ethincaVals, symbol in \
          zip(coincs_list, ethinca_list, symbol_list):
        xVals = coincs.getsngls(ifo).get_column(col)
        plot(xVals, ethincaVals, symbol, markeredgewidth=1, markersize=6)
      if slideTriggersList:
        hold(True)
        for slides, ethincaSlideVals, symbolSlide in \
            zip(slides_list, ethinca_slide_list, symbol_slide_list):
          xSlideVals = slides.getsngls(ifo).get_column(col)
          plot(xSlideVals, ethincaSlideVals, symbolSlide,
              markeredgewidth=1, markersize=6)

      grid(True)
      if coincTriggersList:
        if len(ethincaVals) == 0 or max(ethincaVals) < 1:
          ylim((0,1))
      elif slideTriggersList:
        if len(ethincaSlideVals) == 0 or max(ethincaSlideVals) < 1:
          ylim((0,1))
      xlabel("%s %s" % (ifo, col.replace('_', r'\_')))
      ylabel("E-thinca parameter")
      title("E-thinca parameter vs %s for %s and %s triggers" % \
        (col.replace('_', r'\_'), ifos[0], ifos[1]))
      
      if opts.enable_output:
        fname = prefix + "%s_%s_ethinca_vs_%s_%s" % (ifos[0], ifos[1], ifo, col) + suffix + ".png"   
        savefig(opts.output_path + fname)
        text = "E-thinca parameter vs %s for %s and %s triggers" % (col.replace('_', r'\_'), ifos[0], ifos[1]) + " in " + opts.ifo_times + " times"
        # -- create a link and image html tag
        page.a(extra.img(src=[opts.output_path +fname], width=400, alt = text, border="2"), title=text, href=[opts.output_path + fname])
        # -- keep track of this filename
        output_cachefile_name.append(fname)
        
      if not opts.show_plot:
        close()
  
  if opts.ethinca_vs_stat:  # ethinca-param vs combined statistic
    figure(figure_numbers.next())
    for coincs, ethincaVals, symbol in \
        zip(coincs_list, ethinca_list, symbol_list):
      xVals = [x.stat for x in coincs]
      if opts.log_x:
        semilogx(xVals, ethincaVals, symbol, markeredgewidth=1, markersize=6)
      else:
        plot(xVals, ethincaVals, symbol, markeredgewidth=1, markersize=6)
    if slideTriggersList:
      hold(True)
      for slides, ethincaSlideVals, symbolSlide in \
          zip(slides_list, ethinca_slide_list, symbol_slide_list):
        xSlideVals = [x.stat for x in slides]
        if opts.log_x:
          semilogx(xSlideVals, ethincaSlideVals, symbolSlide,
            markeredgewidth=1, markersize=6)
        else:
          plot(xSlideVals, ethincaSlideVals, symbolSlide,
            markeredgewidth=1, markersize=6)

    grid(True)
    if coincTriggersList:
      if len(ethincaVals) == 0 or max(ethincaVals) < 1:
        ylim((0,1))
    elif slideTriggersList:
      if len(ethincaSlideVals) == 0 or max(ethincaSlideVals) < 1:
        ylim((0,1))
    xlabel("Combined %s" % opts.statistic.replace('_', r'\_'))
    ylabel("E-thinca parameter")
    title("E-thinca parameter vs combined %s for %s and %s triggers" % \
      (opts.statistic.replace('_', r'\_'), ifos[0], ifos[1]))

    if opts.enable_output:
      fname = prefix + "%s_%s_ethinca_vs_combined_%s" % (ifos[0], ifos[1], opts.statistic) + suffix + ".png"   
      savefig(opts.output_path + fname)
      text = "E-thinca parameter vs combined %s for %s and %s triggers" % \
        (opts.statistic.replace('_', r'\_'), ifos[0], ifos[1]) + " in " + opts.ifo_times + " times"
      # -- create a link and image html tag
      page.a(extra.img(src=[opts.output_path +fname], width=400, \
        alt = text, border="2"), title=text, href=[opts.output_path + fname])

      # -- keep track of this filename
      output_cachefile_name.append(fname)
      
    if not opts.show_plot:
      close()

  if opts.hist_stat:  # hist combined statistic
    figure(figure_numbers.next())
    stat_max = max([max([y.stat for y in x]) for x in coincs_list+slides_list \
        if len(x)] + [0.1])
    if coincTriggersList:
      xVals = [[x.stat for x in coincs] for coincs in coincs_list]
      y_list, x_list = zip(*[histogram(xVal, bins=opts.num_bins,
          range=[0, stat_max]) for xVal in xVals])
      n = len(x_list)

    if slideTriggersList:
      xSlideVals = [[x.stat for x in slides] for slides in slides_list]
      y_list, x_list = zip(*[histogram(xSlideVal, bins=opts.num_bins,
          range=[0, stat_max]) for xSlideVal in xSlideVals])
      if not coincTriggersList:
        n = len(x_list)
      for i, x, y, color in zip(range(n), x_list, y_list, color_slide_list):
        x += 0.1*i*stat_max/opts.num_bins  # Introduce some stagger
        y[len(y)-1] = 0
        bar(x, y, color=color, width=(1-0.1*n)*stat_max/opts.num_bins)

    if coincTriggersList:
      hold(True)
      xVals = [[x.stat for x in coincs] for coincs in coincs_list]
      y_list, x_list = zip(*[histogram(xVal, bins=opts.num_bins,
          range=[0, stat_max]) for xVal in xVals])
      n = len(x_list)
      for i, x, y, color in zip(range(n), x_list, y_list, color_list):
        x += 0.1*i*stat_max/opts.num_bins  # Introduce some stagger
        y[len(y)-1] = 0
        bar(x, y, color=color, width=(1-0.1*n)*stat_max/opts.num_bins)
    ylim(0,100)
    grid(True)
    xlabel("Combined %s" % opts.statistic.replace('_', r'\_'))
    ylabel("\#")
    title("Histogram of combined %s for %s and %s triggers" % \
      (opts.statistic.replace('_', r'\_'), ifos[0], ifos[1]))

    if opts.enable_output:
      fname = prefix + "%s_%s_hist_combined_%s" % (ifos[0], ifos[1], opts.statistic) + suffix + ".png"   
      savefig(opts.output_path  + fname)
      text = "Histogram of combined %s for %s and %s triggers" % \
      (opts.statistic.replace('_', r'\_'), ifos[0], ifos[1]) + " in " + opts.ifo_times + " times"
      # -- create a link and image html tag
      page.a(extra.img(src=[opts.output_path +fname], width=400, \
      alt = text, border="2"), title=text, href=[opts.output_path + fname])
      # -- keep track of this filename
      output_cachefile_name.append(fname)
      
    if not opts.show_plot:
      close()
 
  if opts.hist:
    figure(figure_numbers.next())
    
    # Histogram all datasets with the same bins
    ep_max = max([max(eps) for eps in ethinca_list+ethinca_slide_list \
        if len(eps)] + [0.1])
    if coincTriggersList:
      y_list, x_list = zip(*[histogram(eps, bins=opts.num_bins,
          range=[0, ep_max]) for eps in ethinca_list])
      n = len(x_list)
      for i, x, y, color in zip(range(n), x_list, y_list, color_list):
        x += 0.1*i*ep_max/opts.num_bins  # Introduce some stagger
        bar(x, y, color=color, width=(1-0.1*n)*ep_max/opts.num_bins)
    if slideTriggersList:
      hold(True)
      y_list, x_list = zip(*[histogram(eps, bins=opts.num_bins,
          range=[0, ep_max]) for eps in ethinca_slide_list])
      if coincTriggersList:
        normalization = opts.injection_window*numInjections/ \
               (2.0*opts.num_slides*slideTimeAnalyzed)
      else:
        normalization = 1.0
        n = len(x_list)
      for i, x, y, color in zip(range(n), x_list, y_list, color_slide_list):
        x += 0.1*i*ep_max/opts.num_bins  # Introduce some stagger
        y_norm = zeros(len(y),Float)
        for j in range(len(y)):
          y_norm[j] = normalization*y[j]
        bar(x, y_norm, color=color, width=(1-0.1*n)*ep_max/opts.num_bins)
    ylabel("\#")
    xlabel("E-thinca parameter")
    title("E-thinca parameter Histogram for " + ifos[0] + \
          " and " + ifos[1] + " triggers")
    if opts.enable_output:
      fname = prefix + ifos[0] + "_" + ifos[1] + "_ethinca_hist" + suffix + ".png"   
      savefig(opts.output_path  + fname)
      text = "E-thinca parameter Histogram for " + ifos[0] + \
          " and " + ifos[1] + " triggers in " + opts.ifo_times + " times"
      # -- create a link and image html tag
      page.a(extra.img(src=[opts.output_path +fname], width=400, \
      alt = text, border="2"), title=text, href=[opts.output_path + fname])
      # -- keep track of this filename
      output_cachefile_name.append(fname)
      
    if not opts.show_plot:
      close()
# ============================================================================
# final step: html, cache file generation
if opts.enable_output:
  text = InspiralUtils.writeProcessParams( __name__, __version__, command_line)
  page.add(text)
  html_file.write(page(False))
  html_file.close()

if opts.enable_output is True:
  output_cache_name = prefix[0:len(prefix)-1] + suffix +'.cache'
  this = open(opts.output_path + output_cache_name, 'w')
  if opts.enable_output is True:
    this.write(opts.output_path + html_filename + '\n')
  for fname in output_cachefile_name:
    this.write(fname + '\n')
  this.close()

# ============================================================================


if opts.show_plot:
  show()
