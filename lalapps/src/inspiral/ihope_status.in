#!/usr/bin/env @PYTHONPROG@
"""
ihope_status.in - give a brief dag status

$Id $

This script parse a dag file and retrieve the last status line found in the
file. It prints the number of failed/done jobs. 

If a dag contains other dag, those dags are alos read. 

"""
__author__ = 'Thomas Cokelaer < Thomas.Cokelaer@astro.cf.ac.uk>'
__date__ = '$Date$'
__version__ = '$Revision$'
__name__ = 'ihope_status'


import sys
import os
import optparse
from optparse import OptionParser
import time


##############################################################################
usage = """\
%prog [options]
----------------
 brief status of the dag
   
 Purpose - parse one or several dagman.out file(s) to obtain a brief  summary 
 of the dag status and their rescue files if they exist.
 
 Example - You can parse a dag that contains several dag such as ihope.dag 

         >>> python %prog --dag-file ihope.dag
         
         - Or a simple dag:
        
         >>> python %prog --dag-file hipe.dag')

"""

#
# =============================================================================
#
#                     Parse Command Line
#
# =============================================================================
#

def parse_command_line():
  """
  Parser function dedicated
  """
  parser = OptionParser( usage=usage )
  parser.add_option( "--dag-file", default='ihope.dag', metavar='DAGFILE', \
                   help="The dag file to parse")
  comand_line = sys.argv[1:]
  (options,args) = parser.parse_args()

  return options, sys.argv[1:]

# ============================================================================
# -- get command line arguments
options, args = parse_command_line()


##############################################################################
def get_status(filename, depth, totals, debug=False):
  """
  parse a dag filem search for failed/done jobs
  @param filename: name of a dag file to parse
  @param depth: used for the tabbing
  @param totals: cumulitive number of jobs in each category
  @return output_message
  @return error_message
  @return number_of_failed_jobs

  """
  space = "    "
  tab =""
  for i in range(0,depth):
    tab = tab + space

  try:
    thisdag = open(filename, 'r')
  except:
    if debug==True:
      print "This file does not exists ("+filename+")"
    return [], "fileError", -1
  print tab + '-->  parsing '+ filename 
    
  #line = thisdag.readline()
  #if not line:
  #  return [], "emptyFile", -1

  line = "dummy"
  status = []
  error = []
  countline = 0
  while line:
    line = thisdag.readline()
    if line.find('Done')>=0:
      output = tab + line      
      line = thisdag.readline()
      output = output + tab + line
      #read the numbers
      line = thisdag.readline()
      numbers = line.split(" ")
      num = line
      number_of_failed_jobs = int(numbers[len(numbers)-1])
      
      output = output + tab + line
  # count the number of jobs
  num=num.split()
  num = num[2:]
  s = 0
  for i in num:
   s = s+ int(i)
  njobs = s
  # and failed or unready
  s = 0
  for i in num[1:]:
   s = s+ int(i)  
  number_of_failed_jobs = s 
  # adjust totals
  for i in xrange( len( num ) ):
    totals[i] += int(num[i])
  

  if len(output)>0:
    print output
  else:
    print "No line matches \"Done or Failed\" as expected... "
    print error

  return output, error, number_of_failed_jobs


#
# =============================================================================
#
#                    Main
#
# =============================================================================
#
 

""" There are 2 possibilities. 
    First, the file provided is a dag file that ends in '.dag' that
    contains other dag calls such as in ihope.
    Second, it is a pure dag file which might not even contain a dag
    by itself, and in such case we search for the .dagman.out file.
"""

print 'Parsing ' +options.dag_file + '...'
time.sleep(1)

# Need path path for dub dags
if '/' in options.dag_file:
  path = options.dag_file[:( options.dag_file.rindex( '/' ) + 1 )]
else:
  path = ''

dagFile = open(options.dag_file, 'r')
filenames = []
lines = dagFile.readlines()
for line in lines:
  if "JOB" in line:
    strs = line.split()
    if "DIR" in strs:
      fname = strs[-1] + "/"
    else:
      fname = ""
    for string in strs:
      if "dag" in string:
        fname += string.strip(".condor.sub")
    filenames.append(fname)
    print 'Found ' + fname
dagFile.close()

if len(filenames)==0:
  print 'No dag files found in ' + options.dag_file
  print 'Assuming that ' + options.dag_file + ' is the dag file you want to parse'
  filenames.append(options.dag_file)
  
print 'Parsing the dag files for status...\n'
### we found some dag files hopefully

time.sleep(1)

#parse all the dags one by one
totals = [0,0,0,0,0,0,0]
for i in xrange(0,len(filenames), 1):
  tag = filenames[i] 
  filename = tag +'.dagman.out'
  
  # if sub dags add path
  if path != '' and path not in filename:
    filename = path + filename
  

  undone_jobs = 111 #dummy value
  depth = 0   # used for tabulating rescue files
  print '-------------------------------------------------------------------------'
  while undone_jobs is not 0:
    # How many jobs are completed/failed ? 
    output, error, undone_jobs = get_status(filename, depth, totals)
    tag = tag+'.rescue'
    filename = tag + '.dagman.out'
    depth = depth + 1
    # If no file found, we stop this dag parsing
    if len(error)>0:
#      print error
      break
  
  # This dag has been parsed. Where they any failures ?
  if undone_jobs >0:
    print "  WARNING: still " +str(undone_jobs) + "jobs not done"
  if error=="emptyFile":
    print "empty file"
  if undone_jobs==0: 
    print filenames[i]+" is COMPLETED"
#  print '-------------------------------------------------------------------------\n'

# Print totals
print " Done    =", totals[0]
print " Pre     =", totals[1]
print " Queued  =", totals[2]
print " Post    =", totals[3]
print " Ready   =", totals[4]
print " Unready =", totals[5]
print " Failed  =", totals[6]
print " --------------------------- "
print " Total jobs =", sum( totals )
print " --------------------------- "

  
  




