#!/usr/bin/python

# $Id$
"""
Tools to create a HTML document that summarizes results produced by ihope. 
"""
__author__ = "Thomas Cokelaer <thomas.cokelaer@astro.cf.ac.uk>"
__version__ = "$Revision$"
__date__ = "$Date$"
__Id__ = "$Id$"
__name__ = "write_ihope_page"

import sys
import copy
import os
import re
from optparse import *
import glob
from glue  import markup
from glue.markup import oneliner as e
import ConfigParser
sys.path.append('@PYTHONLIBDIR@')


# ***************************************************************************
def functionId(nFramesUp):
  """ 
  Create a string naming the function n frames up on the stack.
  
  @param nFramesUp: input
  @type nFramesUp: number
  @return: message
  """
  try:
    co = sys._getframe(nFramesUp+1).f_code
    msg = "%s (%s @ %d)" % (co.co_name, co.co_filename, co.co_firstlineno)
    if msg.startswith("?") is False:
      print "-->ERROR in function: " + msg
  except:
    msg=[]

  return msg

# ***************************************************************************
def logText(logfile, text, tag="done"):
  """
  Utility to populate a logfile in HTML format. 
  The third argument is a string. Depending on its value, the text will have 
  different color. 
  
  @param text: a text to be printed
  @type text: string
  @type tag: string 
  @param tag: is in {"done","warning","error"} 
  """ 

  if tag=="warning":
    msg= "<"+tag+">"+text+"</"+tag+">\n"
    logfile.write(msg)
    if opts.verbose is True:
      print >>sys.stdout,text
  elif tag=="error":
    msg = "<"+tag+">"+text
    logfile.write(text)
    i =1 
    while len(msg)>0:
      msg = functionId(i)
      if msg.startswith("?") is False:
        logfile.write("\n"+msg)
      else :
        logfile.write("</"+tag+">\n")
        msg=[]
      i=i+1
    print >>sys.stderr, msg
    exit(1)
  else :
    msg = "<"+tag+">"+text+"</"+tag+">\n"
    logfile.write( msg )
    if opts.verbose is True:
      print >>sys.stdout,text

# ***************************************************************************
def patternFoundInFilename(filename, pattern):
  """
   a small function to check that a pattern is contained within a filename.

     >>> filename = "H1H2L1-plotinspmissed_totalMass_versus_eta.png"
     >>> pattern = "plotinspmissed*eta"
     >>> patternfoundInFilename(filename, pattern)

   @param filename: the filename to look at
   @type filename: string
   @param pattern: a pattern which may contain several '*'
   @type pattern: string
   @return: boolean
  """
  tokeep = False
  if pattern is None : return tokeep
  
  # you may have * inside a pattern
  for word in pattern.split('*'):
    if word in filename:
      tokeep = True
    else:
      tokeep = False
      # if one word is not found within filename, we must break and se
      break

  return tokeep

# ***************************************************************************
def make_external_call(\
  command, show_stdout=False, \
  show_command=False, show_error=True):
  """
  Run a command line argument and print informative messages on failure.
  It returns two outputs: the stdout of the command, and its status.  

    >>> make_external_call('cp * /tmp', False, False, True)

  @param command: the command to try
  @type command: string
  @param show_stdout: show the stdout 
  @type show_stdout: boolean
  @param show_command: show the command
  @type show_command: boolean
  @param show_error: show the error if any
  @type show_error: boolean
  @return: the stdout and a status  


  """
  if show_command and opts.verbose is True: 
    print "--- Trying this command :" + command

  stdin, out, err = os.popen3(command)
  pid, status = os.wait()
  this_output = out.read()
  if show_error & status != 0:
    print >>sys.stderr, "External call failed."
    print >>sys.stderr, "  status: %d" % status
    print >>sys.stderr, "  stdout: %s" % this_output
    print >>sys.stderr, "  stderr: %s" % err.read()
    print >>sys.stderr, "  command: %s" % command
    sys.exit(status)
  if show_stdout:
    if this_output[0:1]=='\n': 
      print  this_output[1:]  #first character is \n
    else:
      print this_output

  stdin.close()
  out.close()
  err.close()  
  return this_output, status

# ***************************************************************************
def mkdir( newdir ):
  """
  Create a directory

  @param newdir : name of directory to be created
  @type newdir: string
  """
  if os.path.isdir(newdir): 
    print >>sys.stdout, "WARNING: this directory already exists (" + newdir +")."
    pass
  elif os.path.isfile(newdir):
    raise OSError("a file with the same name as the desired " \
                  "dir, '%s', already exists." % newdir)
  else: 
    os.mkdir(newdir)


# ***************************************************************************
def create_toggle():
  """
  This function is just an alias to create a javascript for the toggle on/off. 

  @return: nothing
  """
  fname = open("toggle.js", "w")
  fname.write("function toggleVisible(division) {\n"+\
    "  if (document.getElementById(\"div_\" + division).style.display =="\
   + " \"none\") {\n document.getElementById(\"div_\" + division).style.display"\
   + " = \"block\";\n document.getElementById(\"input_\" + division).checked "\
   + " = true;\n } else {\n document.getElementById(\"div_\" + "\
   + " division).style.display = \"none\";\n document.getElementById("\
   + "\"input_\" + division).checked = false;\n  }\n  }\n" )

  # common part to expandall and clearall function
  txt=""
  txt += "  var section = new Array();\n"
  number = 0
  for each_section in html_order:
    if each_section!="toc":
      id = each_section.replace(" ","_")     
      txt += "section[" + str(number) + "] = \""+id+"\";\n"
      number+=1
  txt += "  for (x in section){\n"
  txt += "     division = section[x];\n"
  
  txtclose="  }\n}\n"

  # first function
  fname.write( "function expandall(max){\n")
  fname.write(txt)
  fname.write("      if (document.getElementById(\"div_\" + division).style.display == \"none\") {\n")
  fname.write("      document.getElementById(\"div_\" + division).style.display = \"block\";\n")
  fname.write("      document.getElementById(\"input_\" + division).checked  = true;\n")
  fname.write(txtclose)
  fname.write("    for (i=0; i<max;i++){\n")
  fname.write("      division = i+''\n")
  fname.write("      if (document.getElementById(\"div_\" + division).style.display == \"none\") {\n")
  fname.write("      document.getElementById(\"div_\" + division).style.display = \"block\";\n")
  fname.write("      document.getElementById(\"input_\" + division).checked  = true;\n")
  fname.write(txtclose)
  fname.write("}\n")
  
  # second function clearall
  fname.write( "function clearall(max){\n")
  fname.write(txt)
  fname.write("      if (document.getElementById(\"div_\" + division).style.display == \"block\") {\n")
  fname.write("      document.getElementById(\"div_\" + division).style.display = \"none\";\n")
  fname.write("      document.getElementById(\"input_\" + division).checked  = false;\n")
  fname.write(txtclose)
  fname.write("    for (i=0; i<max;i++){\n")
  fname.write("      division = i+''\n")
  fname.write("      if (document.getElementById(\"div_\" + division).style.display == \"block\") {\n")
  fname.write("      document.getElementById(\"div_\" + division).style.display = \"none\";\n")
  fname.write("      document.getElementById(\"input_\" + division).checked  = false;\n")
  fname.write(txtclose)
  fname.write("}\n")

  # function to replace the non-strict  "target" html key
  fname.write("""function externalLinks() {
    if (!document.getElementsByTagName) return;
    var anchors = document.getElementsByTagName("a");
    for (var i=0; i<anchors.length; i++) {
      var anchor = anchors[i];
      if (anchor.getAttribute("href") &&
          anchor.getAttribute("rel") == "external")
        anchor.target = "_blank";
     }
    }
   window.onload = externalLinks;
  """)

  fname.close()

# ***************************************************************************
def write_results(page, opts, section):
  """
  This function is just a switch to the function that create each section of
  the HTML document. 
   
    >>> write_results(page, opts, "injection")

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @param section: the current section to switch to 
  @type section: string
  @return: an update of HTML document
  """

  if opts.verbose is True:
    print >>sys.stdout,"--------------------- Creating section "+section

  if section=='general':
    page = write_general(page, opts)
  elif section=='toc': 
    page = write_toc(page, opts)
  elif section=='summary':
    page = write_summary(page, opts)
  elif section=='playground': 	
    page = write_analysis(page, opts,thisSearch='playground')
  elif section=='full_data_slide': 	
    page = write_analysis(page, opts,thisSearch='full_data_slide')
  elif section=='tuning': 
    page = write_tuning(page, opts)
  elif section=='injection':
    page = write_injection(page, opts)
  elif section=='full_data':
    page=write_analysis(page,opts,thisSearch='full_data')
  elif section=='upperlimit': 	
    page = write_upperlimit(page, opts)
  elif section=='summary files': 
    page = write_summaryFiles(page, opts)
  elif section=='logfile':
    page = write_logfile(page, opts)
  elif section=='about': 
    page = write_about(page, opts)
  else:
    msg = "this section ("+ section +") doest not exist. "
    logText(logfile, msg, "error")

  return page


# ***************************************************************************
def write_logfile(page , opts):
  """
  This function creates an entry with the logfile information.
  
  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  # get the directory of the url
  dir = opts.webdir +'/'
  
  source = dir + __name__ + '.xml'
  
  page.add("<p> Here is a logfile.")
  page = add_href(page, href=source, name=__name__)
  page.add(", which entry should be all in green except if skip options were used.</p>")
  
  return page

def add_href(page, href="", name="click here"):
  try:
    page.add("<a href=\"" + href + "\" rel=\"external\"> " + name + "</a>")
  except: 
    logText(logfile, "Could not create link "+ href, "error")
  return page

# ***************************************************************************
def write_toc(page , opts):
  """ 
  This function creates the table of contents, using the html_sections 
  variable defined in the main part of this program.

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  # get the directory of the url
  dir = opts.webdir +'/'

  # and the section names
  items = html_sections 
  order = html_order 
  # create a frame for the toc, and add contents 
  page.ol()
  for this_item in order:
    try:
      page.li(e.a(items[this_item], href=dir + opts.output + '#' \
         + this_item.replace(" ","_")))
      msg = "added "+this_item
      logText(logfile, msg, "done")
    except:
      msg = 'skip '+this_item
      logText(logfile, msg, "warning")
#      pass

  page.ol.close()

  return page

# ***************************************************************************
def write_general(page,opts):
  """
  Creates the general section. 

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  webdir = opts.webdir
  ini = opts.config_file
    
  text = 'This page summarizes the analysis of the data segment from GPS '
  text += 'time %s up to %s' % (opts.gps_start_time,  opts.gps_end_time)
  page.add(text)

  # The search parameters
  if opts.verbose is True: 
    print "Extracting the version and tag of the executables..." 
  
  # todo : get the list of executables  from the ini file
  executables = ("inspiral", "tmpltbank", "sire",\
                 "thinca", "trigbank", "coire" , "inspinj")

  heading(page, "The search used the following resources:")

  page.ol() #starts enumerate
  # first section with version number
  # get the version of each executables
  try:
    page.add("<li> LAL/LALApps "+get_version("inspiral"))
    page.ul()
    for exe in executables:
      text = "<b>lalapps_"+exe+ "</b>    "+get_version(exe)
      page.li(text)   
    page.ul.close()
    page.li.close()
  except:
    logText(logfile, """Problem with the executable: cannot find them ? """, "warning")
    pass
  
  # second section 
  try:
    page.add("<li>Segment information (see the Data Information section for more details):")
    page.ul()
    for this in get_ifos():
        seg = this +'-SELECTED_SEGS'+opts.txt_suffix
        this_ref = webdir + '/segments/'+seg
        page.li(e.a(seg,href=this_ref,rel="external") )
    page.ul.close()
    page.li.close()
  except:
    logText(logfile, """Problem with the executable: cannot find them ? """, "warning")
    pass

  try:
    # let us give the ihope.ini and log file.
    # we also need to copy some files to the webdir
    cmd = 'cp '+opts.datadir + '/ihope.pipeline.log  '+opts.physdir
    make_external_call(cmd, opts.debug, opts.debug, False)
  except:
    pass
  
  try: 
    page.add("<li>The configuration parameters are contained within the file ")
    page = add_href(page, href=webdir+"/"+ini, name=ini)
    page.add(", which was used by lalapps_ihope as reported in the")
    page = add_href(page, href=webdir + "/ihope.pipeline.log", \
        name="[ihope.pipeline.log]")
    page.li.close()
  except:pass
  
  try:  
    page.add("<li>The list of category files is stored in the directory ")
    page = add_href(page, href=webdir+"/catlists/" , name="[catlists]")
    page.add(", and listed in the ini file.")
    page.li.close()
  except:
    logText(logfile, """Problem with the log file or segment list: cannot find them ? """, "warning")
    pass
  page.ol.close() # end enumerate

  logText(logfile,  "...Get the executables version...")
  page.div.close()

  # The ifo requested
  page = heading(page, "This search concerned the following combination of ifos")
  page = add_config_section(page, "ifo-details")
  page.div.close() #close the main heading

  return page


# ***************************************************************************
def write_title(page, text, tag, checked=False):
  """
  create a title (h2 tag) with a toggle on/off and a link to the TOC.

    >>> write_title(page, "my beautiful title", "whatever_but_unique_tag")

  @param page: the HTML document page.
  @type page: markup.py document
  @param text: the title
  @type text: string
  @param tag: a tag to include within the link/name 
  @type tag: string
  @param checked: whether the checkbox near the title should be initially checked
  @type checked: bool
  @return: an update of HTML document
  """
  global h2_num

  page.h2()
  page.add("<a name=\""+tag+"\">")
  input = "input_"+tag
  if checked:
    page.input(id=input, type="checkbox", checked=None, onclick="toggleVisible('"+tag+"')")
  else:
    page.input(id=input, type="checkbox", onclick="toggleVisible('"+tag+"')")    

  h2_num+=1  # we incremnt the section number
  page.add(str(h2_num)+". "+text)

  page.add("</a>")
  page.h2.close() 
  page.div(e.a("Return to table of contents", href="#toc" ), class_="back")
  
  return page

def write_table(page, segs, keys):
  """
  print a table in html format, where keys is the first column and 
  keys to the dictionary "segs"

  @param page: the html document
  @param segs: the segment durations
  @param keys: the segments names
  @type segs: a dictionary which keys are stored in the parameter "keys"
  @type keys: a list of sorted keys corresponding to the segs dictionary keys (not sorted)
  """
  page.table()
  for key in keys:
    if segs.has_key(key):
      page.tr()
      page.td(key)
      page.td(segs[key])
      page.tr.close()
  page.table.close()

  return page
# ***************************************************************************
def write_summary(page,opts):
  """
  Creates the summary section.

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  # first, get some information 
  webdir = opts.webdir
  datadir = opts.datadir
  ini = opts.config_file
  ifos = get_ifos()

  page.add("<p>This section summarizes the data which was available for analysis.")
  page.add("All of the segment files are linked in")
  page = add_href(page, href= webdir + "segments", name="this directory")
  page.add(".<p>")

  page.add("Segments were generated using the following information:")
  page = add_config_section(page, "segments")

  page = heading(page, "Selected segments", "Switch details on/off")  
  try:
    page.add("<p>The segments files provided in the general section were ")
    page.add("created with no data quality flags set. The times analyzed ")
    page.add("according to ihope/hipe are provided here below</p>")
    page.add("Note that duration of the selected segments added to duration")
    page.add("of categories 1 equals duration of science segment")
    page.p(e.br())
    
    segs = get_segments_tag("SELECTED_SEGS")
    keys = ("segments","H1","H2","L1","G1","V1","T1") 
    page = write_table(page, segs, keys)
  except:
    pass
  page.div.close() #heading
  

  # for each category, we loop over each ifo and create a table
  # with the time analysed.
  i=0
  for cat in ("CATEGORY_1_VETO_SEGS","CATEGORY_2_VETO_SEGS",\
      "CATEGORY_3_VETO_SEGS","CATEGORY_4_VETO_SEGS"):
    i=i+1
    msg = "Category " +str(i) + " veto segments (flags and time)"
    page = heading(page, msg) 
    try:
      msg = "This category includes the following flags : "
      page.add(msg)

      for ifo in ifos:
        command = 'awk \'{print $1}\' ' +  datadir +'/segments/' + ifo + "cat"+str(i)+".txt"
        flags, status = \
          make_external_call(command, opts.debug, opts.debug, True)
        page.pre(flags)

      msg="The veto times (category "+str(i)+") according to hipe ( "+cat+")"
      page.add(msg)

      segs = get_segments_tag(cat)
      keys = ("segments","H1","H2","L1","G1","V1","T1")
      page = write_table(page, segs, keys) 
      page.div.close() # (3)
    except:     
      msg = "Problems parsing category veto segment list "+str(i), "warning"
      logText(logfile, msg)
      page.div.close() # (3)
     

  for tag in ["SCIENCE_SEGMENTS", "RDS_C03_L2", "MISSED_SEGS"] :
    page = heading(page, tag +" summary ")
    if tag == "SCIENCE_SEGMENTS":
      msg = "The times requested for analysis are:"
    elif tag == "RDS_C03_L2":
      msg = "The times for which " + tag + " data is available are: "
    elif tag == "MISSED_SEGS":
      msg = "The times for which data is requested but not available are:" 

    page.add(msg +" <br/>")
    try:
      segs = get_segments_tag(tag)
      keys = ("segments","H1","H2","L1","G1","V1","T1") 
      page = write_table(page, segs,keys)
      page.div.close() 
    except:
      msg = "Problems parsing category veto segment list "+tag, "warning"
      logText(logfile, msg)
      page.div.close() 
  
  return page


# ***************************************************************************
def write_upperlimit(page, opts):
  """
  Creates an upper limit section (not yet done)
  
  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  webdir = opts.webdir
  ini = opts.config_file
  ifos = get_ifos()
  mkdir(opts.physdir+"/playground")
  
  page.add("Upper Limit Results")
  page.add("to be done ? ")

  return page


# ***************************************************************************
def write_tuning(page,opts):
  """
  Creates the tuning section.

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  webdir = opts.webdir
  ini = opts.config_file
  ifos = get_ifos()
  mkdir(opts.physdir+"/tuning")
  
  page.add("This section summarizes the tuning of the e-thinca, \
      r-square, chi-square and h1-h2 cuts. Note that the R-square and chi-square \
      plots use as an input the SIRE of the COIRE files. The other plots use \
      the COIRE files <br/>")
  
  #---------------------------- Tuning

  titles = [\
  	"Ethinca",\
	"chisq",\
  	"rsq",\
  	"distance cut"\
	]
  tags = [\
  	'*plotethinca_SECOND*CAT_2*',\
	'*plotsnrchi*',\
	'*plotsnrchi*',\
	'*ploteffdistcut*'\
	]

  imagetags=[\
	['ethinca_vs_combined'],\
	['chisq_inj_const_lines'],\
	['rsq'],\
	['eff_dist_cut']\
	]

  captions = [\
  	"Ethinca versus combined SNR in the different ifo combinations",\
  	"chi-square versus SNR (injections in red, slides in black) ",\
  	"R-square versus SNR (injections in red, slides in blue) ",\
  	"Fractional differences in effective distance (H1 and H2 detectors). \
         Blue crosses are slided triggers. Red crosses are injection triggers."\
	]

  configs = [	\
	'plotethinca',\
	'plotsnrchi',\
	'plotsnrchi',\
	'ploteffdistcut'\
	]

  injections = hipecp.items("injections")
  images_dirs = []
  for this in injections:     
    images_dirs.append(this[0]+"_summary_plots")
  images_dirs.append("allinj_summary_plots")


  for images_dir in images_dirs:
    if os.path.isdir(opts.datadir + images_dir) is True:
      print '--------------------------------------------------------------'
      page.add("<h1>Summary of the "+images_dir+" directory</h1>")
      for title, tag, caption,config,image_tag in zip(titles, tags, captions, configs,imagetags):
        page = heading(page, title +" ("+images_dir +")")
        try:
          page = add_config_section(page, config)
          page = fom(page, opts, cachefile_tag=tag, caption=caption,\
  	 	image_tag=image_tag, directory=images_dir)
          page.div.close() # for each heading 
        except:
          page.div.close() # for each heading
          
   


  return page


# ***************************************************************************
def write_analysis(page, opts, thisSearch='playground'):
  """
  Creates the playground or full_data section. It uses the same function 
  because except the name and time analysed, the figures of merits are the same. 
  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @param thisSearch: either "playground" or "full_data" or "full_data_slide"
  @type thisSearch: string
  @return: an update of HTML document
  """
  webdir = opts.webdir
  ini = opts.config_file
  ifos = get_ifos()
  mkdir(opts.physdir+"/"+thisSearch)



  if thisSearch=='playground':
    images_dir='/playground_summary_plots/'
  elif thisSearch=='full_data_slide':
    images_dir='/full_data_slide_summary_plots/'
  elif thisSearch=='full_data':
    images_dir='/full_data_summary_plots/'
  else:
    print 'Error in write_analysis function: thisSearch is not valid'
    sys.exit(1)
  msg = "This section summarizes the analysis of the "+thisSearch+" data.<br/>"
  page.add(msg)
  
  #table and venn diagram
  
  page = heading(page, "General information", "see details here")
  try:
    segs = get_segments_tag('SELECTED_SEGS')
    keys = ("segments","H1","H2","L1","G1","V1","T1") 
    msg = "The segment files above were created with no data quality flags set"
    page.p(msg)

    page.p("The times analyzed according to hipe are:")
    coincs = get_coincident_segments(thisSearch)  

    ## here is the table. The first column is another table with the durations, 
    page.add("<table><tr><td>\n")
    page.table()
    page.tr();
    page.td('coincidence'); 
    page.td('duration(s)'); 
    page.tr.close()
    for key in coincs.keys():        
      page.tr()
      if thisSearch=='playground':
        file = webdir +thisSearch +'/segments/'+key+"_play_segs_analyzed.txt"
      elif thisSearch=='full_data' or thisSearch=='full_data_slide':
        file = webdir +'full_data/segments/'+key+"_segs_analyzed.txt"
      page.td(e.a(key,href=file,rel="external"))
  
      page.td(coincs.get(key))
      page.tr.close()
    page.table.close()
    page.add("</td>\n")
  except:
    logText(logfile, "Error in generating analysed segments.", "error")
    pass

  try:
    page.add("<td>")
    #create figure for the venn diagram
    data = ""
    for coinc in ("H1","H1H2","H2","H2L1","L1","H1L1","H1H2L1"):
        data = data +coincs.get(coinc) + " "
    success = create_venn(data, thisSearch)
    if success is True: 
      alt = "Venn diagramm"
    else: 
      alt = "No picture generated, check your matlab installation. you must \
          have vennX.m available (from matapps/src/inspiral/matSpiral package) "
    # and incorporate into html

    comment = "Venn diagram showing distribution of"
    for coinc in  coincs.keys():
      comment = comment + " "+ coinc
    comment += " coincidences "
    page = add_figure(page, fnames =[thisSearch+"/venn_"+thisSearch+".png"],\
      caption=comment, size="full", alt=[alt])
    page.add("</td></tr></table>")
    
    page.add("Here below is the detail of the data and ligo-data section \
        of ihope.ini ")
    page = add_config_section(page, "data")
    page = add_config_section(page, "ligo-data")
    page.div.close()  
  except:
    page.div.close()  
    logText(logfile, "Error in generating Venn diagram.", "error")
    pass
 
  
  
  # title will be the name of the section.
  # tags is a tag to search for the relevant cache file (will use the first one found)
  # imagetags. if not none, will only pu a subset of images corresponding to the list provided. 
  # captions is the text to be written in the caption
  # configs : is not none, the part of the ini file corresponding to this config name will be written in the web page
  titles = [\
  	"Inspiral range plots",\
	"Variation in template bank and triggered template size",\
  	"First inspiral stage (using SIRE_FIRST*_ files)",\
  	"First coincidence stage (using COIRE_FIRST*_ and COIRE_SLIDE_FIRST*_ files)",\
	'Second inspiral stage (using SIRE_SECOND files)',\
	'Second thinca step (all ifo combination and category 2 COIRE_SECOND*_ files)'\
	]

  tags = [\
  	'*inspiralrange*',\
	'*plotnumtemplates*',\
	'*plotinspiral_FIRST_*',\
	'*plotthinca_FIRST_*',\
	'*plotinspiral_SECOND_*',\
	'*plotthinca_SECOND_*CAT_2*'\
	]

  imagetags=[\
	None,\
	None,\
	['snr_vs_time','snr_cum_hist','snr_histogram'],\
        ['dummy_on_purpose_so_that_no_images_is_passed_to_the_web_page'],\
	['snr_vs_time','snr_vs_chisq_log','snr_histogram'],\
	['plot_slide_trigs', 'cum_hist_effective_snr']\
	]

  captions = [\
  	""" "Inspiral Horizon distance for a \
       (1.4,1.4) solar mass system with SNR=8 (first sub-figure), and \
       histograms(second sub-figure). The last sub-figure shows the \
       expected horizon distance for any total mass, using an SNR=8."""  ,\
  	"Variation in template bank and triggered template bank size",\
        "Trigger rate at first inspiral stage",\
        "Trigger rate at first coincidence stage",\
	"Trigger rate at second inspiral stage",\
	'Trigger rate at second coincidence stage'\
	]

  comments = [\
  None,\
  None,\
  None,\
  "<span style=\"color:red\">This section has no images (on purpose)</span>. \
   To obtain the first thinca stage images, clik on the links in the caption here below",\
  None,\
  "This section shows the plotthinca results for the category 2 only.  "\
  ]

  configs = [	\
	None,\
	'tmpltbank',\
	'inspiral',\
	'thinca',\
	'veto-inspiral',\
	'thinca-2'\
	]

  for title, tag, caption,config,image_tag,comment in \
        zip(titles, tags, captions, configs, imagetags,comments):
      page = heading(page, title)
      try:
        if comment is not None:
          page.p(comment)
        page = add_config_section(page, config)
        page = fom(page, opts, cachefile_tag=tag, caption=caption,\
	 	image_tag=image_tag, directory=images_dir)
        page.div.close() # for each heading
      except:
        page.div.close() # for each heading
        pass
  return page


# ***************************************************************************
def write_summaryFiles(page, opts):
  """
  Creates a section to provide the relevant summary files such as COIRE_SUMMARY
  files

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  webdir = opts.webdir
  ini = opts.config_file
  directories = []
  if opts.playground:
    directories.append("playground")
  if opts.full_data or opts.full_data_slide:  
    directories.append("full_data")
  if opts.injection:
    injections = hipecp.items("injections")
    for this in injections: 
      directories.append(this[0])

  page.add("This section provides a list of COIRE and SIRE summary files.<br/>")

  for thisSearch in directories:
    page.add('<h1>' + thisSearch  +' section</h1>')
    page.add("Summary files are available in the search directory")
    page = add_href(page, href= webdir +thisSearch, name="here")

    path = opts.physdir + "/" + thisSearch
    mkdir(path)
    # link all the SUMMARY SIRE text files
    page = heading(page, "Final SIRE Summary files ")
    prefix = opts.datadir + thisSearch + '/'
    ifos = get_ifos()
    for ifo in ifos:
      if 'inj' in thisSearch:
        fname = ifo + '-SIRE_INJECTIONS*SUMMARY_FIRST_' + thisSearch.upper() \
            + opts.txt_suffix     
      else:
        fname = ifo + '-SIRE_SUMMARY_FIRST_' + thisSearch.upper() \
            + opts.txt_suffix     
      page.add( "<p>SIRE Summary file for "+ifo+".</p>")
      flist = glob.glob(prefix + fname)
      if len(flist) == 1: 
        file = open(flist[0], "r")
        text = file.read()
        file.close()
        page.add("<pre>"+fname+"<br/>"+text+"</pre>")
      else:
        page.add('<pre>Could not find '+fname+'</pre>')

    # copy all SUMMARY SIRE file 
    try:
      dest = path + "/sire"
      mkdir(dest)
      src = opts.datadir+thisSearch+'/'+"*SIRE*SUMMARY*xml* " 
      if opts.no_copy is False:
        command = 'cp ' +src +' ' + dest
        make_external_call(command, opts.debug, opts.debug, True)   
      page.add("All SIRE files are available in sire directory")
      page = add_href(page, href= webdir +thisSearch+"/sire", name="here")
    except: 
      page.add("<pre>Problem while copying the sire summary files.</pre>")
    page.div.close()

    # link and copy all the SUMMARY COIRE text files
    
    if 'inj' in thisSearch:
      page = heading(page, "Final COIRE Summary files ")
      for ifostring in get_ifo_coinc():
        if len(ifostring)>2:
          fnames = []
          inj_fname = ifostring +'-COIRE_INJECTIONS*SUMMARY_SECOND_' + \
              ifostring +'_'+thisSearch.upper()+'_CAT_2_VETO' +opts.txt_suffix
          fnames.append(inj_fname)
          for fname in fnames:
            page.add( "<p>COIRE Summary file "+ ifostring +".</p>")
            flist = glob.glob(prefix + fname)
            if len(flist) == 1: 
              file = open(flist[0], "r")
              text = file.read()
              file.close()
              page.add("<pre>" + fname + "<br/>" + text + "</pre>")
            else: 
              page.add('<pre>Could not find '+fname+'</pre>')
      try:
        dest = path + "/coire"
        mkdir(dest)
        src = opts.datadir+thisSearch+'/'+"*COIRE*SUMMARY*xml* "
        if opts.no_copy is False:
          command = 'cp ' +src +' ' + dest
          make_external_call(command, opts.debug, opts.debug, True)
        page.add("All COIRE files are available in coire directory")
        page = add_href(page, href= webdir +thisSearch+"/coire", name="here")
      except:
        page.add("<pre>Problem while copying the coire summary files.</pre>")
      page.div.close()

    if thisSearch == "full_data" or thisSearch == "playground":
      if thisSearch == "playground" or opts.full_data:
        page = heading(page, "Final COIRE zero lag files")
        for ifostring in get_ifo_coinc():
          if len(ifostring)>2:
            fnames = []
            fname = ifostring +'-COIRE_SUMMARY_SECOND_' + ifostring \
                + '_' + thisSearch.upper() + '_CAT_2_VETO' + opts.txt_suffix
            fnames.append(fname)
            for fname in fnames:
              page.add( "<p>COIRE Zero Lag Summary file "+ ifostring +".</p>")
              flist = glob.glob(prefix + fname)
              if len(flist) == 1:
                file = open(flist[0], "r")
                text = file.read()
                file.close()
                page.add("<pre>" + fname + "<br/>" + text + "</pre>")
              else:
                page.add('<pre>Could not find '+fname+'</pre>')
        try:
          dest = path + "/coire_zero_lag"
          mkdir(dest)
          src = opts.datadir+thisSearch+'/'+"*COIRE_SUMMARY*xml* "
          if opts.no_copy is False:
            command = 'cp ' +src +' ' + dest
            make_external_call(command, opts.debug, opts.debug, True)
          page.add("All COIRE zero lag files are available in coire directory")
          page = add_href(page, href= webdir +thisSearch+"/coire_zero_lag",\
	         name="here")
        except:
          page.add("<pre>Problem while copying the coire summary files.</pre>")
        page.div.close()

      if thisSearch == "playground" or opts.full_data_slide:
        page = heading(page, "Final COIRE slide files")
        for ifostring in get_ifo_coinc():
          if len(ifostring)>2:
            fnames = []
            slidefname = ifostring +'-COIRE_SLIDE_SUMMARY_SECOND_' + ifostring \
                + '_' + thisSearch.upper() + '_CAT_2_VETO' + opts.txt_suffix
            fnames.append(slidefname)
            for fname in fnames:
              page.add( "<p>COIRE Slide Summary file "+ ifostring +".</p>")
              flist = glob.glob(prefix + fname)
              if len(flist) == 1:
                file = open(flist[0], "r")
                text = file.read()
                file.close()
                page.add("<pre>" + fname + "<br/>" + text + "</pre>")
              else:
                page.add('<pre>Could not find '+fname+'</pre>')
        try:
          dest = path + "/coire_slide"
          mkdir(dest)
          src = opts.datadir+thisSearch+'/'+"*COIRE_SLIDE_SUMMARY*xml* "
          if opts.no_copy is False:
            command = 'cp ' +src +' ' + dest
            make_external_call(command, opts.debug, opts.debug, True)
          page.add("All COIRE slide files are available in coire directory")
          page = add_href(page, href= webdir +thisSearch+"/coire_slide",\
	         name="here")
        except:
          page.add("<pre>Problem while copying the coire summary files.</pre>")
	page.div.close()

  return page
 

# ***************************************************************************
def write_injection(page, opts):
  """
  Creates the injection section

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  webdir = opts.webdir
  ini = opts.config_file
  ifos = get_ifos()
  mkdir(opts.physdir+"/injections")

  page.add("This section summarizes the analysis of the injection runs.<br/>")


  
  #---------------------------- the injection section
  # title will be the name of the section.
  # tags is a tag to search for the relevant cache file (will use the first one found)
  # imagetags. if not none, will only pu a subset of images corresponding to the list provided. 
  # captions is the text to be written in the caption
  # configs : is not none, the part of the ini file corresponding to this config name will be written in the web page
  titles = [\
  	"Efficiency, Found and Missed plots (first stage)",\
  	"Closeby missed injections (Second coincidence stage and CAT2)",\
  	"Efficiencies (Second stage)",\
  	"Accuracies (First stage)",\
  	"Accuracies (Second stage)"\
	]
  tags = [\
  	'*plotinspmissed_FIRST*',\
  	'*plotinspmissed_SECOND*',\
  	'*plotinspmissed_SECOND*',\
  	'*plotinspinj_FIRST*',\
  	'*plotinspinj_SECOND*'\
	]
	#['map-8'],\  # this is not robust but works for GPS <900,000,000
  imagetags=[\
        ['dummy_on_purpose_so_that_no_images_is_passed_to_the_web_page'],\
	['map-8'],\
        ['efficiency-eff_dist'],\
        ['mchirp_vs_snr_accuracy_scatter_mtotal'],\
        ['mchirp_vs_snr_accuracy_scatter_mtotal']\
	]
  captions = [\
        "Found and Missed injections links (first stage)",\
	'Found and Missed injections. Effective distance versus total mass',\
	'Efficiencies (Second stage)',\
        'Accuracy plots (first stage)',\
        'Accuracy plots (second stage)'\
	]

  comments = [\
        "<span style=\"color:red\">This section has no images (on purpose)</span>. \
        To obtain the efficiency and found/missed plots at the first stage, clik on the links in the caption here below",\
        None, \
        None, \
        None, \
        None, \
        None, \
        ]

  configs = [\
        'plotinspmissed',\
        'plotinspmissed',\
	'plotinspmissed',\
	'plotinspinj',\
	'plotinspinj',\
	'plotinspinj'\
	]

  injections = hipecp.items("injections")
  images_dirs = []
  for this in injections:     
    images_dirs.append(this[0]+"_summary_plots")
  images_dirs.append("allinj_summary_plots")

  #if opts.no_copy is False:
  try:
    for dir in images_dirs:
      copy_plotinspmissed(dir)
  except:
    logText(logfile, "Problem while copying files", "error")
    pass

  for images_dir in images_dirs:
    if os.path.isdir(opts.datadir + images_dir) is True: 
      page.add("<h1>Summary of the "+images_dir+" directory</h1>")
      for title, tag, caption,config,image_tag,comment in\
          zip(titles, tags, captions, configs,imagetags,comments):
        page = heading(page, title)
        try:
          if comment is not None:
            page.p(comment)
          page = add_config_section(page, config)
          page = fom(page, opts, cachefile_tag=tag, caption=caption,\
	 	image_tag=image_tag, directory=images_dir)
          page.div.close() # for each heading 
        except: 
          page.div.close() # for each heading 
          pass


  return page


# ***************************************************************************
def write_about(page, opts):
  """
  Creates the section "About". 

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  webdir = opts.webdir
  
  page.p("This page was automatically generated with write_ihope_page using\
      the following ini file")
  tmp  = open(opts.config)
  tmp2 = tmp.read()
  tmp.close() 
  # the < character in a <pre> HTML tag is read and interpreted, So, we need to 
  # change it to &lt
  page.pre(tmp2.replace('<', '&lt;'))
  # page.pre(tmp.read())

  page.p("and the following command line arguments:")
  text=""
  for arg in sys.argv[:]:
    text = text +  arg +" "
  page.pre( text )
  
  page.p(__Id__[4:len(__Id__)-5])
  return page


# ***************************************************************************
def add_config_section(page, section):
  """
  Copy and paste a section of the ihope.ini into the HTML page within verbatim
  tags

  @param page: the HTML document page.
  @type page: markup.py document
  @param section: the name of the section to copy and paste
  @type section: string
  @return: an update of HTML document
  """
  # section may be empty or set to None
  try:
    ini  = hipecp.items(section)
  except:
    return page

  page.add("<pre>")
  page.add("------------------------------------" +section)
  for i in  ini :
    page.add(i[0]+' = '+i[1])
  page.add("</pre>")
  return page


# ***************************************************************************
def heading(page, title="None", label="Switch details on/off", heading="h3"):
  """
  Add a hx HTML section within the document with the ability to toggle it on/off
   
  @param page: the HTML document page.
  @type page: markup.py document
  @param title: the name of the section
  @type title: string
  @param label: the label to put on the toggle button 
  @type label: string
  @param heading: the HTML heading (h3 by default)
  @type heading: string
  @return: an update of HTML document
  """
  #increment block number
  global count_block
  global h2_num,h3_num
  global fig_num

  input=str(count_block)
  count_block=count_block+1

  fig_num = 1

  if heading == 'h2':
    section_num = str(h2_num)+"."
  elif heading == 'h3':
    section_num = str(h2_num)+"."+str(h3_num)+"."
  else:
    raise ValueError, "heading must be either h2 or h3 in heading function"


  page.add("<"+heading+">"+ section_num+ title)
  h3_num = h3_num + 1
  text = label 

  page.input(id="input_"+input, type="button", \
      onclick="toggleVisible('"+input+"')", value=text ,class_="toggle")
  page.add("</"+heading+">")
  page.div(id="div_"+input , style='display:none') 

  logText(logfile, '      Enters sub-section: '+title )

  return page 

# ***************************************************************************
def add_caption(page, caption):
  """
  Add a caption to the HTML document. Should be used with the figure only. 
  Take care of the figure numbering.

  @param page: the HTML document page.
  @type page: markup.py document
  @param caption: the name of the section to copy and paste
  @type caption: string
  @return: an update of HTML document
  """
  global fig_num
  page.p("<b>Figure "+str(fig_num) + ":</br> "+caption)
  fig_num = fig_num + 1

  return page


# ***************************************************************************
def add_figure(page,fnames="test", caption="add a caption", size=None, \
    alt="no figure found",source="not specified"):
  """
  Add a figure to the HTML document, taking care of the numbering.
 
  @param page: the HTML document page.
  @type page: markup.py document
  @param caption: the name of the section to copy and paste
  @type caption: string
  @param size: the size of the image ("full", "half", "third")
  @type size: string
  @param alt: an HTML alt 
  @type alt: a string
  @param source: the source of the figure
  @type source: string
  @return: an update of HTML document
  """
  global fig_num
  dir = opts.webdir
  page.add("<!-- insert a figure -->\n<div class=\"figure\">")
  this_count = 0
 
  # set the size of the images
  if size==None:
    if len(fnames)==1: 
      size="full"
    elif len(fnames)==2:
      size="half"
    else : size="third"

# Source is the thumnail, target is the full-resolution image. 

  for fnam in fnames:
    source=dir+"/"+fnam.strip()
    title  = ' title="%s" ' % alt[this_count].strip()
    title  = title.replace("_thumb","")
    target = source.replace("_thumb","")
    page.add("\t<a href=\"" + target+"\"" +  title + " rel=\"external\">\n" )
    try:
      thisalt = alt[this_count]
      thisalt.replace("\n","")
      page.img(class_=size ,src=source, alt=thisalt )
    except:
      page.img(class_=size ,src=source )
      
    page.add("</a>")
    this_count = this_count +1

  section_num = str(h2_num)+"."+str(h3_num-1)+"."+str(fig_num)
  page.add("\t<p><b>Figure " + section_num + "</b>:  " + caption + "</p>")
  fig_num +=1

  # add a yellow box (depends on yourcss style though) that contains the 
  # filename of the pictures.
  if fnames is not None:
    page.add("<pre>Source: "+dir+"\n" )
    for fnam in fnames:
      page.add(fnam.replace("\n",""))
    page.add("</pre>")

  page.div.close()

  #check that the file exsits. If not, returns an error message
  return page

# ***************************************************************************
def create_venn(data, tag):
  """
  Create a venn diagram for the 2 or 3 ifos case
  data has to be H1H2 H1 H2L1 H2 H1L1 L1 H1H2L1 array 

    >>> data = 
    >>> tag = 
    >>> create_venn(data, tag)

  @param data: an input dictionary
  @param data: numbers
  @param tag: 
  @type tag: string
  @return: a boolean. True is succesfule, False otherwise.
  """

  try:
    mscript = open("temp.m", "w")
    mscript.write("data = [")
    mscript.write( data +"];" ) 
    mscript.write(" vennX(data\'/3600/24,0.01);")
    mscript.write(" k=colormap(jet); k = [1 1 1; k];colormap(k);")
    mscript.write("saveas(gcf,\'venn_"+tag+".png\')")
    mscript.close()
    command=("matlab -nodisplay -nodesktop -nojvm -nosplash   < temp.m > /tmp/test ;  rm -f temp.m; mv venn_"+tag+".png "+opts.physdir+"/"+tag+"/")
    if not opts.debug:
      make_external_call(command, opts.debug, opts.debug, True)  
    return True 
  except:
    logText(logfile, """WARNING   The matlab command to create the venn diagram failed. 
                Check that matlab is properly set,and vennX.m is available
                (see matapps/src/searches/inspiral/matspiral/utilities")  
          """, "error")
    return False

# ***************************************************************************
def get_coincident_segments(tag):
  """
  @param tag: "playground" or "full_data" 
  @type tag: string
  return: a dictionary with the coincident time for each ifo combination
  """
  ifos = get_ifos()
  thisdata = {}
  thisdata['segments'] = ['duration(days)' ,'duration (s)']
  output={}
  ifo_coincs = get_ifo_coinc()  

  try:
    for coinc in ifo_coincs:
      if tag=="playground":
        command = "awk \'{sum=sum+$4} END {print sum}\' "\
          +opts.datadir+ tag +"/"+coinc+"_play_segs_analyzed.txt"
      elif tag=="full_data" or tag=="full_data_slide":
        command = "awk \'{sum=sum+$4} END {print sum}\' "\
          +opts.datadir+"full_data/"+coinc+"_segs_analyzed.txt"

      output[coinc], status = \
        make_external_call(command, False,opts.debug, True)

    logText(logfile, '...Get the analyzed segments duration...')
  except:
    logText(logfile , 'problem(s) while parsnig the coincident segments', \
      "error")

  return output

  


# ***************************************************************************
def get_segments_tag(tag):
  """
  reads segment files and return table of duration for each ifo
 
    >>> get_segments_tag("SELECTED_SEGS")

  @param tag: a tag to the segments
  @type tag: string
  return: 
  """
  # some variables
  datadir = opts.datadir
  ifos = get_ifos()
  thisdata = {}
  directory = datadir+'/segments/'
  thisdata['segments'] = ['filename', 'duration(days)' ,'duration (s)']

  # the name of the files (except for the ifo)
  this_tag  = '-' + tag + opts.txt_suffix
  if tag=="RDS_C03_L2":
    this_tag  = '_' + tag + opts.txt_suffix
  
  file = datadir +'/segments/' + ifos[1] + this_tag
  if not os.path.isfile(file):
    return thisdata

  #reading the segments files and extract the duration
  command = 'awk \'{print NF}\' ' +  file
  try:
    ncols, status = make_external_call(command, False, opts.debug, True)
    ncols = ncols[len(ncols)-2]
    # some files may be empty, so the first line (the comment 
    # which has 5 cols) will be read, which explain the >= and not strict ==. 
    if float(ncols)>=4:  
      for ifo in ifos:
        thisfile = ifo + this_tag
        command = 'awk \'{sum=sum+$4} END {print sum/3600/24}\' ' \
          +  directory + thisfile
        output_days, status = \
          make_external_call(command, False, opts.debug, True)

        command = 'awk \'{sum=sum+$4} END {print sum}\' ' \
          +  directory + thisfile
        output_seconds, status = \
          make_external_call(command, False, opts.debug, True)

        thisdata[ifo] = [thisfile, output_days, output_seconds]
    # unfortunately, right now, there is no standard, so some files have only 2 columns
    elif float(ncols)==2:
      for ifo in ifos:
        thisfile = ifo + this_tag
        command = 'awk \'{sum=sum+$2-$1} END {print sum/3600/24}\' ' \
          +  directory + thisfile
        output_days, status = \
          make_external_call(command,False,opts.debug, True)

        command = 'awk \'{sum=sum+$2-$1} END {print sum}\' ' \
          +  directory + thisfile
        output_seconds, status = \
          make_external_call(command, False, opts.debug, True)

        thisdata[ifo] = [thisfile, output_days, output_seconds]
  except:
    logText(logfile,  'Error while parsing the segment duration files', "error")

  return thisdata


# ***************************************************************************
def get_ifo_coinc():
  """
  return: list of valid coincidences with respect to the ini file

  """
  # get the ifo requested
  ifos = get_ifos()
  # get number of ifos to look at
  numifos = []  
  for option in ["one-ifo","two-ifo","three-ifo","four-ifo", "five-ifo"]:
    if hipecp.has_option("ifo-details",option): 
	tmp = option.split("-")
 	numifos.append(tmp[0])
  # now let us fill the different possible ifo combinations
  output = []
  for num in numifos:
    if num=="one":
      for ifo in ifos:
        output.append(ifo)
    elif num=="two":
      for ifo1 in ifos:
        for ifo2 in ifos:
          if ifo1 < ifo2:
            output.append(ifo1+ifo2)
    elif num=="three":
      for ifo1 in ifos:
        for ifo2 in ifos:
          for ifo3 in ifos:
            if ifo1 < ifo2 and ifo2 < ifo3:
              output.append(ifo1+ifo2+ifo3)
    elif num=="four":
      for ifo1 in ifos:
        for ifo2 in ifos:
          for ifo3 in ifos:
            for ifo4 in ifos:
              if ifo1 < ifo2 and ifo2 < ifo3 and ifo3 < ifo4:
                output.append(ifo1+ifo2+ifo3+ifo4)
  return output


  


# ***************************************************************************
def get_ifos():
  """
  read the ifos used in the ifo-details section of the ihope ini file
  return: list of ifos
  """
  ifos=[] 
  for option in ["g1-data","h1-data","h2-data","l1-data", "v1-data"]:
    if hipecp.has_option("ifo-details",option): ifos.append(option[0:2].upper() )

  return ifos


# ***************************************************************************
# ***************************************************************************
def get_version(executable): 
  """
  Search for the tag and version of an executable using the --version argument.

  @param executable: the name of an executable
  @type executable: string
  return: the tag name if any and the version of the executable
  """
  output=[]
  try:
    # this is surely useless now to make a distinction with trigbank 
    if executable=="trigbank":
      pathname = hipecp.get("condor", "trigbank") 
    else:
      pathname = hipecp.get("condor", executable) 
    s =  os.path.split(pathname)
    if len(s[0])==0:
      cmd = opts.ihope_directory + "/" + opts.gps_start_time + "-" + \
      opts.gps_end_time + "/executables/" + s[1] + " --version"
    else:
      cmd = s[1] + " --version "
    output,status = make_external_call(cmd, opts.debug, opts.debug, True)
  except:  
    output= '(not found)' 
    pass

  output = output.split()
  
  #searching for the tagname, which may be empty(undefined)
  try:
    index=  output.index("Tag:")
    tagname = output[index+2]
    # found the "Tag" string. Is it different from $ ?
    if tagname=="$":
      tagname = ' Undefined tag name.'
    else:
      tagname = ', tag name is '+tagname+'. '
  except:
    tagname = ' Cannot find the tag name'


  #searching for the version, which may be empty(undefined)
  try:
    index=  output.index("Version:")
    version = output[index+3]
    version = 'Version is '+ version +'.'
  except:
    version = '. Undefined version.'

  return tagname+' '+version

# ***************************************************************************
def copy_segments():
  """
  This function copies the segments list into the web page directory 
  """

  msg =   "Copying segments into the web page directory (in yoururl/segments)"
  logText(logfile, msg)
  # first we create this directory      
  mkdir(opts.physdir+'/segments')
  mkdir(opts.physdir+'/catlists')
  # parsing the ini file, find the cat file and thenread the ./segments directory
  try:
    location = opts.physdir + '/segments/'
    if opts.no_copy is False:
      command = 'cp '+opts.datadir +'/segments/* ' + location
      dummy,status = make_external_call(command, opts.debug, opts.debug, True)
      command = 'cp '+opts.datadir +'/segments/*cat?.txt ' + opts.physdir + '/catlists/' 
      dummy,status = make_external_call(command, opts.debug, opts.debug, True)
  except:
    logText(logfile, "Could not copy the segment files", "error")
    pass

 #  the selected segment files
  for thisSearch in ['playground', 'full_data']:
    mkdir(opts.physdir+thisSearch)
    try :
      stdout ='Copying the selected segments files into /'+thisSearch
      for this in get_ifo_coinc():
          if thisSearch=='playground':
            seg = '/'+thisSearch+'/'+this +'_play_segs_analyzed.txt'
          elif thisSearch=='full_data':
            seg = '/'+thisSearch+'/'+this +'_segs_analyzed.txt'

          if opts.no_copy is False:
            dest = opts.physdir + thisSearch + '/segments'
            mkdir(dest)
            command = 'cp '+opts.datadir + seg + ' ' + dest
            dummy,status = \
                make_external_call(command, opts.debug, opts.debug, True)

          if status>0:
            stdout += " WARNING: could not copy a selected segment file "
            stdout += "from " + thisSearch + " for " + this + "ifo combination"
    except:
      stdout +=" WARNING: problem while copying a selected segment"
      stdout += "(from " + thisSearch + "). passing..."    
      logText(logfile,  stdout, "warning")
      pass
    else: 
      logText(logfile,  stdout)

def copy_plotinspmissed(dir):
  # currently, there is a bug in plotinspmissed : it does not 
  # save the followup png files within the cachefile. So, we have 
  # to get all the plotinspmissed png files related to the 
  # followup, which can be found in the ./Images directory, and copy them.
  command = 'find ' + opts.datadir + '/' + dir + '/Images'  \
      + ' -name \"*plotinspmissed*\" -exec cp \"{}\" '\
      + opts.physdir + '/Images/' + ' \;'     
  print >> sys.stdout, ' .../ copying all plotinspmissed files from ' +dir
  make_external_call(command, opts.debug, opts.debug, True)

  command = 'find ' + opts.datadir + '/' + dir   \
      + ' -name \"*plotinspmissed*html\" -exec cp \"{}\" '\
      + opts.physdir + ' \;'     
  make_external_call(command, opts.debug, opts.debug, True)

# ***************************************************************************
def fom(page, opts, cachefile_tag=None, caption="fix me",\
	 image_tag=None,directory="playground_summary_plots"):
  """
  This function reads a cachefile, copy the files to the relevant directory, and  update the HTML document to add figures and pertinent sections. 

  
  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @param cachefile_tag: the pattern of the cachefile to look at
  @type cachefile_tag: string
  @param caption: a list of caption
  @type caption: list of string 
  @param image_tag: a list of tag (including *) to select files within a
  @param directory:  the directory to look at
  @type directory: string
  cachefile
  """

  dir = opts.datadir+directory+'/'

  # create the div that will contain the figure 
  page.div(class_="figure")

  # create a list of cachefiles, each of which containing
  # the cachefile_tag argument in its name
  thisglob = dir + cachefile_tag +'cache'
  cachefileList =  glob.glob(thisglob)
  
  if opts.verbose is True: 
    print "        Searching for files with this(ese) tag(s): " +str(image_tag)

  # for each cachefile we create a div figure section with all 
  # figures whose name is part of the image_tag list
  for eachcache in cachefileList:
    # read this cachefile
    this = open(eachcache, "r")
    fnameList = []
    #for each file contained in the cachefile
    if opts.debug is True :
      print >>sys.stdout, "        --> Copying files from " +eachcache

    for filename in this:
      # if the file is an image, we copy it in ./Images
      # if the file is an image, we copy the file. Then, if the pattern 
      # (in image_tag)  matches the filename, then we create am html section.
      if filename.find('png')>=0:
        # we copy the file 
        if opts.no_copy is False:
          command = 'cp ' + dir + filename+' ' +opts.physdir +'/Images/'       
          make_external_call(command.replace("\n", " "), opts.debug, opts.debug, True)
          command = 'cp ' + dir + filename.replace(".png","_thumb.png")\
              +  ' ' +opts.physdir  + '/Images/' 
          make_external_call(command.replace("\n", " "), opts.debug, opts.debug, True)

        # second, we check if the pattern match the file
        if image_tag is not None:
          for eachPattern  in image_tag:
            if patternFoundInFilename(filename, eachPattern) is True:
              fnameList.append(filename.replace(".png", "_thumb.png"))
        else:
          fnameList.append(filename.replace(".png", "_thumb.png"))
        
      
    # finally, we copy the html files (all of them) 
    this.close()
    this = open(eachcache, "r")
    for filename in this:
      if filename.find('html')>=0:
        if opts.no_copy is False:
          command = 'cp ' + dir + filename+' ' +opts.physdir        
          make_external_call(command.replace("\n", " "), opts.debug, opts.debug, True)

    # iand create the appropriate html section 
    this.close()
    this = open(eachcache, "r")
    for filename in this:
      if filename.find('html')>=0:
        href=filename.replace("/pictures", "")
        href=href.replace("\n", "")
        msg =" <a href=\"" + href + "\""
        msg+=" rel=\"external\" >"
        msg += """ <br/> --- <b>Click here (to open link in a new tab/window)</b> to get all pictures (full resolution) 
            as well as the pylal arguments used to generate the plots</a> """
        
        source =  eachcache.split('/') 
        source =  source[len(source)-1]
        page = add_figure(page, fnames=fnameList, \
          caption=(caption+' '+msg), source=source,size=None, alt=fnameList)
        break
     # close the cachefile
    this.close()
  
  page.div.close()

  return page
# ***************************************************************************
# ***************************************************************************
def set_style():
  """
  Function to copy the style file as read from the write_ihope_page.ini file
  """

  tmp = []
  tmp.append(configcp.get("main", "style"))
  try:
    style = configcp.get("main","style")
    command = 'cp ' + style + " " +opts.physdir
    make_external_call(command, opts.debug, opts.debug, True )
    tmp=style.split('/')
    return tmp[len(tmp)-1]
    
  except:
    print sys.stderr()<< 'could not copy the style file'
    pass
    return ""

# ----------------------------------------------------------------------------
def parse_arguments():
  """
  Function to parse the arguments and check their validity.
  """
  usage =  """ %prog [options]
  Program to write webpage from upperlimit.py
  """

  parser = OptionParser( usage = usage, version = "%prog CVS "+__Id__ )

  parser.add_option("-C","--config-file",action="store",type="string",\
      metavar=" INI File",\
      help="""ini file with information about run directories. The ini file should look like
-------                        
[main].............................................
gps-start-time  = 847555570........................
gps-end-time    = 849974770........................
title           = \"Low mass CBC analysis\"........
ihope-ini-file  = ihope.ini........................
ihope-directory = /archive/home/cokelaer/S5/Month1/full_analysis/....
home-directory  = /archive/home/...................
url             = ldas-jobs.ligo.caltech.edu.......
username        = cokelaer.........................
style           = /archive/home/cokelaer/style.css.
output          = index.shtml""")
  parser.add_option("-A","--open-the-box",action="store_true",\
      default=False,dest="full_data", metavar="DOANALYSIS",\
      help="" )
  parser.add_option("-T","--skip-tuning",action="store_false",\
      default=True,dest="tuning", metavar="DOTUNING",\
      help="" )
  parser.add_option("-U","--skip-upperlimit",action="store_false",\
      default=True,dest="upperlimit", metavar="DOUPPERLIMIT",\
      help="" )
  parser.add_option("-I","--skip-injection",action="store_false",\
      default=True,dest="injection", metavar="DOUPPERLIMIT",\
      help="" )
  parser.add_option("-P","--skip-playground",action="store_false",\
      default=True,dest="playground", metavar="DOPLAYGROUND",\
      help="" )
  parser.add_option("-B","--skip-full-data-slide",action="store_false",\
      default=True,dest="full_data_slide", metavar="DOPLAYGROUND",\
      help="" )
  parser.add_option("-N","--no-copy",action="store_true",\
       default=False,dest="no_copy",metavar="NOCOPY",\
       help="do not copy any file (useful for debugging only) ")
  parser.add_option("-D","--debug",action="store_true",\
       default=False,dest="debug",metavar="DODEBUG",\
       help="More verbose than --verbose ")
  parser.add_option("-V","--verbose",action="store_true",\
      default=False, dest="verbose",metavar="VERBOSE",\
      help="talkative script! One can also add the debug option." )

  (opts,args) = parser.parse_args()

  if opts.config_file is None:
    raise ValueError

  return opts,args

# ----------------------------------------------------------------------------

#try:
#  from glue import markup
#  from markup import oneliner as e
#except: 
#  raise ImportError("Require markup.py to generate the html page")
#
opts,args = parse_arguments()
#############################################################################
#  MAIN PART                                                                #
#############################################################################
fig_num = 1
count_block = 0  # counter for the unique id of the toggle boxes
h2_num = 0       # counter for the section h2
h3_num = 1       # counter for the section h3
config   =  opts.config_file
opts.config = config # save the name of the ini file, why ?
configcp = ConfigParser.ConfigParser()
configcp.read(config)
maxdiv = 200
print >>sys.stdout, "|------------------- Initialisation"
# First, we open an xml file, for the log file
logfile_name = __name__+".xml"
print >>sys.stdout,"Openning the log file (" +logfile_name+")."
logfile = open(logfile_name, "w")
logfile.write("""<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet type="text/xsl" href="write_ihope_page.xsl"?>
<log>""")


#---------------------------------------
# then, we parse the write_ihope_page.ini file
print >>sys.stdout,"Parsing the ini file: " + opts.config
try:
  opts.config_file 	= configcp.get("main", "ihope-ini-file")
  opts.gps_start_time 	= configcp.get("main", "gps-start-time")
  opts.gps_end_time 	= configcp.get("main", "gps-end-time")
  opts.ihope_directory 	= configcp.get("main", "ihope-directory")
  opts.title	 	= configcp.get("main", "title")
  opts.url	 	= configcp.get("main", "url")
  opts.output	 	= configcp.get("main", "output")
  opts.html_directory 	= configcp.get("main", "html-directory")
except:
  print >> sys.stderr, "ERROR::The ini file does not have the proper field in the [main] section" 
  print >> sys.stderr, """       Consider adding one of those fields if missing: ihope-ini-file, \
	gps-start-time,gps-end-time, ihope-directory, title,url, username, output"""
  raise
  
#------------------------------------
#sub-products of the ini file parsing
opts.gpsdir =  '/'+str(opts.gps_start_time)+'-'+str(opts.gps_end_time)+'/'   # note the / at the end
opts.duration = str(int(opts.gps_end_time) - int(opts.gps_start_time))
opts.webdir = opts.url + opts.gpsdir
opts.datadir = opts.ihope_directory + opts.gpsdir 
opts.physdir = opts.html_directory + opts.gpsdir
opts.txt_suffix = '-'+opts.gps_start_time+'-'+opts.duration+'.txt'


#----------------------
# openning the html file
print >>sys.stdout,"Openning the HTML (" + opts.output+")"
try:
  html_file = file(opts.output,"w")
except:
  msg = "Cannot open %" % opts.output
  print >>sys.stderr, msg
  raise


#-----------------------------------------
# here is the directory we want to extract information from
msg = "Entering this directory (where we will get all the relevant information)" + opts.datadir
print >> sys.stdout, msg
if not  os.path.isdir(opts.datadir):
  raise  "%s is not a valid directory. Check your gps time." % opts.datadir
# which physical name is 
msg = "We will copy all images and HTML documents into this directory " +opts.physdir
logText(logfile, msg,"done")
# Make the physdir and all necessary directories above it
os.makedirs(opts.physdir)
mkdir(opts.physdir+'/Images')

# get the style file and copy it (must happen after the html directories have been created)
opts.style = set_style()


#-----------------------------------------
# now we can parse the ihope.ini file itself
msg =   "Parsing the ihope ini file (" + opts.config_file+")"
logText(logfile, msg)
hipe   = opts.ihope_directory+'/'+opts.config_file
hipecp = ConfigParser.ConfigParser()
hipecp.read(hipe)
make_external_call( 'cp '+opts.config_file + ' ' + opts.physdir, False, opts.debug, True)

#-----------------------------------------
# now we copy the segments to the web directory and other relevant information
copy_segments()


#-----------------------------------------
###### create the section labels  
html_sections={}

# the string "full_data" is hardcoded somewhere else, so it must remain as it is
html_order = ['toc', 'general', 'summary', 'playground', 'full_data_slide', 'injection', \
    'tuning', 'full_data', 'upperlimit', 'summary files', 'logfile', \
    'about']

html_sections['toc'] = "Table of Contents"
html_sections['general'] = "General Information"
html_sections['summary'] = "Data Information"
if opts.playground is True: html_sections['playground']	= "Playground"
if opts.full_data_slide is True: html_sections['full_data_slide']	= "Full Data Slide And Playground Zero lag"
if opts.injection is True: html_sections['injection'] = "Injection"
if opts.tuning is True: html_sections['tuning']	= "Tuning"
if opts.full_data is True: html_sections['full_data'] = "Full Data"
if opts.upperlimit is True: html_sections['upperlimit']	= "Upper Limit"
html_sections['summary files'] = "Summary files"
html_sections['logfile'] = "Log File"
html_sections['about'] = "About"


title = opts.title+ ": from "+str(opts.gps_start_time)\
  +" to "+str(opts.gps_end_time) 
script = {}
script['toggle.js'] = 'javascript'
create_toggle()
# Finally, we create the html document 
msg =   "Creating HTML document"
logText(logfile, msg)
# -------------------------------------------- the html output page
page = markup.page(mode="strict_html")
page._escape = False
doctype="""<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">"""
doctype+="""\n<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">"""

page.init(title=title, css=opts.style, script=script , doctype=doctype)

page.h1(opts.title +" (" + opts.gps_start_time +"-" +opts.gps_end_time+")")
page.add("<p>")
page.input(type="button", value="Wait until the page is fully loaded before navigate (javascript in use !)")
page.add("</p>")

# The main part of the code, which loops over all subsections
for each_section in html_order:
  if each_section in html_sections:
    print "...Processing " + each_section
    page.p(e.br())
    page.add("<!-- beginning of a sub section -->")
    page.div(class_="encadre")
    page.div(class_="contenu")    

    id = each_section.replace(" ","_")

    if each_section=='toc':
      page.input(type="button", onclick="expandall("+str(maxdiv)+")",\
        value="expand all figures and sections" )
      page.input(type="button" ,onclick="clearall("+str(maxdiv)+")", \
        value="clear all (come back to the original page)" )
      page = write_title(page,  html_sections[each_section],id,checked=True)
      page.div(id="div_"+id, style='display:block')
    else:
      page = write_title(page,  html_sections[each_section],id)
      page.div(id="div_"+id, style='display:none')

    try:
      logText(logfile, html_sections[each_section], "section")
      h3_num = 1
      page = write_results(page, opts, each_section)
    except:
      logText(logfile, each_section, "section")
      msg = "Error while processing this section. "\
          + "skipped  "+each_section + " section"
      page.add(msg)
      logText(logfile, msg, "warning")
      print >>sys.stdout, msg
      pass
    page.div.close()
    page.add("<!-- close div display-->")
    page.div.close()
    page.add("<!-- close div contenu-->")
    page.div.close() 
    page.add("<!-- close div encadre-->")

# end of the different sections
# the valid HTML and CSS footer
page.add("<table><tr><td>")
page.add("<a href=\"http://validator.w3.org/check?uri=referer\">")
page.add("<img src=\"http://validator.w3.org/images/valid_icons/valid-xhtml10\" alt=\"Valid XHTML 1.0!\" height=\"31\" width=\"88\"/></a> ")
page.add("<a href=\"http://jigsaw.w3.org/css-validator/\">")
page.add("<img src=\"http://www.w3.org/Icons/valid-css\" alt=\"Valid CSS!\" height=\"31\" width=\"88\" /></a> ")
page.add("</td></tr></table>")

# what is the False for ? I cannot remenber
html_file.write(page(False))
html_file.close()
# just remove the <html lang="en"> line tat is not a strict HTML code
cmd = 'sed -e \'s/<html lang=\"en\">//\' '+ opts.output + '>/tmp/tmp.html'
output,status = make_external_call(cmd, True, True, False)
if status==0:
  cmd = 'mv /tmp/tmp.html '+opts.output
  make_external_call(cmd, True, True, True)
# that's it for the html creation. let us copy it to the requested directory  

print '---------------------FINISHED ---------------------'
print '--- HTML file created. '
print '--- Copying html documents in ' +opts.physdir
make_external_call('mv  '+opts.output +' ' + opts.physdir, opts.debug, opts.debug, True)
make_external_call( 'mv toggle.js '+ opts.physdir, opts.debug, opts.debug,  True)

#let us close the log file
logfile.write("</log>")
logfile.close()
logfile = __name__+".xml"
output, status = make_external_call( 'grep WARNING '+ logfile +'| wc - | awk \'{print $1}\' - ', opts.debug, opts.debug, True)

if status==0:
  if int(output)==0:
    print 'No warnings'
  else:
    print '\n\n\nThere are warnings : '+str(int(output))+' . Check the log file '+logfile
  
  output, status = make_external_call('mv '+logfile + " "+opts.physdir, True,True,True) 
else:
  print 'Could not find the log file ' +logfile
  
 
#Finally create the xsl for the log xml file
logfile = open(__name__+".xsl", "w")
logfile.write("""<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<xsl:template match="/">
  <html>
  <body>
  <center><h1>Log file summary </h1></center>
  <xsl:apply-templates/>
  </body>
  </html>
</xsl:template>

<xsl:template match="section">
<h2 color="blue">Section: <xsl:value-of select="."/></h2>
<br />
</xsl:template>

<xsl:template match="done">
<center>
  <div>
    <table bgcolor="green" border="2" width="80%">
      <tr>
        <td width="80%"><xsl:value-of select="."/></td>
        <td bgcolor="white"> passed</td>
      </tr>
    </table>
  </div>
</center>
</xsl:template>
<xsl:template match="warning">
<center>
  <div>
    <table bgcolor="orange" border="2" width="80%">
      <tr>
        <td width="80%"><xsl:value-of select="."/></td>
        <td bgcolor="white"> fix me</td>
      </tr>
    </table>
  </div>
</center>
</xsl:template>
<xsl:template match="error">
<center>
  <div>
    <table bgcolor="red" border="2" width="80%">
      <tr>
        <td width="80%"><xsl:value-of select="."/></td>
        <td bgcolor="white"> skipped</td>
      </tr>
    </table>
  </div>
</center>
</xsl:template>



</xsl:stylesheet>
""")

logfile.close()
output, status = make_external_call('mv '+__name__+".xsl" + " "+opts.physdir, True,True,True) 


