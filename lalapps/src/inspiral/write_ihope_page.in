#!/usr/bin/python

# $Id$
"""
Tools to create a HTML document that summarizes results produced by ihope. 
"""
__author__ = "Thomas Cokelaer <thomas.cokelaer@astro.cf.ac.uk>"
__version__ = "$Revision$"
__date__ = "$Date$"
__Id__ = "$Id$"
__name__ = "write_ihope_page"

import sys
import copy
import os
import re
from optparse import *
import glob
from glue  import markup
from glue.markup import oneliner as e
import ConfigParser
sys.path.append('@PYTHONLIBDIR@')


# ***************************************************************************
def functionId(nFramesUp):
  """ 
  Create a string naming the function n frames up on the stack.
  
  @param nFramesUp: input
  @type nFramesUp: number
  @return: message
  """
  try:
    co = sys._getframe(nFramesUp+1).f_code
    msg = "%s (%s @ %d)" % (co.co_name, co.co_filename, co.co_firstlineno)
    if msg.startswith("?") is False:
      print "-->ERROR in function: " + msg
  except:
    msg=[]

  return msg

# ***************************************************************************
def logText(logfile, text, tag="done"):
  """
  Utility to populate a logfile in HTML format. 
  The third argument is a string. Depending on its value, the text will have 
  different color. 
  
  @param text: a text to be printed
  @type text: string
  @type tag: string 
  @param tag: is in {"done","warning","error"} 
  """ 

  if tag=="warning":
    msg= "<"+tag+">"+text+"</"+tag+">\n"
    logfile.write(msg)
    if opts.verbose is True:
      print >>sys.stdout,text
  elif tag=="error":
    msg = "<"+tag+">"+text
    logfile.write(text)
    i =1 
    while len(msg)>0:
      msg = functionId(i)
      if msg.startswith("?") is False:
        logfile.write("\n"+msg)
      else :
        logfile.write("</"+tag+">\n")
        msg=[]
      i=i+1
    print >>sys.stderr, msg
    exit(1)
  else :
    msg = "<"+tag+">"+text+"</"+tag+">\n"
    logfile.write( msg )
    if opts.verbose is True:
      print >>sys.stdout,text

# ***************************************************************************
def patternFoundInFilename(filename, pattern):
  """
   a small function to check that a pattern is contained within a filename.

     >>> filename = "H1H2L1-plotinspmissed_totalMass_versus_eta.png"
     >>> pattern = "plotinspmissed*eta"
     >>> patternfoundInFilename(filename, pattern)

   @param filename: the filename to look at
   @type filename: string
   @param pattern: a pattern which may contain several '*'
   @type pattern: string
   @return: boolean
  """
  tokeep = False
  if pattern is None : return tokeep
  
  # you may have * inside a pattern
  for word in pattern.split('*'):
    if word in filename:
      tokeep = True
    else:
      tokeep = False
      # if one word is not found within filename, we must break and se
      break

  return tokeep

# ***************************************************************************
def make_external_call(\
  command, show_stdout=False, \
  show_command=False, show_error=True):
  """
  Run a command line argument and print informative messages on failure.
  It returns two outputs: the stdout of the command, and its status.  

    >>> make_external_call('cp * /tmp', False, False, True)

  @param command: the command to try
  @type command: string
  @param show_stdout: show the stdout 
  @type show_stdout: boolean
  @param show_command: show the command
  @type show_command: boolean
  @param show_error: show the error if any
  @type show_error: boolean
  @return: the stdout and a status  


  """
  if show_command and opts.verbose is True: 
    print "--- Trying this command :" + command

  stdin, out, err = os.popen3(command)
  pid, status = os.wait()
  this_output = out.read()
  if show_error & status != 0:
    print >>sys.stderr, "External call failed."
    print >>sys.stderr, "  status: %d" % status
    print >>sys.stderr, "  stdout: %s" % this_output
    print >>sys.stderr, "  stderr: %s" % err.read()
    print >>sys.stderr, "  command: %s" % command
    sys.exit(status)
  if show_stdout:
    if this_output[0:1]=='\n': 
      print  this_output[1:]  #first character is \n
    else:
      print this_output

  stdin.close()
  out.close()
  err.close()  
  return this_output, status

# ***************************************************************************
def mkdir( newdir ):
  """
  Create a directory

  @param newdir : name of directory to be created
  @type newdir: string
  """
  if os.path.isdir(newdir): 
    print >>sys.stdout, "WARNING: this directory already exists (" + newdir +")."
    pass
  elif os.path.isfile(newdir):
    raise OSError("a file with the same name as the desired " \
                  "dir, '%s', already exists." % newdir)
  else: 
    os.mkdir(newdir)


# ***************************************************************************
def create_toggle():
  """
  This function is just an alias to create a javascript for the toggle on/off. 

  @return: nothing
  """
  fname = open("toggle.js", "w")
  fname.write("function toggleVisible(division) {\n"+\
    "  if (document.getElementById(\"div_\" + division).style.display =="\
   + " \"none\") {\n document.getElementById(\"div_\" + division).style.display"\
   + " = \"block\";\n document.getElementById(\"input_\" + division).checked "\
   + " = true;\n } else {\n document.getElementById(\"div_\" + "\
   + " division).style.display = \"none\";\n document.getElementById("\
   + "\"input_\" + division).checked = false;\n  }\n  }\n" )
  fname.close()

# ***************************************************************************
def write_results(page, opts, section):
  """
  This function is just a switch to the function that create each section of
  the HTML document. 
   
    >>> write_results(page, opts, "injection")

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @param section: the current section to switch to 
  @type section: string
  @return: an update of HTML document
  """

  if opts.verbose is True:
    print >>sys.stdout,"--------------------- Creating section "+section

  if section=='general':
    page = write_general(page, opts)
  elif section=='toc': 
    page = write_toc(page, opts)
  elif section=='summary':
    page = write_summary(page, opts)
  elif section=='playground': 	
    page = write_analysis(page, opts,thisSearch='playground')
  elif section=='tuning': 
    page = write_tuning(page, opts)
  elif section=='injection':
    page = write_injection(page, opts)
  elif section=='full_data':
    page=write_analysis(page,opts,thisSearch='full_data')
  elif section=='upperlimit': 	
    page = write_upperlimit(page, opts)
  elif section=='summary files': 
    page = write_summaryFiles(page, opts)
  elif section=='logfile':
    page = write_logfile(page, opts)
  elif section=='about': 
    page = write_about(page, opts)
  else:
    msg = "this section ("+ section +") doest not exist. "
    logText(logfile, msg, "error")

  return page


# ***************************************************************************
def write_logfile(page , opts):
  """
  This function creates an entry with the logfile information.
  
  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  # get the directory of the url
  dir = opts.webdir +'/'
  page.a("logfile", href=dir +  __name__+'.xml')
  return page

# ***************************************************************************
def write_toc(page , opts):
  """ 
  This function creates the table of contents, using the html_sections 
  variable defined in the main part of this program.

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  # get the directory of the url
  dir = opts.webdir +'/'

  # and the section names
  items = html_sections 
  order = html_order 
  # create a frame for the toc, and add contents 
  page.ol()
  for this_item in order:
    try:
      page.li(e.a(items[this_item], href=dir + opts.output + '#' \
         + this_item.replace(" ","_")))
      msg = "added "+this_item
      logText(logfile, msg, "done")
    except:
      msg = 'skip '+this_item
      logText(logfile, msg, "warning")
#      pass

  page.ol.close()

  return page

# ***************************************************************************
def write_general(page,opts):
  """
  Creates the general section. 

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  webdir = opts.webdir
  ini = opts.config_file
    
  text=  'This page summarizes the analysis of the data segment from GPS time %s up to %s' % (opts.gps_start_time,  opts.gps_end_time)
  page.add(text)

  # The search parameters
  if opts.verbose is True: 
    print "Extracting the version and tag of the executables..." 
  try:
    # todo : get the list of executables  from the ini file
    executables = ("inspiral", "tmpltbank", "sire",\
                   "thinca", "trigbank", "coire" , "inspinj")
    page.h3("The search used the following resources:")
    
    page.ol() #starts enumerate
    page.add("<li> LAL/LALApps "+get_version("inspiral")) #first section
    page.ul()
    for exe in executables:
      text = "<b>lalapps_"+exe+ "</b>    "+get_version(exe)
      page.li(text)   
    page.ul.close()
    page.li.close()

    page.add("<li>Segment information (see the Data Information section for more details):") #section section
    page.ul()
    for this in get_ifos():
        seg = this +'-SELECTED_SEGS'+opts.txt_suffix
        this_ref = webdir + '/segments/'+seg
        page.li(e.a(seg,href=this_ref) )
    page.ul.close()
    page.li.close()


    # let us give the ihope.ini and log file. We need to copy some files to the webdir
    cmd = 'cp '+opts.datadir + '/ihope.pipeline.log  '+opts.physdir
    make_external_call(cmd, opts.debug, opts.debug, False)
    text = ("The configuration is contained in the file <a href=\"" + \
        webdir + "/" + ini + "\">" + ini + "</a>")
    text += ("which was used by lalapps_ihope as reported in the  <a href=\"" + \
        webdir + "/" + "ihope.pipeline.log" + "\"> [ihope.pipeline.log]</a> file.")
    page.li(text) #third section
    text = "A list of category files stored in this directory ("  \
   	+ "<a href=\""+ webdir + "/catlists/\"> catlists</a>"  +\
  	"), and listed in the ini file."

    page.li(text) # fourth section
    page.ol.close()
  except:
    logText(logfile, """Problem with the executable: cannot find them ? """, "warning")
    pass
  else:
    logText(logfile,  "...Get the executables version...")


  # The ifo requested
  page = heading(page, "This search concerned the following combinaison of ifos")
  page = add_config_section(page, "ifo-details")
  page.div.close()

  return page


# ***************************************************************************
def write_title(page, text, tag):
  """
  create a title (h2 tag) with a toggle on/off and a link to the TOC.

    >>> write_title(page, "my beautiful title", "whatever_but_unique_tag")

  @param page: the HTML document page.
  @type page: markup.py document
  @param text: the title
  @type text: string
  @param tag: a tag to include within the link/name 
  @type tag: string
  @return: an update of HTML document
  """
  page.h2()
  page.add("<a name=\""+tag+"\">")
  input = "input_"+tag
  page.input(id=input, type="checkbox", checked="checked", onclick="toggleVisible('"+tag+"')")
  page.add(text)
  page.add("</a>")
  page.h2.close() 
  page.div(e.a("return to top", href="#toc" ), class_="back")
  
  return page


# ***************************************************************************
def write_summary(page,opts):
  """
  Creates the summary section.

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  # first, get some information 
  webdir = opts.webdir
  datadir = opts.datadir
  ini = opts.config_file
  ifos = get_ifos()


  # title with a div to toggle on/off the content 
#  page = write_title(page, html_sections['summary'], "verlaine")
  
#  page.div(id="div_verlaine", style='display:none') 
  page = heading(page, "Selected segments", "Switch details on/off")  
  page.p("""The segments files provided in the general section were created with no data quality flags 
set. The times analyzed according to ihope/hipe are provided here below""")
  page.p(e.br())
  page.table()
  segs = get_segments_tag("SELECTED_SEGS")
  keys = ("segments","H1","H2","L1","G1","V1","T1") 
  for key in keys:
    if segs.has_key(key):
      page.tr()
      page.td(key)
      page.td(segs[key])
      page.tr.close()
  page.table.close()
  page.div.close() #(3)
  

  # for each category, we loop over each ifo and create a table
  # with the time analysed.
  i=0
  for cat in ("CATEGORY_1_VETO_SEGS","CATEGORY_2_VETO_SEGS",\
      "CATEGORY_3_VETO_SEGS","CATEGORY_4_VETO_SEGS"):
    i=i+1
    try:
      msg = "Category " +str(i) + " veto segments (flags and time)"
      page = heading(page, msg) 
      msg = "This category includes the following flags : "
      page.add(msg)

      for ifo in ifos:
        command = 'awk \'{print $1}\' ' +  datadir +'/segments/' + ifo + "cat"+str(i)+".txt"
        flags, status = \
          make_external_call(command, opts.debug, opts.debug, True)
        page.pre(flags)

      msg="The veto times (category "+str(i)+") according to hipe ( "+cat+")"
      page.add(msg)

      page.table()
      segs = get_segments_tag(cat)
      keys = ("segments","H1","H2","L1","G1","V1","T1") 
      for key in keys:
         if segs.has_key(key):
           page.tr()
           page.td(key)
           page.td(segs[key])
           page.tr.close()
      page.table.close()
      page.div.close() # (3)

    except:
    
      msg = "Problems parsing category veto segment list "+str(i), "warning"
      logText(logfile, msg)
     

  for tag in ["SCIENCE_SEGMENTS", "RDS_C03_L2", "MISSED_SEGS"] :
    page = heading(page, tag +" summary ")
    msg = "The science segments (category 1) according to hipe are "+tag+": "
    page.add(msg +" <br/>")

    page.table()
    segs = get_segments_tag(tag)
    keys = ("segments","H1","H2","L1","G1","V1","T1") 
    for key in keys:
      if segs.has_key(key):
        page.tr()
        page.td(key)
        page.td(segs[key])
        page.tr.close()
    page.table.close()
    page.div.close() 
  
  return page


# ***************************************************************************
def write_upperlimit(page, opts):
  """
  Creates an upper limit section (not yet done)
  
  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  webdir = opts.webdir
  ini = opts.config_file
  ifos = get_ifos()
  mkdir(opts.physdir+"/playground")
  
  page.add("Upper Limit Results")
  page.add("to be done ? ")

  return page


# ***************************************************************************
def write_tuning(page,opts):
  """
  Creates the tuning section.

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  webdir = opts.webdir
  ini = opts.config_file
  ifos = get_ifos()
  mkdir(opts.physdir+"/tuning")
  
  page.add("This section summarizes the tuning with e-thinca, \
      r-square, chi-square and h1-h2 cuts.<br/>")
  
  #---------------------------- Tuning

  titles = [\
  	"Ethinca",\
	"chisq",\
  	"rsq",\
  	"distance cut"\
	]
  tags = [\
  	'*plotethinca*COINC_CAT_2*',\
	'*plotsnrchi*',\
	'*plotsnrchi*',\
	'*ploteffdistcut*'\
	]

  imagetags=[\
	['ethinca_vs_combined'],\
	['chisq_inj_const_lines'],\
	['rsq'],\
	['eff_dist_cut']\
	]

  captions = [\
  	"Ethinca versus combined SNr in the different ifo combinaisons",\
  	"fix me",\
  	"fix me",\
  	"Fractional differences in effective distance (H1 and H2 detectors). \
         Blue crosses are slided triggers. Red crosses are injection triggers."\
	]

  configs = [	\
	'plotethinca',\
	'plotsnrchi',\
	'plotsnrchi',\
	'ploteffdistcut'\
	]

  images_dirs = ['bbhinj_summary_plots', 'bnsinj_summary_plots',\
      'nsbhinj_summary_plots', 'spininj_summary_plots', \
      'allinj_summary_plots']

  for images_dir in images_dirs:
    page.add("<h1>Summary of the "+images_dir+" directory</h1>")
    for title, tag, caption,config,image_tag in zip(titles, tags, captions, configs,imagetags):
      page = heading(page, title +" ("+images_dir +")")
      page = add_config_section(page, config)
      page = fom(page, opts, cachefile_tag=tag, caption=caption,\
	 	image_tag=image_tag, directory=images_dir)
      page.div.close() # for each heading 


  return page


# ***************************************************************************
def write_analysis(page, opts, thisSearch='playground'):
  """
  Creates the playground or full_data section. It uses the same function 
  because except the name and time analysed, the figures of merits are the same. 
  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @param thisSearch: either "playground" or "full_data"
  @type thisSearch: string
  @return: an update of HTML document
  """
  webdir = opts.webdir
  ini = opts.config_file
  ifos = get_ifos()
  mkdir(opts.physdir+"/"+thisSearch)



  if thisSearch=='playground':
    images_dir='/playground_summary_plots/'
  else:
    images_dir='/full_data_summary_plots/'

  msg = "This section summarizes the analysis of the "+thisSearch+" data.<br/>"
  page.add(msg)
  
  #table and venn diagram
  
  page = heading(page, "General information", "see details here")
  try:
    segs = get_segments_tag('SELECTED_SEGS')
    keys = ("segments","H1","H2","L1","G1","V1","T1") 
    msg = "The segment files above were created with no data quality flags set"
    page.p(msg)

    page.p("The times analyzed accoring to hipe are:")
    coincs = get_coincident_segments(thisSearch)  

    ## here is the table. The first column is another table with the durations, 
    page.add("<table><tr><td>\n")
    page.table()
    page.tr();
    page.td('coincidence'); 
    page.td('duration(s)'); 
    page.tr.close()
    for key in coincs.keys():        
      page.tr()
      if thisSearch=='playground':
        file = webdir +'/'+thisSearch +'/'+key+"_play_segs_analyzed.txt"
      else:
        file = webdir +'/'+thisSearch +'/'+key+"_segs_analyzed.txt"
      page.td(e.a(key,href=file))
  
      page.td(coincs.get(key))
      page.tr.close()
    page.table.close()
    page.add("</td>\n")
  except:
    logText(logfile, "Error in generating analysed segments.", "error")
    pass

  try:
    page.add("<td>")
    #create figure for the venn diagram
    data = ""
    for coinc in ("H1","H1H2","H2","H2L1","L1","H1L1","H1H2L1"):
        data = data +coincs.get(coinc) + " "
    create_venn(data, thisSearch)
    # and incorporate into html
    comment = "Venn diagram showing distribution of"
    for coinc in  coincs.keys():
      comment = comment + " "+ coinc
    page = add_figure(page, fnames =[thisSearch+"/venn_"+thisSearch+".png"],\
      caption=comment, size="half")
    page.add("</td></tr></table>")
    
    page.add("Here below is the detail of the data and ligo-data section \
        of ihope.ini ")
    page = add_config_section(page, "data")
    page = add_config_section(page, "ligo-data")
    page.div.close()  
  except:
    page.div.close()  
    logText(logfile, "Error in generating Venn diagram.", "error")
    pass
 
  
  # title will be the name of the section.
  # tags is a tag to search for the relevant cache file (will use the first one found)
  # imagetags. if not none, will only pu a subset of images corresponding to the list provided. 
  # captions is the text to be written in the caption
  # configs : is not none, the part of the ini file corresponding to this config name will be written in the web page
  titles = [\
  	"Inspiral range plots",\
	"Variation in template bank and triggered template size",\
  	"First inspiral stage",\
  	"First coincidence stage",\
	'Second inspiral stage',\
	'Second thinca step (all ifo combinaison and category 2)'\
	]

  tags = [\
  	'*inspiralrange*',\
	'*plotnumtemplates*',\
	'*plotinspiral_FIRST_*PLAYGROUND*',\
	'*plotthinca_FIRST_*PLAYGROUND*',\
	'*plotinspiral_SECOND_*PLAYGROUND*',\
	'*plotthinca_SECOND_*_PLAYGROUND*CAT_2*'\
	]

  imagetags=[\
	None,\
	None,\
	['snr_vs_time','snr_cum_hist','snr_histogram'],\
	['dummy_on_purpose'],\
	['snr_vs_time','snr_vs_chisq_log','snr_histogram'],\
	['plot_slide_trigs', 'cum_hist_effective_snr']\
	]

  captions = [\
  	""" "Inspiral Horizon distance for a \
       (1.4,1.4) solar mass system with SNR=8 (first sub-figure), and \
       histograms(second sub-figure). The last sub-figure shows the \
       expected horizon distance for any total mass, using an SNR=8."""  ,\
  	"Variation in template bank and triggered template bank size",\
        "Trigger rate at first inspiral stage",\
        "Trigger rate at first coincidence stage",\
	"Trigger rate at second inspiral stage",\
	'Trigger rate at second coincidence stage'\
	]

  comments = [\
  None,\
  None,\
  None,\
  "This section has no images (on purpose). To obtain the first thinca stage images, see the links here below",\
  None,\
  "This section shows the plotthinca results for the category 2 only.  "\
  ]

  configs = [	\
	None,\
	'tmpltbank',\
	'inspiral',\
	'thinca',\
	'veto-inspiral',\
	'thinca-2'\
	]

  for title, tag, caption,config,image_tag,comment in \
        zip(titles, tags, captions, configs, imagetags,comments):
      page = heading(page, title)
      try:
        if comment is not None:
          page.p(comment)
        page = add_config_section(page, config)
        page = fom(page, opts, cachefile_tag=tag, caption=caption,\
	 	image_tag=image_tag, directory=images_dir)
      except:
        pass
      page.div.close() # for each heading
  return page


# ***************************************************************************
def write_summaryFiles(page, opts):
  """
  Creates a section to provide the relevant summary files such as COIRE_SUMMARY
  files

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  webdir = opts.webdir
  ini = opts.config_file
  ifos = get_ifos()
  
  page.add("This section provides a list of COIRE and SIRE summary files.<br/>")
  page = heading(page, "Final COIRE Summary files ")

  
  for thisSearch in ["playground", "bbhinj", "bnsinj", "nsbhinj", "spininj"]:
    page.add('<h1>' + thisSearch  +' section</h1>')
    for eachifo in get_ifo_coinc():
      if len(eachifo)>2:
        try:
          if 'inj' in thisSearch:
            file = opts.datadir + '/'+thisSearch+'/'+eachifo\
                +'-COIRE_INJECTIONS*SUMMARY_SECOND_'+eachifo\
                +'_'+thisSearch.upper() +opts.txt_suffix     
            file = glob.glob(file)
            file = file[0]
          else:
            file = opts.datadir + '/'+thisSearch+'/'+eachifo\
                +'-COIRE_SUMMARY_SECOND_'+eachifo\
                +'_'+thisSearch.upper() +opts.txt_suffix     
          tmp = open(file, "r")
          this = tmp.read()
          tmp.close()
          page.add( "<p>COIRE Summary file "+eachifo+".</p>")
          page.add("<pre>"+file+"<br/>"+this+"</pre>")
        except:
          page.add('<pre>Could not find '+file+'</pre>')
        # the SLIDE case
        if 'inj'  not in thisSearch:
          try : 
            file = opts.datadir + '/'+thisSearch+'/'+eachifo\
                +'-COIRE_SLIDE_SUMMARY_SECOND_'+eachifo\
                +'_'+thisSearch.upper() +opts.txt_suffix      
            tmp = open(file, "r")
            this = tmp.read()
            tmp.close()
            page.add("<p>COIRE Summary file "+eachifo+" (slide).</p>")
            page.add("<pre>"+file+"<br/>"+this+"</pre>")
          except:
            pass
   
     #copy all SUMMARY COIRE file 
    try:
      mkdir(opts.physdir+"/"+thisSearch)        
      src = opts.datadir+'/'+thisSearch+'/'+"*COIRE*SUMMARY*xml* " 
      dest = opts.physdir+"/"+thisSearch
      if opts.debug is False:
        command = 'cp ' +src +' ' + dest
        make_external_call(command, opts.debug, opts.debug, True)   
      page.add("All COIRE files are available in "+thisSearch\
          +" directory <a href=\""+ webdir +'/' +thisSearch+"\">here</a>")
    except: 
      page.add("<pre>Problem while copying the cummary files.</pre>")

  page.div.close()#rabelais
  return page
 


# ***************************************************************************
def write_injection(page, opts):
  """
  Creates the injection section

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  webdir = opts.webdir
  ini = opts.config_file
  ifos = get_ifos()
  mkdir(opts.physdir+"/injections")

  page.add("This section summarizes the analysis of the injection runs.<br/>")

  images_dirs = ['bbhinj_summary_plots', 'bnsinj_summary_plots', \
      'nsbhinj_summary_plots', 'spininj_summary_plots', \
      'allinj_summary_plots']

  
  #---------------------------- the injection section
  # title will be the name of the section.
  # tags is a tag to search for the relevant cache file (will use the first one found)
  # imagetags. if not none, will only pu a subset of images corresponding to the list provided. 
  # captions is the text to be written in the caption
  # configs : is not none, the part of the ini file corresponding to this config name will be written in the web page
  titles = [\
  	"Efficiency, Found and Missed plots (first stage)",\
  	"Closeby missed injections (Second coincidence stage and CAT2)",\
  	"Efficiencies (second stage)",\
  	"Accuracies (First stage, using SIRE files)",\
  	"Accuracies (Second stage, using SIRE files)",\
  	"Accuracies (Second stage, using SIRE_COIRE files )"\
	]
  tags = [\
  	'*plotinspmissed_FIRST*',\
  	'*plotinspmissed_SECOND*',\
  	'*plotinspmissed_SECOND*',\
  	'*plotinspinj_FIRST*',\
  	'*plotinspinj_SECOND*SNGL1-*',\
  	'*plotinspinj_SECOND*SNGL-*'\
	]
	#['map-8'],\  # this is not robust but works for GPS <900,000,000
  imagetags=[\
        ['dummy_on_purpose_so_that_no_images_is_passed_to_the_web_page'],\
	['map-8'],\
        ['efficiency-eff_dist'],\
        ['mchirp_vs_snr_accuracy_scatter_totalmass'],\
        ['mchirp_vs_snr_accuracy_scatter_totalmass'],\
        ['mchirp_vs_snr_accuracy_scatter_totalmass']\
	]
  captions = [\
        "Found and Missed injections links (first stage)",\
	'Found and Missed injections. Effective distance versus chirp mass',\
	'Efficiencies (Second stage)',\
        'Accuracy plots (first stage)',\
        'Accuracy plots (second stage)',\
        'Accuracy plots (second stage)'\
	]
  configs = [\
        None,\
	'plotinspmissed',\
	'plotinspmissed',\
	'plotinspinj',\
	'plotinspinj',\
	'plotinspinj'\
	]


  for images_dir in images_dirs:
    page.add("<h1>Summary of the "+images_dir+" directory</h1>")
    for title, tag, caption,config,image_tag in\
        zip(titles, tags, captions, configs,imagetags):
      page = heading(page, title)
      page = add_config_section(page, config)
      page = fom(page, opts, cachefile_tag=tag, caption=caption,\
	 	image_tag=image_tag, directory=images_dir)
      page.div.close() # for each heading 
 


  return page


# ***************************************************************************
def write_about(page, opts):
  """
  Creates the section "About". 

  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @return: an update of HTML document
  """
  webdir = opts.webdir
  
  page.p("This page was automatically generated with write_ihope_page using\
      the following ini file")
  tmp  = open(opts.config)
  tmp2 = tmp.read()
  tmp.close() 
  # the < character in a <pre> HTML tag is read and interpreted, So, we need to 
  # change it to &lt
  page.pre(tmp2.replace('<', '&lt;'))
  # page.pre(tmp.read())

  page.p("and the following command line arguments:")
  text=""
  for arg in sys.argv[:]:
    text = text +  arg +" "
  page.pre( text )
  
  page.p(__Id__[4:len(__Id__)-5])
  return page


# ***************************************************************************
def add_config_section(page, section):
  """
  Copy and paste a section of the ihope.ini into the HTML page within verbatim
  tags

  @param page: the HTML document page.
  @type page: markup.py document
  @param section: the name of the section to copy and paste
  @type section: string
  @return: an update of HTML document
  """
  # section may be empty or set to None
  try:
    ini  = hipecp.items(section)
  except:
    return page

  page.add("<pre>")
  page.add("------------------------------------" +section)
  for i in  ini :
    page.add(i[0]+' = '+i[1])
  page.add("</pre>")
  return page


# ***************************************************************************
def heading(page, title="None", label="Switch details on/off", heading="h3"):
  """
  Add a hx HTML section within the document with the ability to toggle it on/off
   
  @param page: the HTML document page.
  @type page: markup.py document
  @param title: the name of the section
  @type title: string
  @param label: the label to put on the toggle button 
  @type label: string
  @param heading: the HTML heading (h3 by default)
  @type heading: string
  @return: an update of HTML document
  """
  #increment block number

  global count_block 
  input=str(count_block)
  count_block=count_block+1

  page.add("<"+heading+">"+ title)
  text = label 

  page.input(id="input_"+input, type="button", \
      onclick="toggleVisible('"+input+"')", value=text ,class_="toggle")
  page.add("</"+heading+">")
  page.div(id="div_"+input , style='display:none') 

  logText(logfile, '      Enters sub-section: '+title )
  return page 

# ***************************************************************************
def add_caption(page, caption):
  """
  Add a caption to the HTML document. Should be used with the figure only. 
  Take care of the figure numbering.

  @param page: the HTML document page.
  @type page: markup.py document
  @param caption: the name of the section to copy and paste
  @type caption: string
  @return: an update of HTML document
  """
  global fig_num
  page.p("<b>Figure "+str(fig_num) + ":</br> "+caption)
  fig_num = fig_num + 1

  return page


# ***************************************************************************
def add_figure(page,fnames="test", caption="add a caption", size="full", \
    alt="no figure found",source="not specified"):
  """
  Add a figure to the HTML document, taking care of the numbering.
 
  @param page: the HTML document page.
  @type page: markup.py document
  @param caption: the name of the section to copy and paste
  @type caption: string
  @param size: the size of the image ("full", "half", "third")
  @type size: string
  @param alt: an HTML alt 
  @type alt: a string
  @param source: the source of the figure
  @type source: string
  @return: an update of HTML document
  """
  global fig_num
  dir = opts.webdir
  page.add("<!-- insert a figure -->\n<div class=\"figure\">")
  this_count = 0
  
  for fnam in fnames:
    source=dir+"/"+fnam
    
    title = " title=\""+alt[this_count]+"\""
    page.add("\t<a href=\"" + source.replace("_thumb", "")+"\"" +  title + ">\n" )
    try:
      page.img(class_=size ,src=source, alt=alt[this_count] )
    except:
      page.img(class_=size ,src=source )
      
    page.add("</a>")
    this_count = this_count +1
  page.add("\t<p><b>Figure " + str(fig_num) + "</b>:  " + caption + "</p>")
  page.add("<pre>Source: " + source + "</pre>")
  page.div.close()
  fig_num +=1

  #check that the file exsits. If not, returns an error message
  return page

# ***************************************************************************
def create_venn(data, tag):
  """
  Create a venn diagram for the 2 or 3 ifos case
  data has to be H1H2 H1 H2L1 H2 H1L1 L1 H1H2L1 array 

    >>> data = 
    >>> tag = 
    >>> create_venn(data, tag)

  @param data: an input dictionary
  @param data: numbers
  @param tag: 
  @type tag: string
  """

  try:
    mscript = open("temp.m", "w")
    mscript.write("data = [")
    mscript.write( data +"];" ) 
    mscript.write(" vennX(data\'/3600/24,0.01);")
    mscript.write(" k=colormap(jet); k = [1 1 1; k];colormap(k);")
    mscript.write("saveas(gcf,\'venn_"+tag+".png\')")
    mscript.close()
    command=("matlab -nodisplay -nodesktop -nojvm -nosplash   < temp.m > /tmp/test ;  rm -f temp.m; mv venn_"+tag+".png "+opts.physdir+"/"+tag+"/")
    if not opts.debug:
      make_external_call(command, opts.debug, opts.debug, True)   
  except:
    logText(logfile, """WARNING   The matlab command to create the venn diagram failed. 
                Check that matlab is properly set,and vennX.m is available
                (see matapps/src/searches/inspiral/matspiral/utilities")  
          """, "error")

# ***************************************************************************
def get_coincident_segments(tag):
  """
  @param tag: "playground" or "full_data" 
  @type tag: string
  return: a dictionary with the coincident time for each ifo combinaison
  """
  ifos = get_ifos()
  thisdata = {}
  thisdata['segments'] = ['duration(days)' ,'duration (s)']
  output={}
  ifo_coincs = get_ifo_coinc()  

  try:
    for coinc in ifo_coincs:
      if tag=="playground":
        command = "awk \'{sum=sum+$4} END {print sum}\' "\
          +opts.datadir+ tag +"/"+coinc+"_play_segs_analyzed.txt"
      elif tag=="full_data":
        command = "awk \'{sum=sum+$4} END {print sum}\' "\
          +opts.datadir+ tag +"/"+coinc+"_segs_analyzed.txt"

      output[coinc], status = \
        make_external_call(command, False,opts.debug, True)

    logText(logfile, '...Get the analyzed segments duration...')
  except:
    logText(logfile , 'problem(s) while parsnig the coincident segments', \
      "error")

  return output

  


# ***************************************************************************
def get_segments_tag(tag):
  """
  reads segment files and return table of duration for each ifo
 
    >>> get_segments_tag("SELECTED_SEGS")

  @param tag: a tag to the segments
  @type tag: string
  return: 
  """
  # some variables
  datadir = opts.datadir
  ifos = get_ifos()
  thisdata = {}
  directory = datadir+'/segments/'
  thisdata['segments'] = ['filename', 'duration(days)' ,'duration (s)']

  # the name of the files (except for the ifo)
  this_tag  = '-' + tag + opts.txt_suffix
  if tag=="RDS_C03_L2":
    this_tag  = '_' + tag + opts.txt_suffix

  #reading the segments files and extract the duration
  command = 'awk \'{print NF}\' ' +  datadir +'/segments/' + ifos[1] + this_tag
  try:
    ncols, status = make_external_call(command, False, opts.debug, True)
    ncols = ncols[len(ncols)-2]
    # some files may be empty, so the first line (the comment 
    # which has 5 cols) will be read, which explain the >= and not strict ==. 
    if float(ncols)>=4:  
      for ifo in ifos:
        thisfile = ifo + this_tag
        command = 'awk \'{sum=sum+$4} END {print sum/3600/24}\' ' \
          +  directory + thisfile
        output_days, status = \
          make_external_call(command, False, opts.debug, True)

        command = 'awk \'{sum=sum+$4} END {print sum}\' ' \
          +  directory + thisfile
        output_seconds, status = \
          make_external_call(command, False, opts.debug, True)

        thisdata[ifo] = [thisfile, output_days, output_seconds]
    # unfortunately, right now, there is no standard, so some files have only 2 columns
    elif float(ncols)==2:
      for ifo in ifos:
        thisfile = ifo + this_tag
        command = 'awk \'{sum=sum+$2-$1} END {print sum/3600/24}\' ' \
          +  directory + thisfile
        output_days, status = \
          make_external_call(command,False,opts.debug, True)

        command = 'awk \'{sum=sum+$2-$1} END {print sum}\' ' \
          +  directory + thisfile
        output_seconds, status = \
          make_external_call(command, False, opts.debug, True)

        thisdata[ifo] = [thisfile, output_days, output_seconds]
  except:
    logText(logfile,  'Error while parsing the segment duration files', "error")

  return thisdata


# ***************************************************************************
def get_ifo_coinc():
  """
  return: list of valid coincidences with respect to the ini file

  """
  # get the ifo requested
  ifos = get_ifos()
  # get number of ifos to look at
  numifos = []  
  for option in ["one-ifo","two-ifo","three-ifo","four-ifo", "five-ifo"]:
    if hipecp.has_option("ifo-details",option): 
	tmp = option.split("-")
 	numifos.append(tmp[0])
  # now let us fill the different possible ifo combinaisons
  output = []
  for num in numifos:
    if num=="one":
      for ifo in ifos:
        output.append(ifo)
    elif num=="two":
      for ifo1 in ifos:
        for ifo2 in ifos:
          if ifo1 < ifo2:
            output.append(ifo1+ifo2)
    elif num=="three":
      for ifo1 in ifos:
        for ifo2 in ifos:
          for ifo3 in ifos:
            if ifo1 < ifo2 and ifo2 < ifo3:
              output.append(ifo1+ifo2+ifo3)
    elif num=="four":
      for ifo1 in ifos:
        for ifo2 in ifos:
          for ifo3 in ifos:
            for ifo4 in ifos:
              if ifo1 < ifo2 and ifo2 < ifo3 and ifo3 < ifo4:
                output.append(ifo1+ifo2+ifo3+ifo4)
  return output


  


# ***************************************************************************
def get_ifos():
  """
  read the ifos used in the ifo-details section of the ihope ini file
  return: list of ifos
  """
  ifos=[] 
  for option in ["g1-data","h1-data","h2-data","l1-data", "v1-data"]:
    if hipecp.has_option("ifo-details",option): ifos.append(option[0:2].upper() )

  return ifos


# ***************************************************************************
# ***************************************************************************
def get_version(executable): 
  """
  Search for the tag and version of an executable using the --version argument.

  @param executable: the name of an executable
  @type executable: string
  return: the tag name if any and the version of the executable
  """
  output=[]
  try:
    # this is surely useless now to make a distinction with trigbank 
    if executable=="trigbank":
      pathname = hipecp.get("condor", "trigbank") 
    else:
      pathname = hipecp.get("condor", executable) 
    s =  os.path.split(pathname)
    if len(s[0])==0:
      cmd = opts.ihope_directory + s[1] + '  --version'
    else:
      cmd = s[1] + ' --version '
    output,status = make_external_call(cmd, opts.debug, opts.debug, True)
  except:  
    output= '(not found)' 
    pass

  output = output.split()
  
  #searching for the tagname, which may be empty(undefined)
  try:
    index=  output.index("Tag:")
    tagname = output[index+2]
    # found the "Tag" string. Is it different from $ ?
    if tagname=="$":
      tagname = ' Undefined tag name.'
    else:
      tagname = ', tag name is '+tagname+'. '
  except:
    tagname = ' Cannot find the tag name'


  #searching for the version, which may be empty(undefined)
  try:
    index=  output.index("Version:")
    version = output[index+3]
    version = 'Version is '+ version +'.'
  except:
    version = '. Undefined version.'

  return tagname+' '+version

# ***************************************************************************
def copy_segments():
  """
  This function copies the segments list into the web page directory 
  """

  msg =   "Copying segments into the web page directory (in yoururl/segments)"
  logText(logfile, msg)
  # first we create this directory      
  mkdir(opts.physdir+'/segments')
  # parsing the ini file, find the cat file and thenread the ./segments directory
  try:
    location = opts.physdir + '/segments/'
    command = 'cp '+opts.datadir +'/segments/* ' + location
    dummy,status = make_external_call(command, opts.debug, opts.debug, True)
  except:
    logText(logfile, "Could not copy the segment files", "error")
    pass

 #  the selected segment files
  for thisSearch in ['playground', 'full_data']:
    mkdir(opts.physdir+'/'+thisSearch)
    try :
      stdout ='Copying the selected segments files into /'+thisSearch
      for this in get_ifo_coinc():
          if thisSearch=='playground':
            seg = '/'+thisSearch+'/'+this +'_play_segs_analyzed.txt'
          elif thisSearch=='full_data':
            seg = '/'+thisSearch+'/'+this +'_segs_analyzed.txt'
          command = 'cp '+opts.datadir + seg +\
              ' '+opts.physdir+'/' +thisSearch +'/'
          dummy,status = \
              make_external_call(command, opts.debug, opts.debug, True)
          if status>0:
            stdout += " WARNING:: could not copy a selected segment ("
            stdout += "from playground or full_data directory)"
            break
    except:
      stdout +=" WARNING:: problem while copying a selected segment"
      stdout += "(from playground or full_data). passing..."    
      logText(logfile,  stdout, "warning")
      pass
    else: 
      logText(logfile,  stdout)

# ***************************************************************************
def fom(page, opts, cachefile_tag=None, caption="fix me",\
	 image_tag=None,directory="playground_summary_plots"):
  """
  This function reads a cachefile, copy the files to the relevant directory, and  update the HTML document to add figures and pertinent sections. 

  
  @param page: the HTML document page.
  @type page: markup.py document
  @param opts: the main options variable
  @type opts: write_ihope_page options
  @param cachefile_tag: the pattern of the cachefile to look at
  @type cachefile_tag: string
  @param caption: a list of caption
  @type caption: list of string 
  @param image_tag: a list of tag (including *) to select files within a
  @param directory:  the directory to look at
  @type directory: string
  cachefile
  """

  dir = opts.datadir+'/'+directory+'/' 

  # create the div that will contain the figure 
  page.div(class_="figure")

  # create a list of cachefiles, each of which containing
  # the cachefile_tag argument in its name
  thisglob = dir + cachefile_tag +'cache'
  cachefileList =  glob.glob(thisglob)

  if opts.verbose is True: 
    print "        Searching for files with this(ese) tag(s): " +str(image_tag)

  # currently, there is a bug in plotinspmissed : it does not 
  # save the followup png files within the cachefile. So, we have 
  # to get all the plotinspmissed png files related to the 
  # followup, which can be found in the ./Images directory, and copy them.
  for eachcache in cachefileList:  
    if 'plotinspmissed' in eachcache:
      if opts.debug is False:
        # they may be many files, for which the command cp may not work. 
        # so we use find instead.
        command = 'find ' + dir + '/Images'  \
            + ' -name \"*plotinspmissed*\" -exec cp \"{}\" '\
            + opts.physdir + '/Images/'+' \;'     
        print >> sys.stdout, ' .../ copying all plotinspmissed files ...'
        make_external_call(command, opts.debug, opts.debug, True)
  
  # for each cachefile we create a div figure section with all 
  # figures whose name is part of the image_tag list
  for eachcache in cachefileList:
    # read this cachefile
    this = open(eachcache, "r")
    fnameList = []
    #for each file contained in the cachefile
    if opts.verbose is True :
      print >>sys.stdout, "        --> Copying files from " +eachcache

    for filename in this:
      # if the file is an image, we copy it in ./Images
      # if the file is an image, we copy the file. Then, if the pattern 
      # (in image_tag)  matches the filename, then we create am html section.
      if filename.find('png')>=0:
        # we copy the file 
        command = 'cp ' + dir + filename+' ' +opts.physdir +'/Images/'       
        if opts.debug is False:
          make_external_call(command.replace("\n", " "), opts.debug, opts.debug, True)
        command = 'cp ' + dir + filename.replace(".png","_thumb.png")\
	  + ' ' +opts.physdir  + '/Images/' 

        if opts.debug is False:
          make_external_call(command.replace("\n", " "), opts.debug, opts.debug, True)
        # second, we check if the pattern match the file
        if image_tag is not None:
          for eachPattern  in image_tag:
            if patternFoundInFilename(filename, eachPattern) is True:
              fnameList.append(filename.replace(".png", "_thumb.png"))
        else:
          fnameList.append(filename.replace(".png", "_thumb.png"))
        
      
    # finally, we copy the html files (all of them) 
    this.close()
    this = open(eachcache, "r")
    for filename in this:
      if filename.find('html')>=0:
        command = 'cp ' + dir + filename+' ' +opts.physdir        
        make_external_call(command.replace("\n", " "), opts.debug, opts.debug, True)

    # iand create the appropriate html section 
    this.close()
    this = open(eachcache, "r")
    for filename in this:
      if filename.find('html')>=0:
        msg =" <a onclick=\"window.open(this.ref); return false;\"  href=\""\
            + filename.replace("/pictures", "")+ """\" > <br/> --- <b>Click here (to open link in a new tab/window)</b> to get all pictures (full resolution) 
            as well as the pylal arguments used to generate the plots</a> """
        
        source =  eachcache.split('/') 
        source =  source[len(source)-1]
        page = add_figure(page, fnames=fnameList, \
          caption=(caption+' '+msg), source=source, size="third", alt=fnameList)
        break
     # close the cachefile
    this.close()
  
  page.div.close()

  return page
# ***************************************************************************
# ***************************************************************************
def set_style():
  """
  Function to copy the style file as read from the write_ihope_page.ini file
  """

  tmp = []
  tmp.append(configcp.get("main", "style"))
  
  try:
    style = configcp.get("main","style")
    command = 'cp ' + style + " " +opts.physdir
    make_external_call(command, opts.debug, opts.debug, True )
    tmp=style.split('/')
    return tmp[len(tmp)-1]
    
  except:
    print sys.stderr()<< 'could not copy the style file'
    pass
    return ""

# ----------------------------------------------------------------------------
def parse_arguments():
  """
  Function to parse the arguments and check their validity.
  """
  usage =  """ %prog [options]
  Program to write webpage from upperlimit.py
  """

  parser = OptionParser( usage = usage, version = "%prog CVS "+__Id__ )

  parser.add_option("-C","--config-file",action="store",type="string",\
      metavar=" INI File",\
      help="ini file with information about run directories" )
  parser.add_option("-A","--skip-full-data",action="store_false",\
      default=True,dest="full_data", metavar="DOANALYSIS",\
      help="" )
  parser.add_option("-T","--skip-tuning",action="store_false",\
      default=True,dest="tuning", metavar="DOTUNING",\
      help="" )
  parser.add_option("-U","--skip-upperlimit",action="store_false",\
      default=True,dest="upperlimit", metavar="DOUPPERLIMIT",\
      help="" )
  parser.add_option("-I","--skip-injection",action="store_false",\
      default=True,dest="injection", metavar="DOUPPERLIMIT",\
      help="" )
  parser.add_option("-P","--skip-playground",action="store_false",\
      default=True,dest="playground", metavar="DOPLAYGROUND",\
      help="" )
  parser.add_option("-D","--debug",action="store_true",\
       default=False,dest="debug",metavar="DODEBUG",\
       help="" )
  parser.add_option("-V","--verbose",action="store_true",\
      default=False, dest="verbose",metavar="VERBOSE",\
      help="" )

  (opts,args) = parser.parse_args()

  if opts.config_file is None:
    raise ValueError,\
"""
------------------------------------------------------------------------------
the arguments --config-file must be used and followed by an ini file, an
example of which is  :

[main]
gps-start-time  = 847555570
gps-end-time    = 849974770
title           = "Low mass CBC analysis"
ihope-ini-file  = ihope.ini
ihope-directory = /archive/home/cokelaer/S5/Month1/full_analysis/
home-directory  = /archive/home/
url             = ldas-jobs.ligo.caltech.edu
username        = cokelaer
output          = index.shtml
style           = /archive/home/cokelaer/style.css
"""

  return opts,args

# ----------------------------------------------------------------------------

#try:
#  from glue import markup
#  from markup import oneliner as e
#except: 
#  raise ImportError("Require markup.py to generate the html page")
#
opts,args = parse_arguments()


#############################################################################
#  MAIN PART                                                                #
#############################################################################
fig_num = 1
count_block = 0
config   =  opts.config_file
opts.config = config # save the name of the ini file, why ?
configcp = ConfigParser.ConfigParser()
configcp.read(config)

print >>sys.stdout, "|------------------- Initialisation"
# First, we open an xml file, for the log file
logfile_name = __name__+".xml"
print >>sys.stdout,"Openning the log file (" +logfile_name+")."
logfile = open(logfile_name, "w")
logfile.write("""<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet type="text/xsl" href="write_ihope_page.xsl"?>
<log>""")


#---------------------------------------
# then, we parse the write_ihope_page.ini file
print >>sys.stdout,"Parsing the ini file: " + opts.config
try:
  opts.config_file 	= configcp.get("main", "ihope-ini-file")
  opts.gps_start_time 	= configcp.get("main", "gps-start-time")
  opts.gps_end_time 	= configcp.get("main", "gps-end-time")
  opts.ihope_directory 	= configcp.get("main", "ihope-directory")
  opts.title	 	= configcp.get("main", "title")
  opts.url	 	= configcp.get("main", "url")
  opts.username	 	= configcp.get("main", "username")
  opts.output	 	= configcp.get("main", "output")
  opts.home_directory 	= configcp.get("main", "home-directory")
except:
  print >> sys.stderr, "ERROR::The ini file does not have the proper field in the [main] section" 
  print >> sys.stderr, """       Consider adding one of those fields if missing: ihope-ini-file, \
	gps-start-time,gps-end-time, ihope-directory, title,url, username, output"""
  raise
  
#------------------------------------
#sub-products of the ini file parsing
opts.gpsdir =  '/'+str(opts.gps_start_time)+'-'+str(opts.gps_end_time)+'/'
opts.duration = str(int(opts.gps_end_time) - int(opts.gps_start_time))
opts.webdir = 'http://' + opts.url + '/~' + opts.username  + opts.gpsdir
opts.datadir = opts.ihope_directory + opts.gpsdir
opts.physdir = opts.home_directory+'/'+opts.username+'/public_html/'+ opts.gpsdir
opts.txt_suffix = '-'+opts.gps_start_time+'-'+opts.duration+'.txt'
# get the style file, and copy it.  
opts.style = set_style()


#----------------------
# openning the html file
print >>sys.stdout,"Openning the HTML (" + opts.output+")"
try:
  html_file = file(opts.output,"w")
except:
  msg = "Cannot open %" % opts.output
  print >>sys.stderr, msg
  raise


#-----------------------------------------
# here is the directory we want to extract information from
msg = "Entering this directory (where we will get all the relevant information)" + opts.datadir
print >> sys.stdout, msg
if not  os.path.isdir(opts.datadir):
  raise  "%s is not a valid directory. Check your gps time." % opts.datadir
# which physical name is 
msg = "We will copy all images and HTML documents into this directory " +opts.physdir
logText(logfile, msg,"done")
mkdir(opts.physdir)
mkdir(opts.physdir+'/Images')


#-----------------------------------------
# now we can parse the ihope.ini file itself
msg =   "Parsing the ihope ini file (" + opts.config_file+")"
logText(logfile, msg)
hipe   = opts.ihope_directory+'/'+opts.config_file
hipecp = ConfigParser.ConfigParser()
hipecp.read(hipe)
make_external_call( 'cp '+opts.config_file + ' ' + opts.physdir, False, opts.debug, True)

#-----------------------------------------
# now we copy the segments to the web directory and other relevant information
#copy_segments()


#-----------------------------------------
###### create the section labels  
html_sections={}

# the string "full_data" is hardcoded somewhere else, so it must remain as it is
html_order = ['toc', 'general', 'summary', 'playground', 'injection', \
    'tuning', 'full_data', 'upperlimit', 'summary files', 'logfile', \
    'about']

html_sections['toc'] = "Table of Contents"
html_sections['general'] = "General Information"
html_sections['summary'] = "Data Information"
if opts.playground is True: html_sections['playground']	= "Playground"
if opts.injection is True: html_sections['injection'] = "Injection"
if opts.tuning is True: html_sections['tuning']	= "Tuning"
if opts.full_data is True: html_sections['full_data'] = "Full Data"
if opts.upperlimit is True: html_sections['upperlimit']	= "Upper Limit"
html_sections['summary files'] = "Summary files"
html_sections['logfile'] = "Log File"
html_sections['about'] = "About"


title = opts.title+ ": from "+str(opts.gps_start_time)\
  +" to "+str(opts.gps_end_time) 
script = {}
script['toggle.js'] = 'javascript'
create_toggle()
# Finally, we create the html document 
msg =   "Creating HTML document"
logText(logfile, msg)


# -------------------------------------------- the html output page
page = markup.page(mode="strict_html")
page._escape = False
doctype="""<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">"""
doctype+="""\n<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">"""

page.init(title=title, css=opts.style, script=script , doctype=doctype)

page.h1(opts.title +" (" + opts.gps_start_time +"-" +opts.gps_end_time+")")
# The main part of the code, which loops over all subsections
for each_section in html_order:
  if each_section in html_sections:
    page.p(e.br())
    page.add("<!-- beginning of a sub section -->")
    page.div(class_="encadre")
    page.div(class_="contenu")    

    id = each_section.replace(" ","_")
    page = write_title(page, html_sections[each_section],id)

    if each_section=='toc':
      page.div(id="div_"+id, style='display:block')
    else:
      page.div(id="div_"+id, style='display:none')

    try:
      logText(logfile, html_sections[each_section], "section")
      page = write_results(page, opts, each_section)
    except:
      logText(logfile, each_section, "section")
      msg = "Error while processing this section. "\
          + "skipped  "+each_section + " section"
      page.add(msg)
      logText(logfile, msg, "warning")
      print >>sys.stdout, msg
      pass
    page.div.close()
    page.div.close()
    page.div.close()

# end of the different sections
# the valid HTML and CSS footer
page.add("<table><tr><td>")
page.add("<a href=\"http://validator.w3.org/check?uri=referer\">")
page.add("<img src=\"http://validator.w3.org/images/valid_icons/valid-xhtml10\" alt=\"Valid XHTML 1.0!\" height=\"31\" width=\"88\"/></a> ")
page.add("<a href=\"http://jigsaw.w3.org/css-validator/\">")
page.add("<img src=\"http://www.w3.org/Icons/valid-css\" alt=\"Valid CSS!\" height=\"31\" width=\"88\" /></a> ")
page.add("</td></tr></table>")

# what is the False for ? I cannot remenber
html_file.write(page(False))
html_file.close()
# just remove the <html lang="en"> line tat is not a strict HTML code
cmd = 'sed -e \'s/<html lang=\"en\">//\' '+ opts.output + '>/tmp/tmp.html'
output,status = make_external_call(cmd, True, True, False)
if status==0:
  cmd = 'mv /tmp/tmp.html '+opts.output
  make_external_call(cmd, True, True, True)
# that's it for the html creation. let us copy it to the requested directory  

print '---------------------FINISHED ---------------------'
print '--- HTML file created. '
print '--- Copying html documents in ' +opts.physdir
make_external_call('mv  '+opts.output +' ' + opts.physdir, opts.debug, opts.debug, True)
make_external_call( 'mv toggle.js '+ opts.physdir, opts.debug, opts.debug,  True)

#let us close the log file
logfile.write("</log>")
logfile.close()
logfile = __name__+".xml"
output, status = make_external_call( 'grep WARNING '+ logfile +'| wc - | awk \'{print $1}\' - ', opts.debug, opts.debug, True)

if status==0:
  if int(output)==0:
    print 'No warnings'
  else:
    print '\n\n\nThere are warnings : '+str(int(output))+' . Check the log file '+logfile
  
  output, status = make_external_call('mv '+logfile + " "+opts.physdir, True,True,True) 
else:
  print 'Could not find the log file ' +logfile
  
 
#Finally create the xsl for the log xml file
logfile = open(__name__+".xsl", "w")
logfile.write("""<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<xsl:template match="/">
  <html>
  <body>
  <center><h1>Log file summary </h1></center>
  <xsl:apply-templates/>
  </body>
  </html>
</xsl:template>

<xsl:template match="section">
<h2 color="blue">Section: <xsl:value-of select="."/></h2>
<br />
</xsl:template>

<xsl:template match="done">
<center>
  <div>
    <table bgcolor="green" border="2" width="80%">
      <tr>
        <td width="80%"><xsl:value-of select="."/></td>
        <td bgcolor="white"> passed</td>
      </tr>
    </table>
  </div>
</center>
</xsl:template>
<xsl:template match="warning">
<center>
  <div>
    <table bgcolor="orange" border="2" width="80%">
      <tr>
        <td width="80%"><xsl:value-of select="."/></td>
        <td bgcolor="white"> fix me</td>
      </tr>
    </table>
  </div>
</center>
</xsl:template>
<xsl:template match="error">
<center>
  <div>
    <table bgcolor="red" border="2" width="80%">
      <tr>
        <td width="80%"><xsl:value-of select="."/></td>
        <td bgcolor="white"> skipped</td>
      </tr>
    </table>
  </div>
</center>
</xsl:template>



</xsl:stylesheet>
""")

logfile.close()
output, status = make_external_call('mv '+__name__+".xsl" + " "+opts.physdir, True,True,True) 



