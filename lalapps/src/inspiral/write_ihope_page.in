#!/usr/bin/python

# $Id$
__author__ = "Thomas Cokelaer <thomas.cokelaer@astro.cf.ac.uk>"
__version__ = "$Revision$"
__date__ = "$Date$"
__Id__ = "$Id$"
__name__ = "write_ihope_page"

import sys
import copy
import os
from optparse import *
import glob
from glue  import markup
from glue.markup import oneliner as e
import ConfigParser
sys.path.append('@PYTHONLIBDIR@')


def functionId(nFramesUp):
  """ 
  Create a string naming the function n frames up on the stack.
  """
  try:
    co = sys._getframe(nFramesUp+1).f_code
    msg = "%s (%s @ %d)" % (co.co_name, co.co_filename, co.co_firstlineno)
    if msg.startswith("?") is False:
      print "-->ERROR in function: " + msg
  except:
    msg=[]
  return msg

# ***************************************************************************
# ***************************************************************************
def logText(logfile, text, tag="done"):
  """
  This function writes in a logfile, the text provided as an argument with color code according to the third argument. 
  It also print on the stdout/stderr relevant the same text.
  @param tag is in {done,warning,error} 
  """ 

  if tag=="warning":
    msg= "<"+tag+">"+text+"</"+tag+">\n"
    logfile.write(msg)
    if opts.verbose is True:
      print >>sys.stdout,text

  elif tag=="error":
    msg = "<"+tag+">"+text
    logfile.write(text)
    i =1 
    while len(msg)>0:
      msg = functionId(i)
      if msg.startswith("?") is False:
        logfile.write("\n"+msg)
      else :
        logfile.write("</"+tag+">\n")
        msg=[]
      i=i+1
    print >>sys.stderr, msg
    exit(1)

  else :
    msg = "<"+tag+">"+text+"</"+tag+">\n"
    logfile.write( msg )
    if opts.verbose is True:
      print >>sys.stdout,text


def make_external_call(command, show_stdout=False, show_command=False, show_error=True):
  """
  Run a program on the shell and print informative messages on failure.
  """
  if show_command and opts.verbose is True: 
    print "--- Trying this command :" + command

  stdin, out, err = os.popen3(command)
  pid, status = os.wait()
  this_output = out.read()
  if show_error & status != 0:
    print >>sys.stderr, "External call failed."
    print >>sys.stderr, "  status: %d" % status
    print >>sys.stderr, "  stdout: %s" % this_output
    print >>sys.stderr, "  stderr: %s" % err.read()
    print >>sys.stderr, "  command: %s" % command
    sys.exit(status)
  if show_stdout:
    if this_output[0:1]=='\n': 
      print  this_output[1:]  #first character is \n
    else:
      print this_output

  stdin.close()
  out.close()
  err.close()  
  return this_output, status

# ***************************************************************************
# ***************************************************************************
def mkdir( newdir ):
  """
  Create a directory, don't complain if it exists

  newdir = name of directory to be created
  """
  if os.path.isdir(newdir): 
    print >>sys.stdout , "WARNING: this directory already exists (" + newdir +")."
    pass
  elif os.path.isfile(newdir):
    raise OSError("a file with the same name as the desired " \
                  "dir, '%s', already exists." % newdir)
  else: os.mkdir(newdir)


# ***************************************************************************
# ***************************************************************************
def create_toggle():
  fname = open("toggle.js", "w")
  fname.write("function toggleVisible(division) {\n"+\
    "  if (document.getElementById(\"div_\" + division).style.display == \"none\") {\n"+\
    "    document.getElementById(\"div_\" + division).style.display = \"block\";\n"+\
    "    document.getElementById(\"input_\" + division).checked = true;\n"+\
    "  } else {\n"+\
    "    document.getElementById(\"div_\" + division).style.display = \"none\";\n"+\
    "    document.getElementById(\"input_\" + division).checked = false;\n"+\
    "   }\n"+\
    " }\n"
   )
  fname.close()

def write_results(page, opts, section):
  """
  """
  if opts.verbose is True:
    print >>sys.stdout,"--------------------- Creating section "+section
  if section=='general': 	page = write_general(page, opts)
  elif section=='toc': 		page = write_toc(page, opts)
  elif section=='summary': 	page = write_summary(page, opts)
  elif section=='playground': 	page = write_analysis(page, opts,thisSearch='playground')
  elif section=='tuning': 	page = write_tuning(page, opts)
  elif section=='injection': 	page = write_injection(page, opts)
  elif section=='analysis': 	page = write_analysis(page, opts,thisSearch='full_data')
  elif section=='upperlimit': 	page = write_upperlimit(page, opts)
  elif section=='logfile': 	page = write_logfile(page, opts)
  elif section=='about': 	page = write_about(page, opts)
  else:
    msg = "this section ("+ section +") doest not exist. "
    logText(logfile, msg, "error")

  return page
# ***************************************************************************
def write_logfile(page , opts):
  """
  This function creates an entry with the logfile information.
 
  @param page:
  @param opts:
  """
  # get the directory of the url
  dir = opts.webdir +'/'

  page.p(e.br())
  page.add("<!-- beginning of the general section -->")
  page.div(class_="encadre")
  page.div(class_="contenu")
  page = write_title(page, html_sections['logfile'], "zola")
  page.div(id="div_zola", style='display:none')
  page.a("logfile", href=dir +  __name__+'.xml')
  page.div.close()
  page.div.close()
  page.div.close()

  return page
# ***************************************************************************
def write_toc(page , opts):
  """ 
  This function creates the table of contents, using the html_sections 
  variable defined in the main part of this program.

  @param page:
  @param opts:
  """
  # get the directory of the url
  dir = opts.webdir +'/'

  # and the section names
  items = html_sections 
  order = html_order 
  # create a frame for the toc, and add contents 
  page.add("<!-- beginning of toc section-->")
  page.div(class_="encadre")
  page.div(class_="contenu")
  page.h2()
  page.add("<a name=\"toc\"> Table of Contents  </a>")
  page.h2.close()
  page.ol()
  for this_item in order:
    try:
      page.li(e.a(this_item, href=dir + opts.output + '#' + items[this_item]))
      msg = "added "+this_item
      logText(logfile, msg, "done")
    except:
      msg = 'skip '+this_item
      logText(logfile, msg, "warning")
#      pass

  page.ol.close()
  page.div.close()
  page.div.close()

  return page

# ***************************************************************************
# ***************************************************************************
def write_general(page,opts):
  webdir = opts.webdir
  ini = opts.config_file

  page.p(e.br())
  page.add("<!-- beginning of the general section -->")
  page.div(class_="encadre")
  page.div(class_="contenu")
  page = write_title(page, html_sections['general'], "rimbaud")
  page.div(id="div_rimbaud", style='display:none')
  text=  'This page summarizes the analysis of the data segment from GPS time %s up to %s' % (opts.gps_start_time,  opts.gps_end_time)
  page.add(text)

  # The search parameters
  if opts.verbose is True: print "Extracting the version and tag of the executables..." 
  try:
    # todo : get the list of executables  from the ini file
    executables = ("inspiral", "tmpltbank", "sire", "thinca", "trigbank", "coire" , "inspinj")
    page.h3("The search used the following resources:")
    
    page.ol() #starts enumerate
    page.add("<li> LAL/LALApps "+get_version("inspiral")) #first section
    page.ul()
    for exe in executables:
      text = "<b>lalapps_"+exe+ "</b>    "+get_version(exe)
      page.li(text)   
    page.ul.close()
    page.li.close()

    page.add("<li>Segment information (see the Data Information section for more details):") #section section
    page.ul()
    for this in get_ifos():
        seg = this +'-SELECTED_SEGS'+opts.txt_suffix
        this_ref = webdir + '/segments/'+seg
        page.li(e.a(seg,href=this_ref) )
    page.ul.close()
    page.li.close()


    # let us give the ihope.ini and log file. We need to copy some files to the webdir
    cmd = 'cp '+opts.datadir + '/ihope.pipeline.log  '+opts.physdir
    make_external_call(cmd, opts.debug, opts.debug, False)
    text=("The configuration is contained in the file <a href=\"" + \
        webdir + "/" + ini + "\">" + ini + "</a>")
    text+=("which was used by lalapps_ihope as reported in the  <a href=\"" + \
        webdir + "/" + "ihope.pipeline.log" + "\"> [ihope.pipeline.log]</a> file.")
    page.li(text) #third section
    text = "A list of category files stored in this directory ("  \
   	+ "<a href=\""+ webdir + "/catlists/\"> catlists</a>"  +\
  	"), and listed in the ini file."

    page.li(text) # fourth section
    page.ol.close()
  except:
    logText(logfile, """Problem with the executable: cannot find them ? """, "warning")
    pass
  else:
    logText(logfile,  "...Get the executables version...")


  # The ifo requested
  page = heading(page, "This search concerned the following combinaison of ifos")
  page = add_config_section(page, "ifo-details")
  page.div.close()


  page.div.close()
  page.div.close()
  page.div.close()
  
  return page


# ***************************************************************************
# ***************************************************************************
def write_title(page, text, tag):
  """
  """
  page.h2()
  page.add("<a name=\""+text.replace(" ", "_")+"\">")
  input = "input_"+tag
  page.input(id=input, type="checkbox", checked="checked", onclick="toggleVisible('"+tag+"')")
  page.add(text)
  page.add("</a>")
  page.h2.close() 
  page.div(e.a("return to top", href="#toc" ), class_="back")

  return page


# ***************************************************************************
# ***************************************************************************
def write_summary(page,opts):
  """
  """
  # first, get some information 
  webdir = opts.webdir
  datadir = opts.datadir
  ini = opts.config_file
  ifos = get_ifos()

  page.p(e.br()) # to put a space between different section
  page.add("<!-- beginning data summary section-->")
  page.div(class_="encadre") #(1)
  page.div(class_="contenu") #(2)

  # title with a div to toggle on/off the content 
  page = write_title(page, html_sections['summary'], "verlaine")
  
  page.div(id="div_verlaine", style='display:none') #(3)
  page = heading(page, "Selected segments", "Switch details on/off")  #(4)
  page.p("""The segments files provided in the general section were created with no data quality flags 
set. The times analyzed according to ihope/hipe are provided here below""")
  page.p(e.br())
  page.table()
  segs = get_segments_tag("SELECTED_SEGS")
  keys = ("segments","H1","H2","L1","G1","V1","T1") 
  for key in keys:
    if segs.has_key(key):
      page.tr()
      page.td(key)
      page.td(segs[key])
      page.tr.close()
  page.table.close()
  page.div.close() #(3)
  


  i=0
  for cat in ("CATEGORY_1_VETO_SEGS","CATEGORY_2_VETO_SEGS","CATEGORY_3_VETO_SEGS","CATEGORY_4_VETO_SEGS"):
    i=i+1
    try:
      page = heading(page, "Category " + str(i) + " veto segments (flags and time)")  #(4)
      
      page.add("This category includes the following flags : ")
      for ifo in ifos:
        command = 'awk \'{print $1}\' ' +  datadir +'/segments/' + ifo + "cat"+str(i)+".txt"
        flags, status = make_external_call(command, opts.debug, opts.debug, True)
        page.pre(flags)

      page.add("The veto times (category "+str(i)+") according to hipe ( "+cat+")")
      page.table()
      segs = get_segments_tag(cat)
      keys = ("segments","H1","H2","L1","G1","V1","T1") 
      for key in keys:
         if segs.has_key(key):
           page.tr()
           page.td(key)
           page.td(segs[key])
           page.tr.close()
      page.table.close()
      page.div.close() # (3)

    except:
      logText(logfile, "Problems parsing category veto segment list "+str(i), "warning")
     

  for tag in ["SCIENCE_SEGMENTS", "RDS_C03_L2", "MISSED_SEGS"] :
    page = heading(page, tag +" summary ") #(4)
    page.add("The science segments (category 1) according to hipe are "+tag+": <br/>")
    page.table()
    segs = get_segments_tag(tag)
    keys = ("segments","H1","H2","L1","G1","V1","T1") 
    for key in keys:
      if segs.has_key(key):
        page.tr()
        page.td(key)
        page.td(segs[key])
        page.tr.close()
    page.table.close()
    page.div.close() #(3)


  page.div.close() #(2)
  page.div.close() #(1)
  page.div.close() #(0)
  
  return page





# ***************************************************************************
# ***************************************************************************
def write_upperlimit(page, opts):
  """
  """
  webdir = opts.webdir
  ini = opts.config_file
  ifos = get_ifos()
  mkdir(opts.physdir+"/playground")
  page.p(e.br())
  page.div(class_="encadre")
  page.div(class_="contenu")
  page = write_title(page, html_sections['upperlimit'], "zola")
  page.div(id="div_zola", style='display:none')
  page.add("Upper Limit Results")

  # gaussian
  page = heading(page, "Gaussian Mass Distribution", "see details here", "h3")
  try:
    page.pre()
    page.add("Compute Posterior output")
    tmp_file = file(opts.datadir + "analysis/plotnumgalaxies/" + "ul-output-gaussian.log")
    page.add(tmp_file.read())
    fname.write("</pre>")

    page = add_figure(fname,dir,fnames=["plotnumgalaxies/Gaussian-posterior-pdf.png", \
      "plotnumgalaxies/Gaussian-posterior-cdf.png"], \
      size="half",\
      caption="posterior and cumulative posterior for the rate")
  except:pass
  page.div.close()

  # uniform
  page = add_input_h3(page, "Uniform Mass Distribution")
  
  page.add("Compute Posterior output:\n")
  #tmp_file = file(opts.actual_directory + "/plotnumgalaxies/" + \
  #    "ul-output-uniform.log")
  #fname.write(tmp_file.read())

  try:
    add_figure(fname,dir,fnames=[ "plotnumgalaxies/Uniform-rate-v-mass.png"], \
      size="full", caption="rate upper limit vs total mass")
    uniFiles = glob.glob(opts.actual_directory + \
      "/plotnumgalaxies/Uniform-*-mtotal*pdf.png")
    for thisFile in uniFiles:
      # keep only the file name
      thisFile = thisFile.split("/")[-1]
      # get the mass range
      mlo = thisFile.split("-")[1]
      mhi = thisFile.split("-")[2]
      add_figure(fname,dir,fnames=["plotnumgalaxies/" + thisFile,\
          "plotnumgalaxies/" + thisFile.strip("pdf.png") + "cdf.png"],\
          size="third", \
          caption="posterior and cumulative posterior in mass range " + \
          mlo + " to " + mhi)
  except:pass
  page.div.close()# close the h3
  
  #---------------------------- loudest events
  page = add_input_h3(page, "loudest events")
  page.div.close()# close the h3

  # the end
  page.div.close()
  page.div.close()
  page.div.close()
  return page

# ***************************************************************************
# ***************************************************************************
def write_tuning(page,opts):
  """
  """
  webdir = opts.webdir
  ini = opts.config_file
  ifos = get_ifos()
  mkdir(opts.physdir+"/tuning")
  page.p(e.br())
  page.div(class_="encadre")
  page.div(class_="contenu")
  page = write_title(page, html_sections['tuning'], "ronsard")
  page.div(id="div_ronsard", style='display:none')
  page.add("This section summarizes the tuning with e-thinca, r-sqaure, chi-square and h1-h2 cuts.<br/>")
  
  #---------------------------- Tuning

  titles = [\
  	"Ethinca",\
	"chisq",\
  	"rsq",\
  	"distance cut"\
	]
  tags = [\
  	'*plotethinca*COINC_CAT_2*',\
	'*plotsnrchi*',\
	'*plotsnrchi*',\
	'*ploteffdistcut*'\
	]
  imagetags=[\
	['andtotMass', 'ethinca_versus_combined'],\
	['chisq_inj_const_lines'],\
	['rsq'],\
	['eff_dist_cut']\
	]
  captions = [\
  	"fix me",\
  	"fix me",\
  	"fix me",\
  	"Fractional differences in effective distance (H1 and H2 detectors). Blue crosses are slided triggers. Red crosses are injection triggers."\
	]
  configs = [	\
	'plotethinca',\
	'plotsnrchi',\
	'plotsnrchi',\
	'ploteffdistcut'\
	]
  images_dirs = ['bbhinj_summary_plots']
  for images_dir in images_dirs:
    for title, tag, caption,config,image_tag in zip(titles, tags, captions, configs,imagetags):
      page = heading(page, title)
      page = add_config_section(page, config)
      page = fom(page, opts, cachefile_tag=tag, caption=caption,\
	 	image_tag=image_tag, directory=images_dir)
      page.div.close() # for each heading 


  # the end
  page.div.close()
  page.div.close()
  page.div.close()
  return page


# ***************************************************************************
# ***************************************************************************
def write_analysis(page,opts, thisSearch='playground'):
  """
  """
  webdir = opts.webdir
  ini = opts.config_file
  ifos = get_ifos()
  mkdir(opts.physdir+"/"+thisSearch)


  page.p(e.br())
  page.div(class_="encadre")
  page.div(class_="contenu")

  if thisSearch=='playground':
    page = write_title(page, html_sections[thisSearch], "hugo")
    images_dir='/playground_summary_plots/'
  else:
    page = write_title(page, html_sections[thisSearch], "hugo")
    images_dir='/analysis_summary_plots/'
  page.div(id="div_hugo", style='display:none')
  page.add("This section summarizes the analysis of the "+thisSearch+" data.<br/>")
  
  #table and venn diagram
  
  try:
    page = heading(page, "General information", "see details here")
    segs = get_segments_tag('SELECTED_SEGS')
    keys = ("segments","H1","H2","L1","G1","V1","T1") 
    page.p("The segment files above were created with no data quality flags set")
    page.p("The times analyzed accoring to hipe are:")
    coincs = get_coincident_segments(thisSearch)  
    ## here is the table. The first column is another table with the durations, 
    page.add("<table><tr><td>\n")
    page.table()
    page.tr();
    page.td('coincidence'); 
    page.td('duration(s)'); 
    page.tr.close()
    for key in coincs.keys():        
      page.tr()
      if thisSearch=='playground':
        file = webdir +'/'+thisSearch +'/'+key+"_play_segs_analyzed.txt"
      else:
        file = webdir +'/'+thisSearch +'/'+key+"_segs_analyzed.txt"
      page.td(e.a(key,href=file))
  
      page.td(coincs.get(key))
      page.tr.close()
    page.table.close()
    page.add("</td>\n")
  except:
    logText(logfile, "Error in generating analysed segments.", "error")
    pass

  try:
    page.add("<td>")
    #create figure for the venn diagram
    data = ""
    for coinc in ("H1","H1H2","H2","H2L1","L1","H1L1","H1H2L1"):
        data = data +coincs.get(coinc) + " "
    create_venn(data, thisSearch)
    # and incorporate into html
    comment = "Venn diagram showing distribution of"
    for coinc in  coincs.keys():
      comment = comment + " "+ coinc
    page = add_figure(page, fnames =[thisSearch+"/venn_"+thisSearch+".png"], caption=comment, size="half")
    page.add("</td></tr></table>")
    page.add("Here below is the detail of the data and ligo-data section of ihope.ini ")
    page = add_config_section(page, "data")
    page = add_config_section(page, "ligo-data")
    page.div.close()  
  except:
    logText(logfile, "Error in generating Venn diagram.", "error")
    pass
 
  
  #---------------------------- the playground pictures
  # title will be the name of the section.
  # tags is a tag to search for the relevant cache file (will use the first one found)
  # imagetags. if not none, will only pu a subset of images corresponding to the list provided. 
  # captions is the text to be written in the caption
  # configs : is not none, the part of the ini file corresponding to this config name will be written in the web page
  titles = [\
  	"Inspiral range plots",\
	"Variation in template bank and triggered template size",\
  	"First inspiral stage",\
  	"First coincidence stage",\
	'Second inspiral stage',\
	'Second thinca step (all ifo combinaison and category 2)'\
	]
  tags = [\
  	'*inspiralrange*',\
	'*plotnumtemplates*',\
	'*plotinspiral_FIRST_*PLAYGROUND*',\
	'*plotthinca_FIRST_*PLAYGROUND*',\
	'*plotinspiral_SECOND_*PLAYGROUND*',\
	'*plotthinca_SECOND_*_PLAYGROUND*CAT_2*'\
	]
  imagetags=[\
	None,\
	None,\
	['snr_vs_time','snr_cum_hist','snr_histogram'],\
	['dummy_on_purpose'],\
	['snr_vs_time','snr_vs_chisq_log','snr_histogram'],\
	['plot_slide_trigs', 'cum_hist_effective_snr']\
	]
  captions = [\
  	""" "Inspiral Horizon distance for a \
       (1.4,1.4) solar mass system with SNR=8 (first sub-figure), and \
       histograms(second sub-figure). The last sub-figure shows the \
       expected horizon distance for any total mass, using an SNR=8."""  ,\
  	"Variation in template bank and triggered template bank size",\
        "Trigger rate at first inspiral stage",\
        "Trigger rate at first coincidence stage",\
	"Trigger rate at second inspiral stage",\
	'Trigger rate at second coincidence stage'\
	]

  comments = [\
  None,\
  None,\
  None,\
  "This section has no images (on purpose). To obtain the first thinca stage images, see the links here below",\
  None,\
  "This section shows the plotthinca results for the category 2 only.  "\
  ]

  configs = [	\
	None,\
	'tmpltbank',\
	'inspiral',\
	'thinca',\
	'veto-inspiral',\
	'thinca-2'\
	]

  for title, tag, caption,config,image_tag,comment in \
        zip(titles, tags, captions, configs, imagetags,comments):
      page = heading(page, title)
      if comment is not None:
        page.p(comment)
      page = add_config_section(page, config)
      page = fom(page, opts, cachefile_tag=tag, caption=caption,\
	 	image_tag=image_tag, directory=images_dir)
      page.div.close() # for each heading


  page = heading(page, "Final COIRE Summary files ")
  
  for eachifo in get_ifo_coinc():
    if len(eachifo)>2:
      file = opts.datadir + '/'+thisSearch+'/'+eachifo+'-COIRE_SUMMARY_SECOND_'+eachifo+'_'+thisSearch.upper() +opts.txt_suffix      
      tmp = open(file, "r")
      this = tmp.read()
      tmp.close()
      page.add( "<p>COIRE Summary file "+eachifo+".<pre>"+file+"<br/>"+this+"</pre></p>")
      # the SLIDE case
      file = opts.datadir + '/'+thisSearch+'/'+eachifo+'-COIRE_SLIDE_SUMMARY_SECOND_'+eachifo+'_'+thisSearch.upper() +opts.txt_suffix      
      tmp = open(file, "r")
      this = tmp.read()
      tmp.close()
      page.add( "<p>COIRE Summary file "+eachifo+" (slide).<pre>"+file+"<br/>"+this+"</pre></p>")


  page.add("All COIRE files are available here <a href=\""+ webdir +'/' +thisSearch+"\">here</a>")
  page.div.close() # for each heading

  #copy all SUMMARY COIRE file 
  command  = "cp "+opts.datadir+'/'+thisSearch+'/'+"*COIRE*SUMMARY*xml* " + opts.physdir+"/"+thisSearch
  make_external_call(command, opts.debug, opts.debug, True)   
 

  page.div.close()#hugo
  page.div.close()#contenu
  page.div.close()#encadre
  return page

# ***************************************************************************
# ***************************************************************************
def write_injection(page, opts):
  """
  """
  webdir = opts.webdir
  ini = opts.config_file
  ifos = get_ifos()
  mkdir(opts.physdir+"/injections")
  page.p(e.br())

  page.div(class_="encadre")
  page.div(class_="contenu")
  page = write_title(page, html_sections['injection'], "baudelaire")
  page.div(id="div_baudelaire", style='display:none')
  page.add("This section summarizes the analysis of the injection runs.<br/>")

  images_dirs=['/bbhinj_summary_plots/']

  
  #---------------------------- the injection section
  # title will be the name of the section.
  # tags is a tag to search for the relevant cache file (will use the first one found)
  # imagetags. if not none, will only pu a subset of images corresponding to the list provided. 
  # captions is the text to be written in the caption
  # configs : is not none, the part of the ini file corresponding to this config name will be written in the web page
  titles = [\
  	"Efficiency, Found and Missed plots (first stage)",\
  	"Closeby missed injections (Second coincidence stage and CAT2)",\
  	"Efficiencies (second stage)",\
  	"Accuracies (Second stage)"\
	]
  tags = [\
  	'*plotinspmissed_FIRST*',\
  	'*plotinspmissed_SECOND*',\
  	'*plotinspmissed_SECOND*',\
  	'*plotinspinj_SECOND*'\
	]
  imagetags=[\
        ['dummy_on_purpose_so_that_no_images_is_passed_to_the_web_page'],\
	['map'],\
        ['efficiency-eff_dist'],\
        ['mchirp_vs_snr_accuracy_scatter_totalmass']
	]
  captions = [\
        "Found and Missed injections links (first stage)",\
	'Found and Missed injections. Effective distance versus chirp mass',\
	'Efficiencies (Second stage)',\
        'Accuracy plots (second stage)'
	]
  configs = [\
        None,\
	'plotinspmissed',\
	'plotinspmissed',\
	'plotinspinj'\
	]

  print titles
  print tags
  print captions
  print configs
  print imagetags

  for images_dir in images_dirs:
    for title, tag, caption,config,image_tag in zip(titles, tags, captions, configs,imagetags):
      print title
      page = heading(page, title)
      page = add_config_section(page, config)
#      page = add_config_section(page, config+-'meta')
      page = fom(page, opts, cachefile_tag=tag, caption=caption,\
	 	image_tag=image_tag, directory=images_dir)
      page.div.close() # for each heading 
      print "done"
 

  page.div.close()
  page.div.close()
  page.div.close()

  return page


def write_about(page, opt):
  webdir = opts.webdir
  page.p(e.br())
  page.div(class_="encadre")
  page.div(class_="contenu")
  page = write_title(page, html_sections['about'], "balzac")
  page.div(id="div_balzac", style='display:none')
  page.p("This page was automatically generated with write_ihope_page using the following ini file")
  tmp  = open(opts.config)
  tmp2 = tmp.read()
  tmp.close() 
  # the < character in a <pre> HTML tag is read and interpreted, So, we need to change it to &lt
  page.pre(tmp2.replace('<', '&lt;'))
 # page.pre(tmp.read())

  page.p("and the following command line arguments:")
  text=""
  for arg in sys.argv[:]:
    text = text +  arg +" "
  page.pre( text )
  
  page.p(__Id__[4:len(__Id__)-5])
  page.div.close()
  page.div.close()
  page.div.close()
  return page


# ***************************************************************************
# ***************************************************************************
def get_numslide(run):
  logText(logfile, opts.datadir + "/" + run + "/inspiral_hipe_" + run )
  return str(29)
  

# ***************************************************************************
# ***************************************************************************
def add_config_section(page, section):
  """
  """
  # section may be empty or set to None
  try:
    ini  = hipecp.items(section)
  except:
    return page

  page.add("<pre>")
  page.add("------------------------------------" +section)
  for i in  ini :
    page.add(i[0]+' = '+i[1])
  page.add("</pre>")
  return page

# ***************************************************************************
# ***************************************************************************
def add_input_h3(page, title):
  """
  """
  #increment block number
  global count_block 
  input=str(count_block)
  count_block=count_block+1

  page.add("<h3> "+title)
  page.input(id="input_"+input, type="checkbox", onclick="toggleVisible('"+input+"')")
  page.add("See details here</h3>")
  page.div(id="div_"+input , style='display:none')  
  return page

def heading(page, title="None", label="Switch details on/off", heading="h3"):
  """
  """
  #increment block number

  global count_block 
  input=str(count_block)
  count_block=count_block+1

  page.add("<"+heading+">"+ title)
#  page.input(id="input_"+input, type="checkbox", onclick="toggleVisible('"+input+"')", size="4")
  text = label 

  page.input(id="input_"+input, type="button", onclick="toggleVisible('"+input+"')", value=text ,class_="toggle")
  page.add("</"+heading+">")
  page.div(id="div_"+input , style='display:none') 


  logText(logfile, '      Enters sub-section: '+title )
  return page 

# ***************************************************************************
# ***************************************************************************
def add_caption(page, caption):
  """
  """
  global fig_num
  page.p("<b>Figure "+str(fig_num) + ":</br> "+caption)
  fig_num = fig_num + 1
  return page

def add_figure(page,fnames="test", caption="add a caption", size="full", alt="no figure found"):
  """
  """
  global fig_num
  dir = opts.webdir
  page.add("<!-- insert a figure -->\n<div class=\"figure\">")
  this_count = 0
  
  for fnam in fnames:
    source=dir+"/"+fnam
    
    title = " title=\""+alt[this_count]+"\""
    page.add("\t<a href=\"" + source.replace("_thumb", "")+"\"" +  title + ">\n" )
    try:
      page.img(class_=size ,src=source, alt=alt[this_count] )
    except:
      page.img(class_=size ,src=source )
      
    page.add("</a>")
    this_count = this_count +1
  page.add("\t<p class=\"figure\">Figure " + str(fig_num) + ":  " + caption + "</p>\n</div>\n\n")
  fig_num +=1

  #check that the file exsits. If not, returns an error message
  return page

# ***************************************************************************
# ***************************************************************************
####
def create_venn(data, tag):
  """
  Create a venn diagram for the 2 or 3 ifos case
  data has to be H1H2 H1 H2L1 H2 H1L1 L1 H1H2L1 array 
  """
  try:
    mscript = open("temp.m", "w")
    mscript.write("data = [")
    mscript.write( data +"];" ) 
    mscript.write(" vennX(data\'/3600/24,0.01);")
    mscript.write(" k=colormap(jet); k = [1 1 1; k];colormap(k); saveas(gcf,\'venn_"+tag+".png\')")
    mscript.close()
    command=("matlab -nodisplay -nodesktop -nojvm -nosplash   < temp.m > /tmp/test ;  rm -f temp.m; mv venn_"+tag+".png "+opts.physdir+"/"+tag+"/")
    if not opts.debug:
      make_external_call(command, opts.debug, opts.debug, True)   
  except:
    logText(logfile, """WARNING   The matlab command to create the venn diagram failed. 
                Check that matlab is properly set,and vennX.m is available
                (see matapps/src/searches/inspiral/matspiral/utilities")  
          """, "error")

# ***************************************************************************
# ***************************************************************************
def sortDict(d):
  """
  """
  items = d.items()
  items.sort()
  return [value for key, value in items]

# ***************************************************************************
# ***************************************************************************
def get_coincident_segments(tag):
  """
  return duration of coincident segments
  """
  ifos = get_ifos()
  thisdata = {}
  thisdata['segments'] = ['duration(days)' ,'duration (s)']
  #duration = str((int(opts.gps_end_time) - int(opts.gps_start_time)))
  output={}
  ifo_coincs = get_ifo_coinc()  

  try:
    for coinc in ifo_coincs:
      if tag=="playground":
        command = "awk \'{sum=sum+$4} END {print sum}\' "+opts.datadir+ tag +"/"+coinc+"_play_segs_analyzed.txt"
      elif tag=="analysis":
        command = "awk \'{sum=sum+$4} END {print sum}\' "+opts.datadir+ tag +"/"+coinc+"_segs_analyzed.txt"

      output[coinc], status = make_external_call(command, False,opts.debug, True)
    logText(logfile, '...Get the analyzed segments duration...')
  except:
    logText(logfile , 'problem(s) while parsnig the coincident segments', "error")

  return output

  


# ***************************************************************************
# ***************************************************************************
def get_segments_tag(tag):
  """
  reads segment files and return table of duration for each ifo
  """
  # some variables
  datadir = opts.datadir
  ifos = get_ifos()
  thisdata = {}
  directory = datadir+'/segments/'
  thisdata['segments'] = ['filename', 'duration(days)' ,'duration (s)']
#  duration = str((int(opts.gps_end_time) - int(opts.gps_start_time)))
  #duration.split('.')

  # the name of the files (except for the ifo)
  this_tag  = '-' + tag + opts.txt_suffix
  if tag=="RDS_C03_L2":
    this_tag  = '_' + tag + opts.txt_suffix

  #reading the segments files and extract the duration
  command = 'awk \'{print NF}\' ' +  datadir +'/segments/' + ifos[1] + this_tag
  try:
    ncols, status = make_external_call(command, False, opts.debug, True)
    ncols = ncols[len(ncols)-2]
    # some files may be empty, so the first line (the comment 
    # which has 5 cols) will be read, which explain the >= and not strict ==. 
    if float(ncols)>=4:  
      for ifo in ifos:
        thisfile = ifo + this_tag
        command = 'awk \'{sum=sum+$4} END {print sum/3600/24}\' ' +  directory + thisfile
        output_days, status = make_external_call(command, False, opts.debug, True)
        command = 'awk \'{sum=sum+$4} END {print sum}\' ' +  directory + thisfile
        output_seconds, status = make_external_call(command, False, opts.debug, True)
        thisdata[ifo] = [thisfile, output_days, output_seconds]
    # unfortunately, right now, there is no standard, so some files have only 2 columns
    elif float(ncols)==2:
      for ifo in ifos:
        thisfile = ifo + this_tag
        command = 'awk \'{sum=sum+$2-$1} END {print sum/3600/24}\' ' +  directory + thisfile
        output_days, status = make_external_call(command,False,opts.debug, True)
        command = 'awk \'{sum=sum+$2-$1} END {print sum}\' ' +  directory + thisfile
        output_seconds, status = make_external_call(command, False, opts.debug, True)
        thisdata[ifo] = [thisfile, output_days, output_seconds]
  except:
    logText(logfile,  'Error while parsing the segment duration files', "error")

  return thisdata


# ***************************************************************************
# ***************************************************************************
def get_ifo_coinc():
  """
  return list of valid coincidences with respect to the ini file
  """
  # get the ifo requested
  ifos = get_ifos()
  # get number of ifos to look at
  numifos = []  
  for option in ["one-ifo","two-ifo","three-ifo","four-ifo", "five-ifo"]:
    if hipecp.has_option("ifo-details",option): 
	tmp = option.split("-")
 	numifos.append(tmp[0])
  # now let us fill the different possible ifo combinaisons
  output = []
  for num in numifos:
    if num=="one":
      for ifo in ifos:
        output.append(ifo)
    elif num=="two":
      for ifo1 in ifos:
        for ifo2 in ifos:
          if ifo1 < ifo2:
            output.append(ifo1+ifo2)
    elif num=="three":
      for ifo1 in ifos:
        for ifo2 in ifos:
          for ifo3 in ifos:
            if ifo1 < ifo2 and ifo2 < ifo3:
              output.append(ifo1+ifo2+ifo3)
    elif num=="four":
      for ifo1 in ifos:
        for ifo2 in ifos:
          for ifo3 in ifos:
            for ifo4 in ifos:
              if ifo1 < ifo2 and ifo2 < ifo3 and ifo3 < ifo4:
                output.append(ifo1+ifo2+ifo3+ifo4)
  return output


  


# ***************************************************************************
# ***************************************************************************
def get_ifos():
  """
  read the ifos used in the ifo-details section of the ihope ini file
  """
  ifos=[] 
  for option in ["g1-data","h1-data","h2-data","l1-data", "v1-data"]:
    if hipecp.has_option("ifo-details",option): ifos.append(option[0:2].upper() )

  return ifos


# ***************************************************************************
# ***************************************************************************
def get_version(executable): 
  """
  search for the tag and version of an executable using the --version argument.
  """
  output=[]
  try:
    # this is surely useless now to make a distinction with trigbank 
    if executable=="trigbank":
      pathname = hipecp.get("condor", "trigbank") 
    else:
      pathname = hipecp.get("condor", executable) 
    s =  os.path.split(pathname)
    if len(s[0])==0:
      cmd = opts.ihope_directory + s[1] + '  --version'
    else:
      cmd = s[1] + ' --version '
    output,status = make_external_call(cmd, opts.debug, opts.debug, True)
  except:  
    output= '(not found)' 
    pass

  output = output.split()
  
  #searching for the tagname, which may be empty(undefined)
  try:
    index=  output.index("Tag:")
    tagname = output[index+2]
    # found the "Tag" string. Is it different from $ ?
    if tagname=="$":
      tagname = ' Undefined tag name.'
    else:
      tagname = ', tag name is '+tagname+'. '
  except:
    tagname = ' Cannot find the tag name'


  #searching for the version, which may be empty(undefined)
  try:
    index=  output.index("Version:")
    version = output[index+3]
    version = 'Version is '+ version +'.'
  except:
    version = '. Undefined version.'

  return tagname+' '+version

# ***************************************************************************
# ***************************************************************************
#### function to copy the segment files in the appropriate directory
def copy_segments():
  """
  This function simply copies the segments list into the web page directory 
  """
  msg =   "Copying segments into the web page directory (in yoururl/segments)"
  logText(logfile, msg)
  # first we create this directory      
  mkdir(opts.physdir+'/segments')

  # parsing the ini file, find the cat file and thenread the ./segments directory
  try:
    location = opts.physdir + '/segments/'
    command = 'cp '+opts.datadir +'/segments/* ' + location
    dummy,status = make_external_call(command, opts.debug, opts.debug, True)
  except:
    logText(logfile, "Could not copy the segment files", "error")
    pass

 #  the selected segment files
  for thisSearch in ['playground', 'full_data']:
    mkdir(opts.physdir+'/'+thisSearch)
    try :
      stdout ='Copying the selected segments files into /'+thisSearch
      for this in get_ifo_coinc():
          if thisSearch=='playground':
            seg = '/'+thisSearch+'/'+this +'_play_segs_analyzed.txt'
          elif thisSearch=='full_data':
            seg = '/'+thisSearch+'/'+this +'_segs_analyzed.txt'
          command = 'cp '+opts.datadir + seg + ' '+opts.physdir+'/' +thisSearch +'/'
          dummy,status = make_external_call(command, opts.debug, opts.debug, True)
          if status>0:
            stdout += " WARNING:: could not copy a selected segment (from playground or full_data directory)"
            break
    except:
      stdout +=" WARNING:: problem while copying a selected segment (from playground or full_data). passing..."    
      logText(logfile,  stdout, "warning")
      pass
    else: 
      logText(logfile,  stdout)

def fom(page, opts, cachefile_tag=None, caption="fix me",\
	 image_tag=None,directory="playground_summary_plots"):
  """
  """

  dir = opts.datadir+'/'+directory+'/' 

  # create the div that will contain the figure 
  page.div(class_="figure")

  # search for the cache file that contain the tag in
  # the directory considered (given as fifth argument)
  thisglob = dir + cachefile_tag +'cache'
  filenames =  glob.glob(thisglob)

  if opts.verbose is True: 
    print "        Searching for files with this(ese) tag(s): " +str(image_tag)

  # and parse this cache files searching for images
  for eachcache in filenames:
    this = open(eachcache, "r")
    fnameList = []
    #for each file in the cachefile
    for filename in this:
      # check that the file is an image ending in png
      validFile = True
      if filename.find('png')<0:
        validFile = False
        
      #if so, keep going if and only if image_tag exists
      if image_tag is not None:
        found = False
        for each_tag in image_tag:          
	  if each_tag in filename :
            if opts.verbose is True : print "        --> Copying " + filename
	    found = True
        if found is False: 
          validFile = False
      # we create a link to the main page only if requested.
      if validFile is True:
        fnameList.append(filename.replace(".png", "_thumb.png"))
      
      if opts.verbose is True : print "        --> Copying files..."
      # however, we still want to copy all the files contained in the cache files 
      command = 'cp ' + dir + filename+' ' +opts.physdir +'/Images/'       
      make_external_call(command.replace("\n", " "), opts.debug, opts.debug, True)
      command = 'cp ' + dir + filename.replace(".png","_thumb.png")+\
		' ' +opts.physdir  + '/Images/' 
      make_external_call(command.replace("\n", " "), opts.debug, opts.debug, True)
    this.close()
    
    this = open(eachcache, "r")
    for filename in this:
      if filename.find('html')>=0:
        command = 'cp ' + dir + filename+' ' +opts.physdir        
        make_external_call(command.replace("\n", " "), opts.debug, opts.debug, True)
        msg =" <a href=\""+filename.replace("/pictures", "")+\
            """\"> <br/><pre> --- <b>Click here</b> to get all pictures (full resolution) 
            as well as the pylal arguments used to generate the plots</a> """
        break
    this.close()
  
    source =  eachcache.split('/') 
    source =  source[len(source)-1]
    page = add_figure(page, fnames=fnameList, \
      caption=(caption+' '+msg+'<br/><b>Source:</b>'+source+"</pre>"), size="third", alt=fnameList)

    this.close()
  page.div.close()

  return page
# ***************************************************************************
# ***************************************************************************
def set_style():
  """
  """
  tmp = []
  tmp.append(configcp.get("main", "style"))
  make_external_call('cp ' + configcp.get("main", "style")+ " " +opts.physdir, opts.debug, opts.debug, True )

  # 10 style file should be allright ;-)
  for i in range(1,10,1):
    try:
      tmp.append (configcp.get("main", "style"+str(i)))    
      make_external_call('cp ' + configcp.get("main", "style"+str(i))+ " " +opts.physdir, opts.debug, opts.debug, True)
    except:
      pass
  style = tmp

  count = 0
  for this in style:
    tmp =  this.split('/')
    style[count] = tmp[len(tmp)-1]
    count = count +1

  return style

# ----------------------------------------------------------------------------
def parse_arguments():
  usage =  """ %prog [options]
  Program to write webpage from upperlimit.py
  """

  parser = OptionParser( usage = usage, version = "%prog CVS "+__Id__ )

  parser.add_option("-C","--config-file",action="store",type="string",\
      metavar=" INI File",\
      help="ini file with information about run directories" )
  parser.add_option("-A","--skip-analysis",action="store_false",\
      default=True,dest="analysis", metavar="DOANALYSIS",\
      help="" )
  parser.add_option("-T","--skip-tuning",action="store_false",\
      default=True,dest="tuning", metavar="DOTUNING",\
      help="" )
  parser.add_option("-U","--skip-upperlimit",action="store_false",\
      default=True,dest="upperlimit", metavar="DOUPPERLIMIT",\
      help="" )
  parser.add_option("-I","--skip-injection",action="store_false",\
      default=True,dest="injection", metavar="DOUPPERLIMIT",\
      help="" )
  parser.add_option("-P","--skip-playground",action="store_false",\
      default=True,dest="playground", metavar="DOPLAYGROUND",\
      help="" )
  parser.add_option("-D","--debug",action="store_true",\
       default=False,dest="debug",metavar="DODEBUG",\
       help="" )
  parser.add_option("-V","--verbose",action="store_true",\
      default=False, dest="verbose",metavar="VERBOSE",\
      help="" )

  (opts,args) = parser.parse_args()

  if opts.config_file is None:
    raise ValueError,\
"""
------------------------------------------------------------------------------
the arguments --config-file must be used and followed by an ini file, an
example of which is  :

[main]
gps-start-time  = 847555570
gps-end-time    = 849974770
title           = "Low mass CBC analysis"
ihope-ini-file  = ihope.ini
ihope-directory = /archive/home/cokelaer/S5/Month1/full_analysis/
home-directory  = /archive/home/
url             = ldas-jobs.ligo.caltech.edu
username        = cokelaer
output          = index.shtml
style           = /archive/home/cokelaer/style.css
"""

  return opts,args

# ----------------------------------------------------------------------------

#try:
#  from glue import markup
#  from markup import oneliner as e
#except: 
#  raise ImportError("Require markup.py to generate the html page")
#
opts,args = parse_arguments()


#############################################################################
#  MAIN PART                                                                #
#############################################################################
fig_num = 1
count_block = 0
config   =  opts.config_file
opts.config = config # save the name of the ini file, why ?
configcp = ConfigParser.ConfigParser()
configcp.read(config)

print >>sys.stdout, "|------------------- Initialisation"
# First, we open an xml file, for the log file
logfile_name = __name__+".xml"
print >>sys.stdout,"Openning the log file (" +logfile_name+")."
logfile = open(logfile_name, "w")
logfile.write("""<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet type="text/xsl" href="write_ihope_page.xsl"?>
<log>""")


#---------------------------------------
# then, we parse the write_ihope_page.ini file
print >>sys.stdout,"Parsing the ini file: " + opts.config
try:
  opts.config_file 	= configcp.get("main", "ihope-ini-file")
  opts.gps_start_time 	= configcp.get("main", "gps-start-time")
  opts.gps_end_time 	= configcp.get("main", "gps-end-time")
  opts.ihope_directory 	= configcp.get("main", "ihope-directory")
  opts.title	 	= configcp.get("main", "title")
  opts.url	 	= configcp.get("main", "url")
  opts.username	 	= configcp.get("main", "username")
  opts.output	 	= configcp.get("main", "output")
  opts.home_directory 	= configcp.get("main", "home-directory")
except:
  print >> sys.stderr, "ERROR::The ini file does not have the proper field in the [main] section" 
  print >> sys.stderr, """       Consider adding one of those fields if missing: ihope-ini-file, \
	gps-start-time,gps-end-time, ihope-directory, title,url, username, output"""
  raise
  
#------------------------------------
#sub-products of the ini file parsing
opts.gpsdir =  '/'+str(opts.gps_start_time)+'-'+str(opts.gps_end_time)+'/'
opts.duration = str(int(opts.gps_end_time) - int(opts.gps_start_time))
opts.webdir = 'http://' + opts.url + '/~' + opts.username  + opts.gpsdir
opts.datadir = opts.ihope_directory + opts.gpsdir
opts.physdir = opts.home_directory+'/'+opts.username+'/public_html/'+ opts.gpsdir
opts.txt_suffix = '-'+opts.gps_start_time+'-'+opts.duration+'.txt'
  
#------------------------------------------------------------------------------------
#read the different css style available and copy the style files in the web directory.
print >>sys.stdout,"Searching for the CSS style"
try:
  opts.style = set_style()
  for this in opts.style:
    print >> sys.stdout, "---Found " + this
except:
  logText(logfile, "Problem with the style file. (either not copied or not found)", "warning")
  raise


#----------------------
# openning the html file
print >>sys.stdout,"Openning the HTML (" + opts.output+")"
try:
  html_file = file(opts.output,"w")
except:
  msg = "Cannot open %" % opts.output
  print >>sys.stderr, msg
  raise


#-----------------------------------------
# here is the directory we want to extract information from
msg = "Entering this directory (where we will get all the relevant information)" + opts.datadir
print >> sys.stdout, msg
if not  os.path.isdir(opts.datadir):
  raise  "%s is not a valid directory. Check your gps time." % opts.datadir
# which physical name is 
msg = "We will copy all images and HTML documents into this directory " +opts.physdir
logText(logfile, msg,"done")
mkdir(opts.physdir)
mkdir(opts.physdir+'/Images')


#-----------------------------------------
# now we can parse the ihope.ini file itself
msg =   "Parsing the ihope ini file (" + opts.config_file+")"
logText(logfile, msg)
hipe   = opts.ihope_directory+'/'+opts.config_file
hipecp = ConfigParser.ConfigParser()
hipecp.read(hipe)
make_external_call( 'cp '+opts.config_file + ' ' + opts.physdir, False, opts.debug, True)

#-----------------------------------------
# now we copy the segments to the web directory and other relevant information
copy_segments()


#-----------------------------------------
###### create the section labels  
html_sections={}
html_order = ['toc', 'general', 'summary', 'playground', 'injection', \
    'tuning', 'analysis', 'upperlimit', 'logfile', 'about']

html_sections['toc'] = "Table of Contents"
html_sections['general'] = "General Information"
html_sections['summary'] = "Data Information"
if opts.playground is True: html_sections['playground']	= "Playground"
if opts.injection is True: html_sections['injection'] = "Injection"
if opts.tuning is True: html_sections['tuning']	= "Tuning"
if opts.analysis is True: html_sections['analysis'] = "Full Data"
if opts.upperlimit is True: html_sections['upperlimit']	= "Upper Limit"
html_sections['logfile'] = "Log File"
html_sections['about'] = "About"


title = opts.title+ ": from "+str(opts.gps_start_time)+" to "+str(opts.gps_end_time) 
script = {}
script['toggle.js'] = 'javascript'
create_toggle()
# Finally, we create the html document 
msg =   "Creating HTML document"
logText(logfile, msg)


# -------------------------------------------- the us now write the web page
page = markup.page(mode="strict_html")
page._escape = False
doctype="""<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">"""
doctype+="""\n<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">"""
page.init(title=title, css=opts.style, script=script , doctype=doctype)
page.h1(opts.title +" (" + opts.gps_start_time +"-" +opts.gps_end_time+")")

for each_section in html_order:
  if each_section in html_sections:
    try:
      logText(logfile, html_sections[each_section], "section")
      page = write_results(page, opts, each_section)
    except:
      logText(logfile, each_section, "section")
      msg = "skipped  "+each_section + " section"
      logText(logfile, msg, "warning")
      print >>sys.stdout, msg
      pass

# end of the different sections
# the valid HTML and CSS footer
page.add("<table><tr><td>")
page.add("<a href=\"http://validator.w3.org/check?uri=referer\">")
page.add("<img src=\"http://validator.w3.org/images/valid_icons/valid-xhtml10\" alt=\"Valid XHTML 1.0!\" height=\"31\" width=\"88\"/></a> ")
page.add("<a href=\"http://jigsaw.w3.org/css-validator/\">")
page.add("<img src=\"http://www.w3.org/Icons/valid-css\" alt=\"Valid CSS!\" height=\"31\" width=\"88\" /></a> ")
page.add("</td></tr></table>")

# what is the False for ? I cannot remenber
html_file.write(page(False))
html_file.close()
# just remove the <html lang="en"> line tat is not a strict HTML code
cmd = 'sed -e \'s/<html lang=\"en\">//\' '+ opts.output + '>/tmp/tmp.html'
output,status = make_external_call(cmd, True, True, False)
if status==0:
  cmd = 'mv /tmp/tmp.html '+opts.output
  make_external_call(cmd, True, True, True)
# that's it for the html creation. 

#let us close the log file
logfile.write("</log>")
logfile.close()

print '---------------------FINISHED ---------------------'
print '--- HTML file created. '
print '--- Copying html documents in ' +opts.physdir
make_external_call('mv  '+opts.output +' ' + opts.physdir, opts.debug, opts.debug, True)
make_external_call( 'mv toggle.js '+ opts.physdir, opts.debug, opts.debug,  True)

logfile = __name__+".xml"
output, status = make_external_call( 'grep WARNING '+ logfile +'| wc - | awk \'{print $1}\' - ', opts.debug, opts.debug, True)

if status==0:
  if int(output)==0:
    print 'No warnings'
  else:
    print '\n\n\nThere are warnings : '+str(int(output))+' . Check the log file '+logfile
  
  output, status = make_external_call('mv '+logfile + " "+opts.physdir, True,True,True) 
else:
  print 'Could not find the log file ' +logfile
  
 
#Finally create the xsl for the log xml file
logfile = open(__name__+".xsl", "w")
logfile.write("""<?xml version="1.0" encoding="ISO-8859-1"?>
<xsl:stylesheet version="1.0"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

<xsl:template match="/">
  <html>
  <body>
  <center><h1>Log file summary </h1></center>
  <xsl:apply-templates/>
  </body>
  </html>
</xsl:template>

<xsl:template match="section">
<h2 color="blue">Section: <xsl:value-of select="."/></h2>
<br />
</xsl:template>

<xsl:template match="done">
<center>
  <div>
    <table bgcolor="green" border="2" width="80%">
      <tr>
        <td width="80%"><xsl:value-of select="."/></td>
        <td bgcolor="white"> passed</td>
      </tr>
    </table>
  </div>
</center>
</xsl:template>
<xsl:template match="warning">
<center>
  <div>
    <table bgcolor="orange" border="2" width="80%">
      <tr>
        <td width="80%"><xsl:value-of select="."/></td>
        <td bgcolor="white"> fix me</td>
      </tr>
    </table>
  </div>
</center>
</xsl:template>
<xsl:template match="error">
<center>
  <div>
    <table bgcolor="red" border="2" width="80%">
      <tr>
        <td width="80%"><xsl:value-of select="."/></td>
        <td bgcolor="white"> skipped</td>
      </tr>
    </table>
  </div>
</center>
</xsl:template>



</xsl:stylesheet>
""")

logfile.close()
output, status = make_external_call('mv '+__name__+".xsl" + " "+opts.physdir, True,True,True) 



