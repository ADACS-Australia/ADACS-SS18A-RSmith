#!@PYTHONPROG@
#
# Copyright (C) 2013  Leo Singer
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
from __future__ import division
from __future__ import print_function
"""
Match sky maps with injections in an inspinjfind-style sqlite database and print
summary values for each sky map:

 * event ID
 * false alarm rate
 * searched area
 * searched posterior probability
 * angle between true sky location and maximum a posteriori estimate
 * runtime in seconds
 * (optional) areas of specified probability contours

The filenames of the sky maps may be provided as positional command line
arguments, and may also be provided as globs (such as '*.fits.gz').
"""
__author__ = "Leo Singer <leo.singer@ligo.org>"


if __name__ == '__main__':
    # Command line interface.
    from optparse import Option, OptionParser
    from lalinference.bayestar import command

    parser = OptionParser(
        formatter=command.NewlinePreservingHelpFormatter(),
        description=__doc__,
        usage="%prog [-o OUTPUT] DATABASE.sqlite FILE1.fits[.gz] FILE2.fits[.gz] ...",
        option_list=[
            Option("-o", "--output", default="/dev/stdout",
                help="Name of output file [default: %default]"),
            Option("-j", "--jobs", default=1, type=int,
                help="Number of threads [default: %default]"),
            Option("-p", "--contour-probability", default=None, action="append", type="float",
                help="Report the area of the smallest contour containing this much probability.  Can be repeated mulitple times")
        ]
    )
    opts, args = parser.parse_args()

    try:
        dbfilename = args[0]
        fitsfileglobs = args[1:]
    except IndexError:
        parser.error("not enough command line arguments")
    if opts.jobs < 1:
        parser.error("invalid value for -j, --jobs: must be >= 1")

    outfile = open(opts.output, "w")


# Imports.
import sqlite3
from lalinference.bayestar import fits
from lalinference.bayestar import postprocess


def startup(dbfilename):
    global db
    db = sqlite3.connect(dbfilename)


def process(fitsfilename):
    sky_map, metadata = fits.read_sky_map(fitsfilename)

    coinc_event_id = metadata['objid']
    try:
        runtime = metadata['runtime']
    except KeyError:
        runtime = None

    simulation_id, true_ra, true_dec, far = db.execute("""
        SELECT DISTINCT sim.simulation_id AS simulation_id, sim.longitude AS ra, sim.latitude AS dec,
        ci.combined_far AS far
        FROM coinc_event_map AS cem1 INNER JOIN coinc_event_map AS cem2
        ON (cem1.coinc_event_id = cem2.coinc_event_id)
        INNER JOIN sim_inspiral AS sim ON (cem1.event_id = sim.simulation_id)
        INNER JOIN coinc_inspiral AS ci ON (cem2.event_id = ci.coinc_event_id)
        WHERE cem1.table_name = 'sim_inspiral'
        AND cem2.table_name = 'coinc_event' AND cem2.event_id = ?""",
        (coinc_event_id,)).fetchone()
    searched_area, searched_prob, offset, prob_areas = postprocess.find_injection(
        sky_map, true_ra, true_dec, prob_contours=opts.contour_probability)

    return [coinc_event_id, simulation_id, far, searched_area, searched_prob, offset, runtime] + prob_areas


if __name__ == '__main__':
    import glob
    import itertools
    import pylal.progress
    progress = pylal.progress.ProgressBar()

    progress.update(-1, 'spawning {0} workers'.format(opts.jobs))
    if opts.jobs == 1:
        from itertools import imap
        startup(dbfilename)
    else:
        import multiprocessing
        imap = multiprocessing.Pool(opts.jobs, startup, (dbfilename,)).imap_unordered

    progress.update(-1, 'obtaining filenames of sky maps')
    fitsfilenames = tuple(itertools.chain.from_iterable(glob.iglob(fitsfileglob)
        for fitsfileglob in fitsfileglobs))

    if opts.contour_probability is not None:
        prob_opts = '\t'.join([str(s)+'_area' for s in opts.contour_probability])
        print('coinc_event_id', 'simulation_id', 'far', 'searched_area', 'searched_prob', 'offset', 'runtime',
            prob_opts, sep="\t", file=outfile)
    else:
        print('coinc_event_id', 'simulation_id', 'far', 'searched_area', 'searched_prob', 'offset', 'runtime',
            sep="\t", file=outfile)

    count_records = 0
    progress.max = len(fitsfilenames)
    for record in imap(process, fitsfilenames):
        count_records += 1
        progress.update(count_records, record[0])
        print(*record, sep="\t", file=outfile)
