/*
 * Copyright (C) 2006 Reinhard Prix
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with with program; see the file COPYING. If not, write to the 
 *  Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
 *  MA  02111-1307  USA
 */


/**
 * \author Reinhard Prix
 * \date 2006
 * \file 
 * \brief Read in MLDC timeseries-files and produce SFTs (v2) for them
 *
 * $Id$
 *
 */

/* ---------- includes ---------- */
#include <lalapps.h>

#include <lal/UserInput.h>
#include <lal/SFTfileIO.h>
#include <lal/TimeSeries.h>
#include <lal/LALStdio.h>

/* lisaXML stuff */
#include "readxml.h"

RCSID ("$Id$");

/** \name Error codes */
/*@{*/
#define LISAMAKESFTS_ENORM 	0
#define LISAMAKESFTS_EINPUT  	1
#define LISAMAKESFTS_EMEM	2
#define LISAMAKESFTS_EFILE	3
#define LISAMAKESFTS_ENULL	4
#define LISAMAKESFTS_ENONULL	5

#define LISAMAKESFTS_MSGENORM 	"Normal exit"
#define LISAMAKESFTS_MSGEINPUT  "Bad argument values"
#define LISAMAKESFTS_MSGEMEM	"Out of memory"
#define LISAMAKESFTS_MSGEFILE	"File input/output error"
#define LISAMAKESFTS_MSGENULL	"Input contained illegal NULL"
#define LISAMAKESFTS_MSGENONULL	"Output container non-NULL"

/*@}*/

/*---------- DEFINES ----------*/
#define TRUE    (1==1)
#define FALSE   (1==0)

#define LISA_START_GPS	1261872014	/**< arbitrary start GPS time for LISA-timeseries: Jan 1, 2020 [hey! let's be optimistic here!] */

/*----- Macros ----- */
/*---------- internal types ----------*/

/*---------- empty initializers ---------- */
static const LALStatus empty_status;
static const LIGOTimeGPS empty_LIGOTimeGPS;
static const LALUnit empty_LALUnit;
/*---------- Global variables ----------*/

/* User variables */
BOOLEAN uvar_help;
CHAR *uvar_extraComment;
CHAR *uvar_descriptionMisc;
CHAR *uvar_outputDir;
CHAR *uvar_inputXML;

/*---------- internal prototypes ----------*/
void initUserVars (LALStatus *status);
void ConvertLISAtimeseries2LAL ( LALStatus *status, MultiREAL4TimeSeries **lalTimeSeries, const TimeSeries *lisaTimeSeries );

/*==================== FUNCTION DEFINITIONS ====================*/

/*----------------------------------------------------------------------
 * main function 
 *----------------------------------------------------------------------*/
int
main(int argc, char *argv[]) 
{
  LALStatus status = empty_status;	/* initialize status */
  CHAR *add_comment = NULL;
  REAL8TimeSeries *Xt, *Yt, *Zt;
  TimeSeries *lisaTimeSeries;		/* lisaXML timeseries-type */
  MultiREAL4TimeSeries *multiTs = NULL;	/* LAL-equivalent: hold 3 timeseries (X(t), Y(t), Z(t)) */
  lalDebugLevel = 0;

  /* set LAL error-handler */
  lal_errhandler = LAL_ERR_EXIT;	/* exit with returned status-code on error */
  
  /* set debug level */
  LAL_CALL (LALGetDebugLevel (&status, argc, argv, 'v'), &status);

  /* register all user-variables */
  LAL_CALL (initUserVars (&status), &status);	  

  /* read cmdline & cfgfile  */	
  LAL_CALL (LALUserVarReadAllInput (&status, argc,argv), &status);  

  if (uvar_help) 	/* help requested: we're done */
    exit (0);

  /* load xml-file and corresponding binary-data into lisaXML-type 'TimeSeries' */
  if ( (lisaTimeSeries = getTDIdata(uvar_inputXML)) == NULL ) {
    fprintf (stderr, "\nlisaXML::getTDIdata() failed for file '%s'\n\n",  uvar_inputXML );
    return LISAMAKESFTS_EFILE;
  }

  /* convert lisaXML::TimeSeries -> LAL::REAL4TimeSeries */
  LAL_CALL ( ConvertLISAtimeseries2LAL ( &status, &multiTs, lisaTimeSeries ), &status );

  /* build up full comment-string to be added to SFTs: 1) generated by LISAmakeSFTs + RCSID + cmdline 2) user extraComment */
  {
    UINT4 len;
    CHAR *logstr = NULL;

    LAL_CALL ( LALUserVarGetLog ( &status, &logstr,  UVAR_LOGFMT_CMDLINE ), &status );
    len = 512 + strlen ( logstr );
    if ( uvar_extraComment )
      len += strlen ( uvar_extraComment );

    if ( ( add_comment = LALCalloc ( 1, len ) ) == NULL ) {
      LALPrintError ( "\nOut of memory!\n");
      return LISAMAKESFTS_EMEM;
    }
    sprintf ( add_comment, "Generated by $Id$:\n%s", logstr );
    if ( uvar_extraComment )
      {
	strcat ( add_comment, "\n");
	strcat ( add_comment, uvar_extraComment );
      }
  } /* construct comment-string */

  /* free memory */
  LALFree ( add_comment );
  LAL_CALL (LALDestroyUserVars (&status), &status);

  LALCheckMemoryLeaks(); 

  return 0;
} /* main */


/*----------------------------------------------------------------------*/
/* register all our "user-variables" */
void
initUserVars (LALStatus *status)
{
  INITSTATUS( status, "initUserVars", rcsid );
  ATTATCHSTATUSPTR (status);

  /* set defaults */
#define DEFAULT_OUTDIR  "./"
  uvar_outputDir = LALCalloc ( 1, strlen ( DEFAULT_OUTDIR + 1) );
  strcpy ( uvar_outputDir, DEFAULT_OUTDIR );

  uvar_extraComment = NULL;
  uvar_descriptionMisc = NULL;

  /* now register all our user-variable */
  LALregSTRINGUserVar(status, outputDir,	'o', UVAR_OPTIONAL, "Output directory for SFTs");
  LALregSTRINGUserVar(status, extraComment,	'C', UVAR_OPTIONAL, "Additional comment to be added to output-SFTs");
  LALregSTRINGUserVar(status, descriptionMisc,	'D', UVAR_OPTIONAL, "'Misc' entry in the SFT filename description-field");
  LALregSTRINGUserVar(status, inputXML,		'i', UVAR_REQUIRED, "XML file describing the LISA timeseries data");
  
  LALregBOOLUserVar(status,   help,		'h', UVAR_HELP,     "Print this help/usage message");
  
  DETATCHSTATUSPTR (status);
  RETURN (status);

} /* initUserVars() */

/** Convert a lisaXML 'TimeSeries' into a LAL MultiREAL4TimeSeries */
void
ConvertLISAtimeseries2LAL ( LALStatus *status, MultiREAL4TimeSeries **lalTs, const TimeSeries *lisaTs )
{
  UINT4 nIFOs, i;
  MultiREAL4TimeSeries *ret = NULL;
  const CHAR *filename;

  INITSTATUS( status, "ConvertLISAtimeseries2LAL", rcsid );
  ATTATCHSTATUSPTR (status);

  ASSERT ( lalTs, status, LISAMAKESFTS_ENULL, LISAMAKESFTS_MSGENULL );
  ASSERT ( *lalTs == NULL, status, LISAMAKESFTS_ENONULL, LISAMAKESFTS_MSGENONULL );
  ASSERT ( lisaTs, status, LISAMAKESFTS_ENULL, LISAMAKESFTS_MSGENULL );

  nIFOs = (UINT4) lisaTs->Records;
  if ( nIFOs == 0 || nIFOs == 1 ) {
    ABORT ( status,  LISAMAKESFTS_EINPUT,  LISAMAKESFTS_MSGEINPUT );
  }
  nIFOs --; /* first lisa-timeseries is just timesteps */

  filename = lisaTs->FileName;

  /* alloctate LAL container */
  if ( (ret = LALCalloc ( 1, sizeof ( MultiREAL4TimeSeries ) )) == NULL ) {
    ABORT ( status, LISAMAKESFTS_EMEM, LISAMAKESFTS_MSGEMEM );
  }
  if ( (ret->data = LALCalloc ( nIFOs, sizeof ( REAL4TimeSeries* ) )) == NULL ) {
    LALFree ( ret );
    ABORT ( status, LISAMAKESFTS_EMEM, LISAMAKESFTS_MSGEMEM );    
  }
  ret->length = nIFOs;

  /* allocate and convert individual timeseries X, Y, Z */
  for ( i=0; i < nIFOs; i ++ )
    {
      UINT4 l;
      CHAR name[LALNameLength];
      LIGOTimeGPS epoch = { LISA_START_GPS, 0 };
      REAL8 f0 = 0;	/* no heterodyning */
      LALUnit units = empty_LALUnit;

      DataColumn *thisTs = lisaTs->Data[i+1];	/* skip first column: timesteps */
      REAL8 deltaT = thisTs->Cadence;
      size_t length = (size_t) thisTs->Length;

      /* Naming-convention: channel = {X1, X2, X3} + ts-name + filename */
      LALSnprintf ( name, LALNameLength, "X%d:%s:%s", i+1, thisTs->Name, lisaTs->FileName );
      name[LALNameLength-1] = 0; /* close string if it was truncated */

      epoch.gpsSeconds += lisaTs->TimeOffset + thisTs->TimeOffset;

      if ( ( ret->data[i] = XLALCreateREAL4TimeSeries ( name, &epoch, f0, deltaT, &units, length )) == NULL )
	goto failed;

      /* now cast + copy all the data */
      for ( l=0; l < length; l ++ )
	ret->data[i]->data->data[l] = (REAL4) thisTs->data[l];

    } /* for i < nIFOs */

  /* ok: return final multiTimeSeries */
  (*lalTs) = ret;

  DETATCHSTATUSPTR (status);
  RETURN (status);

 failed:
  /* free all memory allocated */
  for ( i=0; i < nIFOs; i ++ )
    if ( ret->data[i] ) XLALDestroyREAL4TimeSeries ( ret->data[i] );
  if ( ret->data ) LALFree ( ret->data );
  if ( ret ) LALFree ( ret );

  ABORT ( status, LISAMAKESFTS_EMEM, LISAMAKESFTS_MSGEMEM );    

} /* ConvertLISAtimeseries2LAL() */
