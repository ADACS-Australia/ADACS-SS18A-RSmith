/*
 * Copyright (C) 2006 Reinhard Prix
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with with program; see the file COPYING. If not, write to the 
 *  Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
 *  MA  02111-1307  USA
 */


/**
 * \author Reinhard Prix
 * \date 2006
 * \file 
 * \brief Read in MLDC timeseries-files and produce SFTs (v2) for them
 *
 * $Id$
 *
 */

/* ---------- includes ---------- */
#include <stdio.h>


#include <lalapps.h>

#include <lal/UserInput.h>
#include <lal/SFTfileIO.h>
#include <lal/TimeSeries.h>

RCSID ("$Id$");

/** \name Error codes */
/*@{*/
#define LISAMAKESFTS_ENORM 	0
#define LISAMAKESFTS_EINPUT  	1
#define LISAMAKESFTS_EMEM	2
#define LISAMAKESFTS_EFILE	3

#define LISAMAKESFTS_MSGENORM 	"Normal exit"
#define LISAMAKESFTS_MSGEINPUT  "Bad argument values"
#define LISAMAKESFTS_MSGEMEM	"Out of memory"
#define LISAMAKESFTS_MSGEFILE	"File input/output error"

/*@}*/

/*---------- DEFINES ----------*/
#define TRUE    (1==1)
#define FALSE   (1==0)

/*----- Macros ----- */
/*---------- internal types ----------*/

/*---------- empty initializers ---------- */
static const LALStatus empty_status;
static const LIGOTimeGPS empty_LIGOTimeGPS;

/*---------- Global variables ----------*/

/* User variables */
BOOLEAN uvar_help;
CHAR *uvar_extraComment;
CHAR *uvar_descriptionMisc;
CHAR *uvar_outputDir;
CHAR *uvar_inputTimeseries;

/*---------- internal prototypes ----------*/
void initUserVars (LALStatus *status);
void read_TDI_observables (LALStatus *status, REAL8TimeSeries **Xt, REAL8TimeSeries **Yt, REAL8TimeSeries **Zt, const CHAR *fname );
static long get_file_len ( FILE *fp );

/*==================== FUNCTION DEFINITIONS ====================*/

/*----------------------------------------------------------------------
 * main function 
 *----------------------------------------------------------------------*/
int
main(int argc, char *argv[]) 
{
  LALStatus status = empty_status;	/* initialize status */
  CHAR *add_comment = NULL;
  REAL8TimeSeries *Xt, *Yt, *Zt;

  lalDebugLevel = 0;

  /* set LAL error-handler */
  lal_errhandler = LAL_ERR_EXIT;	/* exit with returned status-code on error */
  
  /* set debug level */
  LAL_CALL (LALGetDebugLevel (&status, argc, argv, 'v'), &status);

  /* register all user-variables */
  LAL_CALL (initUserVars (&status), &status);	  

  /* read cmdline & cfgfile  */	
  LAL_CALL (LALUserVarReadAllInput (&status, argc,argv), &status);  

  if (uvar_help) 	/* help requested: we're done */
    exit (0);

  Xt = Yt = Zt = NULL;
  LAL_CALL ( read_TDI_observables ( &status, &Xt, &Yt, &Zt, uvar_inputTimeseries ), &status );


  /* build up full comment-string to be added to SFTs: 1) generated by LISAmakeSFTs + RCSID + cmdline 2) user extraComment */
  {
    UINT4 len;
    CHAR *logstr = NULL;

    LAL_CALL ( LALUserVarGetLog ( &status, &logstr,  UVAR_LOGFMT_CMDLINE ), &status );
    len = 512 + strlen ( logstr );
    if ( uvar_extraComment )
      len += strlen ( uvar_extraComment );

    if ( ( add_comment = LALCalloc ( 1, len ) ) == NULL ) {
      LALPrintError ( "\nOut of memory!\n");
      return LISAMAKESFTS_EMEM;
    }
    sprintf ( add_comment, "Generated by $Id$:\n%s", logstr );
    if ( uvar_extraComment )
      {
	strcat ( add_comment, "\n");
	strcat ( add_comment, uvar_extraComment );
      }
  } /* construct comment-string */

  /* free memory */
  LALFree ( add_comment );
  LAL_CALL (LALDestroyUserVars (&status), &status);

  LALCheckMemoryLeaks(); 

  return 0;
} /* main */


/*----------------------------------------------------------------------*/
/* register all our "user-variables" */
void
initUserVars (LALStatus *status)
{
  INITSTATUS( status, "initUserVars", rcsid );
  ATTATCHSTATUSPTR (status);

  /* set defaults */
#define DEFAULT_OUTDIR  "./"
  uvar_outputDir = LALCalloc ( 1, strlen ( DEFAULT_OUTDIR + 1) );
  strcpy ( uvar_outputDir, DEFAULT_OUTDIR );

  uvar_extraComment = NULL;
  uvar_descriptionMisc = NULL;

  /* now register all our user-variable */
  LALregSTRINGUserVar(status, outputDir,	'o', UVAR_OPTIONAL, "Output directory for SFTs");
  LALregSTRINGUserVar(status, extraComment,	'C', UVAR_OPTIONAL, "Additional comment to be added to output-SFTs");
  LALregSTRINGUserVar(status, descriptionMisc,	'D', UVAR_OPTIONAL, "'Misc' entry in the SFT filename description-field");
  LALregSTRINGUserVar(status, inputTimeseries,	'i', UVAR_REQUIRED, "Input filename containing LISA timeseries (t,X,Y,Z)");
  
  LALregBOOLUserVar(status,   help,		'h', UVAR_HELP,     "Print this help/usage message");
  
  DETATCHSTATUSPTR (status);
  RETURN (status);

} /* initUserVars() */


/** Given the XML file describing the timeseries data, read it into REAL8TimeSeries, 
 * allocated in here 
 */
void 
read_TDI_observables (LALStatus *status, REAL8TimeSeries **Xt, REAL8TimeSeries **Yt, REAL8TimeSeries **Zt, const CHAR *xmlfname )
{
  FILE *fp;
  CHAR *binfname;
  CHAR *xmldata;
  long filelen;
  size_t read;
  REAL8TimeSeries *X, *Y, *Z;
  const LIGOTimeGPS epoch = {0, 0};

  INITSTATUS( status, "read_TDI_observables", rcsid );
  ATTATCHSTATUSPTR (status);

  /* ----- first parse the xml-file to get some important params ----- */
  if ( (fp = fopen ( xmlfname, "rb" ) ) == NULL ) {
    ABORT ( status, LISAMAKESFTS_EFILE, LISAMAKESFTS_MSGEFILE );
  }
  if ( (filelen = get_file_len ( fp )) <= 0 ) {
    fclose(fp);
    ABORT ( status, LISAMAKESFTS_EFILE, LISAMAKESFTS_MSGEFILE );
  }
  if ( (xmldata = LALCalloc ( 1, filelen + 1 ) ) == NULL ) {
    fclose(fp);
    ABORT ( status, LISAMAKESFTS_EMEM, LISAMAKESFTS_MSGEMEM );
  }
  if (  (read = fread ( xmldata, 1, filelen, fp )) != filelen ) {
    fprintf (stderr, "Failed to read xml-file '%s'\n", xmlfname );
    goto failed;
  }


  fclose ( fp );

  DETATCHSTATUSPTR (status);
  RETURN (status);

 failed:
  fclose(fp);
  LALFree ( xmldata );
  XLALDestroyREAL8TimeSeries ( X );
  XLALDestroyREAL8TimeSeries ( Y );
  XLALDestroyREAL8TimeSeries ( Z );


} /* read_TDI_Observables() */



/* portable file-len function */
static long get_file_len ( FILE *fp )
{
  long save_fp;
  long len;

  if ( (save_fp = ftell(fp)) == -1 )
    return 0;
  
  if ( fseek ( fp, 0, SEEK_END ) == -1 )
    return 0;

  len = ftell(fp);

  if ( fseek ( fp, save_fp, SEEK_SET ) == -1 )
    return 0;

  return len;

} /* get_file_len() */
