
#Key to terminology: 
#BLKs: The input blocks of frequency domain data (e.g., from SFTs). 
#STKs: The BLK data is stacked up and turned in STKs. 
#SUMs: The STKs are slid and then summed to produce SUMs; 

#Example command line arguments for ComputeStackSlide: 

#(Note that sampleRate is not used in the StackSlide analysis; it is included to note deltaT and the Nyquist frequency.)
set gpsStartTimeSec                  714153733; #1  UINT4 analysis start time sec at the detector. 
set gpsStartTimeNan                          0; #2  UNIT4 analysis start time nan at the detector. 
set sampleRate          4.0960000000000000e+03; #3  REAL8 time domain sample rate (deltaT = 1/sampleRate). 
set params->duration    6.0000000000000000e+02; #4  REAL8 analysis duration 

set numBLKs                                 10; #5  INT4 input number of blocks of data (e.g., actual number of SFTs used in this job). 
set tBLK                6.0000000000000000e+01; #6  REAL8 time baseline of input BLKs (e.g., of SFTs). 
set tEffBLK             6.0000000000000000e+01; #7  REAL8 effective time baseline of input BLKs (e.g., not tBLK if oversampling used). 
set f0BLK               1.0095000000000000e+03; #8  REAL8 start frequency of the input BLKs. 
set bandBLK             2.3999999999999999e+00; #9  REAL8 frequency band of input BLKs. 
set nBinsPerBLK                            144; #10 INT4 number of frequency bins one BLKs. 

set numBLKsPerSTK                            1; #11 INT4 number BLKs used to make one STK. 
set tEffSTK             6.0000000000000000e+01; #12 REAL8 effective time baseline of STKs (deltaF = 1/tEffSTK). 
set f0STK               1.0095000000000000e+03; #13 REAL8 start frequency of STKs. 
set bandSTK             2.3999999999999999e+00; #14 REAL8 frequency band of STKs. 
set nBinsPerSTK                            144; #15 INT4 number of frequency bins in one STK. 

set numSTKsPerSUM                           10; #16 INT4 number of STKs used to make one SUM. 
set tEffSUM             6.0000000000000000e+01; #17 REAL8 effective time baseline of SUMs (deltaF = 1/tEffSUM). 
set f0SUM               1.0102000000000000e+03; #18 REAL8 start frequency of SUMs. 
set bandSUM             1.0000000000000000e+00; #19 REAL8 frequency band of SUMs. 
set nBinsPerSUM                             60; #20 INT4 number of frequency bins in one SUM. 

set ifoNickName                             G1; #21 CHAR* H2, H1, L1, or G1. 
set IFO                                    GEO; #22 CHAR* LHO, LLO, or GEO. 
set patchName                       testPulsar; #23 CHAR* a name to identify this search (e.g., S2 Galactic Center).
set patchNumber                              0; #24 INT4 a number to identify this search. 

set tDomainChannel               G1:LSC-AS_Q; #25 CHAR* time domain channel name that produced BLKs. 
set fDomainChannel                    input; #26 CHAR* freq domain channel name of BLKs 

set inputDataTypeFlag                        0; #27 INT2 input data type. 
# Note that 0 = SFTs is only type currently supported value. 

set parameterSpaceFlag                       0; #28 INT2 how to generate parameter space. 
# Note that 0 is the only currently supported value; this causes code to use command line arguments below to generate sky positions uniformly on the sphere and spindowns without using parameter space metric. 

set stackTypeFlag                            0; #29 INT2 how to generate STKs from BLKs. 
set Dterms                                  32; #30 INT4 number of terms for Dirichlet kernel (for STKs = F-stat only). 
# Note that 0 means stacks are PSDs from SFTs (the only option currently support); 1 means stacks are F-statistic from SFTs. 

set thresholdFlag                            1; #31 INT2 how to apply the thresholds. 
set threshold1          2.7999999523162842e+00; #32 REAL4 peak found if power is above this. 
set threshold2          1.0700000524520874e+00; #33 REAL4 peak ends if power drops below this. 
set threshold3          2.0000000298023224e-01; #34 REAL4 ratio peak height to valley depth that indicates a new peak rather than subpeak in a cluster. 
set threshold4          0.0000000000000000e+00; #35 REAL4 unused (except when params->testFlag & 2 > 0; see below).
set threshold5          0.0000000000000000e+00; #36 REAL4 unused (except when params->testFlag & 1 > 0; see below).
set maxWidthBins                             3; #37 REAL4 maximum width in bins. 
#The thresholdFlag rules are: 
# if (params->thresholdFlag <= 0) do not analyze SUMs for peaks about threshold,
# if (params->thresholdFlag > 0) analyze SUMs for peaks above threshold,
# if (params->thresholdFlag & 2 > 0) find peaks above threshold with width less than maxWidthBins; else find peaks above threshold of any width,
# if (params->thresholdFlag & 4 > 0) ignore overlap events within maxWidthBins of edge of SUM band (useful when overlapping adjacent search bands by 2*maxWidthBins),
# if (params->thresholdFlag & 8 > 0) then update pw_mean_thissum, pw_stddev_thissum, pwr_snr ignoring peak bins.

set calibrationFlag                         -1; #38 INT2 whether to calibrate input data (< 0 already done, 0 no, 1 yes). 
# Note that < 0 and 0 are only options currently supported. 

set weightFlag                               0; #39 INT2 whether to weight BLKs with beam pattern response (currently unused). 

set windowFilterFlag                         0; #40 INT2 whether to window or filter data (< 0 already done, 0 no, 1 yes) 
# Note that < 0 and 0 are only options currently supported. 

set normalizationFlag                        4; #41 INT2 what normalization to do. 
set f0NRM               1.0095000000000000e+03; #42 REAL8 frequency to start with when finding norms. 
set bandNRM             2.3999999999999999e+00; #43 REAL8 frequency band to use when finding norms. 
set nBinsPerNRM                             50; #44 INT4 number of frequency bins to use when finding norms. 
set normalizationParameter  0.0000000000000000e+00; #45 REAL4 see uses below. 
#The thresholdFlag rules are: 
# if (params->normalizationFlag & 2) > 0 normalize BLKs else normalize STKs, 
# if (params->normalizationFlag & 4) > 0 normalize STKs using running median, 
# if (params->normalizationFlag & 8) > 0 normalize with veto on power above normalizationParameter = max_power_allowed/mean_power.
# if (params->normalizationFlag & 16) > 0 then output into .Sh file GPS startTime and PSD estimate for each SFT.

set testFlag                                 0; #46 INT2 specify test case.
# if ((testFlag & 1) > 0) output Hough number counts instead of power; use threshold5 for Hough cutoff.
# if ((testFlag & 2) > 0) inject fake signals and run Monte Carlo Simulation; use threshold4 for h_0.
# if ((testFlag & 4) > 0) use LALComputeSkyAndZeroPsiAMResponse and LALFastGeneratePulsarSFTs instead of LALGeneratePulsarSignal and LALSignalToSFTs during Monte Carlo Simulations. See LAL inject package.

set numSUMsPerCall                           1; #47 INT4 nuber of SUMs to produce each call to StackSlide (currently unused). 

set outputSUMFlag                            2; #48 INT2 whether to output SUMs e.g., in ascii. 
#The outputSUMFlag rules are: 
# if (outputSUMFlag <= 0) do not output any SUMs,
# if (outputSUMFlag > 0) output ascii files with sums (if ComputeStackSlide sums compiled with ascii output enabled; see preprocessor flags),
# if ((outputSUMFlag & 2) > 0) output frequency and power into ascii sum files; else output power only. 

set outputEventFlag                          2; #49 INT2 determines xml output of process, event, and summary tables. 
set keepThisNumber                           1; #50 INT4 how many events to keep (used when keeping loudest events). 
#The outputEventFlag rules: 
# if (outputEventFlag <= 0) do not output xml file,
# if (outputEventFlag > 0) output xml file.
# if (((outputEventFlag & 2) > 0) && (keepThisNumber > 0)) keep only keepThisNumber loudest events based on this criteria: 
#  keep the loudest event for every eventBandWidth = params->bandSUM/keepThisNumber, which is the same as, 
#  keep the loudest event for every nBinsPerOutputEvent = params->nBinsPerSUM/keepThisNumber; 
#  thus if keepThisNumber == 1 then we only output the loudest event; if keepThisNumber == nBinsPerSUM we output the loudest event for every bin.
# if ((outputEventFlag & 4) > 0) the loudest event from each template (i.e., each sky position and set of spindown parameters) is output. 

set startRA             0.0000000000000000e+00; #51 REAL8 start right ascension in radians. 
set stopRA              0.0000000000000000e+00; #52 REAL8 end right ascension in radians. 
set deltaRA             0.0000000000000000e+00; #53 REAL8 delta right ascension in radians. 
set numRA                                    1; #54 INT4 number of right ascensions for DEC = 0.  
#Note that for each DEC deltaRA = deltaRA/cos(DEC) is used to cover interval [stopRA stopRA). 

set startDec            0.0000000000000000e+00; #55 REAL8 start declination in radians. 
set stopDec             0.0000000000000000e+00; #56 REAL8 end declination in radians. 
set deltaDec            0.0000000000000000e+00; #57 REAL8 delta declination in radians. 
set numDec                                   1; #58 INT4 number of declinations. 
#Note that DECs are generated by DEC = startDec + i*deltaDec for i = 0 to numDec - 1. 

set numSpinDown                              0; #59 INT4 number of nonzero spindown parameters. 
#Note when numSpinDown > 0 that derivs are generated by FDerivN = startFDerivN + i*deltaFDerivN for i = 0 to numFDerivN - 1. 

set startFDeriv1        0.0000000000000000e+00; #60 REAL8 start 1st deriv of freq in Hz/s. 
set stopFDeriv1         0.0000000000000000e+00; #61 REAL8 end 1st deriv of freq in Hz/s. 
set deltaFDeriv1        0.0000000000000000e+00; #62 REAL8 delta 1st deriv of freq in Hz/s. 
set numFDeriv1                               0; #63 INT4 number 1st derivs of freq. 

set startFDeriv2        0.0000000000000000e+00; #64 REAL8 start 2nd deriv of freq in Hz/s^2. 
set stopFDeriv2         0.0000000000000000e+00; #65 REAL8 end 2nd deriv of freq in Hz/s^2. 
set deltaFDeriv2        0.0000000000000000e+00; #66 REAL8 delta 2nd deriv of freq in Hz/s^2. 
set numFDeriv2                               0; #67 INT4 number 2nd derivs of freq. 

set startFDeriv3        0.0000000000000000e+00; #68 REAL8 start 3rd deriv of freq in Hz/s^3. 
set stopFDeriv3         0.0000000000000000e+00; #69 REAL8 end 3rd deriv of freq in Hz/s^3. 
set deltaFDeriv3        0.0000000000000000e+00; #70 REAL8 delta 3rd deriv of freq in Hz/s^3. 
set numFDeriv3                               0; #71 INT4 number of 3rd derivs of freq. 

set startFDeriv4        0.0000000000000000e+00; #72 REAL8 start 4th deriv of freq in Hz/s^4. 
set stopFDeriv4         0.0000000000000000e+00; #73 REAL8 end 4th deriv of freq in Hz/s^4. 
set deltaFDeriv4        0.0000000000000000e+00; #74 REAL8 delta 4th deriv of freq in Hz/s^4. 
set numFDeriv4                               0; #75 INT4 number of 4th derivs of freq. 

set startFDeriv5        0.0000000000000000e+00; #76 REAL8 start 5th deriv of freq in Hz/s^5. 
set stopFDeriv5         0.0000000000000000e+00; #77 REAL8 end 5th deriv of freq in Hz/s^5. 
set deltaFDeriv5        0.0000000000000000e+00; #78 REAL8 delta 5th deriv of freq in Hz/s^5. 
set numFDeriv5                               0; #79 INT4 number of 5th derivs of freq. 

set sunEdatFile          sun00-04.dat; #80 CHAR* name of ascii file with sun ephemeris data. 
set earthEdatFile      earth00-04.dat; #81 CHAR* name of ascii file with earth ephemeris data. 

set sftDirectory       ../*SFT.*; #82 CHAR* path and pattern to match to find input data. 

set outputFile         myout.txt; #83 CHAR* name of output file (.xml is appended to this name for xml output). 

set debugOptionFlag                          1; #84 INT2 debugging information to print to stdout. 
# if (debugOptionFlag & 1) > 0 then print command line arguments.
# if (debugOptionFlag & 2) > 0 then print table with events.
# if (debugOptionFlag & 4) > 0 then print sky positions with debugging information.
