
#Key to terminology: 
#BLKs: The input blocks of frequency domain data (e.g., from SFTs). 
#STKs: The BLK data is stacked up and turned in STKs. 
#SUMs: The STKs are slid and then summed to produce SUMs; 

#For historical reasons, parameters for controlling Monte Carlo Simulations occur in several places.
#See: maxMCinterations, maxMCfracErr, orientationAngle, cosInclinationAngle, testFlag, numMCInjections, numMCRescalings, rescaleMCFraction, parameterMC, and debugOptionFlag.

#Example command line arguments for ComputeStackSlide: 

set gpsEpochStartTimeSec               731210229; #1  UINT4 GPS seconds at the detector giving SSB epoch reference time.
set gpsEpochStartTimeNan                       0; #2  UINT4 GPS nanoseconds at the detector giving SSB epoch reference time.
set gpsStartTimeSec                    731210229; #3  UINT4 analysis GPS start-time seconds at the detector. 
set params->duration      1.8000000000000000e+04; #4  REAL8 analysis duration 

set numBLKs                                 10; #5  INT4 input number of blocks of data (e.g., actual number of SFTs used in this job). 
set tBLK                1.8000000000000000e+03; #6  REAL8 time baseline of input BLKs (e.g., of SFTs). 
set tEffBLK             1.8000000000000000e+03; #7  REAL8 effective time baseline of input BLKs (e.g., not tBLK if oversampling used). 
set f0BLK               3.0011000000000001e+02; #8  REAL8 start frequency of the input BLKs. 
set bandBLK             1.7999999999999999e-01; #9  REAL8 frequency band of input BLKs. 
set nBinsPerBLK                            324; #10 INT4 number of frequency bins one BLKs. 

set numBLKsPerSTK                            1; #11 INT4 number BLKs used to make one STK. 
set tEffSTK             1.8000000000000000e+03; #12 REAL8 effective time baseline of STKs (deltaF = 1/tEffSTK). 
set f0STK               3.0011000000000001e+02; #13 REAL8 start frequency of STKs. 
set bandSTK             1.7999999999999999e-01; #14 REAL8 frequency band of STKs. 
set nBinsPerSTK                            324; #15 INT4 number of frequency bins in one STK. 

set numSTKsPerSUM                           10; #16 INT4 number of STKs used to make one SUM. 
set tEffSUM             1.8000000000000000e+03; #17 REAL8 effective time baseline of SUMs (deltaF = 1/tEffSUM). 
set f0SUM               3.0017500000000001e+02; #18 REAL8 start frequency of SUMs. 
set bandSUM             5.0000000000000003e-02; #19 REAL8 frequency band of SUMs. 
set nBinsPerSUM                             90; #20 INT4 number of frequency bins in one SUM. 
#Since the entire frequency band slides together, bandSUM cannot exceed 1.0/((v_Earth/c)_max*tEffSTK),
#where (v_Earth/c)_max =  1.0600000000000000e-04 

set ifoNickName                             H1; #21 CHAR* H2, H1, L1, or G1. 
set IFO                                    LHO; #22 CHAR* LHO, LLO, or GEO. 
set patchName                       testPulsar; #23 CHAR* a name to identify this search (e.g., S2 Galactic Center).

set maxMCinterations                         1; #24 INT4 maximum number of times to iterate entire Monte Carlo Simulation when converging on desired confidence. 

set priorResultsFile     None; #25 CHAR* file with the loudest event and estimated UL from a prior step in the pipeline. 
set parameterSpaceFile   None; #26 CHAR* file with parameter space data 

set maxMCfracErr     5.0000000000000001e-03; #27 REAL8 maximum fractional error allowed when testing for convergence of confidence when iterating Monte Carlo. 

set parameterSpaceFlag                       0; #28 INT2 how to generate parameter space. 
#The parameterSpaceFlag options are: 
# if params->parameterSpaceFlag >= 0 generate sky positions uniformly on the sphere and spindowns without using parameter space metric.
# if (params->parameterSpaceFlag & 1 > 0) rotate skyPosData into coordinates with Earth's average acceleration at the pole.
# if (params->parameterSpaceFlag & 2) > 0 rotate skyPosData into galactic plane.

set stackTypeFlag                            0; #29 INT2 how to generate STKs from BLKs. 
set Dterms                                  32; #30 INT4 number of terms for Dirichlet kernel (for STKs = F-stat only). 
# Note that 0 means stacks are PSDs from SFTs (the only option currently support); 1 means stacks are F-statistic from SFTs. 

set thresholdFlag                            1; #31 INT2 how to apply the thresholds. 
set threshold1          2.7999999523162842e+00; #32 REAL4 peak found if power is above this. 
set threshold2          1.0700000524520874e+00; #33 REAL4 peak ends if power drops below this. 
set threshold3          2.0000000298023224e-01; #34 REAL4 ratio peak height to valley depth that indicates a new peak rather than subpeak in a cluster. 
set threshold4          0.0000000000000000e+00; #35 REAL4 unused (except when params->testFlag & 2 > 0; see below).
set threshold5          0.0000000000000000e+00; #36 REAL4 unused (except when params->testFlag & 1 > 0 or params->weightFlag & 8 > 0; see below).
set maxWidthBins                             3; #37 REAL4 maximum width in bins. 
#The thresholdFlag rules are: 
# if (params->thresholdFlag <= 0) do not analyze SUMs for peaks about threshold,
# if (params->thresholdFlag > 0) analyze SUMs for peaks above threshold,
# if (params->thresholdFlag & 2 > 0) find peaks above threshold with width less than maxWidthBins; else find peaks above threshold of any width,
# if (params->thresholdFlag & 4 > 0) ignore overlap events within maxWidthBins of edge of SUM band (useful when overlapping adjacent search bands by 2*maxWidthBins),
# if (params->thresholdFlag & 8 > 0) then update pw_mean_thissum, pw_stddev_thissum, pwr_snr ignoring peak bins.

set weightFlag                               0; #38 INT2 how to weight STKs. 
#The weightFlag rules are: 
# if (params->weightFlag & 1 > 0) use powerFlux style weights; must using running median (see normalizationFlag rules),
# if (params->weightFlag & 2 > 0) include beam pattern F_+ in calculation of weights,
# if (params->weightFlag & 4 > 0) include beam pattern F_x in calculation of weights,
# if (params->weightFlag & 8 > 0) rescale STKs with threshold5 to prevent dynamic range issues.

set orientationAngle     0.0000000000000000e+00; #39 REAL8 orientation angle in radians used to find F_+ and F_x when used to weight STKs or if using fixed polarization for a Monte Carlo Simulation. 
set cosInclinationAngle  0.0000000000000000e+00; #40 REAL8 cosine inclination angle if using fixed value for a Monte Carlo Simulation. 

set normalizationFlag                        4; #41 INT2 what normalization to do. 
set f0NRM               3.0011000000000001e+02; #42 REAL8 frequency to start with when finding norms. 
set bandNRM             1.7999999999999999e-01; #43 REAL8 frequency band to use when finding norms. 
set nBinsPerNRM                             50; #44 INT4 number of frequency bins to use when finding norms. 
set normalizationParameter  0.0000000000000000e+00; #45 REAL4 see uses below. 
#The normalizationFlag rules are: 
# if (params->normalizationFlag & 2) > 0 normalize BLKs else normalize STKs, 
# if (params->normalizationFlag & 4) > 0 normalize STKs using running median (or use medians when weightFlag > 0), 
# if (params->normalizationFlag & 8) > 0 normalize with veto on power above normalizationParameter = max_power_allowed/mean_power.
# if (params->normalizationFlag & 16) > 0 then output into .Sh file GPS startTime and PSD estimate for each SFT.
# if (params->normalizationFlag & 32) > 0 then ignore bins using info in linesAndHarmonicsFile.
# if (params->normalizationFlag & 64) > 0 then clean SFTs using info in linesAndHarmonicsFile before normalizing.
# Note that the (params->normalizationFlag & 32) > 0 and (params->normalizationFlag & 64) > 0 options can be set independently.

set testFlag                                 0; #46 INT2 specify test case.
# if ((testFlag & 1) > 0) output Hough number counts instead of power; use threshold5 for Hough cutoff.
# if ((testFlag & 2) > 0) inject fake signals and run Monte Carlo Simulation; use threshold4 for h_0.
# if ((testFlag & 4) > 0) use LALComputeSkyAndZeroPsiAMResponse and LALFastGeneratePulsarSFTs instead of LALGeneratePulsarSignal and LALSignalToSFTs during Monte Carlo Simulations. See LAL inject package.
# if ((testFlag & 8) > 0) use fixed orientationAngle and cosInclinationAngle set above during Monte Carlo Simulations.
# if ((testFlag & 16) > 0) use results from prior jobs in the pipeline and report on current Monte Carlo results.
# if ((testFlag & 32) > 0) iterate entire Monte Carlo Simulation to converge on desired confidence.
# The prior results must be given in the priorResultsFile set above.
# The maximum number of iterations is given by maxMCinterations set above.
# The maximum fractional error allowed when testing for convergence of confidence when iterating the Monte Carlo is set by maxMCfracErr above.
# The loudest event, upper limits and confidence are reported in the searchresults_stackslidemontecarlo table in the xml file.

set linesAndHarmonicsFile None; #47 CHAR* file with instrument line and harmonic spectral disturbances data.

set outputSUMFlag                            2; #48 INT2 whether to output SUMs e.g., in ascii. 
#The outputSUMFlag rules are: 
# if (outputSUMFlag <= 0) do not output any SUMs,
# if (outputSUMFlag > 0) output ascii files with sums (if ComputeStackSlide sums compiled with ascii output enabled; see preprocessor flags),
# if ((outputSUMFlag & 2) > 0) output frequency and power into ascii sum files; else output power only. 

set outputEventFlag                          2; #49 INT2 determines xml output of process, event, and summary tables. 
set keepThisNumber                           1; #50 INT4 how many events to keep (used when keeping loudest events). 
#The outputEventFlag rules: 
# if (outputEventFlag <= 0) do not output xml file,
# if (outputEventFlag > 0) output xml file.
# if (((outputEventFlag & 2) > 0) && (keepThisNumber > 0)) keep only keepThisNumber loudest events based on this criteria: 
#  keep the loudest event for every eventBandWidth = params->bandSUM/keepThisNumber, which is the same as, 
#  keep the loudest event for every nBinsPerOutputEvent = params->nBinsPerSUM/keepThisNumber; 
#  thus if keepThisNumber == 1 then we only output the loudest event; if keepThisNumber == nBinsPerSUM we output the loudest event for every bin.
# if ((outputEventFlag & 4) > 0) the loudest event from each template (i.e., each sky position and set of spindown parameters) is output. 

set startRA             0.0000000000000000e+00; #51 REAL8 start right ascension in radians. 
set stopRA              0.0000000000000000e+00; #52 REAL8 end right ascension in radians. 
set deltaRA             0.0000000000000000e+00; #53 REAL8 delta right ascension in radians. 
set numRA                                    1; #54 INT4 number of right ascensions for DEC = 0.  
#Note that for each DEC deltaRA = deltaRA/cos(DEC) is used to cover interval [stopRA stopRA). 

set startDec            0.0000000000000000e+00; #55 REAL8 start declination in radians. 
set stopDec             0.0000000000000000e+00; #56 REAL8 end declination in radians. 
set deltaDec            0.0000000000000000e+00; #57 REAL8 delta declination in radians. 
set numDec                                   1; #58 INT4 number of declinations. 
#Note that DECs are generated by DEC = startDec + i*deltaDec for i = 0 to numDec - 1. 

set numSpinDown                              1; #59 INT4 number of nonzero spindown parameters. 
#Note when numSpinDown > 0 that derivs are generated by FDerivN = startFDerivN + i*deltaFDerivN for i = 0 to numFDerivN - 1. 

set startFDeriv1        0.0000000000000000e+00; #60 REAL8 start 1st deriv of freq in Hz/s. 
set stopFDeriv1         0.0000000000000000e+00; #61 REAL8 end 1st deriv of freq in Hz/s. 
set deltaFDeriv1        0.0000000000000000e+00; #62 REAL8 delta 1st deriv of freq in Hz/s. 
set numFDeriv1                               1; #63 INT4 number 1st derivs of freq. 

set startFDeriv2        0.0000000000000000e+00; #64 REAL8 start 2nd deriv of freq in Hz/s^2. 
set stopFDeriv2         0.0000000000000000e+00; #65 REAL8 end 2nd deriv of freq in Hz/s^2. 
set deltaFDeriv2        0.0000000000000000e+00; #66 REAL8 delta 2nd deriv of freq in Hz/s^2. 
set numFDeriv2                               0; #67 INT4 number 2nd derivs of freq. 

set startFDeriv3        0.0000000000000000e+00; #68 REAL8 start 3rd deriv of freq in Hz/s^3. 
set stopFDeriv3         0.0000000000000000e+00; #69 REAL8 end 3rd deriv of freq in Hz/s^3. 
set deltaFDeriv3        0.0000000000000000e+00; #70 REAL8 delta 3rd deriv of freq in Hz/s^3. 
set numFDeriv3                               0; #71 INT4 number of 3rd derivs of freq. 

set startFDeriv4        0.0000000000000000e+00; #72 REAL8 start 4th deriv of freq in Hz/s^4. 
set stopFDeriv4         0.0000000000000000e+00; #73 REAL8 end 4th deriv of freq in Hz/s^4. 
set deltaFDeriv4        0.0000000000000000e+00; #74 REAL8 delta 4th deriv of freq in Hz/s^4. 
set numFDeriv4                               0; #75 INT4 number of 4th derivs of freq. 

set numMCInjections                          0; #76 INT4 number of Monte Carlo injections to do when (testFlag & 2) > 0.
set numMCRescalings                          0; #77 INT4 number of times to rescale signal injection to run multiple Monte Carlo simulations in parallel. 
set rescaleMCFraction   0.0000000000000000e+00; #78 REAL8 fraction to change injected amplitude by with each rescaling. 
set parameterMC         0.0000000000000000e+00; #79 REAL8 unused Monte Carlo parameter. 

set sunEdatFile          sun00-04.dat; #80 CHAR* name of ascii file with sun ephemeris data. 
set earthEdatFile      earth00-04.dat; #81 CHAR* name of ascii file with earth ephemeris data. 

set sftDirectory       ../*SFT.*; #82 CHAR* path and pattern to match to find input data. 

set outputFile         myout.txt; #83 CHAR* name of output file (.xml is appended to this name for xml output). 

set debugOptionFlag                          1; #84 INT2 debugging information to print to stdout. 
# if (debugOptionFlag & 1) > 0 then print command line arguments.
# if (debugOptionFlag == 1) then print command line arguments and abort!
# if (debugOptionFlag & 2) > 0 then print table with events (isolated case only).
# if (debugOptionFlag & 4) > 0 then print sky positions with debugging information.
# if (debugOptionFlag & 8) > 0 then the STK bin with max power is set to 1, all other to 0.
# if (debugOptionFlag & 16) > 0 also set to 1 one bin to either side of the bin with maxPwr.
# if (debugOptionFlag & 32) > 0 print Monte Carlo Simulation results to stdout.
# if (debugOptionFlag & 128) > 0 creates SUMs from the STKs without sliding (isolated case only).
# Use of the debugOptionFlag provides an easy way to validate the StackSlide code! 
# For fake data with a signal and no noise, run on the exact template for the signal with the 
# debugOptionFlag bit for 8, or 8 and 16, set. The StackSlide power should equal the number of SFTs,
# to within ~4 percent, for debugOptionFlag & 8 > 0 and exactly equal this for debugOptionFlag & 24 > 0.
