	/** SSE version from Akos */

#ifdef __GNUC__
        {

          COMPLEX8 XSums __attribute__ ((aligned (16))); /* sums of Xa.re and Xa.im for SSE */
	  REAL4 kappa_s = kappa_star; /* single precision version of kappa_star */

	  static REAL4 *scd = &(sincosLUTdiff[0]);
	  static REAL4 *scb = &(sincosLUTbase[0]);
	  static REAL4 M1 = -1.0f;
	  static REAL8 sincos_adds = 402653184.0;
	  REAL8 tmp;
          REAL8 _lambda_alpha = -lambda_alpha;
          /* vector constants */
          /* having these not aligned will crash the assembler code */
#define ALIGNED_VECTOR(name) static REAL4 name[4] __attribute__ ((aligned (16)))
          ALIGNED_VECTOR(D2222) = {2.0f, 2.0f, 2.0f, 2.0f};
	  ALIGNED_VECTOR(D1100) = {1.0f, 1.0f, 0.0f, 0.0f};
	  ALIGNED_VECTOR(D3322) = {3.0f, 3.0f, 2.0f, 2.0f};
	  ALIGNED_VECTOR(D5544) = {5.0f, 5.0f, 4.0f, 4.0f};
	  ALIGNED_VECTOR(D7766) = {7.0f, 7.0f, 6.0f, 6.0f};
	  ALIGNED_VECTOR(Daabb) = {-1.0f, -1.0f, -2.0f, -2.0f};
	  ALIGNED_VECTOR(Dccdd) = {-3.0f, -3.0f, -4.0f, -4.0f};
	  ALIGNED_VECTOR(Deeff) = {-5.0f, -5.0f, -6.0f, -6.0f};
	  ALIGNED_VECTOR(Dgghh) = {-7.0f, -7.0f, -8.0f, -8.0f};

	  /* hand-coded SSE version from Akos */

	  /* one loop iteration as a macro */

#ifdef EAH_HOTLOOP_INTERLEAVED
/* Macros to interleave linear sin/cos calculation (in x87 opcodes)
   with SSE hotloop.*/

/* Version 1 : with trimming of input argument 
   to [0,2) */ 
#define LIN_SIN_COS_TRIM_P0A(alpha) \
		"fldl %[" #alpha "] \n\t"   /* st: alpha */ \
		"fistpll %[tmp] \n\t"	    /* tmp=(INT8)(round((alpha)) */ \
		"fld1 \n\t" 	            /* st: 1.0 */ \
		"fildll %[tmp] \n\t"        /* st: 1.0;(round((alpha))*/ 

#define LIN_SIN_COS_TRIM_P0B(alpha)\
		"fsubrp %%st,%%st(1) \n\t"  /* st: 1.0 -round(alpha) */  \
		"faddl %[" #alpha "] \n\t"  /* st: alpha -round(alpha)+1.0*/ \
		"faddl  %[sincos_adds]  \n\t" /* ..continue lin. sin/cos as lebow */ \
		"fstpl  %[tmp]    \n\t" 
/* Version 2 : assumes input argument is already trimmed */ 
		
#define LIN_SIN_COS_P0(alpha) \
		"fldl %[" #alpha "] \n\t"     /*st:alpha */\
		"faddl  %[sincos_adds]  \n\t" /*st:alpha+A */\
		"fstpl  %[tmp]    \n\t"
#define LIN_SIN_COS_P1 \
		"mov  %[tmp],%%eax \n\t"      /* alpha +A ->eax (ix)*/ \
                "mov  %%eax,%%edx  \n\t"      /* n  = ix & SINCOS_MASK2 */\
		"and  $0x3fff,%%eax \n\t"     	
#define LIN_SIN_COS_P2 \
		"mov  %%eax,%[tmp] \n\t"     \
		"mov  %[scd], %%eax \n\t"    \
		"and  $0xffffff,%%edx \n\t"   /* i  = ix & SINCOS_MASK1;*/
#define LIN_SIN_COS_P3 \
		"fildl %[tmp]\n\t" \
		"sar $0xe,%%edx \n\t"        /*  i  = i >> SINCOS_SHIFT;*/\
		"fld %%st  \n\t"   	     /* st: n; n; */
#define LIN_SIN_COS_P4 \
		"fmuls (%%eax,%%edx,4)   \n\t" \
		"mov  %[scb], %%edi \n\t" \
		"fadds (%%edi,%%edx,4)   \n\t" /*st:sincosLUTbase[i]+n*sincosLUTdiff[i]; n*/
#define LIN_SIN_COS_P5(sin)\
		"add $0x100,%%edx \n\t"   /*edx+=SINCOS_LUT_RES/4*/\
		"fstps %[" #sin "] \n\t"  /*(*sin)=sincosLUTbase[i]+n*sincosLUTdiff[i]*/\
		"fmuls (%%eax,%%edx,4)   \n\t"
#define LIN_SIN_COS_P6(cos) \
		"fadds (%%edi,%%edx,4)   \n\t" \
		"fstps %[" #cos "] \n\t" /*(*cos)=cosbase[i]+n*cosdiff[i];*/

	
#else
#define LIN_SIN_COS_TRIM_P0A(alpha) ""
#define LIN_SIN_COS_TRIM_P0B(alpha) ""
#define LIN_SIN_COS_P0(alpha) ""
#define LIN_SIN_COS_P1 ""
#define LIN_SIN_COS_P2 "" 
#define LIN_SIN_COS_P3 ""
#define LIN_SIN_COS_P4(sin) ""
#define LIN_SIN_COS_P5(cos) ""		

	  SINCOS_2PI_TRIMMED ( &s_alpha, &c_alpha, kappa_star );

          SINCOS_TRIM_X (_lambda_alpha,_lambda_alpha);
#endif /* EAH_HOTLOOP_INTERLEAVED */
          __asm __volatile
	    (
		"movaps %[D7766],%%xmm0\n\t"
		"movaps %[D5544],%%xmm1	\n\t"
		"movups (%[Xa]),%%xmm2	\n\t"
		"movups 0x10(%[Xa]),%%xmm3 \n\t"
		"movss  %[kappa_s],%%xmm7\n\t"
		"shufps $0x0,%%xmm7,%%xmm7\n\t"
	LIN_SIN_COS_P0(kappa_star)
		"addps  %%xmm7,%%xmm0\n\t"
		"addps  %%xmm7,%%xmm1\n\t"
		"rcpps  %%xmm0,%%xmm0\n\t"
		"rcpps  %%xmm1,%%xmm1\n\t"
		"mulps  %%xmm2,%%xmm0\n\t"
		"mulps  %%xmm3,%%xmm1\n\t"
	LIN_SIN_COS_P1
		"addps  %%xmm1,%%xmm0\n\t"
		"movaps %[D3322],%%xmm2\n\t"
		"movaps %[Dccdd],%%xmm3\n\t"
		"movups 0x20(%[Xa]),%%xmm4\n\t"
		"movups 0x50(%[Xa]),%%xmm5\n\t"
	LIN_SIN_COS_P2
		"addps  %%xmm7,%%xmm2\n\t"
		"addps  %%xmm7,%%xmm3\n\t"
		"rcpps  %%xmm2,%%xmm2\n\t"
		"rcpps  %%xmm3,%%xmm3\n\t"
		"mulps  %%xmm4,%%xmm2\n\t"
		"mulps  %%xmm5,%%xmm3\n\t"
	LIN_SIN_COS_P3
		"addps  %%xmm3,%%xmm2\n\t"
		"movaps %[Deeff],%%xmm4\n\t"
		"movaps %[Dgghh],%%xmm5\n\t"
		"movups 0x60(%[Xa]),%%xmm1\n\t"
		"movups 0x70(%[Xa]),%%xmm6\n\t"
	LIN_SIN_COS_P4
		"addps  %%xmm7,%%xmm4\n\t"
		"addps  %%xmm7,%%xmm5\n\t"
		"rcpps  %%xmm4,%%xmm4\n\t"
		"rcpps  %%xmm5,%%xmm5\n\t"
		"mulps  %%xmm1,%%xmm4\n\t"
		"mulps  %%xmm6,%%xmm5\n\t"
	LIN_SIN_COS_P5(sin)
		"addps  %%xmm2,%%xmm0\n\t"
		"addps  %%xmm5,%%xmm4\n\t"
		"movaps %[D1100],%%xmm1\n\t"
		"movaps %[Daabb],%%xmm2\n\t"
	LIN_SIN_COS_P6(cos)
		"addps  %%xmm7,%%xmm1\n\t"
		"addps  %%xmm7,%%xmm2\n\t"
		"rcpps  %%xmm1,%%xmm5\n\t"
		"rcpps  %%xmm2,%%xmm6\n\t"
	LIN_SIN_COS_TRIM_P0A(_lambda_alpha)
		"addps  %%xmm4,%%xmm0\n\t"
		"movaps %[D2222],%%xmm3\n\t"
		"movaps %[D2222],%%xmm4\n\t"
		"mulps  %%xmm5,%%xmm1\n\t"
		"mulps  %%xmm6,%%xmm2\n\t"
	LIN_SIN_COS_TRIM_P0B(_lambda_alpha)
		"subps  %%xmm1,%%xmm3\n\t"
		"subps  %%xmm2,%%xmm4\n\t"
		"mulps  %%xmm3,%%xmm5\n\t"
		"mulps  %%xmm4,%%xmm6\n\t"
		"movups 0x30(%[Xa]),%%xmm1\n\t"
		"movups 0x40(%[Xa]),%%xmm2\n\t"
	LIN_SIN_COS_P1
		"mulps  %%xmm5,%%xmm1\n\t"
		"mulps  %%xmm6,%%xmm2\n\t"
		"addps  %%xmm1,%%xmm0\n\t"
		"addps  %%xmm2,%%xmm0\n\t"
	LIN_SIN_COS_P2
		"movhlps %%xmm0,%%xmm1\n\t"
		"addps  %%xmm1,%%xmm0\n\t"

/*	  
        c_alpha-=1.0f;
	  realXP = s_alpha * XSums.re - c_alpha * XSums.im;
	  imagXP = c_alpha * XSums.re + s_alpha * XSums.im;
*/

		"movss %[M1],%%xmm5 \n\t"
		"movaps %%xmm0,%%xmm3 \n\t"
		"shufps $1,%%xmm3,%%xmm3 \n\t"	
	LIN_SIN_COS_P3
		"movss %[cos],%%xmm2 \n\t"
		"movss %[sin],%%xmm1 \n\t"
		"addss %%xmm5,%%xmm2 \n\t"	
		"movss %%xmm2,%%xmm6 \n\t"	
	LIN_SIN_COS_P4
		"movss %%xmm1,%%xmm5  \n\t"
		"mulss %%xmm0,%%xmm1 \n\t"		
		"mulss %%xmm0,%%xmm2 \n\t"

	LIN_SIN_COS_P5(Qimag)
		"mulss %%xmm3,%%xmm5 \n\t"
		"mulss %%xmm3,%%xmm6 \n\t"
		"addss %%xmm5,%%xmm2 \n\t"
		"subss %%xmm6,%%xmm1 \n\t"
	LIN_SIN_COS_P6(Qreal)
		"MOVSS	%%xmm2,%[XPimag]   	\n\t"	/*  */
		"MOVSS	%%xmm1,%[XPreal]   	\n\t"	/*  */

	     /* interface */
	     :
	     /* output  (here: to memory)*/
	     [XPreal]      "=m" (realXP),
	     [XPimag]      "=m" (imagXP),
	     [Qreal]      "=m" (realQ),
	     [Qimag]      "=m" (imagQ),
	     [sin]	  "=m" (s_alpha),
	     [cos]	  "=m" (c_alpha),
	     [tmp]        "=m" (tmp)

	     :
	     /* input */
	     [Xa]          "r"  (Xalpha_l),
	     [kappa_s]     "m"  (kappa_s),
	     [kappa_star]  "m"  (kappa_star),
	     [_lambda_alpha] "m" (_lambda_alpha),
	     [scd]	   "m"  (scd),
	     [scb]	   "m"  (scb),
	     [sincos_adds] "m"  (sincos_adds),
	     [M1]	  "m" (M1),


	     /* vector constants */
	     [D2222]       "m"  (D2222[0]),
	     [D1100]       "m"  (D1100[0]),
	     [D3322]       "m"  (D3322[0]),
	     [D5544]       "m"  (D5544[0]),
	     [D7766]       "m"  (D7766[0]),
	     [Daabb]       "m"  (Daabb[0]),
	     [Dccdd]       "m"  (Dccdd[0]),
	     [Deeff]       "m"  (Deeff[0]),
	     [Dgghh]       "m"  (Dgghh[0])

	     :
	     /* clobbered registers */
	     "xmm0","xmm1","xmm2","xmm3","xmm4","xmm5","xmm6","xmm7","st","st(1)","st(2)","eax","edx","edi","cc"
	     );

	  /* moved the sin/cos call down here to avoid the store/forward stall of Core2s */

	  /* NOTE: sin[ 2pi (Dphi_alpha - k) ] = sin [ 2pi Dphi_alpha ], therefore
	   * the trig-functions need to be calculated only once!
	   * We choose the value sin[ 2pi(Dphi_alpha - kstar) ] because it is the 
	   * closest to zero and will pose no numerical difficulties !
	   */

	}
#else /* __GNUC__ */
	{
	  __declspec(align(16)) static struct { REAL4 a,b,c,d; } v0011 = {0.0, 0.0, 1.0, 1.0};
	  __declspec(align(16)) static struct { REAL4 a,b,c,d; } v2222 = {2.0, 2.0, 2.0, 2.0};
  	  __declspec(align(16)) COMPLEX8 STn; 
	
	  REAL4 kappa_m = kappa_max; /* single precision version of kappa_max */
	      
	  /* prelude */
	  __asm {
 	      mov      esi , Xalpha_l                 /* Xal = Xalpha_l         */
	      movss    xmm2, kappa_m                  /* pn[0] = kappa_max      */
	      movlps   xmm1, MMWORD PTR [esi]         /* STnV = Xal ...         */
	      movhps   xmm1, MMWORD PTR [esi+8]       /* ... continued          */
	      shufps   xmm2, xmm2, 0                  /* pn[3]=pn[2]=pn[1]=pn[0]*/
	      movaps   xmm4, XMMWORD PTR v2222        /* xmm4 = V2222           */
	      subps    xmm2, XMMWORD PTR v0011        /* pn[2]-=1.0; pn[3]-=1.0 */
	      movaps   xmm0, xmm2                     /* qn = pn                */
	      };

	  /* one loop iteration as a macro */
#define VEC_LOOP_AV(a,b)\
	  { \
	      __asm movlps   xmm3, MMWORD PTR [esi+a] /* Xai = Xal[a]  ...*/\
	      __asm movhps   xmm3, MMWORD PTR [esi+b] /* ... continued    */\
	      __asm subps    xmm2, xmm4		      /* pn   -= V2222    */\
	      __asm mulps    xmm3, xmm0		      /* Xai  *= qn       */\
	      __asm mulps    xmm1, xmm2		      /* STnV *= pn       */\
	      __asm mulps    xmm0, xmm2		      /* qn   *= pn       */\
	      __asm addps    xmm1, xmm3		      /* STnV += Xai      */\
	      }

	  /* seven macro calls i.e. loop iterations */
	  VEC_LOOP_AV(16,24);
	  VEC_LOOP_AV(32,40);
	  VEC_LOOP_AV(48,56);
	  VEC_LOOP_AV(64,72);
	  VEC_LOOP_AV(80,88);
	  VEC_LOOP_AV(96,104);
	  VEC_LOOP_AV(112,120);

	  /* four divisions and summing in SSE, then write out the result */
	  __asm {
	      divps    xmm1, xmm0                     /* STnV      /= qn       */
	      movhlps  xmm4, xmm1                     /* / STnV[0] += STnV[2] \ */
	      addps    xmm4, xmm1                     /* \ STnV[1] += STnV[3] / */
	      movlps   STn, xmm4                      /* STn = STnV */
	      };

	  /* NOTE: sin[ 2pi (Dphi_alpha - k) ] = sin [ 2pi Dphi_alpha ], therefore
	   * the trig-functions need to be calculated only once!
	   * We choose the value sin[ 2pi(Dphi_alpha - kstar) ] because it is the 
	   * closest to zero and will pose no numerical difficulties !
	   */
	  SINCOS_2PI_TRIMMED( &s_alpha, &c_alpha, kappa_star );

	  c_alpha -= 1.0f;

	  realXP = s_alpha * STn.re - c_alpha * STn.im;
	  imagXP = c_alpha * STn.re + s_alpha * STn.im;
	     
	}
#endif /* __GNUC__ */

#ifndef EAH_HOTLOOP_INTERLEAVED
      {
	REAL8 _lambda_alpha = -lambda_alpha;
	SINCOS_TRIM_X (_lambda_alpha,_lambda_alpha);
	SINCOS_2PI_TRIMMED( &imagQ, &realQ, _lambda_alpha );
      }
#endif
