<html>
<body>
<h1>Checkpointing the TopList</h1>
<hr>
Bernd Machenschalk

<br><br>

<br><h2>Requirements</h2>
<p>
The HierarchicalSearch scans the whole sky point by point.
After finishing the analysis for a particular skypoint,
the candidates that have been found are put into a "toplist"
that keeps track of the n top rated canditates of the
analysis of all skypoints so far.
</p><p>
Without checkpointing this list is written to a file after all
skypoints had been looked at. Up to that moment, this toplist
is kept in RAM only.
</p><p>
Checkpointing should allow this process to be interrupted and
picked up at reasonable points in the middle of the analysis run,
(e.g. after every sky position) so that not much time is lost. It therefore
should provide a way to externally (i.e. in a file on disk) store
information about the state of the analysis (e.g. loop counters).
In particular it needs to provide an external representation
of the toplist of candidates, that is consistant with the
toplist in memory at any time. This file should not grow arbitrary
large, there should be possibility to limit its size during the
analysis run. Checkpointing code also needs to provide support for
picking up from a previously written checkpoint, i.e. restore the
toplist and loop counters from the checkpoint. As the application
is meant to run on potentially unattended or faulty machines,
broken checkpoint information should be detected and dealt with appropriately.
</p><p>
The modifications necessary for the checkpointing to the main
program should be kept to a minimum to not affect readability and
maintainability.
</p>


<br><h2>Solution Outline</h2>

<ul><li>
The external representation of the toplist is a file that has a
format similar to that of the final output file. It is referred
to as "previous output" or "checkpointed file".
</li><br><li>
The checkpointing code periodically writes a "checkpoint file".
It contains the current value of the skypoint loop counter,
the total number of skypoints of the current analysis run,
the current sky location, a checksum of the current checkpointed
file, and the lenght of the file the checksum refers to.
</li><br><li>
The function that inserts a candidate into the toplist (in memory)
should indicate whether it actually inserted the candidate or neglected
it because it is "smaller" than the "smallest" element of the list.
</li><br><li>
When a candidate is actually inserted into the toplist,
it is also appended to the "previous output" file. Simply reading
this file line by line and inserting each line / candidate into an 
initailly empty toplist then results in a toplist equal to that
at time of writing the last checkpoint.
</li><br><li>
A local file buffer is assigned to the "previous output" that is
flushed just before writing a new checkpint. This ensures that
the file is never shorter than what the information in the
checkpoint file referrs to, while minimizing the necessary disk
accesses (e.g. for laptops with appropriate settings of time
between checkpoints).
</li><br><li>
With the method mentioned above, the "previous output" file
would be growing continously with every candidate that's inserted
into the toplist (and thus appended to the file).
To avoid this, the file is "compacted", i.e.
effectively overwritten by a new, clean dump of the current
toplist, when the filesize reaches a certain limit. To ensure
consistency with the checkpoint on disk this is done when writing a
checkpoint, and not when adding a candidate to the output file.
</li><br><li>
The interface of the funtions that make up the checkpointed 
version of the toplist is compatible to the functions that
manipulate the non-checkpointing toplist, so one can simply
replace the non-checkpointing toplist functions with their
checkpointing pendants in the calling program to get a
checkpointig application. Information needed beyond what's
available in the toplist function interfaces is kept locally
to the module the checkpoint functions are implemented in
(hs_boinc_extras).
</li><br><li>
The list is interneally kept (partially) sorted by "relevance"
according to a comparison function. However at the very end it
should be sorted by different criteria (frequency, sky position,
spindown). Reading back in the previously written values
limits the prcision, so values that have been calculated identical
aren't neccessarily after reading one of them from a checkpoint.
Thus all elements in the toplist are treated as if they have
actually been written to a file to limit their precision
before the final sorting.
(<b>NOTE:</b> Shouldn't we do this with all candidates (or at least the
FStat value) already during the run to ensure the same sorting
order? Sure the validator does take care of it)
</li><br></ul>


<br><h2>Interface</h2>
<p>
Checkpointing is implemented by means of four functions that can be found in in hs_boinc_extras:
</p><p>
<a href=http://www.lsc-group.phys.uwm.edu/lal/slug/nightly/doxygen/html/hs__boinc__extras_8c.html#83cf13b8cf9aa58546ca1b436abe729c>init_and_read_checkpoint</a>()
</p><p>
This funcion initializes the data structures for checkpointing,
and looks for a previous checkpoint file. If it finds one, it
tries to read the previous output back into memory and returns
information to resume from the checkpoint. Its interface is such
that it can replace a fstat_toplist_init() call in a
non-checkpointing version of the program.
</p><p>
<a href=http://www.lsc-group.phys.uwm.edu/lal/slug/nightly/doxygen/html/hs__boinc__extras_8c.html#063c7d14098e819e3be5811d3310634a>add_checkpoint_candidate</a>()
</p><p>
Whenever a candiadate has been found, this function not only adds
it to the "toplist" in memory; it also appends it to the
checkpointed file on disk in case it was actually inserted into
the toplist, i.e. if it was "larger" than the "smallest" element
in the toplist. Note that actually the candidate is appended to a
file buffer in memory, which will be flushed (i.e. written to disk)
when writing a checkpoint. Its interface is such
that it can simply replace a insert_into_fstat_toplist() call in a
non-checkpointing version of the program.
</p><p>
<a href=http://www.lsc-group.phys.uwm.edu/lal/slug/nightly/doxygen/html/hs__boinc__extras_8c.html#3456798a8996c66031cb3dafc05781f5>set_checkpoint</a>()
</p><p>
Actually writes a checkpoint (file). When it's "time to checkpoint"
(according to boinc_time_to_checkpoint()),
the checkpointed file is flushed, i.e. the candidates in the file
buffer (put there by add_checkpoint_candidate()) are actually wrtten
to disk. If the file has reached te maximum size, it is "compacted",
i.e. completely rewritten from the toplist in memory. Finally a new
checkpoint file is written, containing the skypoint counter and the
length and checksum of the checkpointed file. For consistency checks
and a possible external progress counter, also the total number of
skypoints and the current sky position (rac,dec) is recorded. This
is the only call that's necessary to be added to a program to make
it checkpoint.
</p><p>
<a href=http://www.lsc-group.phys.uwm.edu/lal/slug/nightly/doxygen/html/hs__boinc__extras_8c.html#6a41f413964523eb5acec70727ecd67b>write_and_close_checkpointed_file</a>()
</p><p>
After all operations on the toplist and the checkpointed file have
been performed, this fuction should be called to finally write the
toplist to a file. It actually does this "compacted", i.e. writes
it completely from scratch, containing only the candidates that
are in the toplist at this moment. It adds an end marker ("%DONE")
to the checkpointed file and cleans up all structures used for
the toplist and checkpointing. Note that the checkpoint file itself
is not removed by this function, this is purposefully left to the
BOINC Clinet. Its interface is such
that it can simply replace a final_write_fstat_toplist_to_file() call in a
non-checkpointing version of the program.
</p>


<br><h2>Implementation Levels</h2>
<p>
The implementation of toplist and checkpointing features five levels:
</p><p>
1. HeapToplist (Heaptoplist.h/c): generic functions for manipulating
toplists independent of a certain type (void* and function*)
</p><p>
2. FStatToplist: An incarnation of HeapToplist that adds a tupe for
an FStat candidate and a comparison function to order objects of this
type.
</p><p>
3. FStat File I/O: Functions for Reading and writing FStatToplist(s),
defines a file format for an FStatToplist. 
</p><p>
4. Checkpointed File I/O: Functions for managing a "checkpointed
FstatToplist file". 
</p><p>
5. Interface (hs_boinc_extras.c): implementation of the interface
listed above, in particular functions to write and read the actual
"checkpoint file".
</p><p>
The HeapToplist is implemented in the module HeapToplist.h/c
(lalapps/src/pulsar/FDS_isolated). the interface functions
are located in hs_boinc_extras.h/c (in lalapps/src/pulsar/hough/src2),
the other levels make up the module FstatToplist.h/c
(in lalapps/src/pulsar/FDS_isolated).
</p>


<br><h2>Callgraph</h2><br>
