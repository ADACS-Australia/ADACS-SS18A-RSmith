/*-----------------------------------------------------------------------
 *
 * File Name: MCInjectHoughS2.c
 *
 * Authors: Sintes, A.M., Krishnan, B. 
 *
 * Revision: $Id$
 *  
 * Monte Carlo signal injections for several h_0 values and
 *  compute the Hough transform for only one point in parameter space each time
 *-----------------------------------------------------------------------
 */

/* 
 The idea is that we would like to analize a 300 Hz band on a cluster of
 machines. Each process should analyze 1 Hz band  (or whatever).
 
 	- Read the  band to be analized and the wings needed to read the originals SFTs. 
	-Read the h_0 values to be analyzed in one go
	- Read the file  containing the times and velocities generated by
	DriveHoughColor or compute them 
	-loop over the MC injections:
		+ Generate random parameters (f, f', alpha, delata, i...)
		+ generate h(t), produce its FFT
		+ Add h(f) to SFT for a given h_o value (and all of them)
		+ get number count
		+ wite to file
	(note if one loop fails, should print error , but continue with the next
	value)
	
Input shoud be from
             SFT files 
	     band, wings, nh_0, h_01, h_02....
	     ephemeris info
             (it should also read the times and velocities used in
	     DriveHoughColor)
	     
   This code will output files containing the MC results and info about injected
   signals. 
*/

#include "./MCInjectHoughS2.h" /* proper path*/


/******************************************************
 *  Assignment of Id string using NRCSID()
 */

NRCSID (MCINJECTHOUGHS2C, "$Id$");

/* vvvvvvvvvvvvvvvvvvvvvvvvvvvvvv------------------------------------ */
int main(int argc, char *argv[]){

  static LALStatus            status;  
  static LALDetector          detector;
  static LIGOTimeGPSVector    timeV;
  static REAL8Cart3CoorVector velV;
  static REAL8Vector          timeDiffV;
  static REAL8Vector          foft;
  static REAL8Vector          foftV[NTEMPLATES];
  static REAL8Vector          h0V;
 
  static HoughInjectParams    injectPar;
  static PulsarData           pulsarInject;
  static HoughTemplate        pulsarTemplate;
  static HoughNearTemplates   closeTemplates;

  SFTVector    *inputSFTs  = NULL;  
  SFTVector    *outputSFTs = NULL;
  REAL4TimeSeries   *signalTseries = NULL;
  
  static PulsarSignalParams  params;
  static SFTParams           sftParams;

  EphemerisData   *edat = NULL;
  CHAR  *earthEphemeris = NULL; 
  CHAR  *sunEphemeris = NULL;

  static COMPLEX8SFTData1  sft1;
  static REAL8PeriodoPSD   periPSD;
  static UCHARPeakGram     pg1;
    
  UINT4  msp; /*number of spin-down parameters */
  INT4   ifo;
  CHAR   filelist[MAXFILES][MAXFILENAMELENGTH];  
  CHAR   *directory = NULL; /* the directory where the SFT  could be */
  CHAR   *fnameOut = NULL;               /* The output prefix filename */
  
  UINT4  numberCount,maxNumberCount;
  INT4   nTemplates, controlN, controlNN, controlNH;
  UINT4  numberCountV[NTEMPLATES];
   
  INT4   mObsCoh, nfSizeCylinder;
  INT8   f0Bin, fLastBin;           /* freq. bin to perform search */
  REAL8  peakThreshold, normalizeThr;
  REAL8  f0, fSearchBand, timeBase, deltaF, alpha, delta;
  REAL8  patchSizeAlpha, patchSizeDelta;
  INT4   blocksRngMed;
  REAL8  threshold, h0scale;

  UINT4  sftlength; 
  INT4   sftHeaderlength;
  REAL4  sftRenorm; 
  INT4   sftFminBin;
  REAL8  fHeterodyne;
  REAL8  tSamplingRate;
      
  UINT2  nh0;
  REAL8  h0Min, h0Max;
  UINT4  nMCloop;

  UINT4 MCloopId;
  UINT4 h0loop;
  
  FILE  *fpPar = NULL;
  FILE  *fpH0 = NULL;
  FILE  *fpNc = NULL;
  /* FILE  **fp = NULL; */
  
 /* to be removed ?
 *  CHAR   *fnameVelocity = NULL;
 */

#ifdef TIMING
  unsigned long long start, stop;
#endif


#ifdef TIMING
   start = realcc();
#endif

  /******************************************************************/
  /*    Set up the default parameters.      */
  /* ****************************************************************/
  msp = 1; /*only one spin-down */
  
  nh0 = NH0;
  h0Min = H0MIN;
  h0Max = H0MIN;
  
  nMCloop = NMCLOOP;
  nTemplates = NTEMPLATES;
  
  alpha = ALPHA;
  delta = DELTA;
  f0 =  F0;
  fSearchBand = FBAND;
  peakThreshold = THRESHOLD;
  nfSizeCylinder = NFSIZE;
  patchSizeAlpha = PATCHSIZEX;
  patchSizeDelta = PATCHSIZEY;

  injectPar.fullSky= 1;  /* full sky */
  injectPar.spnFmax.length = 1; /* only one spd parameter used */
 
  detector = lalCachedDetectors[LALDetectorIndexGEO600DIFF]; /* default */
  ifo = IFO;
  
  if (ifo ==1) detector=lalCachedDetectors[LALDetectorIndexGEO600DIFF];
  if (ifo ==2) detector=lalCachedDetectors[LALDetectorIndexLLODIFF];
  if (ifo ==3) detector=lalCachedDetectors[LALDetectorIndexLHODIFF];
 
  earthEphemeris = EARTHEPHEMERIS;
  sunEphemeris = SUNEPHEMERIS;
  
  directory = SFTDIRECTORY;
  fnameOut = FILEOUT;
  blocksRngMed = BLOCKSRNGMED;
  SUB( LALRngMedBias( &status, &normalizeThr, blocksRngMed ), &status ); 

  /* to be removed */
/*
 *   fnameInData = FILEINDATA;
 *   fnameVelocity=FILEVELOCITY;
 *   fnameTime = FILETIME; 
 */

  /*****************************************************************/
  /*    Parse argument list.  i stores the current position.       */
  /*****************************************************************/
  {  
    INT4  arg;        /* Argument counter */

    arg = 1;
    while ( arg < argc ) {
      /* Parse debuglevel option. */
      if ( !strcmp( argv[arg], "-d" ) ) {
	if ( argc > arg + 1 ) {
	  arg++;
	  lalDebugLevel = atoi( argv[arg++] );
	} else {
	  ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	  LALPrintError( USAGE, *argv );
	  return DRIVEHOUGHCOLOR_EARG;
	}
      }
      /* Parse interferometer option. */
      else if ( !strcmp( argv[arg], "-i" ) ) {
	if ( argc > arg + 1 ) {
	  arg++;
	  ifo = atoi( argv[arg++] );
	  if (ifo ==1) detector=lalCachedDetectors[LALDetectorIndexGEO600DIFF];
	  if (ifo ==2) detector=lalCachedDetectors[LALDetectorIndexLLODIFF];
	  if (ifo ==3) detector=lalCachedDetectors[LALDetectorIndexLHODIFF];
	} else {
	  ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	  LALPrintError( USAGE, *argv );
	  return DRIVEHOUGHCOLOR_EARG;
	}
      }
      /* Parse filename of earth  ephemeris data option. */
      else if ( !strcmp( argv[arg], "-E" ) ) {
	if ( argc > arg + 1 ) {
	  arg++;
	  earthEphemeris = argv[arg++];
	} else {
	  ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	  LALPrintError( USAGE, *argv );
	  return DRIVEHOUGHCOLOR_EARG;
	}
      }
      /* Parse filename of sun ephemeris data option. */
      else if ( !strcmp( argv[arg], "-S" ) ) {
	if ( argc > arg + 1 ) {
	  arg++;
	  sunEphemeris = argv[arg++];
	} else {
	  ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	  LALPrintError( USAGE, *argv );
	  return DRIVEHOUGHCOLOR_EARG;
	}
      }
       /* Parse directory SFT path  option. */
      else if ( !strcmp( argv[arg], "-D" ) ) {
	if ( argc > arg + 1 ) {
	  arg++;
	  directory = argv[arg++];
	} else {
	  ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	  LALPrintError( USAGE, *argv );
	  return DRIVEHOUGHCOLOR_EARG;
	}
      }
      /* Parse output file prefix option. */
      else if ( !strcmp( argv[arg], "-o" ) ) {
	if ( argc > arg + 1 ) {
	  arg++;
	  fnameOut = argv[arg++];
	} else {
	  ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	  LALPrintError( USAGE, *argv );
	  return DRIVEHOUGHCOLOR_EARG;
	}
      }
       /* Parse filename of Velocity.Data file corresponding to the SFTs. */
 /*
 *      else if ( !strcmp( argv[arg], "-V" ) ) {
 *         if ( argc > arg + 1 ) {
 *           arg++;
 *           fnameVelocity = argv[arg++];
 *         } else {
 *           ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
 *           LALPrintError( USAGE, *argv );
 *           return DRIVEHOUGHCOLOR_EARG;
 *         }
 *       }
 * 
 */
     /* Parse frequency option. */
      else if ( !strcmp( argv[arg], "-f" ) ) {
	if ( argc > arg + 1 ) {
	  arg++;
	  f0 = atof(argv[arg++]);
	} else {
	  ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	  LALPrintError( USAGE, *argv );
	  return DRIVEHOUGHCOLOR_EARG;
	}
      }
      /* Parse search frequency band option. */
      else if ( !strcmp( argv[arg], "-b" ) ) {
	if ( argc > arg + 1 ) {
	  arg++;
	  fSearchBand = atof(argv[arg++]);	 
	} else {
	  ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	  LALPrintError( USAGE, *argv );
	  return DRIVEHOUGHCOLOR_EARG;
	}
      }
      /* Parse peak threshold option. */
      else if ( !strcmp( argv[arg], "-t" ) ) {
	if ( argc > arg + 1 ) {
	  arg++;
	  peakThreshold = atof(argv[arg++]);
	} else {
	  ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	  LALPrintError( USAGE, *argv );
	  return DRIVEHOUGHCOLOR_EARG;
	}
      }
      /* Parse Running median window size. */
      else if ( !strcmp( argv[arg], "-w" ) ) {
	if ( argc > arg + 1 ) {
	  arg++;
	  blocksRngMed = atoi( argv[arg++] );
          SUB( LALRngMedBias( &status, &normalizeThr, blocksRngMed ), &status );	  
	} else {
	  ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	  LALPrintError( USAGE, *argv );
	  return DRIVEHOUGHCOLOR_EARG;
	}
      }
      /* Parse sky position options. */
      else if ( !strcmp( argv[arg], "-p" ) ) {
	if ( argc > arg + 2 ) {
	  arg++;
	  alpha = atof(argv[arg++]);
	  delta = atof(argv[arg++]);
	} else {
	  ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	  LALPrintError( USAGE, *argv );
	  return DRIVEHOUGHCOLOR_EARG;
	}
      }
      /* Parse patch size option. */
      else if ( !strcmp( argv[arg], "-s" ) ) {
	if ( argc > arg + 2 ) {
	  arg++;
	  patchSizeAlpha = atof(argv[arg++]);
	  patchSizeDelta = atof(argv[arg++]);
	  injectPar.fullSky= 0;  /* patch case */
	} else {
	  ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	  LALPrintError( USAGE, *argv );
	  return DRIVEHOUGHCOLOR_EARG;
	}
      }
      /* Parse injected h0 amplitude  range and how many*/
      else if ( !strcmp( argv[arg], "-H" ) ) {
	if ( argc > arg + 3 ) {
	  arg++;
	  nh0 = atoi(argv[arg++]);
	  h0Min = atof(argv[arg++]);
	  h0Max = atof(argv[arg++]);
	} else {
	  ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	  LALPrintError( USAGE, *argv );
	  return DRIVEHOUGHCOLOR_EARG;
	}
      }
      /* Parse monte carlo iterations. */
      else if ( !strcmp( argv[arg], "-L" ) ) {
	if ( argc > arg + 1 ) {
	  arg++;
	  nMCloop = atoi( argv[arg++] );	  
	} else {
	  ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	  LALPrintError( USAGE, *argv );
	  return DRIVEHOUGHCOLOR_EARG;
	}
      }
      /* Unrecognized option. */
      else {
	ERROR( DRIVEHOUGHCOLOR_EARG, DRIVEHOUGHCOLOR_MSGEARG, 0 );
	LALPrintError( USAGE, *argv );
	return DRIVEHOUGHCOLOR_EARG;
      }
    } /* End of argument parsing loop. */
  }
  /******************************************************************/

  if ( f0 < 0 ) {
    ERROR( DRIVEHOUGHCOLOR_EBAD, DRIVEHOUGHCOLOR_MSGEBAD, "freq<0:" );
    LALPrintError( USAGE, *argv  );
    return DRIVEHOUGHCOLOR_EBAD;
  }
  /******************************************************************/  
 
  /******************************************************************/
  /* computing h0 values and preparing  output files */
  /******************************************************************/
  h0V.length=nh0;
  h0V.data = NULL;
  h0V.data = (REAL8 *)LALMalloc(nh0*sizeof(REAL8));
  h0V.data[0] = h0Min;
  
  if(nh0 >1){
    INT4 k;
    REAL8 steph0;   
    steph0 = (h0Max-h0Min)/(nh0-1.);
    for(k=1; k<nh0; ++k) h0V.data[k]= h0V.data[k-1]+steph0;
  }
  
   /*fp = LALMalloc(nh0*sizeof(FILE *)); */
  {
    INT4 k;
    CHAR filename[MAXFILENAMELENGTH];
    
 	/* the paramerter file */
    strcpy( filename, fnameOut);
    strcat( filename, "_par");
    fpPar= fopen(filename, "w"); /* where to write the parameters */
    setlinebuf(fpPar);  /* line buffered on */
    
   	/* the  file  with the h0 values */
    strcpy( filename, fnameOut);
    strcat( filename, "_h0");
    fpH0= fopen(filename, "w"); /* where to write the parameters */
    setlinebuf(fpH0);  /* line buffered on */
        
   	/* the  file  with the the number-counts for different h0 values */
    strcpy( filename, fnameOut);
    strcat( filename, "_nc");
    fpNc= fopen(filename, "w"); /* where to write the parameters */
    setlinebuf(fpNc);  /* line buffered on */

    for (k=0; k<nh0; ++k){ fprintf(fpH0, "%g \n",  h0V.data[k] ); }  
    fclose(fpH0);
    
/*
 *     for (k=0; k<nh0; ++k){
 *       sprintf(filename, "%s_%03d.m",fnameOut, k); 
 *       fp[k] = fopen(filename, "w");
 *       setlinebuf(fp[k]);  
 *       fprintf(fp[k], " h0 = %g; \n",  h0V.data[k] );
 *       fprintf(fp[k], " Ncount= [ \n" );
 *     } 
 */

  }
  
  /******************************************************************/
  /* Looking into the SFT data files to get the names and how many there are*/
  /******************************************************************/
  { 
    CHAR     command[256];
    glob_t   globbuf;
    INT4    j;
     
    strcpy(command, directory);
    strcat(command, "/*SFT*.*");
    
    globbuf.gl_offs = 1;
    glob(command, GLOB_ERR, NULL, &globbuf);
    
    if(globbuf.gl_pathc==0)
      {
	fprintf(stderr,"No SFTs in directory %s ... Exiting.\n", directory);
	return 1;  /* stop the program */
      }
    
    /* we will read up to a certain number of SFT files, but not all 
       if there are too many ! */ 
    mObsCoh = MIN (MAXFILES, globbuf.gl_pathc);
    
    /* Remember to do the following: 
       globfree(&globbuf); after reading the file names. The file names are 
       globbuf.gl_pathv[fileno]   that one can copy into whatever as:
       strcpy(filelist[fileno],globbuf.gl_pathv[fileno]);  */
    
    for (j=0; j < mObsCoh; j++){
      strcpy(filelist[j],globbuf.gl_pathv[j]);
    }
    globfree(&globbuf);	
  }

  /* ****************************************************************/
  /*  Reading the first headerfile of the first SFT  */
  /* ****************************************************************/
  {
    SFTHeader    header;
    CHAR   *fname = NULL;
    
    fname = filelist[0];
    SUB( LALReadSFTheader( &status, &header, fname ), &status );
   /* SUB( ReadSFTbinHeader1( &status, &header,&(filelist[0]) ), &status ); */
 
    timeBase= header.timeBase; /* Coherent integration time */
    deltaF = 1./timeBase;  /* the frequency resolution */ 
    sftHeaderlength = header.length;   
  }
   
  /* ****************************************************************/
  /* computing sftLength, sftFminBin, fHeterodyne, tSamplingRate  */
  /* bandwith to be read should account for Doppler effects and 
       possible spin-down-up  and running median block size*/
  /* ****************************************************************/
  {    
    INT4   length, fWings;
 
    f0Bin = f0*timeBase;     /* initial frequency to be analyzed */
    length =  fSearchBand*timeBase; 
    fLastBin = f0Bin+length;   /* final frequency to be analyzed */
    fWings =  floor( fLastBin * VTOT +0.5) + nfSizeCylinder + blocksRngMed;

    sftlength = 1 + length + 2*fWings;
    sftFminBin= f0Bin-fWings;
    fHeterodyne = sftFminBin*deltaF;
    tSamplingRate = 2.0*deltaF*(sftlength -1.);
    sftRenorm= 1.0 * sftlength/sftHeaderlength;
  } 
   
  /* ****************************************************************/
  /* reading  SFTs,  & times */
  /* ****************************************************************/
  timeV.length = mObsCoh;
  timeV.data = NULL;  
  timeV.data = (LIGOTimeGPS *)LALMalloc(mObsCoh*sizeof(LIGOTimeGPS));
  SUB(LALCreateSFTVector(&status, &inputSFTs, mObsCoh, sftlength),&status );
  
  { 
    INT4    j; 
    CHAR     *fname = NULL; 
    SFTtype  *sft= NULL; 
    
    sft = inputSFTs->data;
    for (j=0; j < mObsCoh; j++){
      fname = filelist[j];
      SUB( LALReadSFTdata( &status, sft, fname, sftFminBin), &status ); 
      timeV.data[j].gpsSeconds = sft->epoch.gpsSeconds;
      timeV.data[j].gpsNanoSeconds = sft->epoch.gpsNanoSeconds;
      ++sft;
    }    
  }
  
  /******************************************************************/
  /* compute the time difference relative to startTime for all SFT */
  /******************************************************************/
  timeDiffV.length = mObsCoh;
  timeDiffV.data = NULL; 
  timeDiffV.data = (REAL8 *)LALMalloc(mObsCoh*sizeof(REAL8));

  {   
    REAL8   t0, ts, tn, midTimeBase;
    INT4   j; 

    midTimeBase=0.5*timeBase;
    ts = timeV.data[0].gpsSeconds;
    tn = timeV.data[0].gpsNanoSeconds * 1.00E-9;
    t0=ts+tn;
    timeDiffV.data[0] = midTimeBase;

    for (j=1; j< mObsCoh; ++j){
      ts = timeV.data[j].gpsSeconds;
      tn = timeV.data[j].gpsNanoSeconds * 1.00E-9;  
      timeDiffV.data[j] = ts+tn -t0+midTimeBase; 
    }  
  }

  /******************************************************************/ 
  /*   setting of ephemeris info */ 
  /******************************************************************/ 
  edat = (EphemerisData *)LALMalloc(sizeof(EphemerisData));
  (*edat).ephiles.earthEphemeris = earthEphemeris;
  (*edat).ephiles.sunEphemeris = sunEphemeris;
  
  /******************************************************************/
  /* compute detector velocity for those time stamps  
     if it is too slow , we can read it from the file genrated from the driver*/
  /******************************************************************/
  velV.length = mObsCoh;
  velV.data = NULL;
  velV.data = (REAL8Cart3Coor *)LALMalloc(mObsCoh*sizeof(REAL8Cart3Coor));
  
  {  
    VelocityPar   velPar;
    REAL8     vel[3]; 
    UINT4     j; 
    
    LALLeapSecFormatAndAcc lsfas = {LALLEAPSEC_GPSUTC, LALLEAPSEC_STRICT};
    INT4 tmpLeap; /* need this because Date pkg defines leap seconds as
		     INT4, while EphemerisData defines it to be INT2. This won't
                   cause problems before, oh, I don't know, the Earth has been 
                   destroyed in nuclear holocaust. -- dwchin 2004-02-29 */    
    
    velPar.detector = detector;
    velPar.tBase = timeBase;
    velPar.vTol = ACCURACY;
    velPar.edat = NULL;
    
    /* Leap seconds for the start time of the run */   
    SUB( LALLeapSecs(&status, &tmpLeap, &(timeV.data[0]), &lsfas), &status);
    (*edat).leap = (INT2)tmpLeap;
    
    /* read in ephemeris data */
    SUB( LALInitBarycenter( &status, edat), &status);
    velPar.edat = edat;
    
    for(j=0; j< velV.length; ++j){
      velPar.startTime.gpsSeconds     = timeV.data[j].gpsSeconds;
      velPar.startTime.gpsNanoSeconds = timeV.data[j].gpsNanoSeconds;
      
      SUB( LALAvgDetectorVel ( &status, vel, &velPar), &status );
      velV.data[j].x= vel[0];
      velV.data[j].y= vel[1];
      velV.data[j].z= vel[2];   
    }  
  }
 
  /******************************************************************/ 
  /*   setting of parameters */ 
  /******************************************************************/ 
  injectPar.h0   = h0Min;
  injectPar.fmin = f0;
  injectPar.fSearchBand = fSearchBand;
  injectPar.deltaF = deltaF;
  injectPar.alpha = alpha;  /* patch center if not full sky */
  injectPar.delta = delta;
  injectPar.patchSizeAlpha = patchSizeAlpha; /* patch size if not full sky */
  injectPar.patchSizeDelta = patchSizeDelta; 
  injectPar.pixelFactor = PIXELFACTOR;
  injectPar.vTotC = VTOT;
  injectPar.timeObs =timeDiffV.data[mObsCoh-1]+ timeBase;
  
  injectPar.spnFmax.data = NULL; 
  injectPar.spnFmax.length=msp;   /*only 1 spin */
  injectPar.spnFmax.data = (REAL8 *)LALMalloc(msp*sizeof(REAL8));
  injectPar.spnFmax.data[0] = (nfSizeCylinder/2) *deltaF/timeDiffV.data[mObsCoh-1];
  
  pulsarInject.spindown.length = msp;
  pulsarTemplate.spindown.length = msp;
  
  pulsarInject.spindown.data = NULL;
  pulsarTemplate.spindown.data = NULL;
  
  pulsarInject.spindown.data = (REAL8 *)LALMalloc(msp*sizeof(REAL8));
  pulsarTemplate.spindown.data = (REAL8 *)LALMalloc(msp*sizeof(REAL8));
 
  /******************************************************************/  
  sftParams.Tsft = timeBase;
  sftParams.timestamps = &(timeV);
  sftParams.noiseSFTs = NULL;       /* or =inputSFTs; */
  
  /* ****************************************************************/
  params.orbit = NULL;
  /* params.transferFunction = NULL; */
  params.site = &(detector);
  params.ephemerides = edat;
  params.startTimeGPS.gpsSeconds = timeV.data[0].gpsSeconds;   /* start time of output time series */
  params.startTimeGPS.gpsNanoSeconds = timeV.data[0].gpsNanoSeconds;   /* start time of output time series */
  params.duration = injectPar.timeObs; /* length of time series in seconds */
  params.samplingRate = tSamplingRate;
  params.fHeterodyne = fHeterodyne;
  
  params.pulsar.tRef.gpsSeconds = timeV.data[0].gpsSeconds; 
  params.pulsar.tRef.gpsNanoSeconds = timeV.data[0].gpsNanoSeconds; 
  /* ****************************************************************/
  
  /* WE SHOULD LOOP OVER MC SIGNAL INJECTION HERE
     BEFORE THAT :
         -initialize ephemeris data
	 -create the set of h0 to be studied
	 -for each different h0 value create a file containing the h0
	 value
     LOOP over xxx Monte-Carlo signal Injections:
		- Generate signal injections parameters (using h0Min values) and
		random numbers....and also generate the corresponding template
		parameters (position , frequency spin-down) allowing some
		mismatch
		- Compute the frequency path for the template parameters
		-Generate the time series for injected signals and the
		corresponding SFTs with no added noise (for all times).
		 (free memory)
		
		LOOP over the different h0 values:
		   number count  = 0
		   compute normalization factor (for different h0)
		- for j=0; j<mObsCoh:
		     -Add SFT with the signal normalized to the SFT original noise
		     -COMPLEX8SFT2Periodogram1
		     -Periodo2PSDrng
		     -SelectPeackColorNoise
		     - check corresponding index
		     - increase or not numbercount
		 print final number count to the correesponding file
		 END LOOP for h0
	END LOOP for MC
 		(free memory)   */
		
  /* ****************************************************************/
  
  /* sft1  stores the sum of one  signal + noise SFT */
  sft1.length = sftlength;
  sft1.fminBinIndex = sftFminBin;
  sft1.epoch.gpsSeconds = timeV.data[0].gpsSeconds;
  sft1.epoch.gpsNanoSeconds = timeV.data[0].gpsNanoSeconds;
  sft1.timeBase = timeBase;
  sft1.data = NULL;
  sft1.data = (COMPLEX8 *)LALMalloc(sftlength* sizeof(COMPLEX8));
  
  periPSD.periodogram.length = sftlength;
  periPSD.periodogram.data = NULL;
  periPSD.periodogram.data = (REAL8 *)LALMalloc(sftlength* sizeof(REAL8));
  periPSD.psd.length = sftlength;
  periPSD.psd.data = NULL;
  periPSD.psd.data = (REAL8 *)LALMalloc(sftlength* sizeof(REAL8));
  
  threshold = peakThreshold/normalizeThr; 
  
  pg1.length = sftlength;
  pg1.data = NULL;
  pg1.data = (UCHAR *)LALMalloc(sftlength* sizeof(UCHAR));
  
  foft.length = mObsCoh;
  foft.data = NULL;
  foft.data = (REAL8 *)LALMalloc(mObsCoh*sizeof(REAL8));
  {
    UINT4 j;
    for (j=0;j<nTemplates;++j) {
      foftV[j].length = mObsCoh;
      foftV[j].data = NULL;
      foftV[j].data = (REAL8 *)LALMalloc(mObsCoh*sizeof(REAL8));
    }
  }


  /* ****************************************************************/
  /*  HERE SHOULD START THE MONTE-CARLO */
    
  for(MCloopId=0; MCloopId < nMCloop; ++MCloopId){

    controlN=1; /* checks if near template corresponds to max number count*/
    controlNN=nh0;
    controlNH=1;  /* checks if near template corresponds to max 
    		number count for the highest h0 value */
    
    SUB( GenerateInjectParams(&status, &pulsarInject, &pulsarTemplate,
			&closeTemplates, &injectPar), &status );
    
    /*  params.pulsar.TRefSSB=  ? ; */
    params.pulsar.position.longitude = pulsarInject.longitude;
    params.pulsar.position.latitude =  pulsarInject.latitude ;
    params.pulsar.position.system= COORDINATESYSTEM_EQUATORIAL; 
    params.pulsar.psi=    pulsarInject.psi;
    params.pulsar.aPlus=  pulsarInject.aPlus;
    params.pulsar.aCross= pulsarInject.aCross;
    params.pulsar.phi0=   pulsarInject.phi0;
    params.pulsar.f0=     pulsarInject.f0;
    params.pulsar.spindown=  &pulsarInject.spindown ;
    
    SUB( LALGeneratePulsarSignal(&status, &signalTseries, &params ), &status);
    SUB( LALSignalToSFTs(&status, &outputSFTs, signalTseries, &sftParams), 
	 &status);
	   
   /* ****************************************************************/
    /* writing the parameters into fpPar, following the format
       MCloopId  I.f0 H.f0 I.f1 H.f1 I.alpha H.alpha I.delta H.delta I.phi0  I.psi
       (not cos iota)  */
    /* ****************************************************************/   
    fprintf(fpPar," %d %f %f %g %g %f %f %f %f %f %f ", 
	    MCloopId, pulsarInject.f0, pulsarTemplate.f0,
	    pulsarInject.spindown.data[0], pulsarTemplate.spindown.data[0],
	    pulsarInject.longitude, pulsarTemplate.longitude,
	    pulsarInject.latitude, pulsarTemplate.latitude,
	    pulsarInject.phi0, pulsarInject.psi
	    );
    /* ****************************************************************/
    /* Computing the frequency path f(t) = f0(t)* (1+v/c.n)  for */
    /*  all the different templates */
    /* ****************************************************************/   

    /* the geometrically nearest template */
    SUB( ComputeFoft(&status, &foft,&pulsarTemplate,&timeDiffV,&velV), &status);
    
    /* for all the 16 near templates */
    {
      UINT4 j,i,k, itemplate;
      
      itemplate =0;
      for(j=0;j<2;++j){
        pulsarTemplate.f0 = closeTemplates.f0[j];
        for(i=0;i<2;++i){
          pulsarTemplate.spindown.data[0] = closeTemplates.f1[i];
	  for(k=0;k<4;++k){
	    pulsarTemplate.latitude = closeTemplates.skytemp[k].delta;
	    pulsarTemplate.longitude = closeTemplates.skytemp[k].alpha;
            SUB( ComputeFoft(&status, &(foftV[itemplate]),
	                   &pulsarTemplate,&timeDiffV,&velV), &status);
            ++itemplate;
	  }
	}
      }
    }
     
    /*  HERE THE LOOP FOR DIFFERENT H0 VALUES */
    
    fprintf(fpNc, " %d ",  MCloopId);
    
    for(h0loop=0; h0loop <nh0; ++h0loop){
      
      INT4  j, i, index, itemplate; 
      COMPLEX8 *noise1SFT;
      COMPLEX8 *signal1SFT;
      COMPLEX8 *sumSFT;
      
      numberCount=0;
      for(itemplate=0; itemplate<nTemplates; ++itemplate){
        numberCountV[itemplate]=0;
      }
      h0scale =h0V.data[h0loop]/h0V.data[0]; /* different for different h0 values */
      
      /* ****************************************************************/
      /* adding signal+ noise SFT,  generating peakgrams  and producing the number-count*/
      /* ****************************************************************/      
      for (j=0; j < mObsCoh; j++)  {
	sumSFT = sft1.data;
	signal1SFT = outputSFTs->data[j].data->data;
	noise1SFT  =  inputSFTs->data[j].data->data;
	
	for (i=0; (UINT4)i < sftlength; i++)  {
	  /* sumSFT->re = noise1SFT->re + h0scale *signal1SFT->re; */
	  /* sumSFT->im = noise1SFT->im + h0scale *signal1SFT->im; */
	  sumSFT->re = sftRenorm *noise1SFT->re + h0scale *signal1SFT->re;
	  sumSFT->im = sftRenorm *noise1SFT->im + h0scale *signal1SFT->im;
	  ++noise1SFT;
	  ++signal1SFT;
	  ++sumSFT;
	}
	
	SUB( COMPLEX8SFT2Periodogram1(&status, &periPSD.periodogram, &sft1), &status );	
	/* for color noise */    
	SUB( LALPeriodo2PSDrng( &status, 
			     &periPSD.psd, &periPSD.periodogram, &blocksRngMed), &status );	
	/* SUB( Periodo2PSDrng( &status, 
                     &periPSD.psd, &periPSD.periodogram, &blocksRngMed),  &status ); */	
	SUB( LALSelectPeakColorNoise(&status,&pg1,&threshold,&periPSD), &status); 	

	index = floor( foft.data[j]*timeBase -sftFminBin+0.5); 
	numberCount+=pg1.data[index]; /* adds 0 or 1 to the counter*/

        for (itemplate=0; itemplate<nTemplates; ++itemplate) {
	  index = floor( foftV[itemplate].data[j]*timeBase -sftFminBin+0.5); 
          numberCountV[itemplate]+=pg1.data[index];
        }
      }
      
      /*check the max number count */
      maxNumberCount = numberCount;
      for (itemplate=0; itemplate<nTemplates; ++itemplate) {
         if( numberCountV[itemplate] > maxNumberCount ) {
	   maxNumberCount = numberCountV[itemplate];
	   controlN=0;
	   if (h0loop == (nh0-1)) controlNH=0;
	 }
      }
      /******************************************************************/
      /* printing result in the proper file */
      /******************************************************************/
      fprintf(fpNc, " %d ", maxNumberCount);
     
    } /* closing loop for different h0 values */
    fprintf(fpNc, " \n");
    
    

    /* ****************************************************************/
    /* writing the parameters into fpPar, following the format
       MCloopId  I.f0 H.f0 I.f1 H.f1 I.alpha H.alpha I.delta H.delta I.phi0  I.psi
       (not cos iota) and now adding the 2 control */
    /* ****************************************************************/   
    fprintf(fpPar,"  %d %d \n",  controlN, controlNH );
    
    LALFree(signalTseries->data->data);
    LALFree(signalTseries->data);
    LALFree(signalTseries);
    signalTseries =NULL;
    SUB(LALDestroySFTVector(&status, &outputSFTs),&status );
    outputSFTs = NULL;
    
  } /* Closing MC loop */
  
  /******************************************************************/
  /* Closing files */
  /******************************************************************/  
  fclose(fpPar); 
  fclose(fpNc); 

  
  /******************************************************************/
  /* Free memory and exit */
  /******************************************************************/
  
  /* LALFree(fp); */
  LALFree(sft1.data);
  LALFree(periPSD.periodogram.data);
  LALFree(periPSD.psd.data);
  LALFree(pg1.data);
  
  LALFree(timeV.data);
  LALFree(timeDiffV.data);
  LALFree(velV.data);
  LALFree(foft.data);
  LALFree(h0V.data);
  {
     UINT4 j;
     for (j=0;j<nTemplates;++j) {
        LALFree(foftV[j].data);
     }
   }

  
  LALFree(injectPar.spnFmax.data);
  LALFree(pulsarInject.spindown.data);
  LALFree(pulsarTemplate.spindown.data);
   
  LALFree(edat->ephemE);
  LALFree(edat->ephemS);
  LALFree(edat);
  
  SUB(LALDestroySFTVector(&status, &inputSFTs),&status );
  
  LALCheckMemoryLeaks();
  
  
#ifdef TIMING
  stop = realcc();
  printf(" All: %llu\n", stop-start);
#endif
  
  INFO( DRIVEHOUGHCOLOR_MSGENORM );
  return DRIVEHOUGHCOLOR_ENORM;
}


 
/***************************************************************************/
void GenerateInjectParams(LALStatus   *status,
                        PulsarData           *injectPulsar,
                        HoughTemplate        *templatePulsar,
			HoughNearTemplates   *closeTemplates,
                        HoughInjectParams    *params){
			
  INT4          seed=0; /* seed generated using current time */
  REAL4         randval;
  RandomParams  *randPar=NULL;
  FILE     *fpRandom;
  INT4     count;
  
  REAL4    cosiota, h0;
  REAL8    f0, deltaF, deltaX;
  REAL8    latitude, longitude;  /* of the source in radians */
  INT8    f0bin;
  UINT4    msp;
  
  /* --------------------------------------------- */
  INITSTATUS (status, "GenerateInjectParams", MCINJECTHOUGHS2C);
  ATTATCHSTATUSPTR (status);
  
  /*   Make sure the arguments are not NULL: */
  ASSERT (injectPulsar,  status, DRIVEHOUGHCOLOR_ENULL, DRIVEHOUGHCOLOR_MSGENULL);
  ASSERT (templatePulsar, status, DRIVEHOUGHCOLOR_ENULL, DRIVEHOUGHCOLOR_MSGENULL);
  ASSERT (params, status, DRIVEHOUGHCOLOR_ENULL, DRIVEHOUGHCOLOR_MSGENULL);
  
  
  /*  ++++++++++++++++++from makefakedata
   * Modified so as to not create random number parameters with seed
   * drawn from clock.  Seconds don't change fast enough and sft's
   * look alike.  We open /dev/urandom and read a 4 byte integer from
   * it and use that as our seed.  Note: /dev/random is slow after the
   * first, few accesses.
   */

  fpRandom = fopen("/dev/urandom","r");
  ASSERT (fpRandom, status, DRIVEHOUGHCOLOR_EFILE,  DRIVEHOUGHCOLOR_MSGEFILE); 
  
  count = fread(&seed, sizeof(INT4),1, fpRandom);
  ASSERT (count, status, DRIVEHOUGHCOLOR_EARG,  DRIVEHOUGHCOLOR_MSGEARG); 
  
  fclose(fpRandom);
  
  TRY( LALCreateRandomParams(status->statusPtr, &randPar, seed), status);
  
 /*
  *   to create a single random deviate distributed uniforly between zero and unity		     
  *   TRY( LALUniformDeviate(status->statusPtr, &randval, randPar), status);
  */
  
  
  /* get random value phi0 [0, 2 pi] */ 
  TRY( LALUniformDeviate(status->statusPtr, &randval, randPar), status);
  injectPulsar->phi0 = randval * LAL_TWOPI;
  
  /* get random value cos iota [-1,1] */ 
  TRY( LALUniformDeviate(status->statusPtr, &randval, randPar), status);
  cosiota = 2.0* randval -1.0;
  
  h0=params->h0;
  injectPulsar->aCross = h0*cosiota;
  injectPulsar->aPlus  = 0.5*h0*(1.0 + cosiota*cosiota);
  
  /* get random value psi [0, 2 pi] */ 
  TRY( LALUniformDeviate(status->statusPtr, &randval, randPar), status);
  injectPulsar->psi = randval * LAL_TWOPI;

  /* getting random number for the frequency (and mismatch)*/
  TRY( LALUniformDeviate(status->statusPtr, &randval, randPar), status);
  f0 = params->fmin + (params->fSearchBand) * randval;
  injectPulsar->f0 = f0;
  deltaF = params->deltaF;
  f0bin  = floor(f0/deltaF +0.5);
  templatePulsar->f0 = f0bin*deltaF;
  closeTemplates->f0[0] = floor(f0/deltaF)*deltaF;
  closeTemplates->f0[1] = ceil(f0/deltaF)*deltaF;
 
  /* sky location, depending if  full sky or small patch is analyzed */
  deltaX = deltaF/(params->vTotC * params->pixelFactor *
 	           (params->fmin + params->fSearchBand) );
  
  
  if (params->fullSky){ /*full sky*/   
    REAL8 kkcos;
    
    TRY( LALUniformDeviate(status->statusPtr, &randval, randPar), status);
    longitude = randval * LAL_TWOPI;
    TRY( LALUniformDeviate(status->statusPtr, &randval, randPar), status);
    kkcos = 2.0* randval -1.0;
    latitude = acos(kkcos) -LAL_PI_2;
  }
  else {  /*small patch */  
    TRY( LALUniformDeviate(status->statusPtr, &randval, randPar), status);
    longitude = params->alpha + (params->patchSizeAlpha) *(randval-0.5);
    TRY( LALUniformDeviate(status->statusPtr, &randval, randPar), status);
    latitude = params->delta + (params->patchSizeDelta) *(randval-0.5);    
  }
  
  injectPulsar->longitude = longitude;
  injectPulsar->latitude  = latitude;   
  
  {
    REAL8UnitPolarCoor    template, par; 
    REAL8UnitPolarCoor    templRotated;
    REAL8Cart2Coor        templProjected;
    REAL8      dX1[2], dX2[2];
    INT4      ii,jj,kk;
    
    par.alpha = injectPulsar->longitude;
    par.delta = injectPulsar->latitude; 

    /* mismatch with the template in stereographic plane */
    TRY( LALUniformDeviate(status->statusPtr, &randval, randPar), status);
    templProjected.x = dX1[0] = deltaX*(randval-0.5);
    TRY( LALUniformDeviate(status->statusPtr, &randval, randPar), status);
    templProjected.y = dX2[0] = deltaX*(randval-0.5);

    if (dX1[0]<0.0) { 
      dX1[1]= dX1[0]+deltaX;
    } else {
      dX1[1]= dX1[0]-deltaX;
    }
    
    if (dX2[0]<0.0) { 
      dX2[1]= dX2[0]+deltaX;
    } else {
      dX2[1]= dX2[0]-deltaX;
    }
    
    /* invert the stereographic projection for a point on the projected plane */
    TRY( LALStereoInvProjectCart( status->statusPtr,
                                &templRotated, &templProjected ), status );
    /* inverse rotate the mismatch from the south pole to desired location */
    TRY( LALInvRotatePolarU( status->statusPtr, &template, &templRotated, &par), status);
    templatePulsar->longitude = template.alpha; 
    templatePulsar->latitude = template.delta; 
     
    kk=0;
    for (ii=0; ii<2; ii++){
      for (jj=0; jj<2; jj++) {
      templProjected.x = dX1[ii];
      templProjected.y = dX2[jj];
      TRY( LALStereoInvProjectCart( status->statusPtr,
                                &templRotated, &templProjected ), status );
      TRY( LALInvRotatePolarU( status->statusPtr, &(closeTemplates->skytemp[kk]), &templRotated, 
                               &par), status);
      ++kk;
      }
    }
    
  }

  /* now the spindown if any */
  msp = params->spnFmax.length ;
  closeTemplates->f1[0] = 0.0;
  closeTemplates->f1[1] = 0.0;

  ASSERT (templatePulsar->spindown.length == msp, status, DRIVEHOUGHCOLOR_EBAD,
	  DRIVEHOUGHCOLOR_MSGEBAD);
  ASSERT (injectPulsar->spindown.length == msp, status, DRIVEHOUGHCOLOR_EBAD,
	  DRIVEHOUGHCOLOR_MSGEBAD);
  
  if(msp){ /*if there are spin-down values */
    REAL8 deltaFk, spink;
    REAL8 timeObsInv;
    UINT4   i;
    ASSERT (injectPulsar->spindown.data,  status, DRIVEHOUGHCOLOR_ENULL, 
	    DRIVEHOUGHCOLOR_MSGENULL);
    ASSERT (templatePulsar->spindown.data,  status, DRIVEHOUGHCOLOR_ENULL, 
	    DRIVEHOUGHCOLOR_MSGENULL);
    ASSERT (params->spnFmax.data,  status, DRIVEHOUGHCOLOR_ENULL, 
	    DRIVEHOUGHCOLOR_MSGENULL);
    
    /* delta f_k = k! deltaF/ [T_Obs}^k  spd grid resolution*/
    timeObsInv= 1.0/params->timeObs;
    deltaFk= deltaF*timeObsInv;
    
    /* first spin-down parameter, (only spin-down) */	    
    TRY( LALUniformDeviate(status->statusPtr, &randval, randPar), status);
    spink=params->spnFmax.data[0]* randval;
    
    injectPulsar->spindown.data[0]= spink;
    templatePulsar->spindown.data[0] = floor(spink/deltaFk +0.5)*deltaFk;
    
    closeTemplates->f1[0] = floor(spink/deltaFk)*deltaFk;
    closeTemplates->f1[1] = ceil( spink/deltaFk)*deltaFk;

    /* the rest of the spin orders */
    for (i=1; i< msp; ++i) {
      TRY( LALUniformDeviate(status->statusPtr, &randval, randPar), status);
      spink=params->spnFmax.data[i]* (2.0* randval-1.0);
      injectPulsar->spindown.data[i]= spink;   
      deltaFk= deltaFk*timeObsInv*(i+1.0);
      templatePulsar->spindown.data[i] = floor(spink/deltaFk +0.5)*deltaFk;
    }
  }
  /* free memory */
  TRY( LALDestroyRandomParams(status->statusPtr, &randPar), status);
  
  DETATCHSTATUSPTR (status);
  /* normal exit */
  RETURN (status);
}


/* ****************************************************************/
/* Computing the frequency path f(t) = f0(t)* (1+v/c.n)   */
/* ****************************************************************/   
/******************************************************************/
void ComputeFoft(LALStatus   *status,
		 REAL8Vector          *foft,
                 HoughTemplate        *pulsarTemplate,
		 REAL8Vector          *timeDiffV,
		 REAL8Cart3CoorVector *velV){
  
  INT4   mObsCoh;
  REAL8   f0new, vcProdn, timeDiffN;
  REAL8   sourceDelta, sourceAlpha, cosDelta;
  INT4    j,i, nspin, factorialN; 
  REAL8Cart3Coor  sourceLocation;
  
  /* --------------------------------------------- */
  INITSTATUS (status, "ComputeFoft", MCINJECTHOUGHS2C);
  ATTATCHSTATUSPTR (status);
  
  /*   Make sure the arguments are not NULL: */
  ASSERT (foft,  status, DRIVEHOUGHCOLOR_ENULL, DRIVEHOUGHCOLOR_MSGENULL);
  ASSERT (pulsarTemplate,  status, DRIVEHOUGHCOLOR_ENULL, DRIVEHOUGHCOLOR_MSGENULL);
  ASSERT (timeDiffV,  status, DRIVEHOUGHCOLOR_ENULL, DRIVEHOUGHCOLOR_MSGENULL);
  ASSERT (velV,  status, DRIVEHOUGHCOLOR_ENULL, DRIVEHOUGHCOLOR_MSGENULL);
  
  ASSERT (foft->data,  status, DRIVEHOUGHCOLOR_ENULL, DRIVEHOUGHCOLOR_MSGENULL);
  ASSERT (timeDiffV->data,  status, DRIVEHOUGHCOLOR_ENULL, DRIVEHOUGHCOLOR_MSGENULL);
  ASSERT (velV->data,  status, DRIVEHOUGHCOLOR_ENULL, DRIVEHOUGHCOLOR_MSGENULL);
  
  sourceDelta = pulsarTemplate->latitude;
  sourceAlpha = pulsarTemplate->longitude;
  cosDelta = cos(sourceDelta);
  
  sourceLocation.x = cosDelta* cos(sourceAlpha);
  sourceLocation.y = cosDelta* sin(sourceAlpha);
  sourceLocation.z = sin(sourceDelta);
    
  mObsCoh = foft->length;    
  nspin = pulsarTemplate->spindown.length;
  
  for (j=0; j<mObsCoh; ++j){  /* loop for all different time stamps */
    vcProdn = velV->data[j].x * sourceLocation.x
      + velV->data[j].y * sourceLocation.y
      + velV->data[j].z * sourceLocation.z;
    f0new = pulsarTemplate->f0;
    factorialN = 1;
    timeDiffN = timeDiffV->data[j];
    
    for (i=0; i<nspin;++i){ /* loop for spin-down values */
      factorialN *=(i+1);
      f0new += pulsarTemplate->spindown.data[i]* timeDiffN / factorialN;
      timeDiffN *= timeDiffN;
    }
    foft->data[j] = f0new * (1.0 +vcProdn);
  }    
    
  DETATCHSTATUSPTR (status);
  /* normal exit */
  RETURN (status);
}			
