#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

from optparse import OptionParser
import os
import sys

from glue import pipeline
from pylal import llwapp
from pylal import packing
from lalapps import power

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"[11:-2]
__date__ = "$Date$"[7:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version = "%prog CVS $Id$")
	parser.add_option("-a", "--args", default = "", help = "set command-line arguments for ligolw_burca")
	parser.add_option("-n", "--max-nodes", default = 400, help = "set the maximum number of nodes in the DAG")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	if not filenames:
		raise ValueError, "must provide list of filenames"

	return options, filenames

try:
	options, filenames = parse_command_line()
except ValueError, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)


#
# =============================================================================
#
#                              Static Parameters
#
# =============================================================================
#

out_dir = "logs/"
dag_log = "/tmp/kipp_burca.log"
dag_name = "burca"
executable = "/archive/home/kipp/local/bin/ligolw_burca"


#
# =============================================================================
#
#                                 Choose Bins
#
# =============================================================================
#

def compute_bin_count(size_name_pairs, maxnodes):
	"""
	Determine how many bins the files will be grouped into.  The
	algorithm is to try and set the number of bins to maxnodes unless
	that would result in the bins being too small.  If maxnodes bins
	would each be too small, then the count of bins is set so that each
	bin has 2**24 bytes of data in it (16 MiB), unless the single
	largest file is bigger than that in which case the count of bins is
	set so that each bin has as many bytes as the largest file.
	"""
	sizes = [item[0] for item in size_name_pairs]
	total_size = reduce(long.__add__, sizes)
	minimum_bin_size = max(min(2**24, total_size), max(sizes))
	return min(total_size / minimum_bin_size, maxnodes)


filenames = llwapp.measure_file_sizes(filenames, reverse = True)
bins = packing.BiggestIntoEmptiest(packing.bin_list(compute_bin_count(filenames, options.max_nodes)))
bins.packlist(filenames)


#
# =============================================================================
#
#                                 DAG Assembly
#
# =============================================================================
#

os.mkdir(out_dir)

dag = pipeline.CondorDAG(dag_log)
dag.set_dag_file(dag_name)

burcajob = power.BurcaJob(executable, out_dir, options.args or None)
for n, bin in enumerate(bins.bins):
	node = power.BurcaNode(burcajob)
	node.set_name("ligolw_burca_%d" % n)
	map(node.add_file_arg, bin.objects)
	dag.add_node(node)

dag.write_sub_files()
dag.write_dag()
