#!/usr/bin/python
#
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

from optparse import OptionParser
import math
import matplotlib
matplotlib.use("Agg")
from matplotlib import figure
from matplotlib.backends.backend_agg import FigureCanvasAgg
import numpy
import sys

from glue.ligolw import ligolw
from glue.ligolw import array
from glue.ligolw import param
from glue.ligolw import utils
from pylal import llwapp
from pylal import SnglBurstUtils
from pylal.xlal import inject

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__version__ = "$Revision$"
__date__ = "$Date$"

inject.cached_detector.update({
	"H1": inject.cached_detector["LHO_4k"],
	"H2": inject.cached_detector["LHO_2k"],
	"L1": inject.cached_detector["LLO_4k"]
})


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version="%prog CVS $Id$")
	parser.add_option("--correlation", metavar = "instrument", action = "append", default = [], help = "in correlation plot, show the traces for this instrument")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	return options, (filenames or [None])


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

def get_instrument(elem):
	return param.get_param(elem.parentNode, "instrument").pcdata


#
# =============================================================================
#
#                                    Plots
#
# =============================================================================
#

def make_frequency_plot(fseries):
	fig = figure.Figure()
	FigureCanvasAgg(fig)
	fig.set_figsize_inches(16, 8)
	axes = fig.gca()
	axes.semilogy()
	axes.grid(True)
	axes.plot(fseries[0], numpy.fabs(fseries[1]))
	axes.plot(fseries[0], numpy.fabs(fseries[2]))
	axes.plot(fseries[0], numpy.sqrt(fseries[1]**2.0 + fseries[2]**2.0))
	axes.set_xlim([min(fseries[0]), max(fseries[0])])
	axes.set_title("Frequency Decomposition of Confidence Time Series")
	axes.set_xlabel("Frequency (Hz)")
	axes.set_ylabel("Re, Im Magnitude")
	return fig


def normalize(array):
	"""
	Remove the DC offset, and normalize amplitude so square magnitude
	of data is 1.
	"""
	array = array.copy()
	array -= array.mean()
	return array / array.stddev() / math.sqrt(len(array))


class RatePlot(SnglBurstUtils.BurstPlot):
	def __init__(self, instrument, source_ra, source_dec):
		SnglBurstUtils.BurstPlot.__init__(self, r"Greenwich Mean Sidereal Time (rad)", r"\begin{center}Event Power Accumulation Rate\\(power / sidereal day / rad)\end{center}")
		self.axes.semilogy()
		self.axes.set_title(r"\begin{center}%s Event Power Accumulation Rate By Sidereal Time for\\Source at R.A. %g rad, Dec. %g rad\end{center}" % (instrument.replace("_", r"\_"), source_ra, source_dec))
		self.axes.set_xticks(numpy.arange(9) * math.pi / 4)
		self.axes.set_xticklabels([r"0", r"$\pi/4$", r"$\pi/2$", r"$3\pi/4$", r"$\pi$", r"$5\pi/4$", r"$3\pi/2$", r"$7\pi/4$", r"$2\pi$"])
		#self.axes.set_xticks(numpy.arange(25))
		self.instrument = instrument
		self.source_ra = source_ra
		self.source_dec = source_dec

		l, b, w, h = self.axes.get_position()
		self.axes2 = self.fig.add_axes((l, b, w, h / 3), sharex = self.axes)
		self.axes.set_position((l, b + h / 3, w, 2 * h / 3))
		self.axes2.grid(True)
		self.axes2.set_ylabel(r"\begin{center}Antenna Response\\($F_{+}^{2} + F_{\times}^{2}$)\end{center}")
		self.axes2.set_xlabel(r"Greenwich Mean Sidereal Time (rad)")

	def add_contents(self, rate):
		self.rate = rate

	def finish(self):
		self.sidereal_times = self.rate.xvals()
		sidereal_hours = self.sidereal_times / math.pi * 12.0
		n = len(self.sidereal_times)

		# Compute the normalized power accumulation rate and the
		# normalized response function
		rate = self.rate.ratio()
		response = numpy.array([plus**2.0 + cross**2.0 for (plus, cross) in map(lambda t: inject.XLALComputeDetAMResponse(inject.cached_detector[self.instrument].response(), self.source_ra, self.source_dec, 0.0, t), self.sidereal_times)], "Float64")
		normalized_rate = normalize(rate)
		normalized_response = normalize(response)

		# triplicate to simplify cross-correlation computation
		normalized_rate = numpy.concatenate((normalized_rate, normalized_rate, normalized_rate))
		normalized_response = numpy.concatenate((normalized_response, normalized_response, normalized_response))

		# compute cross-correlation
		self.correlation = numpy.zeros((n,), "Float64")
		self.resp_autocorr = numpy.zeros((n,), "Float64")
		for i in xrange(n):
			self.correlation[i] = numpy.inner(normalized_response[0:n], normalized_rate[i + n / 2 : i + 3 * n / 2])
			self.resp_autocorr[i] = numpy.inner(normalized_response[0:n], normalized_response[i + n / 2 : i + 3 * n / 2])

		# plot
		self.axes.plot(self.sidereal_times, rate, "k")
		self.axes2.plot(self.sidereal_times, response, "k")
		self.axes2.set_ylim([0, 1])


class CorrelationPlot(SnglBurstUtils.BurstPlot):
	def __init__(self, correlation_instruments):
		SnglBurstUtils.BurstPlot.__init__(self, r"Phase (rad)", r"Inner Product")
		self.axes.set_title(r"Projections of Event Power Accumulation Rate onto Antenna Response")
		self.axes.set_xticks(numpy.arange(9) * math.pi / 4)
		self.axes.set_xticklabels([r"$-\pi$", r"$-3\pi/4$", r"$-\pi/2$", r"$-\pi/4$", r"$0$", r"$\pi/4$", r"$\pi/2$", r"$3\pi/4$", r"$\pi$"])
		self.correlation_instruments = correlation_instruments
		self.correlation = {}

	def add_contents(self, rateplot):
		self.correlation[rateplot.instrument] = (rateplot.sidereal_times, rateplot.correlation, rateplot.resp_autocorr)

	def finish(self):
		colours = iter("bgrcmykw")
		legend = []
		for instrument, (sidereal_times, correlation, resp_autocorr) in self.correlation.iteritems():
			if options.correlation and instrument not in options.correlation:
				continue
			colour = colours.next()
			self.axes.plot(sidereal_times, 10 * correlation, "%s" % colour)
			self.axes.plot(sidereal_times, resp_autocorr, "%s--" % colour)
			legend.extend([r"%s \times 10" % instrument.replace(r"_", r"\_"), r"%s Response Autocorrelation" % instrument.replace(r"_", r"\_")])
		self.axes.set_ylim([-1, 1])
		self.axes.legend(legend)


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

options, filenames = parse_command_line()

for filename in filenames:
	doc = utils.load_filename(filename, options.verbose)
	for elem in array.getArraysByName(doc, "confidence_frequencies"):
		fig = make_frequency_plot(elem.array)
		outname = "%s_frequency_%s.png" % (filename, get_instrument(elem))
		if options.verbose:
			print >>sys.stderr, "writing %s..." % outname
		fig.savefig(outname)
	correlation = CorrelationPlot(options.correlation)
	for elem in param.getParamsByName(doc, "rate"):
		instrument = get_instrument(elem)
		outname = "%s_rate_%s.png" % (filename, instrument)
		if options.verbose:
			print >>sys.stderr, "generating %s..." % outname
		plot = RatePlot(instrument, 2.0318570464121519, -0.50628171572274738)
		plot.add_contents(llwapp.pickle_from_param(elem, "rate"))
		plot.finish()
		correlation.add_contents(plot)
		if options.verbose:
			print >>sys.stderr, "writing %s..." % outname
		plot.fig.savefig(outname)
	correlation.finish()
	outname = "%s_correlation.png" % filename
	if options.verbose:
		print >>sys.stderr, "writing %s..." % outname
	correlation.fig.savefig(outname)
