#!/usr/bin/python
#
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


"""
Burst trigger frequency decomposition.
"""

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__date__ = "$Date$"
__version__ = "$Revision$"

import math
import numpy
from optparse import OptionParser
from pysqlite2 import dbapi2 as sqlite
import sys

from glue import segments
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import array
from glue.ligolw import param
from glue.ligolw import lsctables
from glue.ligolw import utils
from pylal import llwapp
from pylal import date
from pylal import rate
from pylal import SnglBurstUtils


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(version = "%prog CVS $Id$")
	parser.add_option("--delta-f", metavar = "Hz", help = "set the frequency bin spacing")
	parser.add_option("--n-f", metavar = "count", help = "set the number of frequency bins")
	parser.add_option("-o", "--output", metavar = "filename", help = "write to filename (default = stdout)")
	parser.add_option("--f-naught", metavar = "Hz", default = "0", help = "set lowest frequency bin (default = 0 Hz)")
	parser.add_option("--t-naught", metavar = "GPS seconds", default = "0", help = "set origin of time coordinate (default = 0)")
	parser.add_option("--only-rate", action = "store_true", help = "only compute trigger confidence rates")
	parser.add_option("--program", metavar = "name", default = "power", help = "set name of program that generated the triggers (default = \"power\")")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	if not options.only_rate:
		try:
			options.n_f = int(options.n_f)
		except Exception:
			raise ValueError, "invalid or missing --n-f"
		try:
			options.delta_f = float(options.delta_f)
		except Exception:
			raise ValueError, "invalid or missing --delta-f"
		try:
			options.f_naught = float(options.f_naught)
		except Exception:
			raise ValueError, "invalid --f-naught"
		try:
			options.t_naught = date.LIGOTimeGPS(options.t_naught)
		except Exception:
			raise ValueError, "invalid --t-naught"

	return options, (filenames or [None])


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#


#
# Override some methods of the SnglBurst and SearchSummary row classes
#


class SnglBurst(SnglBurstUtils.SnglBurst):
	def get_stop(self):
		# lal doesn't include stop time column, so need a different
		# function
		return date.LIGOTimeGPS(self.start_time, self.start_time_ns) + self.duration

	def get_power(self):
		# extra method to recover normalized event power
		return self.snr + 2.0 * self.tfvolume


class SearchSummary(lsctables.SearchSummary):
	def get_out(self):
		# use date.LIGOTimeGPS insetad of lal.LIGOTimeGPS
		return segments.segment(date.LIGOTimeGPS(self.out_start_time, self.out_start_time_ns), date.LIGOTimeGPS(self.out_end_time, self.out_end_time_ns))


SnglBurstUtils.SnglBurstTable.RowType = SnglBurst
lsctables.SearchSummaryTable.RowType = SearchSummary


#
# input cross-checks
#


def verify_burst_events(database):
	for event in database.sngl_burst_table:
		seg = segments.segment(event.get_start(), event.get_stop())
		if seg not in database.seglists[event.ifo]:
			raise ValueError, "event spanning times %s for instrument %s not contained in search summary segments" % (str(seg), event.ifo)


#
# =============================================================================
#
#                                  Transform
#
# =============================================================================
#


def new_fseries(f_0, delta_f, n):
	"""
	Initialize and return an array for holding a single-instrument data
	set.
	"""
	f = numpy.zeros((3, n), "Float64")
	f[0] = f_0 + numpy.arange(n) * delta_f
	return f


def fourier_transform(sngl_burst_table, options):
	"""
	Returns
	
	C_{k} = \int_{t_{\mathrm{start}}}^{t_{\mathrm{stop}}} C(t) \exp^{-2 \pi \aye f_{k} t} \diff t

	where \(C(t)\) is confidence as a function of time for the events
	in the sngl_burst table, and \(f_{k} = \delta f \cdot k\) for \(k
	\in [0, nf)\).
	"""
	fseries = {}
	for n, event in enumerate(sngl_burst_table):
		if not n % max(len(sngl_burst_table) / 1000, 200):
			print >>sys.stderr, "	%.1f%%\r" % (100.0 * n / len(sngl_burst_table)),
		if event.ifo not in fseries:
			fseries[event.ifo] = new_fseries(options.f_naught, options.delta_f, options.n_f)
		value = event.get_power() / (-2j * math.pi) / fseries[event.ifo][0] * (numpy.exp(-2j * math.pi * float(event.get_stop() - options.t_naught) * fseries[event.ifo][0]) - numpy.exp(-2j * math.pi * float(event.get_start() - options.t_naught) * fseries[event.ifo][0]))
		fseries[event.ifo][1] += value.real
		fseries[event.ifo][2] += value.imag
	print >>sys.stderr, "	100.0%"

	return fseries


def new_rate():
	# 1 filter-width per 1 sidereal minute
	return rate.RatiosRate(segments.segment(0.0, 2.0 * math.pi), 60.0 * math.pi / 43200.0)


def bin_power_by_sidereal_time(rates, sngl_burst_table):
	for n, event in enumerate(sngl_burst_table):
		if event.ifo not in rates:
			rates[event.ifo] = new_rate()
		start = date.XLALGreenwichMeanSiderealTime(event.get_start())
		stop = date.XLALGreenwichMeanSiderealTime(event.get_stop())
		duration = stop - start
		start %= 2.0 * math.pi
		stop %= 2.0 * math.pi
		if stop >= start:
			rates[event.ifo].incnumerator((segments.segment(start, stop),), event.get_power() / duration)
		else:
			rates[event.ifo].incnumerator((segments.segment(start, 2.0 * math.pi),), event.get_power() / duration)
			rates[event.ifo].incnumerator((segments.segment(0.0, stop),), event.get_power() / duration)


def gps_seglist_to_gmst(seglist):
	return segments.segmentlist([segments.segment(date.XLALGreenwichMeanSiderealTime(start), date.XLALGreenwichMeanSiderealTime(stop)) for (start, stop) in seglist])


def bin_livetime_by_sidereal_time(rates, segmentlists):
	for key, value in segmentlists.iteritems():
		if key not in rates:
			rates[key] = new_rate()
		value = gps_seglist_to_gmst(value)
		# in this formula, we add a little bit to the stop time to
		# ensure we generate a segment for the last day
		gmst_days = segmentsUtils.segmentlist_range(value[0][0] - value[0][0] % (2.0 * math.pi), value[-1][1] - value[-1][1] % (2.0 * math.pi) + 2.0 * math.pi + 0.5, 2.0 * math.pi)
		for seglist in segmentsUtils.Fold(value, gmst_days):
			for seg in seglist:
				# take a negligible amount off the
				# segment's upper bound to hack around
				# precision issues
				rates[key].incdenominator((segments.segment(seg[0], seg[1] - 1e-9),))


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#


def new_doc(fseries, rates):
	if options.verbose:
		print >>sys.stderr, "generating output document ..."
	doc = ligolw.Document()
	container = ligolw.LIGO_LW()
	doc.appendChild(container)
	for key, value in fseries.iteritems():
		container.appendChild(ligolw.LIGO_LW())
		container.childNodes[-1].appendChild(param.new_param("instrument", "lstring", key))
		container.childNodes[-1].appendChild(array.from_array("sngl_burst:confidence_frequencies:array", value, ["Bin", "Hz Re(C_k) Im(C_k)"]))
	for key, value in rates.iteritems():
		container.appendChild(ligolw.LIGO_LW())
		container.childNodes[-1].appendChild(param.new_param("instrument", "lstring", key))

		container.childNodes[-1].appendChild(llwapp.pickle_to_param(rates[key], "rate"))
	return doc


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


options, filenames = parse_command_line()


fseries = {}
rates = {}
for n, filename in enumerate(utils.sort_files_by_size(filenames, options.verbose)):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	database = SnglBurstUtils.CoincDatabase(sqlite.connect(":memory:"))
	xmldoc = utils.load_filename(filename, options.verbose, gz = filename[-3:] == ".gz")
	database.summarize(xmldoc, options.program, options.verbose)

	# check that triggers are all inside segments
	if options.verbose:
		print >>sys.stderr, "verifying event times ..."
	verify_burst_events(database)

	# bin by sidereal time
	if options.verbose:
		print >>sys.stderr, "binning power and live time by sidereal time..."
	bin_power_by_sidereal_time(rates, database.sngl_burst_table)
	bin_livetime_by_sidereal_time(rates, database.seglists)

	# Fourier transform
	if not options.only_rate:
		if options.verbose:
			print >>sys.stderr, "Fourier transforming power..."
		newfseries = fourier_transform(database.sngl_burst_table, options)
		for key, value in newfseries.iteritems():
			if key in fseries:
				fseries[key][1:] += value[1:]
			else:
				fseries[key] = value
	xmldoc.unlink()


utils.write_filename(new_doc(fseries, rates), options.output, options.verbose)
