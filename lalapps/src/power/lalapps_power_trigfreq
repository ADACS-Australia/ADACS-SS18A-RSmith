#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

"""
Burst trigger frequency decomposition.
"""

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__date__ = "$Date$"[7:-2]
__version__ = "$Revision$"[11:-2]

import math
import numarray
from optparse import OptionParser
import sys

from glue import segments
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import array
from glue.ligolw import param
from glue.ligolw import lsctables
from pylal import llwapp
from pylal import date
from pylal import rate


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	parser = OptionParser(version = "%prog CVS $Id$")
	parser.add_option("--delta-f", metavar = "Hz", help = "set the frequency bin spacing")
	parser.add_option("--n-f", metavar = "count", help = "set the number of frequency bins")
	parser.add_option("-o", "--output", metavar = "filename", help = "write to filename (default = stdout)")
	parser.add_option("--f-naught", metavar = "Hz", default = "0", help = "set lowest frequency bin (default = 0 Hz)")
	parser.add_option("--t-naught", metavar = "GPS seconds", default = "0", help = "set origin of time coordinate (default = 0)")
	parser.add_option("--only-rate", action = "store_true", help = "only compute trigger confidence rates")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, filenames = parser.parse_args()

	if not options.only_rate:
		try:
			options.n_f = int(options.n_f)
		except Exception:
			raise ValueError, "invalid or missing --n-f"
		try:
			options.delta_f = float(options.delta_f)
		except Exception:
			raise ValueError, "invalid or missing --delta-f"
		try:
			options.f_naught = float(options.f_naught)
		except Exception:
			raise ValueError, "invalid --f-naught"
		try:
			options.t_naught = date.LIGOTimeGPS(options.t_naught)
		except Exception:
			raise ValueError, "invalid --t-naught"

	return options, (filenames or [None])


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

def element_filter(name, attrs):
	return lsctables.IsTableProperties(lsctables.SnglBurstTable, name, attrs) or lsctables.IsTableProperties(lsctables.ProcessTable, name, attrs) or lsctables.IsTableProperties(lsctables.SearchSummaryTable, name, attrs)


class ContentHandler(ligolw.PartialLIGOLWContentHandler):
	def __init__(self, doc):
		ligolw.PartialLIGOLWContentHandler.__init__(self, doc, element_filter)


llwapp.ContentHandler = ContentHandler


class SnglBurst(object):
	__slots__ = ["ifo", "confidence", "start_time", "start_time_ns", "duration"]

	def get_start(self):
		return date.LIGOTimeGPS(self.start_time, self.start_time_ns)

	def get_stop(self):
		return self.get_start() + self.duration


def search_summary_get_out(self):
	return segments.segment(date.LIGOTimeGPS(self.out_start_time, self.out_start_time_ns), date.LIGOTimeGPS(self.out_end_time, self.out_end_time_ns))


lsctables.SnglBurstTable.RowType = SnglBurst
lsctables.SearchSummary.get_out = search_summary_get_out


#
# =============================================================================
#
#                                  Transform
#
# =============================================================================
#

def new_fseries(f_0, delta_f, n):
	"""
	Initialize and return an array for holding a single-instrument data
	set.
	"""
	f = numarray.zeros((3, n), "Float64")
	f[0] = f_0 + numarray.arange(n) * delta_f
	return f


def fourier_transform(eventlist, options):
	"""
	Returns
	
	C_{k} = \int_{t_{\mathrm{start}}}^{t_{\mathrm{stop}}} C(t) \exp^{-2 \pi \aye f_{k} t} \diff t

	where \(C(t)\) is confidence as a function of time for the events
	in the eventlist, and \(f_{k} = \delta f \cdot k\) for \(k \in [0,
	nf)\).
	"""
	fseries = {}
	for n, event in enumerate(eventlist):
		if not n % max(len(eventlist) / 1000, 200):
			print >>sys.stderr, "	%.1f%%\r" % (100.0 * n / len(eventlist)),
		if event.ifo not in fseries:
			fseries[event.ifo] = new_fseries(options.f_naught, options.delta_f, options.n_f)
		value = -event.confidence / (-2j * math.pi) / fseries[event.ifo][0] * (numarray.exp(-2j * math.pi * float(event.get_stop() - options.t_naught) * fseries[event.ifo][0]) - numarray.exp(-2j * math.pi * float(event.get_start() - options.t_naught) * fseries[event.ifo][0]))
		fseries[event.ifo][1] += value.real
		fseries[event.ifo][2] += value.imag
	print >>sys.stderr, "	100.0%"

	return fseries


def bin_by_sidereal_time(rates, eventlist):
	for n, event in enumerate(eventlist):
		if event.ifo not in rates:
			# 1000 bins per sidereal day
			rates[event.ifo] = rate.Rate(segments.segment(0.0, 2.0 * math.pi), 2.0 * math.pi / 1000.0)
		start = date.XLALGreenwichMeanSiderealTime(event.get_start()) % (2.0 * math.pi)
		stop = date.XLALGreenwichMeanSiderealTime(event.get_stop()) % (2.0 * math.pi)
		rates[event.ifo][segments.segment(start, stop)] = -event.confidence


def gps_seglist_to_gmst(seglist):
	return segments.segmentlist([segments.segment(date.XLALGreenwichMeanSiderealTime(seg[0]), date.XLALGreenwichMeanSiderealTime(seg[1])) for seg in seglist])


def normalize_sidereal_bins(rates, segmentlists):
	for key, value in segmentlists.iteritems():
		# 1000 bins per sidereal day
		livetime = rate.Rate(segments.segment(0.0, 2.0 * math.pi), 2.0 * math.pi / 1000.0)
		gmst_days = segmentsUtils.segment_range(value[0][0] - value[0][0] % (2.0 * math.pi), value[-1][1] - value[-1][1] % (2.0 * math.pi) + 2.0 * math.pi, 2.0 * math.pi)
		for seglist in segmentsUtils.Fold(gps_seglist_to_gmst(value), gmst_days):
			for seg in seglist:
				# take a negligible amount off the segment's
				# uppoer bound to hack around precision issues
				livetime[segments.segment(seg[0], seg[1] - 1e-10)] = 1.0
		rates[key].array /= numarray.where(rates[key].array > 0.0, livetime.array, 1.0)


#
# =============================================================================
#
#                                    Output
#
# =============================================================================
#

def new_doc(fseries, rates):
	doc = ligolw.Document()
	container = ligolw.LIGO_LW()
	doc.appendChild(container)
	for key, value in fseries.iteritems():
		container.appendChild(ligolw.LIGO_LW())
		container.childNodes[-1].appendChild(param.new_param("instrument", "lstring", key))
		container.childNodes[-1].appendChild(array.from_array("sngl_burst:confidence_frequencies:array", value, ["Bin", "Hz Re(C_k) Im(C_k)"]))
	for key, value in rates.iteritems():
		container.appendChild(ligolw.LIGO_LW())
		container.childNodes[-1].appendChild(param.new_param("instrument", "lstring", key))

		container.childNodes[-1].appendChild(llwapp.pickle_to_param(rates[key], "rate"))
	return doc


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

options, filenames = parse_command_line()

segmentlists = segments.segmentlistdict()
fseries = {}
rates = {}
for n, filename in enumerate(llwapp.sort_files_by_size(filenames, options.verbose)):
	if options.verbose:
		print >>sys.stderr, "%d/%d:" % (n + 1, len(filenames)),
	doc = llwapp.load_filename(filename, options.verbose)
	segmentlists |= llwapp.segmentlistdict_fromsearchsummary(doc, "power")
	eventlist = llwapp.get_table(doc, lsctables.SnglBurstTable.tableName)
	if options.verbose:
		print >>sys.stderr, "transforming %d events..." % len(eventlist)
	# for better numerical accuracy, process events with smallest
	# confidence first.
	eventlist.sort(lambda a, b: cmp(a.confidence, b.confidence))

	# bin by sidereal time
	bin_by_sidereal_time(rates, eventlist)

	# Fourier transform
	if not options.only_rate:
		newfseries = fourier_transform(eventlist, options)
		for key, value in newfseries.iteritems():
			if key in fseries:
				fseries[key][1:] += value[1:]
			else:
				fseries[key] = value
	doc.unlink()

normalize_sidereal_bins(rates, segmentlists)
llwapp.write_filename(new_doc(fseries, rates), options.output, options.verbose)
