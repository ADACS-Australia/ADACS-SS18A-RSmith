#include <math.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <FrameL.h>
#include "series.h"

double epoch_diff( const epoch *t2, const epoch *t1 )
{
  long long dt;
  dt  = 1000000000LL * (long long) t2->sec;
  dt += (long long) t2->nan;
  dt -= 1000000000LL * (long long) t1->sec;
  dt -= (long long) t1->nan;
  return (double)dt;
}

void epoch_add( epoch *t1, epoch *t0, double dt )
{
  long long t;
  t  = 1000000000LL * (long long) t0->sec;
  t += (long long) t0->nan;
  t += (long long)( 1e9 * dt );
  t1->sec = t / 1000000000LL;
  t1->nan = t % 1000000000LL;
  return;
}

int write_ilwd( const char *fname, const struct series *ser )
{
  size_t i;
  FILE *fp;
  fp = fopen( fname, "w" );
  fprintf( fp, "<?ilwd?>\n" );
  if ( IS_TIME( ser->type ) )
  {
    fprintf( fp, "<ilwd name='%s::sequence' size='7'>\n", ser->name );
    fprintf( fp, "<lstring name='complex:domain' size='4'>TIME</lstring>\n" );
  }
  else
  {
    fprintf( fp, "<ilwd name='%s::sequence' size='9'>\n", ser->name );
    fprintf( fp, "<lstring name='complex:domain' size='4'>FREQ</lstring>\n" );
  }
  fprintf( fp, "<int_4u name='gps_sec:start_time' units='sec'>%d</int_4u>\n",
      ser->tbeg.sec );
  fprintf( fp, "<int_4u name='gps_nan:start_time' units='nanosec'>%d</int_4u>\n",
      ser->tbeg.nan );
  fprintf( fp, "<int_4u name='gps_sec:stop_time' units='sec'>%d</int_4u>\n",
      ser->tend.sec );
  fprintf( fp, "<int_4u name='gps_nan:stop_time' units='nanosec'>%d</int_4u>\n",
      ser->tend.nan );
  if ( IS_TIME( ser->type ) )
  {
    fprintf( fp, "<real_8 name='time:step_size' units='sec'>%e</real_8>\n",
        ser->step );
  }
  else
  {
    fprintf( fp, "<real_8 name='start_freq' units='hz'>0</real_8>\n" );
    fprintf( fp, "<real_8 name='stop_freq' units='hz'>%e</real_8>\n",
        ( ser->size - 1 ) * ser->step );
    fprintf( fp, "<real_8 name='freq:step_size' units='hz'>%e</real_8>\n", 
        ser->step );
  }
  fprintf( fp, "<complex_8 dims='%d' name='data' units='%s'>",
      (int)ser->size, ser->unit );
  fprintf( fp, "%e %e", ser->data[0], ser->data[1] );
  for ( i = 1; i < ser->size; ++i )
    fprintf( fp, " %e %e", ser->data[2*i], ser->data[2*i+1] );
  fprintf( fp, "</complex_8>\n" );
  fprintf( fp, "</ilwd>\n" );
  fclose( fp );
  return 0;
}

FrameH *fr_add_proc_data( FrameH *frame, const struct series *ser )
{
  char channel[256];
  char comment[] = "Generated by $Id$";
  char seconds[] = "s";
  char hertz[]   = "Hz";
  struct FrVect     *vect;
  struct FrProcData *proc;
  size_t i;

  if ( ! frame )
  {
    char src[2];
    src[0] = ser->name[0];
    src[1] = 0;
    frame = FrameHNew( src );
    frame->run    = 1;
    frame->frame  = 1;
    frame->GTimeS = ser->tbeg.sec;
    frame->GTimeN = ser->tbeg.nan;
    frame->dt     = epoch_diff( &ser->tend, &ser->tbeg );
  }

  /* get rid of mangling */
  strcpy( channel, ser->name );
  strcpy( channel + 2, ser->name + 3 );

  vect = FrVectNew1D( channel, FR_VECT_8C, ser->size, ser->step,
      IS_TIME( ser->type ) ? seconds : hertz, ser->unit );
  proc = calloc( 1, sizeof( *proc ) );
  proc->classe     = FrProcDataDef();
  proc->sampleRate = IS_TIME( ser->type ) ? 1.0 / ser->step : -1;
  proc->fShift     = 0;
  proc->data       = vect;
  proc->next       = frame->procData;
  frame->procData  = proc;
  FrStrCpy( &proc->name, ser->name );
  FrStrCpy( &proc->comment, comment );
  for ( i = 0; i < ser->size; ++i )
  {
    vect->dataF[2*i]   = ser->data[2*i];
    vect->dataF[2*i+1] = ser->data[2*i+1];
  }

  return frame;
}
