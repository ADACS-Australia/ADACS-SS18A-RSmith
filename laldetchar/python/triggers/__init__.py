# Copyright (C) 2011 Duncan Macleod
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation,.

## \addtogroup pkg_py_laldetchar_triggers
"""A collestion of modules for manipulating the output of LIGO-Virgo
event trigger generators (ETGs)
"""
#
#\heading{Synopsis}
#~~~
#from laldetchar import triggers
#~~~
#\author Duncan Macleod (<duncan.macleod@ligo.org>)

from __future__ import division

import re
import sys
import numpy

from glue import iterutils
from glue.ligolw import (ligolw, lsctables, utils as ligolw_utils,
                         table as ligolw_table)

from laldetchar import git_version

__author__ = "Duncan Macleod <duncan.macleod@ligo.org>"
__version__ = git_version.id
__date__ = git_version.date

_re_etg_kw = re.compile("\A(kw|kleinewelle)\Z", re.I)
_re_etg_omega = re.compile("\Aomega\Z", re.I)
_re_etg_ep = re.compile("\A(ep|excesspower|gstlal_excesspower)\Z", re.I)
_re_etg_sngl_burst = re.compile("\A(kw|kleinewelle|omega|ep|excesspower|"
                                  "gstlal_excesspower|hacr)\Z", re.I)

_re_etg_cwb = re.compile("(cwb|waveburst)", re.I)
_re_etg_multi_burst = re.compile("(cwb|waveburst)", re.I)

_re_etg_di = re.compile("\Adaily*ihope\Z", re.I)
_re_etg_ihope = re.compile("\Aihope\Z", re.I)
_re_etg_sngl_insp = re.compile("ihope", re.I)

_re_etg_cohptf = re.compile("\Acoh_PTF", re.I)
_re_etg_multi_insp = re.compile("\Acoh_PTF", re.I)

_re_etg_ring = re.compile("ring", re.I)
_re_etg_sngl_ring = re.compile("ring", re.I)

_re_etg_sim_insp = re.compile("sim*inspiral", re.I)

# open doxygen
#@{

def which_table(etg):
    """@returns the name of the LIGO_LW table appropriate for triggers
    generated by the given etg
    """
    if _re_etg_sngl_burst.search(etg):
        return lsctables.SnglBurstTable.tableName
    elif _re_etg_multi_burst.search(etg):
        return lsctables.MultiBurstTable.tableName
    elif _re_etg_sngl_insp.search(etg):
        return lsctables.SnglInspiralTable.tableName
    elif _re_etg_multi_insp.search(etg):
        return lsctables.MultiInspiralTable.tableName
    elif _re_etg_sngl_ring.search(etg):
        return lsctables.SnglRingdownTable.tableName
    raise ValueError("No LIGO_LW table mapped for ETG=\'%s\'" % etg)


def new_ligolw_table(etg, columns=None):
    """@returns a new glue.ligolw.table relevant for the given event
    trigger generator (etg)
    """
    table_name = which_table(etg)
    out = lsctables.New(lsctables.TableByName(table_name), columns=columns)
    if columns is not None:
        if isinstance(columns[0], str):
            columns = map(str.lower, columns)
        if isinstance(columns[0], unicode):
            columns = map(unicode.lower, columns)
        for c in out.columnnames:
            if c.lower() not in columns:
                idx = out.columnnames.index(c)
                out.columnnames.pop(idx)
                out.columntypes.pop(idx)
    return out


def load_table_from_fileobj(fileobj, etg, columns=None, start=None,
                            end=None):
    """@returns a glue.ligolw.table of triggers read from the given
    LIGOLw XML fileobj
    """
    table_name = which_table(etg)
    xmldoc, digest = ligolw_utils.load_fileobj(fileobj,
                                               gz=fileobj.name.endswith("gz"))
    doctable = ligolw_table.get_table(xmldoc, table_name)
    if columns:
        out = new_ligolw_table(etg, columns=columns)
        out.extend(doctable)
    else:
        out = doctable
    if start or end:
        get_time = get_time_func(out.tableName)
        keep = lambda t: ((start and start <= float(get_time(t)) or True) &
                          (end and float(get_time(t)) < end or True))
        iterutils.inplace_filter(keep, out)
    return out


def load_table_from_filenames(filelist, etg, columns=None, verbose=False,
                              load_func=load_table_from_fileobj, **load_args):
    """@returns a glue.ligolw.table containing the triggers from each
    file in the list, in the correct format for the given etg.

    @param filelist
        list of filepaths from which to read the data
    @param etg
        name of event trigger generator that produced LIGO_LW files
    @param columns
        set of valid SnglBurst columns to read from data
    @param verbose
        print verbose progress, default False
    @param load_func
        function to use when loading the events, defaults to
        load_ligolw_from_fileobj

    All other keyword arguments will be passed directory to load_func
    """
    if verbose:
        N = len(filelist)
        sys.stdout.write("Extracting %s triggers from %d files...     \r"
                         % (etg, N))
        sys.stdout.flush()
    # load first file to load the columns dynamically
    if filelist:
        with open(filelist[0], "r") as f:
            out = load_func(f, etg, columns=columns, **load_args)
        filelist = filelist[1:]
        if verbose:
            sys.stdout.write("Extracting %s triggers from %d files... "
                             "%.2d%%\r" % (etg, N, int(1/N*100)))
            sys.stdout.flush()
    else:
        out = new_ligolw_table(etg, columns=columns)
    # load the rest
    extend = out.extend
    for i,fp in enumerate(filelist):
        with open(fp, "r") as f:
            extend(load_func(f, etg, columns=columns, **load_args))
        if verbose:
            progress = int((i+1)/N*100)
            sys.stdout.write("Extracting %s triggers from %d files... "
                             "%.2d%%\r" % (etg, N, progress))
            sys.stdout.flush()
    if verbose:
        sys.stdout.write("Extracting %s triggers from %d files... "
                         "100%%\n" % (etg, N))
        sys.stdout.flush()
    return out


def load_table_from_lal_cache(cache, etg, columns=None, verbose=False,
                              load_func=load_table_from_fileobj, **load_args):
    """@returns a glue.ligolw.table containing the triggers from each
    file in the cache, in the correct format for the given etg.

    @param filelist
        list of filepaths from which to read the data
    @param etg
        name of event trigger generator that produced LIGO_LW files
    @param columns
        set of valid SnglBurst columns to read from data
    @param verbose
        print verbose progress, default False
    @param load_func
        function to use when loading the events, defaults to
        load_ligolw_from_fileobj

    All other keyword arguments will be passed directory to load_func
    """
    return load_table_from_filenames(cache.pfnlist(), etg, columns=columns,
                                     verbose=verbose, load_func=load_func,
                                     **load_args)


def get_time_func(table_name, ifo=None):
    """@returns a function to return the 'time' of an event in any table
    with the given name.

    @param table_name
        name of the relevant LIGO_LW table
    @param ifo
        interferometer prefix if extracting single-detector time
    """
    if re.search("burst", table_name, re.I):
        return lambda row: row.get_peak()
    elif re.search("inspiral", table_name, re.I):
        return lambda row: row.get_end()
    elif re.search("sim*inspiral", table_name, re.I):
        site = ifo and ifo[0] or None
        return lambda row: row.get_end(site)
    elif re.search("ringdown", table_name, re.I):
        return lambda row: row.get_start()
    else:
        raise ValueError("No known time method for table_name=\'%s\'"
                         % table_name)


def get_time_column(table, ifo=None):
    """@returns a numpy Array containing the 'time' of each row in the
    given table.

    @param table
        a glue.table.Table object representing a LIGO_LW xml table
    @param ifo
        interferometer prefix if extracting single-detector time
    """
    table_name = table.tableName
    if re.search("inspiral", table_name, re.I):
        return numpy.asarray(table.get_end())
    elif re.search("ringdown", table_name, re.I):
        return numpy.asarray(table.get_start())
    else:
        get_time = get_time_func(table_name)
        return numpy.asarray(map(get_time, table))

# close doxygen
#@}
