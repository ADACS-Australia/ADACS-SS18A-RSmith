//
//  Copyright (C) 2011 Karl Wette
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with with program; see the file COPYING. If not, write to the
//  Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
//  MA  02111-1307  USA
//

// SWIG interface code for GSL functions and structures
// Author: Karl Wette, 2011

/////////////// GSL vectors and matrices ///////////////

// This macro defines wrappng classes representing GSL vectors and
// matrices, as well as functions used to create and destroy them.
//
// Note that these classes do not include every variable that is
// defined by the GSL vector and matrix C structs; only the data and
// dimension variables are defined. This is okay; as long as they
// have the same names, SWIG will match them to the variables in the
// real underlying C structs.
//
// Note too that the type of the data variable in the wrapping class
// does not even have to match the type of the same variable in the
// C struct; e.g. in a gsl_vector_complex struct, data is *not* a
// pointer to an array of gsl_complex, but to an array of double
// (which is twice the size, to pack the real and imaginary parts).
// This is also okay, because we never refer to the data variable in
// the wrapping class; it exists only to give the correct name and
// type to the typemaps and accessor methods generated by the
// swiglal_dynamic_* macros. Instead we use GSL functions, such as
// gsl_*_ptr, to access the underlying struct, and these require
// only the SELF pointer.
%define swiglal_gsl_vecmat(TYPE, NAME)

  // These macros return pointers to the (I)th element of the GSL vector,
  // and the (I,J)th element of the GSL matrix respectively. They are for
  // use with the swiglal_{vector,matrix}_convert_{in,out} macros.
  #define swiglal_gsl_vector##NAME##_ptr(DATA, I, NI) \
    gsl_vector##NAME##_ptr(arg1, I)
  #define swiglal_gsl_matrix##NAME##_ptr(DATA, I, NI, J, NJ) \
    gsl_matrix##NAME##_ptr(arg1, I, J)

  // Wrapping class representing a GSL vector of type NAME.
  // Con/destructors call GSL functions to create/destroy the vector.
  // Data is exposes using the swiglal_dynamic_vector_... macros.
  %nodefaultctor gsl_vector##NAME;
  %nocopyctor    gsl_vector##NAME;
  %nodefaultdtor gsl_vector##NAME;
  struct gsl_vector##NAME {
    %extend {
      gsl_vector##NAME(const size_t n) {
        return gsl_vector##NAME##_calloc(n);
      }
      gsl_vector##NAME(gsl_vector##NAME *v0) {
        gsl_vector##NAME *v = gsl_vector##NAME##_alloc(v0->size);
        gsl_vector##NAME##_memcpy(v, v0);
        return v;
      }
      ~gsl_vector##NAME() {
        gsl_vector##NAME##_free($self);
      }
    }
    swiglal_dynamic_vector_begin(TYPE, data, size, swiglal_gsl_vector##NAME##_ptr, SL_AV_DEFAULT);
    size_t size;
    TYPE *data;
    swiglal_dynamic_vector_end(TYPE, data, size1);
  };

  // Wrapping class representing a GSL matrix of type NAME.
  // Con/destructors call GSL functions to create/destroy the matrix.
  // Data is exposes using the swiglal_dynamic_matrix_... macros.
  %nodefaultctor gsl_matrix##NAME;
  %nocopyctor    gsl_matrix##NAME;
  %nodefaultdtor gsl_matrix##NAME;
  struct gsl_matrix##NAME {
    %extend {
      gsl_matrix##NAME(const size_t n1, const size_t n2) {
        return gsl_matrix##NAME##_calloc(n1, n2);
      }
      gsl_matrix##NAME(gsl_matrix##NAME *m0) {
        gsl_matrix##NAME *m = gsl_matrix##NAME##_alloc(m0->size1, m0->size2);
        gsl_matrix##NAME##_memcpy(m, m0);
        return m;
      }
      ~gsl_matrix##NAME() {
        gsl_matrix##NAME##_free($self);
      }
    }
    swiglal_dynamic_matrix_begin(TYPE, data, size1, size2, swiglal_gsl_matrix##NAME##_ptr, SL_AV_DEFAULT);
    size_t size1;
    size_t size2;
    TYPE *data;
    swiglal_dynamic_matrix_end(TYPE, data, size1, size2);
  };

%enddef // swiglal_gsl_vecmat

// GSL integer vectors and matrices.
swiglal_gsl_vecmat(short, _short);
swiglal_gsl_vecmat(unsigned short, _ushort);
swiglal_gsl_vecmat(int, _int);
swiglal_gsl_vecmat(unsigned int, _uint);
swiglal_gsl_vecmat(long, _long);
swiglal_gsl_vecmat(unsigned long, _ulong);

// GSL real and complex vectors and matrices
swiglal_gsl_vecmat(float, _float);
swiglal_gsl_vecmat(double, ); // GSL double vec./mat. has no typename suffix.
swiglal_gsl_vecmat(gsl_complex_float, _complex_float);
swiglal_gsl_vecmat(gsl_complex, _complex);
