\documentclass[12pt]{article}
\usepackage{amsmath,psfig}

\begin{document}
\huge
\begin{center}
TappRpnTdomTime.c
\end{center}
\normalsize
\vspace{10mm}

\section{Purpose}

The code \texttt{TappRpnTdomTime.c} generates a chirp waveform for a binary system consisting of two non--spinning point--mass stars in quasi--circular orbits, up to second post--Newtonian order. The method used is as follows.

A gravitational wave detector is sensitive to the linear combination of the two polarizations $h_{+}$ and $h_{\times}$ of the gravitational wave, in the following way,
\begin{equation}
h(t) = F_{+} h_{+} (t) + F_{\times} h_{\times} (t) \,\,,
\label{hoft}
\end{equation}
where $F_{+}$ and $F_{\times}$ are the \emph{beam--pattern functions} of the detector.
The two polarizations $h_{+}$ and $h_{\times}$ of the gravitational wave are given by the following equation, which is taken from Blanchet, Iyer, Will and Wiseman, CQG \textbf{13}, 575, 1996, which we will abbreviate as BIWW from now on.

\begin{equation}
\begin{split}
h_{+,\times} &=  \frac{2Gm \eta}{c^{2}_{0} r} \left(\frac{Gm \omega}{c^{3}_{0}} \right)^{2/3} \left\{ \right. H^{(0)}_{+,\times} + x^{1/2} H^{(1/2)}_{+,\times}  \\
             &      \\
             & + x H^{(1)}_{+,\times} + x^{3/2} H^{(3/2)}_{+,\times} + x^{2} H^{(2)}_{+,\times} \left. \right\}.
\label{H+cross}
\end{split}
\end{equation}

In this Eq. $x$ is defined as $x \equiv (Gm \omega/c^{3}_{0})^{2/3}$ where $\omega$ is the 2PN--accurate orbital frequency of the circular orbit, and $\omega=2 \pi/P$ where $P$ is the orbital period. $m \equiv m_{1} + m_{2}$ is the total mass of the binary, and $c_{0}$ is the speed of light. $\eta$ is defined as $\eta \equiv m_{1} m_{2}/m^{2}$.

In this code, we only include the $H^{(0)}_{+,\times}$ terms, which are given by (BIWW)

\begin{equation}
H^{(0)}_{+} = -(1+c^{2}) \cos 2\psi
\label{H0+}
\end{equation}
and
\begin{equation}
H^{(0)}_{\times} = -2c \sin 2 \psi
\label{H0cross}
\end{equation}

The notation used in these equations is as follows. The vector along the line of sight from the binary to the detector defines the inclination angle $i$ with respect to the normal to the orbital plane of the binary. In Eq.(\ref{H0+}) and Eq.(\ref{H0cross}) the variable c is defined as the cosine of the inclination angle $i$, $c=\cos i$. The phase variable $\psi$ is defined by
\begin{equation}
\psi = \phi - \frac{2Gm \omega}{c^{3}_{0}} \ln \left( \frac{\omega}{\omega_{0}} \right)
\end{equation}
where $\phi$ is the actual orbital phase of the binary and $\omega_{0}$ is a constant which can be chosen arbitrarily. In this code, we neglect the second term in this expression, leaving us with $\psi=\phi$.

We may also write the orbital angular velocity $\omega$ in terms of the orbital frequency $f_{orb}$ as $\omega=2 \pi f_{orb}$. The gravitational wave frequency $f_{GW}$ has a value which is twice that of the orbital frequency, and so $\omega= \pi f_{GW}$. If we substitute this into Eq.(\ref{H+cross}) then we obtain
\begin{equation}
h_{+} = A f_{GW}(t)^{2/3} (1+c^{2}) \cos 2\phi
\label{hplus}
\end{equation}
and
\begin{equation}
h_{\times} =  2A f_{GW}(t)^{2/3} 2c \sin 2 \phi
\label{htimes}
\end{equation}
where the constant $A$ is given by
\begin{equation}
A = \frac{- 2G^{5/3}m^{5/3} \eta \pi^{2/3}}{c^{4}_{0} r} \,\,.
\end{equation}

The two polarizations (\ref{hplus}) and (\ref{htimes}) are combined as given by Eq.(\ref{hoft}) to yield
\begin{equation}
h(t) = A f_{GW}(t)^{2/3} \left\{ F_{+} (1+c^{2}) \cos 2 \phi + 2F_{\times} c \sin 2 \phi \right\}
\end{equation}
This equation may be re--written in the form
\begin{equation}
h(t) = A \left[F^{2}_{+} (1+c^{2})^{2} + 4 F^{2}_{\times} c^{2} \right]^{1/2} \, f_{GW}(t)^{2/3} \, \cos \left[ 2 \phi - \phi^{\prime} \right]
\end{equation}
where
\begin{equation}
\phi^{\prime} = \tan^{-1} \left( \frac{2 F_{\times} c}{F_{+} (1+c^{2})} \right)
\end{equation}
Therefore we arrive at an equation of the form
\begin{equation}
h(t) = A^{\prime} \, f_{GW}(t)^{2/3} \, \cos \left[ 2 \phi - \phi^{\prime} \right]
\label{hoft2}
\end{equation}
where
\begin{equation}
A^{\prime} = A \left[F^{2}_{+} (1+c^{2})^{2} + 4 F^{2}_{\times} c^{2} \right]^{1/2}
\end{equation}




In order to compute the time variation of $h(t)$ we need expressions for the time dependence of $\psi(t)=\phi(t)$ and $f_{GW}(t)$. These are conveniently given in terms of the dimensionless time variable

\begin{equation}
\Theta = \frac{c^{3}_{0} \eta}{5Gm} (t_{c} - t)
\end{equation}
where $t_{c}$ is a constant which represents the instant of coalescence of the two point--masses which constitute the binary. From BIWW we have the instantaneous orbital phase $\phi$ in terms of $\Theta$ as given by

\begin{equation}
\begin{split}
\phi(t) = \phi_{c} - &  \frac{1}{\eta} \left\{ \Theta^{5/8} + \left( \frac{3715}{8064} + \frac{55}{96} \eta \right) \Theta^{3/8} - \frac{3 \pi}{4} \Theta^{1/4} \right.  \\
                     &  + \left. \left( \frac{9275495}{14450688} + \frac{284875}{258048} \eta + \frac{1855}{2048} \eta^{2} \right) \Theta^{1/8} \right\}
\end{split}
\label{phioft}
\end{equation} 
where $\phi_{c}$ is a constant representing the value of the phase at instant $t_{c}$.


We had the variable $x(t) \equiv (Gm \omega(t)/c^{3}_{0})^{2/3}$. This may be re--arranged to give

\begin{equation}
f_{GW}(t) = \frac{c^{3}_{0}}{G m \pi} \, x(t)^{3/2}
\label{fofx}
\end{equation}
where $x(t)$ is given by
\begin{equation}
\begin{split}
x(t) =  &  \frac{\Theta^{-1/4}}{4} \left\{  1 + \left(\frac{743}{4032} + \frac{11}{48} \eta \right) \Theta^{-1/4} - \frac{\pi}{5} \Theta^{-3/8} \right. \\
     &  + \left. \left( \frac{19583}{254016} + \frac{24401}{193536} \eta + \frac{31}{288} \eta^{2} \right) \Theta^{-1/2} \right\}
\end{split}
\label{xoft}
\end{equation}

All of the equations presented so far have included explicitly their dependence upon $G$ and $c$. The code uses units where $G=c=1$.

To summarise, equations (\ref{xoft}) and (\ref{fofx}) are used to determine $f_{GW}(t)$ and Eq.(\ref{phioft}) is used to determine $\phi(t)$. These quantities are then substituted into Eq.(\ref{hoft2}) which defines $h(t)$.

\section{Algorithms}

This code uses no algorithms.


\section{Arguments}

The function header is of the form:

\vspace{5mm}

\begin{tabular}{ll}
void \texttt{TappRpnTdomTime}&(\texttt{Status $\ast$status},     \\
                                   &\texttt{REAL8Vector $\ast$output}, \\
                                   &\texttt{InspiralTemplate $\ast$params})
\end{tabular}

\vspace{5mm}

The structure which is of type \texttt{Status}, which is pointed to by the pointer \texttt{status} writes information to the screen should the code encounter a problem. The output structure is of the form \texttt{REAL8Vector} and is pointed to by the pointer \texttt{output}.
The inputs needed come from the input structure which is of type \texttt{InspiralInput}, and which is pointed to by the pointer \texttt{params}.

The output structure has the form

\vspace{5mm}

\begin{tabular}{ll}
\texttt{typedef struct} & \texttt{tagREAL8Vector} \{ \\
                        & \texttt{INT4 m;} \\
                        & \texttt{REAL8 $\ast$data;}  \\
                        & \} \texttt{REAL8Vector;}
\end{tabular}

\vspace{5mm}

where \texttt{m} is the number of data points which make up the waveform, and \texttt{signal} is a pointer to the waveform itself. The input structure is of the form

\vspace{5mm}

\begin{tabular}{ll}
\texttt{typedef struct} & \texttt{InspiralTemplate} \{ \\
                        & \texttt{REAL8 m1;} \\
                        & \texttt{REAL8 m2;}  \\
                        & \texttt{REAL8 spin1[3];}  \\
                        & \texttt{REAL8 spin2[3];}  \\
                        & \texttt{REAL8 inclination;}  \\
                        & \texttt{REAL8 eccentricity;}  \\
                        & \texttt{REAL8 totalMass;} \\
                        & \texttt{REAL8 mu;}  \\
                        & \texttt{REAL8 eta;}  \\
                        & \texttt{REAL8 fLower;}  \\
                        & \texttt{REAL8 fCutoff;}  \\
                        & \texttt{REAL8 tSampling;}  \\
                        & \texttt{REAL8 phaseShift;} \\
                        & \texttt{INT4  nStartPad;}  \\
                        & \texttt{INT4  nEndPad;}  \\
                        & \texttt{InputMasses MassChoice;}  \\
                        & \texttt{InspiralMethod method;}  \\
                        & \} \texttt{InspiralInput;}
\end{tabular}

\vspace{5mm}

The parameters which are represented by these input are as follows: \texttt{m1} and \texttt{m2} are the masses of the compact objects in solar masses, \texttt{totalMass} is their combined mass $m=m_{1}+m_{2}$, \texttt{mu} is the reduced mass $\mu=m_{1}m_{2}/(m_{1}+m_{2})$, \texttt{eta} is the symmetric mass ratio $\eta=m_{1}m_{2}/(m_{1}+m_{2})^{2}$, \texttt{fLower} is the frequency at which the detectors' noise curve rises steeply (the seismic limit), \texttt{fCutoff} is the frequency at which the user can choose to terminate the waveform, \texttt{tSampling} is the time interval between samples in units of seconds, \texttt{phaseShift} is the initial phase given to the signal, \texttt{nStartPad} is the number of zeros which are added at the start of the waveform and \texttt{nEndPad} is the number of zeros which are added at the end of the waveform. The code also calculates $f_{lso}$, which is the frequency of the binary at the last stable orbit. If the user specifies \texttt{fCutoff} to be larger than $f_{lso}$, then the code will truncate the waveform when it reaches $f_{lso}$. 

The range of values which we allow is as follows: The smallest total mass of any system $m_{min}$ allowed is 0.4~$\rm{M_{\odot}}$, and the maximum total mass allowed is $m_{max}=100~\rm{M_{\odot}}$. The symmetric mass ratio $\eta$ should lie in the range $0 \leq \eta \leq 1/4$ and $\mu$ should always be positive.

The parameter \texttt{MassChoice} is of type \texttt{enum InputMasses}, which determines which pair of input masses the user has defined. This typedef is as follows:

\vspace{5mm}

\begin{tabular}{ll}
\texttt{typedef enum} & \{ \\
                      & \texttt{m1Andm2,} \\
                      & \texttt{totalMassAndEta,}  \\
                      & \texttt{totalMassAndMu} \\
                      & \} \texttt{InputMasses;}
\end{tabular}

\vspace{5mm}
 


\section{Operating Instructions}

When this function is called each of the following input structure members must be defined:
\texttt{fLower}, \texttt{fCutoff}, \texttt{tSampling}, \texttt{phaseShift}, \texttt{nStartPad} and \texttt{nEndPad}. From the remaining five input members (\texttt{m1,m2,totalMass,mu,eta}), it is not necessary to define all five. Instead, only  one of the following pairs needs to be defined: (\texttt{m1,m2}), (\texttt{totalMass,mu}), or (\texttt{totalMass,eta}). Given these inputs, the function is able to generate all the other parameters it needs in order to compute the waveform.

Here is an example of a code fragment which shows how the members of the input structure (which is pointed to by the pointer \texttt{params}) are initialized, and how the function is then called. In this example, we have chosen to define the pair \texttt{m1} and \texttt{m2} as inputs.

\vspace{5mm}

\noindent
\begin{verbatim}
/* Declare the structures to be used  */
\end{verbatim}
\texttt{InspiralTemplate params;} \\
\texttt{REAL8Vector $\ast$output;} \\
\texttt{Status status;} \\
\begin{verbatim}
/* Define a pointer for the output waveform 
   and allocate the correct amount 
   of memory for it  */
\end{verbatim}
\texttt{output=(REAL8Vector $\ast$)LLALMalloc(sizeof(REAL8Vector));} \\
\begin{verbatim}
/* Initialize the inputs  */
\end{verbatim}
\texttt{params.fLower} = 40.0;\\
\texttt{params.fCutoff} = 1000.0; \\
\texttt{params.tSampling} = 1.0/4000.0; \\
\texttt{params.phaseShift} = 0.0; \\
\texttt{params.nStartPad} = 0; \\
\texttt{params.nEndPad} = 0; \\
\texttt{params.massChoice=m1Andm2}\\
\texttt{params.m1} = 1.0; \\
\texttt{params.m2} = 1.0; \\
\begin{verbatim}
/* Call the function to generate the waveform  */
\end{verbatim}
\texttt{TappRpnTdomTime (\&status, output, \&params);}
\begin{verbatim}
/* Write the data to the screen  */
i=0; 
do 
  fprintf(stderr,"%e\n",output->data[i]); 
while (n-++i);
\end{verbatim}

Inside the function \texttt{TappRpnTdomTime()}, error checks are made upon its arguments, using the ASSERT macro. Because each of the arguments to the function involves a pointer being passed to the function (e.g.\ \texttt{output, params}), we first of all check that each of the pointers are not NULL pointers.

Inside the function \texttt{TappRpnTdomTime()}, this looks like:

\vspace{5mm}

\begin{tabular}{ll}
\texttt{void TappRpnTdomTime} & (\texttt{Status $\ast$status}, \\
                        & \texttt{REAL8Vector $\ast$output}, \\
                        & \texttt{InspiralTemplate $\ast$params)}
\end{tabular}

\vspace{5mm}

\begin{tabular}{ll}
ASSERT & (output!=NULL,  \\
       &  status,    \\
       &  TAPPRPNTDOMTIME\_ENULL, \\
       &  TAPPRPNTDOMTIME\_MSGENULL1);
\end{tabular}

\vspace{5mm}

This above example checks whether the pointer \texttt{output} is a NULL pointer or not. If it is a NULL pointer, then an error message which is defined by the character string \texttt{TAPPRPNTDOMTIME\_MSGENULL1} is sent to the screen.



\section{Options}

The options available to the user are the choice of input parameters. As explained above, from the following list of five $(m_{1},m_{2},m,\mu,\eta)$, the user need only specify any one of the following pairs $(m_{1},m_{2})$, $(m,\eta)$ or $(m,\mu)$.

\section{Accuracy}

All variables are decalred to be REAL8, which means that they are double precision.
Each double precision variable has an approximate precision of 15 significant figures.


\section{Error conditions}

We first of all check that each of the pointers passed to the function \\ \texttt{TappRpnTdomTime()} as an argument , i.e.\ \texttt{Status}, \texttt{output} and \texttt{params}, are not NULL pointers. If any of them are NULL, then an error message is sent to the screen.

Checks are performed upon the other inputs to make sure that they have values with the expected ranges. We check that the number of zeros at the start and at the end of the waveform is greater than or equal to zero, that the lower and upper frequency limits are greater than zero, that the time interval between samples is greater than zero, and that the lower frequency cutoff is smaller than the upper frequency cutoff. 
We also check that the highest frequency which is generated by the code is not larger than the Nyquist frequency. If any of these conditions are not met, then an appropriate error message specific to that error is written to the screen.

\section{Tests}

We have performed a cross--check of this code with \texttt{TappRpnTdomFreq()}, which is designed to perform the same task. The test was as follows. We took the waveform generated by \texttt{TappRpnTdomFreq()} and generated a zero phase and a $\pi/2$ waveform which was used as a "template" waveform. Then we generated a waveform with \texttt{TappRpnTdomTime()} with exactly the same input parameters and used this waveform as the "signal" waveform. This waveform was correlated with the two template waveforms and the overlap was calculated. If a perfect match were achieved, then the overlap would equal unity. We did this calculation for masses in the range 1--50 $\rm{M_{\odot}}$. The results are shown in figure \ref{overlap1}.

\begin{figure}
\begin{center}
%\psfig{file=overlap.ps,width=140mm,clip=}
\caption{The overlap as a function of the masses of the compact objects.}
\label{overlap1}
\end{center}
\end{figure}




\section{Uses}

This function directly calls the following functions:

\vspace{5mm}

\noindent
\texttt{InspiralParameterCalc()} \\
\texttt{TappRpnTdomTimePhase()} \\
\texttt{TappRpnTdomTimeFrequency()}. \\




\end{document}
