\documentclass[12pt]{article}
\usepackage{amsmath}

\begin{document}
\huge
\begin{center}
TappRpnTdomFreqPhase.c
\end{center}
\normalsize
\vspace{10mm}

\section{Purpose}

The code \texttt{TappRpnTdomFreqPhase.c} calculates the phase of an inspiral waveform as a function of the instantaneous frequency of the wave, up to $2^{nd}$ post--Newtonian order.


The equation which the code evaluates is as follows:

\begin{equation}
\begin{split}
\phi(f) & = \frac{16 \pi f_{a} \tau_{N}}{5} \left[ 1 - \left( \frac{f}{f_{a}} \right)^{-5/3} \right] + 4 \pi f_{a}\tau_{P^{1}N} \left[ 1 - \left( \frac{f}{f_{a}} \right)^{-1} \right]  \\
        &     \\
        & - 5 \pi f_{a} \tau_{P^{1.5}N} \left[ 1 - \left( \frac{f}{f_{a}} \right)^{-2/3} \right] + 8 \pi f_{a} \tau_{P^{2}N} \left[ 1 - \left( \frac{f}{f_{a}} \right)^{-1/3} \right] + \Phi \,.
\end{split}
\label{phioff}
\end{equation}

The terms in this equation are defined as follows:
$\tau_{N}$ is the Newtonian chirp time, $\tau_{P^{1}N}$ is the first post--Newtonian chirp time, and so on for $\tau_{P^{1.5}N}$ and $\tau_{P^{2}N}$. The parameter $f$ is the instantaneous frequency of the gravitational wave, and $f_{a}$ is the value of this frequency when the wave enters the lower end of the detectors' bandwidth.
Here we will neglect the $\Phi$ term, which is an initial phase which can be defined alsewhere. If we define
\begin{equation}
\phi_{N} = \frac{16 \pi f_{a} \tau_{N}}{5} \,\,,
\end{equation}
\begin{equation}
\phi_{P^{1}N} = 4 \pi f_{a} \tau_{P^{1}N} \,\,,
\end{equation}
\begin{equation}
\phi_{P^{1.5}N} = 5 \pi f_{a} \tau_{P^{1.5}N} \,\,,
\end{equation}
\begin{equation}
\phi_{P^{2}N} = 8 \pi f_{a} \tau_{P^{2}N}
\end{equation}
and 
\begin{equation}
\phi_{c} = \phi_{N} + \phi_{P^{1}N} - \phi_{P^{1.5}N} + \phi_{P^{2}N}
\end{equation}
then Eq.(\ref{phioff}) becomes
\begin{equation}
\begin{split}
\phi(f) & = \phi_{N} - \phi_{N}\left( \frac{f}{f_{a}} \right)^{-5/3} + \phi_{P^{1}N} - \phi_{P^{1}N} \left( \frac{f}{f_{a}} \right)^{-1} \\
      &      \\
      & - \phi_{P^{1.5}N} + \phi_{P^{1.5}N} \left( \frac{f}{f_{a}} \right)^{-2/3} + \phi_{P^{2}N} - \phi_{P^{2}N} \left( \frac{f}{f_{a}} \right)^{-1/3} + \Phi
\end{split}
\end{equation}
i.e.\
\begin{equation}
\begin{split}
\phi(f) & = - \phi_{N}\left( \frac{f}{f_{a}} \right)^{-5/3}- \phi_{P^{1}N} \left( \frac{f}{f_{a}} \right)^{-1} \\
   &   \\
   & + \phi_{P^{1.5}N} \left( \frac{f}{f_{a}} \right)^{-2/3} - \phi_{P^{2}N} \left( \frac{f}{f_{a}} \right)^{-1/3} + \phi_{c} + \Phi
\end{split}
\label{phioff2}
\end{equation}

As $f \rightarrow \infty$, then $\phi(f) \rightarrow \phi_{c} + \Phi$. If $f=f_{a}$ then $\phi(f=f_{a}) = \Phi$. If $f=f_{lso}$ then $\phi(f=f_{lso})$ is given by Eq(\ref{phioff2}). evaluated with $f=f_{lso}$.


\section{Algorithms}

The code uses no algorithms to perform its calculation, it merely evaluates the equation shown above.


\section{Arguments}

The function header is of the form:

\vspace{5mm}

\begin{tabular}{ll}
\texttt{void TappRpnTdomFreqPhase} & (\texttt{Status $\ast$status}, \\
                        & \texttt{REAL8 $\ast$phase}, \\
                        & \texttt{InspiralPhasesInput $\ast$params)} 
\end{tabular}

\vspace{5mm}

The structure which is of type \texttt{Status}, which is pointed to by the pointer \texttt{status} writes information to the screen should the code encounter a problem. 

The double precision output will be pointed to by the pointer \texttt{phase}.
The inputs needed are contained within the input structure which is of type InspiralPhasesInput, and which is pointed to by the pointer \texttt{params}. This input structure has the following form:

\vspace{5mm}

\begin{tabular}{ll}
\texttt{typedef struct} & \texttt{tagInspiralPhasesInput} \{ \\
                        & \texttt{REAL8 phi0;} \\
                        & \texttt{REAL8 phi1;} \\
                        & \texttt{REAL8 phi15;} \\
                        & \texttt{REAL8 phi2;} \\
                        & \texttt{REAL8 phic;} \\
                        & \texttt{REAL8 f;} \\
                        & \} \texttt{InspiralPhasesInput;}
\end{tabular}

\vspace{5mm}


The parameters $\phi_{N}$, $\phi_{P^{1}N}$, $\phi_{P^{1.5}N}$, $\phi_{P^{2}N}$,  $\phi_{c}$ and $(f/f_{a})$ are recieved by the function as members of this structure,as follows:

\vspace{5mm}

\begin{tabular}{ll}
$\phi_{N}$        &= \texttt{params->phi0}  \\
$\phi_{P^{1}N}$   &= \texttt{params->phi1}  \\
$\phi_{P^{1.5}N}$ &= \texttt{params->phi15}  \\
$\phi_{P^{2}N}$   &= \texttt{params->phi2}  \\
$\phi_{c}$        &= \texttt{params->phic}  \\
$(f/f_{a})$       &= \texttt{params->f}
\end{tabular}

\vspace{5mm}

The LIGO document says that we should decare the range/domain of all input/output argument.


\section{Operating Instructions}

Here is a simple example of the function having its inputs initialized and then being called

\vspace{5mm}

\noindent
\begin{verbatim}
/* Declare the structures to be used  */
\end{verbatim}
\texttt{InspiralPhasesInput phaseIn;} \\
\texttt{REAL8 phase;}\\
\texttt{Status status;} \\
\begin{verbatim}
/* Initialize the inputs  */
\end{verbatim}
\texttt{phaseIn.phi0} = $\frac{16 \pi f_{a} \tau_{N}}{5}$; \\
\texttt{phaseIn.phi1} = $4 \pi f_{a} \tau_{P^{1}N}$; \\
\texttt{phaseIn.phi15} = $5 \pi f_{a} \tau_{P^{1.5}N}$; \\
\texttt{phaseIn.phi2} = $8 \pi f_{a} \tau_{P^{2}N}$; \\
\texttt{phaseIn.phic} = $\phi_{N} + \phi_{P^{1}N} - \phi_{P^{1.5}N} + \phi_{P^{2}N}$; \\ \texttt{phaseIn.f} = 40.0; \\
\begin{verbatim}
/* Call the function  */
\end{verbatim}
\texttt{TappRpnTdomFreqPhase (\&status, \&phase, \&phaseIn);} \\
\begin{verbatim}
printf("the phase is=%e\n",phase);
\end{verbatim}




Inside the function \texttt{TappRpnTdomFreqPhase()}, error checks are made upon the inputs, using the ASSERT macro. Because each of the arguments to the function involve pointers being passed to the function, we first of all check that each of the pointers are not NULL pointers. We also check that the inputted frequency is positive.

Inside the function \texttt{TappRpnTdomFreqPhase()}, this looks like:

\vspace{5mm}

\begin{tabular}{ll}
\texttt{void TappRpnTdomFreqPhase} & (\texttt{Status $\ast$status}, \\
                        & \texttt{REAL8 $\ast$phase}, \\
                        & \texttt{InspiralPhasesInput $\ast$inparams)}
\end{tabular}

\vspace{5mm}

\begin{tabular}{ll}
ASSERT & (phase!=NULL,  \\
       &  status,    \\
       &  TAPPRPNTDOMFREQPHASE\_ENULL, \\
       &  TAPPRPNTDOMFREQPHASE\_MSGENULL1);
\end{tabular}

\vspace{5mm}

This above example checks whether the pointer \texttt{phase} is a NULL pointer or not. If it is a NULL pointer, then an error message which is defined by the character string \texttt{TAPPRPNTDOMFREQPHASE\_MSGENULL1}is sent to the screen.



\section{Options}
There are no options to this function.

\section{Accuracy}
All variables are decalred to be REAL8, which means that they are double precision.
Each double precision variable has an approximate precision of 15 significant figures.

\section{Error Conditions}
When the code is called, the macro ASSERT checks various properties to make sure that they are correct. If any of the pointers have not been declared, and so are NULL, then an  error message is written to the screen which tells the user which pointer is NULL. If the inputted frequency is not greater than zero then a message specific to this problem is written to the screen. 


\section{Tests}

This function is tested as a part of the test of the function TappRPNTdomFreq(). For a discussion of this test, see the documentation for that function.

\section{Uses}

This function does not call any other functions.


\section{References}
For a fuller description of how this function is used in the generation of an inspiral waveform, see the documentation for the function \texttt{TappRPNTdomFreq()}.
The nomenclature adopted is the same as that used in Sathyaprakash, PRD, 50, R7111, 1994, which may be consulted for further details.



\end{document}
