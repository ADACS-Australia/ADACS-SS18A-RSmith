\documentclass[12pt]{article}
\usepackage{amsmath}

\begin{document}
\huge
\begin{center}
TimeDomain2.c
\end{center}
\normalsize
\vspace{10mm}

\section{Purpose}

The code \texttt{TimeDomain2.c} generates an inspiral waveform using method \texttt{one} as outlined in the documentation for the function \texttt{InspiralWave}. This means that the integrals involving the energy and flux function are solved numerically.




\section{Algorithms}

This code uses a fourth--order Runge--Kutta algorithm to solve the integrals as a pair of coupled first--order differential equations.


\section{Arguments}

The function header is of the form:

\vspace{5mm}

\begin{tabular}{ll}
void \texttt{TimeDomain2}&(\texttt{Status $\ast$status},     \\
                                   &\texttt{REAL8Vector $\ast$signal}, \\
                                   &\texttt{InspiralTemplate $\ast$params})
\end{tabular}

\vspace{5mm}

The structure which is of type \texttt{Status}, which is pointed to by the pointer \texttt{status} writes information to the screen should the code encounter a problem. The output structure is of the form \texttt{REAL8Vector} and is pointed to by the pointer \texttt{signal}. This is the required waveform.
The inputs needed come from the input structure which is of type \texttt{InspiralTemplate}, and which is pointed to by the pointer \texttt{params}.

The output structure has the form

\vspace{5mm}

\begin{tabular}{ll}
\texttt{typedef struct} & \texttt{tagREAL8Vector} \{ \\
                        & \texttt{UINT4 length;} \\
                        & \texttt{REAL8 $\ast$data;}  \\
                        & \} \texttt{REAL8Vector;}
\end{tabular}

\vspace{5mm}

\vspace{5mm}


The input structure is of the form

\vspace{5mm}

\begin{tabular}{ll}
\texttt{typedef struct} & \texttt{tagInspiralTemplate} \{ \\
                        & \texttt{INT4 number;} \\
                        & \texttt{REAL8 mass1;} \\
                        & \texttt{REAL8 mass2;}  \\
                        & \texttt{REAL8 spin1[3];}  \\
                        & \texttt{REAL8 spin2[3];}  \\
                        & \texttt{REAL8 inclination;} \\
                        & \texttt{REAL8 eccentricity;} \\
                        & \texttt{REAL8 totalMass;} \\
                        & \texttt{REAL8 mu;}  \\
                        & \texttt{REAL8 eta;}  \\
                        & \texttt{REAL8 fLower;}  \\
                        & \texttt{REAL8 fCutoff;} \\
                        & \texttt{REAL8 tSampling;} \\
                        & \texttt{REAL8 startPhase;} \\
                        & \texttt{REAL8 startTime;} \\
                        & \texttt{REAL8 signalAmplitude;} \\
                        & \texttt{REAL8 nStartPad;} \\
                        & \texttt{REAL8 nEndPad;} \\
                        & \texttt{INT4 ieta;} \\
                        & \texttt{InspiralMethod method;}  \\
                        & \texttt{InputMasses massChoice;}  \\
                        & \texttt{Order order;}  \\
                        & \texttt{Domain domain;}  \\
                        & \texttt{Approximant approximant;}  \\
                        & \} \texttt{InspiralTemplate;}
\end{tabular}

\vspace{5mm}




The parameters which are represented by these input are as follows: \texttt{number} is a label for each template, \texttt{mass1} and \texttt{mass2} are the masses of the compact objects in solar masses, \texttt{spin1} and \texttt{spin2} are the spins of the objects, \texttt{inclination} is the angle of inclination which the binary system makes to the observer, \texttt{eccentricity} is the eccentricity of the objects' orbit, \texttt{totalMass} is their combined mass $m=m_{1}+m_{2}$, \texttt{mu} is the reduced mass $\mu=m_{1}m_{2}/(m_{1}+m_{2})$, \texttt{eta} is the symmetric mass ratio $\eta=m_{1}m_{2}/(m_{1}+m_{2})^{2}$, \texttt{fLower} is the frequency at which the detectors' noise curve rises steeply (the seismic limit), \texttt{fCutoff} is the frequency at which the user can choose to terminate the waveform, \texttt{tSampling} is the sampling rate in units if Hertz, \texttt{startPhase} is the initial phase given to the signal, \texttt{startTime} is the time at which the frequency of the wave is \texttt{fLower},  \texttt{signalAmplitude} is the choice of amplitude for the waveform, \texttt{nStartPad} is the number of zeros which are added at the start of the waveform and \texttt{nEndPad} is the number of zeros which are added at the end of the waveform. \texttt{ieta} is a parameter which distinguishes between the cases $\eta=0$ and $\eta \neq 0$. If the user sets \texttt{ieta}=0 then test mass waveforms will be generated.

The parameter \texttt{method} is of type \texttt{enum Method}, which tells the function which code is to be used to generate the waveform. This typedef is as follows:

\vspace{5mm}

\begin{tabular}{ll}
\texttt{typedef enum} & \{ \\
                      & \texttt{one,} \\
                      & \texttt{two,}  \\
                      & \texttt{three,} \\
                      & \texttt{best} \\
                      & \} \texttt{Method;}
\end{tabular}

\vspace{5mm}

As mentioned above, this function represents method \texttt{one}. This means that the the gravitational wave phasing formula is solved as follows. The formula is

\begin{eqnarray}
t(v) & = & t_{0} - m \int_{v_{0}}^{v} \, 
\frac{E'(v)}{{\cal F}(v)} \, dv, \nonumber \\ 
\phi (v) & = & \phi_{0} - 2 \int_{v_{0}}^{v}  v^3 \, 
\frac{E'(v)}{{\cal F}(v)} \, dv,
\label{phasing formula}
\end{eqnarray}

where $v=(\pi m F)^{1/3}$ is an invariantly defined velocity, $F$ is the instantaneous GW frequency, and $m$ is the total mass of the binary. 

The variable $t$ is in our hands, and the phasing formula is solved by finding the value of $v$ (for a given $t$) which satisfies the first of the equations in Eq. (\ref{phasing formula}). This value of $v$ is then substituted into the second equation to yield $\phi(t)$.

Method \texttt{one} leaves  $E^{\prime}(v)/\mathcal{F}(v)$ as a serias in terms of ascending powers of $x$ and integrate the equations numerically. This numerical integration is done by replacing the integrals by a pair of first order coupled differential equations, as follows.

Instead of writing the first of the equations in Eq. (\ref{phasing formula}), we may write 

\begin{equation}
\frac{dt(v)}{dv} = -m \frac{E^{\prime}(v)}{\mathcal{F}(v)} \,\,,
\end{equation}

therefore

\begin{equation}
\frac{dv}{dt} = - \frac{\mathcal{F}(v)}{m E^{\prime}(v)} \,\,.
\label{ode1}
\end{equation}

Instead of the second equation in Eq. (\ref{phasing formula}) we may write

\begin{equation}
\frac{d \phi (t)}{dt} = 2 \pi F(t)
\end{equation}

where

\begin{equation}
F = \frac{v^{3}}{\pi m} \,\,,
\end{equation}

therefore

\begin{equation}
\frac{d \phi(t)}{dt} = \frac{2v^{3}}{m}
\label{ode2}
\end{equation}

So Eq. (\ref{ode1}) and Eq. (\ref{ode2}) are our coupled first order differential equations to solve. This we do using a fourth--order Runge--Kutta algorithm.



The parameter \texttt{order}, which is of type \texttt{enum Order}, lets the user choose to which order of post--Newtonian expansion they would like to go. This enum is defined as follows:

\vspace{5mm}

\begin{tabular}{ll}
\texttt{typedef enum} & \{ \\
                      & \texttt{newtonian,} \\
                      & \texttt{oneHalfPN,}  \\
                      & \texttt{onePN} \\
                      & \texttt{onePointFivePN} \\
                      & \texttt{twoPN} \\
                      & \texttt{twoPointFivePN} \\
                      & \} \texttt{Order;}
\end{tabular}

\vspace{5mm}


The parameter \texttt{domain}, which is of type \texttt{enum Domain}, lets the user to choose to generate the waveform in the time or frequency domain. This enum is defined as:

\vspace{5mm}

\begin{tabular}{ll}
\texttt{typedef enum} & \{ \\
                      & \texttt{time,} \\
                      & \texttt{frequency,}  \\
                      & \} \texttt{Domain;}
\end{tabular}

\vspace{5mm}

At the moment, only time domain waveforms are available.

The user has have the additional choice of specifying the form of the expansion which defines $E^{\prime}(v)/\mathcal{F}(v)$. This ratio can be expressed in the form of a \emph{Taylor series} (T--Approximants) or by using \emph{P--Approximants}. This choice is handled by the parameter \texttt{approximant}, which is of type \texttt{enum Approximant}, and which is defined as follows:

\vspace{5mm}

\begin{tabular}{ll}
\texttt{typedef enum} & \{ \\
                      & \texttt{taylor,} \\
                      & \texttt{pade,}  \\
                      & \} \texttt{Approximant;}
\end{tabular}

\vspace{5mm}


\section{Operating Instructions}

Here is an example of a code fragment which shows how the members of the input structure are initialized, and how the function is then called.

\vspace{5mm}

\noindent
\begin{verbatim}
/* Declare the structures to be used  */
\end{verbatim}
\texttt{REAL8Vector signal;} \\
\texttt{InspiralTemplate params;} \\
\texttt{Status status;} \\
\begin{verbatim}
/* Initialize the inputs  */
\end{verbatim}
\texttt{params.ieta} = 1; \\
\texttt{params.mass1} = 10.0; \\
\texttt{params.mass2} = 10.0; \\
\texttt{params.startTime} = 0.0; \\
\texttt{params.startPhase} = 0.0; \\
\texttt{params.fCutoff} = 1000.0; \\
\texttt{params.tSampling} = 4000.0; \\
\texttt{params.signalAmplitude} = 1.0; \\
\texttt{params.nStartPad} = 0; \\
\texttt{params.nEndPad} = 0; \\
\texttt{params.order} = twoPN; \\
\texttt{params.domain} = time; \\
\texttt{params.approximant} = taylor; \\
\begin{verbatim}
/* Call the function */
\end{verbatim}
\texttt{TimeDomain2 (\&status, \&signal, \&params);}
\begin{verbatim}
/* Write the data to the screen  */
  fprintf(stderr,"%e\n",signal.data); 
\end{verbatim}

Inside the function \texttt{TimeDomain2}, error checks are made upon its arguments, using the ASSERT macro. Because each of the arguments to the function involves a pointer being passed to the function (e.g.\ \texttt{signal, params}), we check that each of the pointers are not NULL pointers.
Inside the function \texttt{TimeDomain2}, this looks like:

\vspace{5mm}

\begin{tabular}{ll}
void \texttt{TimeDomain2}&(\texttt{Status $\ast$status},     \\
                                   &\texttt{REAL8Vector $\ast$signal}, \\
                                   &\texttt{InspiralTemplate $\ast$params})
\end{tabular}

\vspace{5mm}

\begin{tabular}{ll}
ASSERT & (signal,  \\
       &  status,    \\
       &  TIMEDOMAIN2\_ENULL, \\
       &  TIMEDOMAIN2\_MSGENULL);
\end{tabular}

\vspace{5mm}

This above example checks whether the pointer \texttt{signal} is a NULL pointer or not. If it is a NULL pointer, then an error message which is defined by the character string \texttt{TIMEDOMAIN2\_MSGENULL} is sent to the screen.


\section{Options}

The user may choose from one of three methods of solving the gravitational wave phasing formula. If method \texttt{one} is chosen, then the user may choose to use T or P--Approximants for the energy and flux functions. Then the order of post--Newtonian expansion mey be chosen. If the user chooses methods \texttt{two} or \texttt{three} then only T--Approximants are available, but the user may choose the order of post--Newtonian expansion. At the moment, only time domain waveforms are available.

\section{Accuracy}

All variables are decalred to be REAL8, which means that they are double precision.
Each double precision variable has an approximate precision of 15 significant figures.


\section{Error conditions}

We check that each of the pointers passed to the function \\ \texttt{TimeDomain2} as an argument , i.e.\ \texttt{Status}, \texttt{signal} and \texttt{params}, are not NULL pointers. If any of them are NULL, then an error message is sent to the screen.


\section{Tests}

This code has been extensively tested by B. Sathyaprakash. This test included a comparison to the routines in the GRASP library.

\section{Uses}

This function immediately calls the functions \texttt{InspiralSetup}, \texttt{ChooseModel}, \texttt{TappRpnTdomTime}, \texttt{InspiralVelocity}, \texttt{InspiralPhase}, \texttt{InspiralDerivatives} and \texttt{RungeKutta4}.


\end{document}
