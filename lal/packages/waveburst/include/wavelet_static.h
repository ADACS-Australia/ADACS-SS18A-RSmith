#ifndef WAVELET_STATIC_H
#define WAVELET_STATIC_H

#include <math.h>
#include <strings.h>
#include "lal/LALWavelet.h"

static int _f2l(int level, int indx);
/* static int _l2f(int level, int layer); */
static void _getSliceL(int level, int layer, Wavelet *wavelet, Slice *slice);
static void _getSliceF(int indx, Wavelet *wavelet, Slice *slice);
static int _getOffset(int level,int layer);
static int _getMaxLevel(Wavelet *wavelet, UINT4 n);
static int _getMaxLayer(Wavelet *wavelet);
static UINT4 _limit(Slice s);
static int _getLayer(REAL4TimeSeries **layerOut, int indx, Wavelet *wavelet);
static void _putLayer(REAL4TimeSeries *layerData, int layer, Wavelet *wavelet);
static void _assignREAL4TimeSeriesMetadata(REAL4TimeSeries **left, 
					   REAL4TimeSeries *right);
static void _assignREAL4TimeSeries(REAL4TimeSeries **left, REAL4TimeSeries *right);
static void _assignREAL4FrequencySeries(REAL4FrequencySeries **left,
					REAL4FrequencySeries *right);
static void _assignCOMPLEX8FrequencySeries(COMPLEX8FrequencySeries **left, 
					   COMPLEX8FrequencySeries *right);
static void _assignWavelet(Wavelet **left,Wavelet *right);
static void _assignBlob(ClusterBlobWavelet *left, ClusterBlobWavelet * right);
static void  _assignClusterWavelet(ClusterWavelet **left, ClusterWavelet *right);
static void _unitCopy(LALUnit *source, LALUnit *destination);
static void _calibrate(Wavelet *in, COMPLEX8FrequencySeries *R, 
		       COMPLEX8FrequencySeries *C,
		       REAL8TimeSeries *alpha, REAL8TimeSeries *gamma, 
		       ClusterWavelet *w, UINT4 offset);
static void _interpolate(InputPercentileWavelet  *input);
static REAL4 _polypredict(REAL4 *pL, REAL4 *pC, REAL4 *pR, int m);
static void _initCOMPLEX8(COMPLEX8 *n, REAL4 a, REAL4 b);
static void _plusCOMPLEX8(COMPLEX8 *one, COMPLEX8 *two, COMPLEX8 *result);
static void _minusCOMPLEX8(COMPLEX8 *one, COMPLEX8 *two,COMPLEX8 *result);
static void _multiplyCOMPLEX8(COMPLEX8 *one, COMPLEX8 *two,COMPLEX8 *result);
static void _divideCOMPLEX8(COMPLEX8 *one, COMPLEX8 *two,COMPLEX8 *result);
static REAL4 _normCOMPLEX8(COMPLEX8 *one);

static int _white(UINT4 k, REAL4TimeSeries *data, REAL4 *norm50, 
		  REAL4 *median, UINT4 offset);
static void _whiteAlone(Wavelet *wavelet,
                        REAL4 **median,
                        REAL4 **norm50, UINT4 k, UINT4 offset);
static void _waveFilter(Wavelet **in, ClusterWavelet *w, UINT4 offset, UINT4 extradeep,
			UINT4 wf_LPFilterLength, UINT4 wf_HPFilterLength);
static REAL4 _computeRMS(REAL4TimeSeries *a, UINT4 offset);
static void _createClusterWavelet(ClusterWavelet **w);
static double _setMask(ClusterWavelet *wavelet, int nc, BOOLEAN aura);
static void _pMaskPushBack(ClusterWavelet *wavelet, PixelWavelet *pix);
static void _copyPixel(PixelWavelet *to, PixelWavelet *from);
static void _assignPixel(PixelWavelet **to, PixelWavelet *from);
static BOOLEAN _create2DintArray(int ***a, int n1, int n2);
static void _destroy2DintArray(int ***a, int n1);
/* static void _print2DintArray(int ***a, FILE *out, int n1, int n2); */
static int _clusterMain(ClusterWavelet *wavelet);
static int _clusterR(ClusterWavelet *wavelet, int k);
static REAL4 _noise(ClusterWavelet *w, INT4 number, INT4 steps_in_sublayer);

static int _duplicateClusterStructure(OutputClusterWavelet *output, 
				      InputReuseClusterWavelet *input);

static BOOLEAN _allocateWavelet(Wavelet **wavelet);

static double _percentile(Wavelet *wavelet, double nonZeroFraction, 
			  BOOLEAN keepAmplitudes, REAL4 **norm10L, REAL4 **norm10R); 
static int _compare(const void *a, const void *b);
static int _compareAbs(const void *a, const void *b);

static void _clusterProperties(ClusterWavelet *w);

static void _doubleToSecNan(double t, INT4 *sec, INT4 *nan);
static double _secNanToDouble(UINT4 sec, UINT4 nan);
/* static int _nanoSeconds2steps(REAL4TimeSeries *ts, int nanoseconds); */

static void _freeREAL4TimeSeries(REAL4TimeSeries **t);
static void _freeREAL8TimeSeries(REAL8TimeSeries **t);
static void _freeREAL4FrequencySeries(REAL4FrequencySeries **psd);
static void _freeCOMPLEX8FrequencySeries(COMPLEX8FrequencySeries **psd);
static void _freeWavelet(Wavelet **w);
static void _freeClusterWavelet(ClusterWavelet **w);
static void _freeOutPercentile(OutputPercentileWavelet **p);
static void _freeOutCoincidence(OutputCoincidenceWavelet **co);
static void _freeOutCluster(OutputClusterWavelet **cl);
static void _freeOutPixelMixer(OutputPixelMixerWavelet **pm);
static void _freeOutPixelSwap(OutputPixelSwapWavelet **ps);

static void _setAmplitudes(ClusterWavelet *w);
static int _countNonZeroes(REAL4TimeSeries *t);
static BOOLEAN _getSpectrogram(Wavelet *w, REAL4 ***spectrogram);
static void _freeSpectrogram(Wavelet *w, REAL4 ***spectrogram);

static void _predict(Wavelet *w, int level, int layer, const double *p_H);
static void _update(Wavelet *w, int level, int layer, const double *p_L);
static void _forward(Wavelet *w, int level, int layer);
static void _forwardFWT(Wavelet *w, int level, int layer, 
			const double *pLPF, const double *pHPF);
static void _inverse(Wavelet *w, int level, int layer);
static void _inverseFWT(Wavelet *w, int level, int layer, 
			const double *pLPF, const double *pHPF);
static double _Lagrange(const int n, const int i, const double x);
static double _Nevill(const double x0, int n, double *p, double *q);
static void _setFilter(Wavelet *w);
static void _setFilterB(Wavelet *w);
static void _setFilterS(Wavelet *w);
static void _setFilterD(Wavelet *w);
static void _setFilterH(Wavelet *w);
static void _setFilterM(Wavelet *w);
static void _writeWavelet(Wavelet *w, FILE *out);

static const double dbc1[2]={0.70710678118655,0.70710678118655};

static const double dbc2[4]=
{0.48296291314469,0.83651630373747, 0.22414386804186,-0.12940952255092};

static const double dbc3[6]=
{0.33267055295096,0.80689150931334,0.45987750211933,-0.13501102001039,
-0.08544127388224,0.03522629188210};

static const double dbc4[8]=
{0.23037781330886,0.71484657055254,0.63088076792959,-0.02798376941698,
-0.18703481171888,0.03084138183599,0.03288301166698,-0.01059740178500};

static const double dbc5[10]=
{0.16010239797413,0.60382926979747,0.72430852843857,0.13842814590110,
-0.24229488706619,-0.03224486958503,0.07757149384007,-0.00624149021301,
-0.01258075199902,0.00333572528500};

static const double dbc6[12]=
{0.11154074335008,0.49462389039839,0.75113390802158,0.31525035170924,
-0.22626469396517,-0.12976686756710,0.09750160558708,0.02752286553002,
-0.03158203931803,0.00055384220099,0.00477725751101,-0.00107730108500};

static const double dbc7[14]=
{0.07785205408506,0.39653931948231,0.72913209084656,0.46978228740536,
-0.14390600392911,-0.22403618499417,0.07130921926705,0.08061260915107,
-0.03802993693503,-0.01657454163102,0.01255099855601,0.00042957797300,
-0.00180164070400,0.00035371380000};

static const double dbc8[16]=
{0.05441584224308,0.31287159091447,0.67563073629801,0.58535468365487,
-0.01582910525602,-0.28401554296243,0.00047248457400,0.12874742662019,
-0.01736930100202,-0.04408825393106,0.01398102791702,0.00874609404702,
-0.00487035299301,-0.00039174037300,0.00067544940600,-0.00011747678400};

static const double dbc9[18]=
{0.03807794736317,0.24383467463767,0.60482312367678,0.65728807803664,
0.13319738582209,-0.29327378327259,-0.09684078322088,0.14854074933476,
0.03072568147832,-0.06763282905952,0.00025094711499,0.02236166212352,
-0.00472320475789,-0.00428150368190,0.00184764688296,0.00023038576400,
-0.00025196318900,0.00003934732000};

static const double dbc10[20]=
{0.02667005790095,0.18817680007762,0.52720118893092,0.68845903945259,
0.28117234366043,-0.24984642432649,-0.19594627437660,0.12736934033574,
0.09305736460381,-0.07139414716586,-0.02945753682195,0.03321267405893,
0.00360655356699,-0.01073317548298,0.00139535174699,0.00199240529499,
-0.00068585669500,-0.00011646685499,0.00009358867000,-0.00001326420300};

static const double dbc11[22]=
{0.01869429776147,0.14406702115062,0.44989976435603,0.68568677491617,
0.41196436894790,-0.16227524502747,-0.27423084681793,0.06604358819669,
0.14981201246638,-0.04647995511667,-0.06643878569502,0.03133509021905,
0.02084090436018,-0.01536482090620,-0.00334085887301,0.00492841765606,
-0.00030859285882,-0.00089302325067,0.00024915252355,0.00005443907470,
-0.00003463498419,0.00000449427428};

static const double dbc12[24]=
{0.01311225795723,0.10956627282118,0.37735513521419,0.65719872257928,
0.51588647842779,-0.04476388565377,-0.31617845375276,-0.02377925725606,
0.18247860592758,0.00535956967437,-0.09643212009649,0.01084913025583,
0.04154627749509,-0.01221864906975,-0.01284082519830,0.00671149900880,
0.00224860724100,-0.00217950361863,0.00000654512821,0.00038865306282,
-0.00008850410921,-0.00002424154576,0.00001277695222,-0.00000152907176};

static const double dbc13[26]=
{0.00920213353896,0.08286124387290,0.31199632216043,0.61105585115878,
0.58888957043121,0.08698572617964,-0.31497290771138,-0.12457673075080,
0.17947607942935,0.07294893365679,-0.10580761818792,-0.02648840647534,
0.05613947710028,0.00237997225405,-0.02383142071033,0.00392394144879,
0.00725558940162,-0.00276191123466,-0.00131567391189,0.00093232613087,
0.00004925152513,-0.00016512898856,0.00003067853758,0.00001044193057,
-0.00000470041648,0.00000052200351};

static const double dbc14[28]=
{0.00646115346009,0.06236475884939,0.25485026779257,0.55430561794077,
0.63118784910472,0.21867068775886,-0.27168855227868,-0.21803352999321,
0.13839521386480,0.13998901658447,-0.08674841156811,-0.07154895550399,
0.05523712625925,0.02698140830794,-0.03018535154036,-0.00561504953034,
0.01278949326634,-0.00074621898927,-0.00384963886802,0.00106169108561,
0.00070802115424,-0.00038683194731,-0.00004177724577,0.00006875504253,
-0.00001033720918,-0.00000438970490,0.00000172499468,-0.00000017871400};

static const double dbc15[30]=
{0.00453853736158,0.04674339489277,0.20602386398700,0.49263177170816,
0.64581314035744,0.33900253545474,-0.19320413960915,-0.28888259656697,
0.06528295284880,0.19014671400716,-0.03966617655576,-0.11112093603722,
0.03387714392350,0.05478055058448,-0.02576700732848,-0.02081005016973,
0.01508391802781,0.00510100036039,-0.00648773456032,-0.00024175649076,
0.00194332398038,-0.00037348235414,-0.00035956524436,0.00015589648992,
0.00002579269916,-0.00002813329627,0.00000336298718,0.00000181127041,
-0.00000063168823,0.00000006133360};

static const double dbc16[32]=
{0.00318922092535,0.03490771432367,0.16506428348885,0.43031272284599,
0.63735633208377,0.44029025688634,-0.08975108940249,-0.32706331052792,
-0.02791820813305,0.21119069394708,0.02734026375270,-0.13238830556381,
-0.00623972275247,0.07592423604429,-0.00758897436884,-0.03688839769171,
0.01029765964098,0.01399376885985,-0.00699001456340,-0.00364427962149,
0.00312802338121,0.00040789698085,-0.00094102174936,0.00011424152004,
0.00017478724523,-0.00006103596621,-0.00001394566899,0.00001133660866,
-0.00000104357134,-0.00000073636568,0.00000023087841,-0.00000002109340};

static const double dbc17[34]=
{0.00224180700104,0.02598539370361,0.13121490330784,0.37035072415269,
0.61099661568471,0.51831576405701,0.02731497040330,-0.32832074836400,
-0.12659975221589,0.19731058956506,0.10113548917751,-0.12681569177829,
-0.05709141963170,0.08110598665412,0.02231233617804,-0.04692243838934,
-0.00327095553587,0.02273367658392,-0.00304298998137,-0.00860292152033,
0.00296799669153,0.00230120524216,-0.00143684530480,-0.00032813251941,
0.00043946542777,-0.00002561010957,-0.00008204803202,0.00002318681380,
0.00000699060099,-0.00000450594248,0.00000030165496,0.00000029577009,
-0.00000008423948,0.00000000726749};

static const double dbc18[36]=
{0.00157631021844,0.01928853172418,0.10358846582258,0.31467894133751,
0.57182680776747,0.57180165488952,0.14722311197014,-0.29365404073704,
-0.21648093400555,0.14953397556546,0.16708131276330,-0.09233188415126,
-0.10675224666029,0.06488721621171,0.05705124773838,-0.04452614190323,
-0.02373321039602,0.02667070592642,0.00626216795425,-0.01305148094667,
0.00011863003383,0.00494334360546,-0.00111873266700,-0.00134059629834,
0.00062846568297,0.00021358156191,-0.00019864855231,-0.00000015359171,
0.00003741237881,-0.00000852060254,-0.00000333263448,0.00000176871298,
-0.00000007691633,-0.00000011760988,0.00000003068836,-0.00000000250793};

static const double dbc19[38]=
{0.00110866976318,0.01428109845070,0.08127811326510,0.26438843173972,
0.52443637746232,0.60170454912487,0.26089495264991,-0.22809139421438,
-0.28583863175437,0.07465226970810,0.21234974330584,-0.03351854190149,
-0.14278569503735,0.02758435062625,0.08690675555608,-0.02650123624947,
-0.04567422627659,0.02162376740985,0.01937554988940,-0.01398838867821,
-0.00586692228080,0.00704074736719,0.00076895435932,-0.00268755180066,
0.00034180865347,0.00073580252051,-0.00026067613568,-0.00012460079173,
0.00008711270467,0.00000510595049,-0.00001664017630,0.00000301096432,
0.00000153193148,-0.00000068627557,0.00000001447088,0.00000004636938,
-0.00000001116402,0.00000000086668};

static const double dbc20[40]=
{0.00077995361366,0.01054939462487,0.06342378045858,0.21994211354965,
0.47269618530714,0.61049323893374,0.36150229873647,-0.13921208801035,
-0.32678680043141,-0.01672708830897,0.22829105081798,0.03985024645728,
-0.15545875070610,-0.02471682733811,0.10229171917456,0.00563224685888,
-0.06172289962210,0.00587468181393,0.03229429953237,-0.00878932492251,
-0.01381052613626,0.00672162730258,0.00442054238715,-0.00358149425955,
-0.00083156217282,0.00139255961930,-0.00005349759845,-0.00038510474870,
0.00010153288973,0.00006774280828,-0.00003710586183,-0.00000437614386,
0.00000724124829,-0.00000101199401,-0.00000068470796,0.00000026339242,
0.00000000020143,-0.00000001814843,0.00000000405613,-0.00000000029988};

static const double dbc21[42]=
{0.00054882250986,0.00777663905246,0.04924777153883,0.18135962544278,
0.41968794494492,0.60150609494296,0.44459045193348,-0.03572291961772,
-0.33566408953492,-0.11239707156980,0.21156452768396,0.11523329844160,
-0.13994042493413,-0.08177594298219,0.09660039032382,0.04572340574753,
-0.06497750489781,-0.01865385920593,0.03972683542509,0.00335775638782,
-0.02089205367997,0.00240347091984,0.00898882438159,-0.00289133434884,
-0.00295837403905,0.00171660704064,0.00063941850053,-0.00069067111708,
-0.00003196406277,0.00019366465042,-0.00003635520250,-0.00003499665985,
0.00001535482509,0.00000279033054,-0.00000309001716,0.00000031660954,
0.00000029921366,-0.00000010004009,-0.00000000225401,0.00000000705803,
-0.00000000147195,0.00000000010388};

static const double dbc22[44]=
{0.00038626323150,0.00572185463145,0.03806993723721,0.14836754089323,
0.36772868345377,0.57843273102169,0.50790109063283,0.07372450118513,
-0.31272658043501,-0.20056840610944,0.16409318810947,0.17997318799515,
-0.09711079841387,-0.13176813769363,0.06807631438861,0.08455737636227,
-0.05136425430463,-0.04653081183330,0.03697084661864,0.02058670762720,
-0.02348000134426,-0.00621378284801,0.01256472522016,0.00030013739972,
-0.00545569198552,0.00104426073960,0.00182701049587,-0.00077069098807,
-0.00042378739982,0.00032860941423,0.00004345899905,-0.00009405223635,
0.00001137434966,0.00001737375696,-0.00000616672932,-0.00000156517913,
0.00000129518206,-0.00000008779880,-0.00000012833362,0.00000003761229,
0.00000000168017,-0.00000000272962,0.00000000053359,-0.00000000003602};

static const double dbc23[46]=
{0.00027190419416,0.00420274889370,0.02931000366146,0.12051553179868,
0.31845081389173,0.54493114794003,0.55101851730917,0.18139262538597,
-0.26139214806257,-0.27140209864102,0.09212540709353,0.22357365826899,
-0.03303744709916,-0.16401132155390,0.02028307457378,0.11229704362359,
-0.02112621237227,-0.07020739160254,0.02176585681370,0.03849533250212,
-0.01852351367601,-0.01753710102460,0.01275194391902,0.00603184064178,
-0.00707531927963,-0.00113486547603,0.00312287644907,-0.00024650140100,
-0.00106123122919,0.00031942049269,0.00025676245202,-0.00015002185037,
-0.00003378894835,0.00004426071204,-0.00000263520789,-0.00000834787557,
0.00000239756955,0.00000081475748,-0.00000053390054,0.00000001853092,
0.00000005417549,-0.00000001399935,-0.00000000094729,0.00000000105045,
-0.00000000019324,0.00000000001250};

static const double dbc24[48]=
{0.00019143580095,0.00308208171500,0.02248233995038,0.09726223583651,
0.27290891607582,0.50437104085489,0.57493922111260,0.28098555324203,
-0.18727140689076,-0.31794307900890,0.00477661368430,0.23923738878710,
0.04252872964227,-0.17117535137613,-0.03877717358004,0.12101630347157,
0.02098011370824,-0.08216165421234,-0.00457843624443,0.05130162003823,
-0.00494470943241,-0.02821310710056,0.00766172187681,0.01304997086673,
-0.00629143537412,-0.00474656878930,0.00373604617663,0.00115376493595,
-0.00169645681942,-0.00004416184869,0.00058612705931,-0.00011812332380,
-0.00014600798177,0.00006559388640,0.00002183241461,-0.00002022888293,
0.00000001341158,0.00000390110034,-0.00000089802531,-0.00000040325078,
0.00000021663397,-0.00000000050576,-0.00000002255740,0.00000000515778,
0.00000000047484,-0.00000000040247,0.00000000006992,-0.00000000000434};

static const double dbc25[50]=
{0.00013480297936,0.00225695959203,0.01718674125537,0.07803586287819,
0.23169350790401,0.45968341518179,0.58163689679121,0.36788507483148,
-0.09717464097229,-0.33647307966812,-0.08758761459496,0.22453781976164,
0.11815528672764,-0.15056021376482,-0.09850861530222,0.10663380501832,
0.06675216448493,-0.07708411108361,-0.03717396289023,0.05361790937603,
0.01554260590837,-0.03404232047610,-0.00307983679799,0.01892280448261,
-0.00198942577434,-0.00886070261061,0.00272693626530,0.00332270777835,
-0.00184248428806,-0.00089997742272,0.00087725819420,0.00011532124422,
-0.00030988009907,0.00003543714525,0.00007904640005,-0.00002733048120,
-0.00001277195293,0.00000899066139,0.00000052328277,-0.00000177920133,
0.00000032120375,0.00000019228068,-0.00000008656942,-0.00000000261160,
0.00000000927922,-0.00000000188042,-0.00000000022285,0.00000000015359,
-0.00000000002528,0.00000000000151};

static const double dbc26[52]=
{0.00009493795747,0.00165052023287,0.01309755428729,0.06227474400009,
0.19503943863827,0.41329296211202,0.57366904280335,0.43915831161244,
0.00177407678034,-0.32638459356024,-0.17483996121861,0.18129183223897,
0.18275540951738,-0.10432390024244,-0.14797719321441,0.06982318608594,
0.10648240520785,-0.05344856165621,-0.06865475956471,0.04223218580538,
0.03853571600107,-0.03137811028460,-0.01776090348004,0.02073492025806,
0.00582958063302,-0.01178549783685,-0.00052873835369,0.00560194726473,
-0.00093905823572,-0.00214553027435,0.00083834880766,0.00061613822092,
-0.00043195570707,-0.00010605747474,0.00015747952381,-0.00000527779549,
-0.00004109673995,0.00001074221541,0.00000700007868,-0.00000388740016,
-0.00000046504632,0.00000079392106,-0.00000010790042,-0.00000008904466,
0.00000003407796,0.00000000216933,-0.00000000377601,0.00000000067800,
0.00000000010023,-0.00000000005840,0.00000000000913,-0.00000000000053};

static const double dbc27[54]=
{0.00006687131379,0.00120553123053,0.00995258877145,0.04945259993605,
0.16292202734804,0.36711021377760,0.55384986046579,0.49340612221061,
0.10284085496457,-0.28971680303965,-0.24826458166690,0.11482301941169,
0.22727328820471,-0.03878641858319,-0.17803174076834,0.01579939748221,
0.13119797164867,-0.01406275146647,-0.09102290634917,0.01731101835678,
0.05796940579574,-0.01851249342470,-0.03273906647991,0.01614696702403,
0.01566559574354,-0.01157718635089,-0.00586209625930,0.00685663566511,
0.00134262691970,-0.00333285443828,0.00014575297882,0.00130117745760,
-0.00034183511836,-0.00038790185541,0.00020197198834,0.00007660058395,
-0.00007711145508,-0.00000351748362,0.00002063442645,-0.00000390116407,
-0.00000365750091,0.00000163436962,0.00000030508807,-0.00000034724681,
0.00000003286559,0.00000004026255,-0.00000001321332,-0.00000000130947,
0.00000000152161,-0.00000000024155,-0.00000000004375,0.00000000002214,
-0.00000000000330,0.00000000000018};

static const double dbc28[56]=
{0.00004710807766,0.00087949851431,0.00754265036328,0.03909260804095,
0.13513791399624,0.32256336067113,0.52499823063037,0.53051629243100,
0.20017614366470,-0.23049895360849,-0.30132780895814,0.03285787910353,
0.24580815091531,0.03690688527328,-0.18287733031840,-0.04683823352168,
0.13462756788564,0.03447863155804,-0.09768535516323,-0.01734192227806,
0.06774789588669,0.00344801938223,-0.04333336823364,0.00443173305187,
0.02468805998294,-0.00681554982076,-0.01206359205683,0.00583881650115,
0.00478486300787,-0.00372546130632,-0.00136037388200,0.00187599864580,
0.00014156723219,-0.00074867495568,0.00011546560683,0.00022957909867,
-0.00008903901415,-0.00004907713377,0.00003641401216,0.00000463866501,
-0.00001004326038,0.00000124790032,0.00000184036373,-0.00000066702155,
-0.00000017574612,0.00000014906600,-0.00000000826239,-0.00000001784139,
0.00000000504405,0.00000000069445,-0.00000000060770,0.00000000008492,
0.00000000001867,-0.00000000000837,0.00000000000119,-0.00000000000006};

static const double dbc29[58]=
{0.00003318966297,0.00064095168358,0.00570212654694,0.03077358037883,
0.11137011752144,0.28065345740663,0.48975880726750,0.55137443557886,
0.28910523981468,-0.15402873524802,-0.33004095060681,-0.05570680036129,
0.23610523735052,0.11241917542149,-0.16087798947795,-0.10784595061226,
0.11447229626215,0.08322074724110,-0.08512549355142,-0.05502749046173,
0.06347916412676,0.03053154257401,-0.04518798236422,-0.01291714340149,
0.02947043137455,0.00264832683582,-0.01704122498871,0.00173788013922,
0.00846972541737,-0.00255080721472,-0.00347379905891,0.00187712089643,
0.00108705391903,-0.00100077835149,-0.00020007114870,0.00041112834174,
-0.00002292018316,-0.00012930448572,0.00003645026049,0.00002913344752,
-0.00001657328408,-0.00000359364483,0.00000475060927,-0.00000030290546,
-0.00000089757018,0.00000026338984,0.00000009387197,-0.00000006286157,
0.00000000107659,0.00000000776898,-0.00000000189400,-0.00000000034268,
0.00000000024071,-0.00000000002941,-0.00000000000783,0.00000000000315,
-0.00000000000043,0.00000000000002};

static const double dbc30[60]=
{0.00002338616182,0.00046663795235,0.00430079718272,0.02413083277074,
0.09123830444189,0.24202067193463,0.45048782370427,0.55757223520372,
0.36624268487617,-0.06618367104886,-0.33296697639194,-0.14196851392136,
0.19946212238116,0.17782987393397,-0.11455821998655,-0.15723681875947,
0.07277865900869,0.12274774614278,-0.05380646625820,-0.08765869114446,
0.04380166398048,0.05671236507154,-0.03567339847522,-0.03226375971045,
0.02707861927863,0.01528796063552,-0.01839974396002,-0.00529685959906,
0.01091563182436,0.00061967186322,-0.00553073010417,0.00084338462127,
0.00232452011131,-0.00086092770350,-0.00076787825930,0.00050509482141,
0.00017248258226,-0.00021617183228,-0.00000854830600,0.00006982008384,
-0.00001339716873,-0.00001636152487,0.00000725214556,0.00000232754911,
-0.00000218726769,0.00000001099474,0.00000042616623,-0.00000010004147,
-0.00000004764380,0.00000002605443,0.00000000055534,-0.00000000333111,
0.00000000069849,0.00000000016136,-0.00000000009461,0.00000000001000,
0.00000000000324,-0.00000000000119,0.00000000000015,-0.00000000000001};


static const double sym2[4]=
{0.48296291314469,0.83651630373747,0.22414386804186,-0.12940952255092};

static const double sym3[6]=
{0.33267055295096,0.80689150931334,0.45987750211933,-0.13501102001039,
-0.08544127388224,0.03522629188210};

static const double sym4[8]=
{0.03222310060404,-0.01260396726204,-0.09921954357685,0.29785779560528,
0.80373875180592,0.49761866763202,-0.02963552764600,-0.07576571478927};

static const double sym5[10]=
{0.01953888273529,-0.02110183402476,-0.17532808990845,0.01660210576452,
0.63397896345821,0.72340769040242,0.19939753397739,-0.03913424930238,
0.02951949092577,0.02733306834508};

static const double sym6[12]=
{-0.00780070832503,0.00176771186424,0.04472490177067,-0.02106029251230,
-0.07263752278646,0.33792942172762,0.78764114103019,0.49105594192675,
-0.04831174258563,-0.11799011114819,0.00349071208422,0.01540410932703};

static const double sym7[14]=
{0.01026817670851,0.00401024487153,-0.10780823770382,-0.14004724044296,
0.28862963175151,0.76776431700316,0.53610191709176,0.01744125508686,
-0.04955283493713,0.06789269350137,0.03051551316596,-0.01263630340325,
-0.00104738488868,0.00268181456826};

static const double sym8[16]=
{0.00188995033276,-0.00030292051472,-0.01495225833705,0.00380875201389,
0.04913717967361,-0.02721902991706,-0.05194583810771,0.36444189483533,
0.77718575170052,0.48135965125837,-0.06127335906766,-0.14329423835081,
0.00760748732492,0.03169508781149,-0.00054213233179,-0.00338241595101};

static const double sym9[18]=
{0.00106949003291,-0.00047315449868,-0.01026406402763,0.00885926749340,
0.06207778930289,-0.01823377077940,-0.19155083129729,0.03527248803528,
0.61733844914095,0.71789708276441,0.23876091460730,-0.05456895843084,
0.00058346274613,0.03022487885828,-0.01152821020768,-0.01327196778182,
0.00061978088899,0.00140091552591};

static const double sym10[20]=
{-0.00045932942100,0.00005703608362,0.00459317358531,-0.00080435893202,
-0.02035493981231,0.00576491203358,0.04999497207738,-0.03199005688243,
-0.03553674047382,0.38382676106708,0.76951003702110,0.47169066693844,
-0.07088053578324,-0.15949427888492,0.01160989390371,0.04592723923109,
-0.00146538258130,-0.00864129927702,0.00009563267072,0.00077015980911};

static const double sym11[22]=
{0.00048926361026,0.00011053509764,-0.00638960366645,-0.00200347190011,
0.04300019068155,0.03526675956446,-0.14460234370532,-0.20465479449578,
0.23768990904928,0.73034354908840,0.57202297801007,0.09719839445889,
-0.02283265102257,0.06997679961073,0.03703741597886,-0.02408084159587,
-0.00985793482879,0.00651249567477,0.00058835273540,-0.00173436626730,
-0.00003879565574,0.00017172195070};

static const double sym12[24]=
{-0.00017906658698,-0.00001815807886,0.00235029761418,0.00030764779631,
-0.01458983644923,-0.00260439103133,0.05780417944551,0.01530174062248,
-0.17037069723887,-0.07833262231632,0.46274103121933,0.76347909778368,
0.39888597239018,-0.02216230617039,-0.03584883073697,0.04917931829966,
0.00755378061168,-0.02422072267502,-0.00140890924433,0.00741496551766,
0.00018021409009,-0.00134975575557,-0.00001135392804,0.00011196719425};

static const double sym13[26]=
{0.00007042986691,0.00003690537342,-0.00072136438514,0.00041326119884,
0.00567485376012,-0.00149244727426,-0.02074968632552,0.01761829688065,
0.09292603089915,0.00881975767043,-0.14049009311369,0.11023022302128,
0.64456438390117,0.69573915056158,0.19770481877127,-0.12436246075151,
-0.05975062771796,0.01386249743584,-0.01721164272631,-0.02021676813340,
0.00529635973872,0.00752622538997,-0.00017094285853,-0.00113606343893,
-0.00003573862365,0.00006820325263};

static const double sym14[28]=
{0.00004461897799,0.00001932901697,-0.00060576018247,-0.00007321421357,
0.00453267747195,0.00101314198718,-0.01943931426363,-0.00236504883674,
0.06982761636183,0.02589858753105,-0.15999741114654,-0.05811182331763,
0.47533576263445,0.75997624196128,0.39320152196202,-0.03531811211520,
-0.05763449835147,0.03743308836280,0.00428052049898,-0.02919621776406,
-0.00275377479123,0.01003769371768,0.00036647657366,-0.00257944172593,
-0.00006286542481,0.00039843567298,0.00001121086581,-0.00002587909027};

static const double sym15[30]=
{0.00002866070853,0.00002171789015,-0.00040216853760,-0.00010815440169,
0.00348102873707,0.00152613827819,-0.01717125278165,-0.00874478888650,
0.06796982904489,0.06839331006054,-0.13405629845629,-0.19662635876643,
0.24396270543204,0.72184302963632,0.57864041521527,0.11153369514269,
-0.04108266663544,0.04073547969677,0.02193764271975,-0.03887671687685,
-0.01940501143095,0.01007997708790,0.00342345073635,-0.00359016544737,
-0.00026731644647,0.00107056721946,0.00005512254786,-0.00016066186637,
-0.00000735966680,0.00000971241974};

static const double sym16[32]=
{-0.00001079798210,-0.00000539648318,0.00016545679579,0.00003656592483,
-0.00133872060669,-0.00022211647621,0.00693776113081,0.00135984474247,
-0.02495275804631,-0.00351027506830,0.07803785290360,0.03072113906330,
-0.15959219218533,-0.05404060138707,0.47534280601285,0.75652498787649,
0.39712293361998,-0.03457422841817,-0.06698304907080,0.03233309161055,
0.00486927440478,-0.03105120284367,-0.00312651717226,0.01266673165989,
0.00071821197882,-0.00388091225262,-0.00010844562231,0.00085235471081,
0.00002807858213,-0.00010943147930,-0.00000311355641,0.00000623000670};

static const double sym17[34]=
{0.00000379125319,-0.00000245271634,-0.00007607124406,0.00002520793314,
0.00071982706421,0.00005840042870,-0.00393232527979,-0.00190540768987,
0.01239698836660,0.00995298252353,-0.01803889724182,-0.00726163475091,
0.01615880872602,-0.08607087472032,-0.15507600534989,0.18053958457921,
0.68148899534246,0.65071662920429,0.14239835041670,-0.11856693260976,
0.01727117821070,0.10475461484209,0.01790395221460,-0.03329138349213,
-0.00481921280320,0.01048236693298,0.00085677007020,-0.00274167597567,
-0.00013864230268,0.00047599638026,-0.00001350638340,-0.00006293702598,
0.00000278012669,0.00000429734333};

static const double sym18[36]=
{-0.00000151315307,0.00000078472981,0.00002955743762,-0.00000985881603,
-0.00026583011024,0.00004741614518,0.00142808632708,-0.00018877623940,
-0.00523978968302,0.00108778478960,0.01501235634429,-0.00326074419997,
-0.03171268473169,0.00627794455441,0.02852959703912,-0.07379920729075,
-0.03248057329092,0.40148386056943,0.75362914010133,0.47396905989475,
-0.05202915898285,-0.15993814866901,0.03399566710369,0.08421992997028,
-0.00507708516062,-0.03032509108928,0.00164298639727,0.00950216439096,
-0.00041152110922,-0.00231387181450,0.00007021273459,0.00039616840638,
-0.00001402099258,-0.00004524675787,0.00000135491576,0.00000261261256};

static const double sym19[38]=
{0.00000175093680,0.00000206231706,-0.00002815113866,-0.00001682138703,
0.00027621877686,0.00012930767651,-0.00170496026116,-0.00061792232780,
0.00826223695551,0.00431935187495,-0.02770989693110,-0.01690823486119,
0.08407267627915,0.09363084341623,-0.11624173010592,-0.17659686625066,
0.25826616923642,0.71955552571378,0.57814494533691,0.10902582508132,
-0.06752505803991,0.00895459117312,0.00701557385747,-0.04663598353443,
-0.02265199337798,0.01579743929571,0.00796843832065,-0.00512220500254,
-0.00116070325720,0.00212142502817,0.00015915804768,-0.00063576451500,
-0.00004612039600,0.00011553923334,0.00000887331217,-0.00001188051827,
-0.00000064636513,0.00000054877328};

static const double sym20[40]=
{-0.00000063291290,-0.00000032567026,0.00001228725278,0.00000452542221,
-0.00011739133516,-0.00002661555034,0.00074761085974,0.00012544091727,
-0.00347164780267,-0.00061112638609,0.01215704094790,0.00193859706772,
-0.03537333675507,-0.00684370196894,0.08891966801896,0.03625095165273,
-0.16057829841234,-0.05108834294808,0.47199147504138,0.75116272838989,
0.40583144438308,-0.02981936882107,-0.07899434489912,0.02557934951284,
0.00812322835892,-0.03162943714139,-0.00331385738520,0.01700404902119,
0.00142308736006,-0.00660658579824,-0.00030526283204,0.00208899470791,
0.00007215991195,-0.00049473109149,-0.00001928412302,0.00007992967834,
0.00000302566606,-0.00000791936141,-0.00000019015676,0.00000036955375};

static const double sym21[42]=
{0.00000023116904,-0.00000007401089,-0.00000516158836,0.00000183899845,
0.00005820786308,-0.00001055398996,-0.00041349561806,-0.00002060745324,
0.00203118441578,0.00069591568201,-0.00674898277369,-0.00409543219752,
0.01450786941750,0.01118865626885,-0.01508147033057,0.00625464069426,
0.02791728151204,-0.08709884432141,-0.15131078012891,0.19202706524796,
0.68158332059527,0.64618599743615,0.14412386119274,-0.12356548353363,
0.00736738941236,0.10148310770052,0.01067013591536,-0.04716326398300,
-0.00899202924623,0.01540083464058,0.00176596179226,-0.00535395747976,
-0.00043315590952,0.00142132044885,0.00006208657527,-0.00028647517579,
0.00000607913038,0.00004694778085,-0.00000183116834,-0.00000509819139,
0.00000007895915,0.00000024662467};

static const double sym22[44]=
{0.00000015701037,0.00000009966118,-0.00000328417896,-0.00000146277694,
0.00003442102521,0.00001076285381,-0.00023615708448,-0.00004790058918,
0.00120819750454,0.00021700733081,-0.00470892831539,-0.00077852943445,
0.01485841354863,0.00255497233268,-0.03922962637142,-0.00752552739132,
0.09413257032833,0.04132666895742,-0.15420831552203,-0.04123051452708,
0.47683319799820,0.74899293929327,0.40287666044285,-0.03659053895049,
-0.09061187088512,0.01915428943071,0.00842098867472,-0.03179026919182,
-0.00355937471201,0.01864608663048,0.00168314925131,-0.00800078674386,
-0.00046737262697,0.00282051712122,0.00011079462032,-0.00079412754687,
-0.00003361349829,0.00016465262503,0.00000770422674,-0.00002357636865,
-0.00000098649840,0.00000210708665,0.00000005624840,-0.00000008861606};

static const double sym23[46]=
{0.00000010235430,0.00000011947301,-0.00000207996803,-0.00000168882731,
0.00002269111797,0.00001337545480,-0.00016515274988,-0.00006891398065,
0.00092065028998,0.00035751068028,-0.00393795248714,-0.00159865021268,
0.01387834485221,0.00751868829733,-0.03854919903172,-0.02759831960490,
0.09194189389449,0.10791667041303,-0.11151590218887,-0.17895622157283,
0.24859349726852,0.70931934236184,0.58652666181596,0.12546897118256,
-0.07028820351936,-0.00454376049568,0.00255211302562,-0.04643623117797,
-0.02186836373024,0.02077476122165,0.01143485977922,-0.00717111121596,
-0.00281604932182,0.00304595670399,0.00045268316044,-0.00123284622195,
-0.00009789651829,0.00036373350955,0.00002965227285,-0.00007386036564,
-0.00000627559386,0.00001006623708,0.00000074523049,-0.00000084388462,
-0.00000003876629,0.00000003321165};

static const double sym24[48]=
{-0.00000003763894,-0.00000001379902,0.00000092122723,0.00000035313033,
-0.00001083968061,-0.00000471080885,0.00007954430272,0.00003554828409,
-0.00041089637963,-0.00015315078955,0.00165852411624,0.00036533725724,
-0.00578932461719,-0.00070874601122,0.01791452935815,0.00422746501837,
-0.04281324592714,-0.01507710368464,0.08102456049784,0.02392107501492,
-0.16088779689114,-0.02988259975726,0.48880974855408,0.74688385743468,
0.39288115166264,-0.04379342297629,-0.08777599016841,0.03444149388902,
0.02574605129641,-0.02426279125326,-0.00322429774344,0.01824651181612,
0.00027829218166,-0.01009299895819,-0.00061288026541,0.00390135636880,
0.00032248385033,-0.00117205334361,-0.00010277190304,0.00027429214178,
0.00002161714042,-0.00004875059458,-0.00000276094813,0.00000635141112,
0.00000020725965,-0.00000054069132,-0.00000000809775,0.00000002208787};

static const double sym25[50]=
{0.00000001417393,-0.00000000128584,-0.00000035883307,0.00000008450483,
0.00000460200134,-0.00000106655594,-0.00003862052166,0.00000525387369,
0.00023387577301,0.00000581099069,-0.00106357085882,-0.00024665256419,
0.00363827754098,0.00168360713385,-0.00899375078539,-0.00591958921067,
0.01498023419939,0.00993789458552,-0.01340322915072,0.01798969208769,
0.03862447178667,-0.08574203560471,-0.14658183869341,0.20129994479568,
0.68175692878985,0.64245780610168,0.14440656141754,-0.12888353966089,
-0.00288020261395,0.09620356820102,0.00454479703964,-0.05697322565402,
-0.01086875280482,0.02115133223651,0.00336812528826,-0.00801783983806,
-0.00080537486804,0.00276454631473,0.00021102111165,-0.00074974673235,
-0.00002424720226,0.00016847624768,-0.00000317175456,-0.00003152810174,
0.00000107502980,0.00000434483509,-0.00000008618136,-0.00000036987182,
0.00000000130255,0.00000001435812};

static const double sym26[52]=
{-0.00000000543571,0.00000000199024,0.00000014430002,-0.00000005275976,
-0.00000183707240,0.00000073688296,0.00001516517917,-0.00000654194941,
-0.00009206773058,0.00003757555029,0.00043268934169,-0.00014414125172,
-0.00160482533375,0.00038470529620,0.00477959384708,-0.00058695506598,
-0.01115011462549,0.00028029270803,0.01851220018216,-0.00454082260968,
-0.02417683712649,0.02788593725265,0.03357868590107,-0.08973261009127,
-0.04066610256625,0.39654996642049,0.74534691300998,0.48659675911554,
-0.03054816636870,-0.16263026270583,0.02381623987822,0.08335972926050,
-0.01571336409339,-0.04542223587036,0.00529771387456,0.02060700942608,
-0.00097581041791,-0.00728998611856,0.00040607789503,0.00226218548420,
-0.00019898334754,-0.00062562025657,0.00005915042437,0.00014332547319,
-0.00001083563455,-0.00002507873243,0.00000124228948,0.00000309673285,
-0.00000008854202,-0.00000024216780,0.00000000335850,0.00000000917271};

static const double sym27[54]=
{0.00000000200486,-0.00000000225655,-0.00000005780336,0.00000005816294,
0.00000081043393,-0.00000067142671,-0.00000724188402,0.00000454696437,
0.00004551014829,-0.00001987214817,-0.00020932941145,0.00006267580812,
0.00071471422728,-0.00020855313323,-0.00183995581592,0.00103837743414,
0.00396141302209,-0.00484585447809,-0.00946085230775,0.01431280731090,
0.02593596176648,-0.01789276436445,-0.04191593809368,0.00091947692675,
-0.01754596460237,-0.07886544762866,0.13063831337891,0.58946164295955,
0.70449404469039,0.24869269195981,-0.17335255579376,-0.10550196328364,
0.11576172687488,0.09374636823657,-0.03849177869134,-0.04783974419199,
0.01091220407678,0.01925636749894,-0.00314457482910,-0.00679065270580,
0.00076187111254,0.00197699552151,-0.00018852424968,-0.00048322234864,
0.00004468020830,0.00009726406937,-0.00000899977529,-0.00001546107195,
0.00000144610528,0.00000186359765,-0.00000015046913,-0.00000015232407,
0.00000000686339,0.00000000609786};

static const double sym28[56]=
{-0.00000000223841,-0.00000000080814,0.00000006348994,0.00000002240654,
-0.00000087514214,-0.00000032744949,0.00000772104424,0.00000313803239,
-0.00004848031767,-0.00002021976593,0.00023114897537,0.00008673264856,
-0.00088921450226,-0.00024089432929,0.00295035213651,0.00045574888521,
-0.00885635272453,-0.00132060610611,0.02310526980043,0.00629724042357,
-0.04771096755582,-0.01621457161075,0.08536229609472,0.02357730093902,
-0.16437040480472,-0.03154320812556,0.48424408416030,0.74397532266483,
0.40014593426660,-0.03744630472127,-0.09120194632275,0.03285695485769,
0.02986054897631,-0.02404713054345,-0.00585973849229,0.01865510958775,
0.00038509113319,-0.01202490038160,-0.00054004768399,0.00563725023110,
0.00043338521493,-0.00208037206914,-0.00018786535509,0.00062860489607,
0.00005764318298,-0.00015428555363,-0.00001257590187,0.00003035437524,
0.00000189746857,-0.00000466642977,-0.00000019675201,0.00000052609490,
0.00000001351981,-0.00000003830230,-0.00000000048383,0.00000000134012};

static const double sym29[58]=
{0.00000000086914,0.00000000007683,-0.00000002476128,0.00000000304434,
0.00000035944572,-0.00000006997480,-0.00000343511732,0.00000067174032,
0.00002415810963,-0.00000310632315,-0.00013140817964,0.00000160162253,
0.00056818760343,0.00008532968392,-0.00195185738910,-0.00065489520898,
0.00527183982333,0.00284145407341,-0.01048311108995,-0.00699646454543,
0.01478801128217,0.00757358653480,-0.01212866901975,0.02896370174289,
0.04899578905306,-0.08385363336444,-0.14426113167429,0.20571029834063,
0.68048314526649,0.64077273046963,0.14693981020727,-0.13193541112313,
-0.01228374764213,0.08980937772282,-0.00093576808478,-0.06412063880974,
-0.01161867252201,0.02656533167184,0.00487002331131,-0.01083258821344,
-0.00136198949647,0.00428940824406,0.00040722859294,-0.00143251730877,
-0.00009078820672,0.00040339823174,0.00000745768225,-0.00009793537610,
0.00000196559708,0.00002001819326,-0.00000066704682,-0.00000321133820,
0.00000007745993,0.00000036644309,-0.00000000281205,-0.00000002591084,
-0.00000000007491,0.00000000084744};

static const double sym30[60]=
{0.00000000055439,0.00000000025363,-0.00000001650488,-0.00000000612778,
0.00000024412962,0.00000008995017,-0.00000232354978,-0.00000089828469,
0.00001589700483,0.00000647382806,-0.00008272690614,-0.00003293176436,
0.00034385221446,0.00011735869759,-0.00119692134911,-0.00027628415438,
0.00371380699054,0.00054379852399,-0.01038876691564,-0.00162932203336,
0.02556854601492,0.00760939671239,-0.04889669601845,-0.01523693636380,
0.08910160894494,0.02619852893355,-0.16204680547674,-0.02843781124261,
0.48469802756342,0.74269377583417,0.40072254149852,-0.03849152799019,
-0.09630227409198,0.02927099877092,0.02965858799887,-0.02521794463036,
-0.00795200551976,0.01829724962657,0.00037212410631,-0.01284118848030,
-0.00051919347319,0.00645416697646,0.00046642596970,-0.00258964861453,
-0.00023156691354,0.00086145323605,0.00008209441595,-0.00023724380919,
-0.00002120204181,0.00005384704875,0.00000402586750,-0.00000989667625,
-0.00000055432800,0.00000142300528,0.00000005465707,-0.00000014986092,
-0.00000000380480,0.00000001014810,0.00000000014934,-0.00000000032641};


static int _f2l(int level, int indx)
{
  int n = indx;
  int j,i;
  for(i=level-1; i>=1; i--) {
    j = ((1<<i) & (n));
    if(j) n = ((1<<i)-1) ^ (n);
  }
  return n;
}

#if 0 /* NOT USED */
static int _l2f(int level, int layer)
{
  int n = layer;
  int i;
  int j;
  for(i=1; i<level; i++) {
    j = (1<<i) & (n);
    if(j) n = ((1<<i)-1) ^ (n);
  }
  return n;
}
#endif

static void _getSliceL(int level, int layer, Wavelet *wavelet, Slice *slice)
{
  UINT4 waveletSize=wavelet->data->data->length;
  
  slice->start=_getOffset(level,layer);
  slice->step=(1<<level);
  slice->size=(waveletSize>>level);
  if(slice->start+(slice->size-1)*slice->step+1 > waveletSize)
    {
      fprintf(stderr,"Inconsistent slice: start=%d, step=%d, size=%d, waveletSize=%d\n",
	      slice->start, slice->step, slice->size, waveletSize);
      slice->size=-1;
    }
}

static void _getSliceF(int indx, Wavelet *wavelet, Slice *slice)
{

  int level=wavelet->level;
  int layer=abs(indx);
  
  int maxLayer=(wavelet->treeType==BINARY) ? ((1<<level) - 1) : level;

  if(layer>maxLayer){
    fprintf(stderr,"layer=%d > maxLayer=%d\n",layer,maxLayer);
    layer=maxLayer;
    fprintf(stderr,"Setting layer=maxLayer\n");
  }

  if(wavelet->treeType==BINARY){
    if(indx>0) layer=_f2l(level,layer);
  }
  else{
      if(layer) {               
	 level -= layer-1; 
	 layer = 1;
      }
      else{                     
	 layer = 0;
      }
  }
  _getSliceL(level,layer,wavelet,slice);
}

static int _getOffset(int level,int layer)
{
  int n=0,i;
  for(i=0; i<level; i++)
    if((layer>>i)&1) n += 1<<(level-1-i);
  return n;
}

static int _getMaxLevel(Wavelet *wavelet, UINT4 n)
{
  int maxLevel = 0;
  for(; (n>=2*wavelet->HPFilterLength) && (n>=2*wavelet->LPFilterLength) && !(n&1); n/=2) maxLevel++;
  return maxLevel;
} 

static int _getMaxLayer(Wavelet *wavelet)
{ 
  return ((wavelet->treeType==BINARY) ? (1<<(int)wavelet->level)-1 : (int)wavelet->level);
}

static UINT4 _limit(Slice s)
{ 
  return s.start + (s.size-1)*s.step + 1; 
}

static int _getLayer(REAL4TimeSeries **layerOut, int indx, Wavelet *wavelet)
{
  char name[LALNameLength];

  Slice s;
  UINT4 i;
  UINT4 waveletSize=wavelet->data->data->length;
  int maxLayer=_getMaxLayer(wavelet);

  sprintf(name,"layer indx=%d of wavelet ",indx);
  strcat(name,wavelet->data->name);

  if(indx>maxLayer) indx=maxLayer;
  _getSliceF(indx,wavelet,&s);

  if(_limit(s)<=waveletSize){
    _assignREAL4TimeSeriesMetadata(layerOut, wavelet->data);
    (*layerOut)->deltaT *= s.step;
    strcpy((*layerOut)->name,name);
    (*layerOut)->data->length=s.size;
    (*layerOut)->data->data=(REAL4*)LALCalloc(s.size,sizeof(REAL4));
    if((*layerOut)->data->data==NULL)
      {
	fprintf(stderr,"Cannot allocate memory 13\n"); fflush(stderr);
	exit(1);
      }
    for(i=0;i<s.size;i++){
      if(s.start+s.step*i >= wavelet->data->data->length)
	{
	  fprintf(stderr,"Index out of bounds start=%d step=%d i=%d length=%d\n",
		  s.start,s.step,i,wavelet->data->data->length);fflush(stderr);
	  exit(1);
	}
      (*layerOut)->data->data[i]=wavelet->data->data->data[s.start+s.step*i];
    }
    return indx;
  }
  else{
    return -1;
  }
}

static void _putLayer(REAL4TimeSeries *layerData, int layer, Wavelet *wavelet)
{
  UINT4 i;
  Slice s;
  _getSliceF(layer,wavelet,&s);
  if(s.size < layerData->data->length || 
     _limit(s) > wavelet->data->data->length) {
    fprintf(stderr,"Invalid layer size\n");
  }
  else{
    for(i=0;i<s.size;i++){
      wavelet->data->data->data[s.start+i*s.step]=layerData->data->data[i];
    }
  }
} 

static BOOLEAN _getSpectrogram(Wavelet *w, REAL4 ***spectrogram)
{
  int mlayer, mtime, i, j;
  REAL4TimeSeries *tmp;
  
  mlayer=_getMaxLayer(w);

  *spectrogram=(REAL4**)LALCalloc(mlayer+1,sizeof(REAL4*));
  for(i=0;i<=mlayer;i++)
    {
      _getLayer(&tmp,i,w);
      mtime=tmp->data->length;
      (*spectrogram)[i]=(REAL4*)LALCalloc(mtime,sizeof(REAL4));
      for(j=0;j<mtime;j++)
	{
	  (*spectrogram)[i][j]=tmp->data->data[j];
	}
      _freeREAL4TimeSeries(&tmp);
    }
  return TRUE;
}

static void _freeSpectrogram(Wavelet *w, REAL4 ***spectrogram)
{
  int mlayer, i;
  mlayer=_getMaxLayer(w);

  for(i=0;i<=mlayer;i++)
    {
      LALFree((*spectrogram)[i]);
      (*spectrogram)[i]=NULL;
    }
  LALFree(*spectrogram);
  *spectrogram=NULL;
}

/* Allocates memory for left and _assignes all the metadata from right. 
   (*left)->name and (*left)->data->data are not _assigned.
   (*left)->data->data is not allocated.
*/

static void _assignREAL4TimeSeriesMetadata(REAL4TimeSeries **left, REAL4TimeSeries *right)
{
  *left=(REAL4TimeSeries*)LALCalloc(1,sizeof(REAL4TimeSeries));
  if(*left==NULL)
    {
      fprintf(stderr,"Cannot allocate memory 12\n");
      exit(1);
    }
  (*left)->data=(REAL4Sequence*)LALCalloc(1,sizeof(REAL4Sequence));
  if((*left)->data==NULL)
    {
      fprintf(stderr,"Cannot allocate memory 11\n");
      exit(1);
    }
  (*left)->epoch=right->epoch;
  (*left)->deltaT=right->deltaT;
  (*left)->f0=right->f0;
  _unitCopy(&(*left)->sampleUnits,&right->sampleUnits);
  /*  (*left)->sampleUnits=right->sampleUnits; */
  (*left)->data->length=right->data->length;
  (*left)->data->data=NULL;
  strncpy((*left)->name,"Assign a name manually",LALNameLength);
}

/* REAL4TimeSeries copy constructor */
static void _assignREAL4TimeSeries(REAL4TimeSeries **left, REAL4TimeSeries *right)
{
  UINT4 i;
  _assignREAL4TimeSeriesMetadata(left,right);
  strncpy((*left)->name,right->name,LALNameLength);
  (*left)->data->data=(REAL4*)LALCalloc(right->data->length,sizeof(REAL4));
  if((*left)->data->data==NULL)
    {
      fprintf(stderr,"Cannot allocate memory 10\n");
      exit(1);
    }
  for(i=0;i<right->data->length;i++){
    (*left)->data->data[i]=right->data->data[i];
  }
}

static void _assignREAL4FrequencySeries(REAL4FrequencySeries **left,REAL4FrequencySeries *right)
{
  UINT4 i;

  (*left)=(REAL4FrequencySeries*)LALCalloc(1,sizeof(REAL4FrequencySeries));
  (*left)->data=(REAL4Sequence*)LALCalloc(1,sizeof(REAL4Sequence));
  (*left)->data->data=(REAL4*)LALCalloc(right->data->length,sizeof(REAL4));

  strncpy((*left)->name,right->name,LALNameLength);
  (*left)->epoch=right->epoch;
  (*left)->f0=right->f0;
  (*left)->deltaF=right->deltaF;
  _unitCopy(&(*left)->sampleUnits,&right->sampleUnits);

  (*left)->data->length=right->data->length;
  for(i=0;i<right->data->length;i++)
    {
      (*left)->data->data[i]=right->data->data[i];
    }
}

static void _assignCOMPLEX8FrequencySeries(COMPLEX8FrequencySeries **left, COMPLEX8FrequencySeries *right)
{
  UINT4 i;

  (*left)=(COMPLEX8FrequencySeries*)LALCalloc(1,sizeof(COMPLEX8FrequencySeries));
  (*left)->data=(COMPLEX8Sequence*)LALCalloc(1,sizeof(COMPLEX8Sequence));
  (*left)->data->data=(COMPLEX8*)LALCalloc(right->data->length,sizeof(COMPLEX8));

  strncpy((*left)->name,right->name,LALNameLength);
  (*left)->epoch=right->epoch;
  (*left)->f0=right->f0;
  (*left)->deltaF=right->deltaF;
  _unitCopy(&(*left)->sampleUnits,&right->sampleUnits);

  (*left)->data->length=right->data->length;
  for(i=0;i<right->data->length;i++)
    {
      (*left)->data->data[i]=right->data->data[i];
    }
}


/* wavelet copy constructor */
static void _assignWavelet(Wavelet **left,Wavelet *right)
{

  *left=(Wavelet*)LALCalloc(1,sizeof(Wavelet));
  if(*left==NULL)
    {
      fprintf(stderr,"Cannot allocate memory 9\n");
      exit(1);
    }
  (*left)->type=right->type;
  (*left)->border=right->border;
  (*left)->treeType=right->treeType;
  (*left)->level=right->level;
  (*left)->HPFilterLength=right->HPFilterLength;
  (*left)->LPFilterLength=right->LPFilterLength;
  (*left)->PForward=NULL;
  (*left)->PInverse=NULL;
  (*left)->UForward=NULL;
  (*left)->UInverse=NULL;
  (*left)->pLForward=NULL;
  (*left)->pLInverse=NULL;
  (*left)->pHForward=NULL;
  (*left)->pHInverse=NULL;
  _assignREAL4TimeSeries(&((*left)->data),right->data);
}

static void  _assignClusterWavelet(ClusterWavelet **left, ClusterWavelet *right)
{
  UINT4 i,j,M;

  
  if(right==NULL) return;
  if(*left!=NULL) _freeClusterWavelet(left);
    

  M = _getMaxLayer(right->wavelet)+1;
  _createClusterWavelet(left);
  if(right->wavelet!=NULL) _assignWavelet(&(*left)->wavelet,right->wavelet);
  if(right->original!=NULL) _assignWavelet(&(*left)->original,right->original);
  if(right->afterCalibration!=NULL) 
    _assignWavelet(&(*left)->afterCalibration,right->afterCalibration);
  /*  if(right->psd!=NULL) _assignREAL4FrequencySeries(&(*left)->psd,right->psd);*/

  (*left)->pMaskCount=right->pMaskCount;
  (*left)->clusterCount=right->clusterCount;
  (*left)->clusterCountFinal=right->clusterCountFinal;
  (*left)->clusterType=right->clusterType;
  (*left)->simulationType=right->simulationType;
  (*left)->delta_f=right->delta_f;
  (*left)->delta_t=right->delta_t;
  (*left)->nonZeroFractionAfterPercentile=right->nonZeroFractionAfterPercentile;
  (*left)->nonZeroFractionAfterCoincidence=right->nonZeroFractionAfterCoincidence;
  (*left)->nonZeroFractionAfterSetMask=right->nonZeroFractionAfterSetMask;
  (*left)->nonZeroFractionAfterClustering=right->nonZeroFractionAfterClustering;
  (*left)->nonZeroFractionAfterCuts=right->nonZeroFractionAfterCuts;
  (*left)->nonZeroFractionAfterVetoes=right->nonZeroFractionAfterVetoes;
  (*left)->pixelSwapApplied=right->pixelSwapApplied;
  (*left)->pixelMixerApplied=right->pixelMixerApplied;
  (*left)->noise_rms_flag=right->noise_rms_flag;
  (*left)->calibration_max_freq=right->calibration_max_freq;
  (*left)->nsubintervals=right->nsubintervals;
  (*left)->M=right->M;
  (*left)->nalpha=right->nalpha;
  (*left)->error=right->error;

  if(right->medians!=NULL)
    {
      (*left)->medians=(REAL4*)LALCalloc(M*right->nsubintervals,sizeof(REAL4));
      for(i=0;i<M*right->nsubintervals;i++)
	{
	  (*left)->medians[i]=right->medians[i];
	}
    }
  if(right->Rij!=NULL)
    {
      (*left)->Rij=(REAL4*)LALCalloc(M*right->nalpha,sizeof(REAL4));
      for(i=0;i<M*right->nalpha;i++)
        {
          (*left)->Rij[i]=right->Rij[i];
        }
    }
  if(right->norm50!=NULL)
    {
      (*left)->norm50=(REAL4*)LALCalloc(M*right->nsubintervals,sizeof(REAL4));
      for(i=0;i<M*right->nsubintervals;i++)
	{
	  (*left)->norm50[i]=right->norm50[i];
	}
    }
  
  if(right->norm10L!=NULL)
    {
      (*left)->norm10L=(REAL4*)LALCalloc(M,sizeof(REAL4));
      for(i=0;i<M;i++)
        {
          (*left)->norm10L[i]=right->norm10L[i];
        }
    }
  if(right->norm10R!=NULL)
    {
      (*left)->norm10R=(REAL4*)LALCalloc(M,sizeof(REAL4));
      for(i=0;i<M;i++)
        {
          (*left)->norm10R[i]=right->norm10R[i];
        }
    }
  /*
  if(right->avgPSD!=NULL)
    {
      (*left)->avgPSD=(REAL4*)LALCalloc(M,sizeof(REAL4));
      for(i=0;i<M;i++)
	{
	  (*left)->avgPSD[i]=right->avgPSD[i];
	}
    }
  */
  if(right->pMask!=NULL)
    {
      (*left)->pMask=(PixelWavelet**)LALCalloc(right->pMaskCount,sizeof(PixelWavelet*));
      for(i=0;i<right->pMaskCount;i++)
	{
	  if(right->pMask[i]!=NULL)
	    {
	      _assignPixel(&(*left)->pMask[i],right->pMask[i]);
	    }
	}
    }
  if(right->sCuts!=NULL)
    {
      (*left)->sCuts=(UINT4*)LALCalloc(right->clusterCount,sizeof(UINT4));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->sCuts[i]=right->sCuts[i];
	}
    }

  if(right->volumes!=NULL)
    {
      (*left)->volumes=(UINT4*)LALCalloc(right->clusterCount,sizeof(UINT4));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->volumes[i]=right->volumes[i];
	}
    }

  if(right->cList!=NULL)
    {
      (*left)->cList=(UINT4**)LALCalloc(right->clusterCount,sizeof(UINT4*));
      for(i=0;i<right->clusterCount;i++)
	{
	  if(right->cList[i]!=NULL)
	    {
	      (*left)->cList[i]=(UINT4*)LALCalloc(right->volumes[i],sizeof(UINT4));
	      for(j=0;j<right->volumes[i];j++)
		{
		  (*left)->cList[i][j]=right->cList[i][j];
		}
	    }
	}
    }

  if(right->coreSize!=NULL)
    {
      (*left)->coreSize=(UINT4*)LALCalloc(right->clusterCount,sizeof(UINT4));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->coreSize[i]=right->coreSize[i];
	}
    }

  if(right->correlation!=NULL)
    {
      (*left)->correlation=(REAL4*)LALCalloc(right->clusterCount,sizeof(REAL4));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->correlation[i]=right->correlation[i];
	}
    }

   if(right->likelihood!=NULL)
    {
      (*left)->likelihood=(REAL4*)LALCalloc(right->clusterCount,sizeof(REAL4));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->likelihood[i]=right->likelihood[i];
	}
    }
 
   if(right->power!=NULL)
    {
      (*left)->power=(REAL4*)LALCalloc(right->clusterCount,sizeof(REAL4));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->power[i]=right->power[i];
	}
    }
   if(right->confidence!=NULL)
     {
       (*left)->confidence=(REAL4*)LALCalloc(right->clusterCount,sizeof(REAL4));
       for(i=0;i<right->clusterCount;i++)
	 {
	   (*left)->confidence[i]=right->confidence[i];
	 }
     }
   if(right->maxAmplitude!=NULL)
     {
      (*left)->maxAmplitude=(REAL4*)LALCalloc(right->clusterCount,sizeof(REAL4));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->maxAmplitude[i]=right->maxAmplitude[i];
	}
     }

   if(right->relativeStartTime!=NULL)
     {
      (*left)->relativeStartTime=(REAL8*)LALCalloc(right->clusterCount,sizeof(REAL8));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->relativeStartTime[i]=right->relativeStartTime[i];
	}
     }

   if(right->relativeStopTime!=NULL)
     {
      (*left)->relativeStopTime=(REAL8*)LALCalloc(right->clusterCount,sizeof(REAL8));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->relativeStopTime[i]=right->relativeStopTime[i];
	}
     }
  
   if(right->centralTime!=NULL)
     {
       (*left)->centralTime=(REAL8*)LALCalloc(right->clusterCount,sizeof(REAL8));
       for(i=0;i<right->clusterCount;i++)
	 {
	   (*left)->centralTime[i]=right->centralTime[i];
	 }
     }

   if(right->centralFrequency!=NULL)
     {
       (*left)->centralFrequency=(REAL4*)LALCalloc(right->clusterCount,sizeof(REAL4));
       for(i=0;i<right->clusterCount;i++)
         {
           (*left)->centralFrequency[i]=right->centralFrequency[i];
         }
     }
                                                                                                                                                                                                                                                        
   if(right->duration!=NULL)
    {
      (*left)->duration=(REAL8*)LALCalloc(right->clusterCount,sizeof(REAL8));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->duration[i]=right->duration[i];
	}
    }

   if(right->absoluteStartTime!=NULL)
     {
      (*left)->absoluteStartTime=
	(LIGOTimeGPS*)LALCalloc(right->clusterCount,sizeof(LIGOTimeGPS));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->absoluteStartTime[i]=right->absoluteStartTime[i];
	}
     }

   if(right->absoluteStopTime!=NULL)
     {
      (*left)->absoluteStopTime=
	(LIGOTimeGPS*)LALCalloc(right->clusterCount,sizeof(LIGOTimeGPS));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->absoluteStopTime[i]=right->absoluteStopTime[i];
	}
     }

   if(right->startFrequency!=NULL)
    {
      (*left)->startFrequency=
	(REAL4*)LALCalloc(right->clusterCount,sizeof(REAL4));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->startFrequency[i]=right->startFrequency[i];
	}
    }

   if(right->stopFrequency!=NULL)
    {
      (*left)->stopFrequency=
	(REAL4*)LALCalloc(right->clusterCount,sizeof(REAL4));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->stopFrequency[i]=right->stopFrequency[i];
	}
    }

   if(right->bandwidth!=NULL)
    {
      (*left)->bandwidth=(REAL4*)LALCalloc(right->clusterCount,sizeof(REAL4));
      for(i=0;i<right->clusterCount;i++)
	{
	  (*left)->bandwidth[i]=right->bandwidth[i];
	}
    }

   if(right->noise_rms!=NULL)
     {
       (*left)->noise_rms=(REAL4*)LALCalloc(right->clusterCount,sizeof(REAL4));
       for(i=0;i<right->clusterCount;i++)
	 {
	   (*left)->noise_rms[i]=right->noise_rms[i];
	 }
     }

   if(right->blobs!=NULL)
     {
       (*left)->blobs=(ClusterBlobWavelet*)LALCalloc(right->clusterCount,sizeof(ClusterBlobWavelet));
       for(i=0;i<right->clusterCount;i++)
	 {
	   _assignBlob(&(*left)->blobs[i],&right->blobs[i]);
	 }
						     
     }

}

static void _assignBlob(ClusterBlobWavelet *left, ClusterBlobWavelet * right)
{
  UINT4 i;
  *left=*right;
  left->pBlob=(REAL4*)LALCalloc(right->time_width*right->freq_width,sizeof(REAL4));
  right->oBlob=(REAL4*)LALCalloc(right->time_width*right->freq_width,sizeof(REAL4));
  /*
  memcpy(left->pBlob, right->pBlob, right->time_width*right->freq_width*sizeof(REAL4));
  memcpy(left->oBlob, right->oBlob, right->time_width*right->freq_width*sizeof(REAL4));
  */
  for(i=0;i< right->time_width*right->freq_width;i++)
    {
      left->pBlob[i]=right->pBlob[i];
      left->oBlob[i]=right->oBlob[i];
    }
}

#if 0 /* NOT USED */
static int _nanoSeconds2steps(REAL4TimeSeries *ts, int nanoseconds)
{
  return (int)(nanoseconds*pow(10,-9)/ts->deltaT+0.0001);
}
#endif 

static double _setMask(ClusterWavelet *w, int nc, BOOLEAN aura)
{
  register int i;
  register int j;
  int x, y, L, k;
  register int* q = NULL;
  register int* p = NULL; 
  int* pp; 
  int* pm;
  PixelWavelet pix;
  REAL4TimeSeries *a;
  int ni;
  int nj;
  int n;
  int m;
  int nPixel;
  int **FT;
  int **XY;
  BOOLEAN status;
  int maxPixels;
  unsigned int *f;
  unsigned int *t;
  register unsigned int* pN;
  int nM;
  Slice S;
  Wavelet *original=w->original;
  Wavelet *afterCalibration=w->afterCalibration;
  /*  REAL4 minAmp; */

  nc--;/*minClusterSize-1*/
  
  if(w->wavelet->treeType!=BINARY) return 1.;

  ni = _getMaxLayer(w->wavelet)+1;
  nj = w->wavelet->data->data->length/ni;
  n = ni-1;
  m = nj-1;
  nPixel = 0;

  /*  printf("_setMask: before _create2DintArray(&FT,ni,nj)\n");fflush(stdout);*/
  
  status=_create2DintArray(&FT,ni,nj);

  if(!status){
    printf("Memory allocation problem\n");
    exit(1);
  }
  status=_create2DintArray(&XY,ni,nj);
  if(!status){
    printf("Memory allocation problem\n");
    exit(1);
  }

  for(i=0; i<ni; i++){
    p  = FT[i]; 
    q  = XY[i];
    _getLayer(&a, i, w->wavelet);

    for(j=0; j<nj; j++){
      p[j] = (a->data->data[j]!=0) ? 1 : 0;
      if(p[j]) nPixel++;
      q[j] = 0;
    }
    _freeREAL4TimeSeries(&a);
  }


  /*  printf("setMask: 1\n");fflush(stdout); */

  if(nc<0 || ni<3 || nPixel<2) 
    return (double)(nPixel)/((double)(w->wavelet->data->data->length));


  if(FT[0][0]) XY[0][0] = FT[0][1]   + FT[1][0]   + FT[1][1];
  if(FT[0][m]) XY[0][m] = FT[1][m]   + FT[1][m-1] + FT[0][m-1];
  if(FT[n][0]) XY[n][0] = FT[n-1][0] + FT[n-1][1] + FT[n][1];
  if(FT[n][m]) XY[n][m] = FT[n][m-1] + FT[n-1][m] + FT[n-1][m-1];
  

  for(j=1; j<m; j++){
    p  = FT[0]; 
    q  = FT[n];

    if(p[j]){
      pp = FT[1];
      XY[0][j] = p[j-1]+p[j+1] + pp[j-1]+pp[j]+pp[j+1];
    }
    if(q[j]){
      pm = FT[n-1];
      XY[n][j] = q[j-1]+q[j+1] + pm[j-1]+pm[j]+pm[j+1];
    }
  }

  for(i=1; i<n; i++){
    pm = FT[i-1]; p  = FT[i]; pp = FT[i+1]; q = XY[i];

    if(p[0]) 
      q[0] = p[1] + pm[0]+pm[1] + pp[0]+pp[1];

    if(p[m]) 
      q[m] = p[m-1] + pm[m]+pm[m-1] + pp[m]+pp[m-1];

    for(j=1; j<m; j++){
      if(p[j])
	q[j] = pm[j-1]+pm[j]+pm[j+1] + pp[j-1]+pp[j]+pp[j+1] + p[j-1]+p[j+1];
    }
  }

  /**************************************/
  /* remove clusters with 2,3 pixels  */
  /**************************************/

  if(nc>1){


    if(XY[0][0]){ 
      x = XY[0][1]   + XY[1][0]   + XY[1][1];
      if(x==1 || x==4) XY[0][0]=XY[0][1]=XY[1][0]=XY[1][1]=0;
    }
    if(XY[0][m]){ 
      x = XY[1][m]   + XY[1][m-1] + XY[0][m-1];
      if(x==1 || x==4) XY[0][m]=XY[1][m]=XY[1][m-1]=XY[0][m-1]=0;
    }
    if(XY[n][0]){ 
      x = XY[n-1][0] + XY[n-1][1] + XY[n][1];
      if(x==1 || x==4) XY[n][0]=XY[n-1][0]=XY[n-1][1]=XY[n][1]=0;
    }
    if(XY[n][m]){
      x = XY[n-1][m]   + XY[n][m-1] + XY[n-1][m-1];
      if(x==1 || x==4) XY[n][m]=XY[n-1][m]=XY[n][m-1]=XY[n-1][m-1]=0;
    }


    for(j=1; j<m; j++){
      p  = XY[0]; 
      q  = XY[n];

      if(p[j]==1 || p[j]==2){
	if(p[j-1]+p[j+1] < 4){
	  pp = XY[1];
	  L = p[j-1]+p[j+1] + pp[j];
	  x = pp[j-1] + pp[j+1] + L;
	       
	  if(x==1 || (p[j]==2 && nc>2 && (x==2 || (x==4 && L==4))))
	    p[j]=p[j-1]=p[j+1]=pp[j-1]=pp[j]=pp[j+1]=0;
	}
      }

      if(q[j]==1 || q[j]==2){
	if(q[j-1]+q[j+1] < 4){
	  pm = XY[n-1];
	  L = q[j-1]+q[j+1] + pm[j];
	  x = pm[j-1] + pm[j+1] + L;

	  if(x==1 || (q[j]==2 && nc>2 && (x==2 || (x==4 && L==4))))
	    q[j]=q[j-1]=q[j+1]=pm[j-1]=pm[j]=pm[j+1]=0;
	}
      }
    }


    for(i=1; i<n; i++){
      pm = XY[i-1];
      p  = XY[i];
      pp = XY[i+1];
	 
	 
      if(p[0]==1 || p[0]==2){ 
	if(pm[0]+pp[0] < 4){
	  L = p[1] + pm[0] + pp[0];
	  x = pm[1] + pp[1] + L;
	       
	  if(x==1 || (p[0]==2 && nc>2 && (x==2 || (x==4 && L==4))))
	    p[0]=pm[0]=pp[0]=pm[1]=pp[1]=p[1]=0;;
	}
      }

      if(p[m]==1 || p[m]==2){ 
	if(pm[m]+pp[m] < 4){
	  L = p[m-1] + pm[m] + pp[m];
	  x = pm[m-1] + pp[m-1] + L;
	       
	  if(x==1 || (p[m]==2 && nc>2 && (x==2 || (x==4 && L==4))))
	    p[m]=pm[m]=pp[m]=pm[m-1]=pp[m-1]=p[m-1]=0;
	}
      }
	 
      for(j=1; j<m; j++){
	y = p[j];
	if(y == 1 || y == 2){
	  if(pm[j]+pp[j] >3) continue;
	  if(p[j-1]+p[j+1] >3) continue;

	  L  = pm[j]+pp[j] + p[j-1]+p[j+1];
	  x  = pm[j-1]+pm[j+1] + pp[j-1]+pp[j+1] + L;
	       
	  if(x==1 || (y==2 && nc>2 && (x==2 || (x==4 && L==4))))
	    p[j]=p[j-1]=p[j+1]=pm[j-1]=pm[j]=pm[j+1]=pp[j-1]=pp[j]=pp[j+1]=0;
	}
      }
    }
  }

  L = 0;
  /*  maxPixels=(int)(w->wavelet->data->data->length*w->nonZeroFractionAfterCoincidence);*/

  maxPixels=w->wavelet->data->data->length;


  /*     printf("setMask: 2\n");fflush(stdout); */

/*    printf("nonzerofraction after coincidence: %f\n",w->nonZeroFractionAfterCoincidence); fflush(stdout); */

  w->pMask=(PixelWavelet**)LALCalloc(maxPixels,sizeof(PixelWavelet*));
  if(w->pMask==NULL)
    {
      fprintf(stderr,"Cannot allocate memory 1\n");
      exit(1);
    }
  w->pMaskCount=0;

  w->sCuts=NULL;
  w->cList=NULL;

  pix.amplitude=-1.0;
  pix.amplitudeOriginal=-1.0;
  pix.amplitudeAfterCalibration=-1.0;
  pix.clusterID = 0;     
  pix.neighborsCount=0;

  f = &pix.frequency;
  t = &pix.time;

  for(i=0; i<ni; i++){
    q  = XY[i]; p = FT[i];
    /*_getLayer(&a, i, w->wavelet);*/
    /*    minAmp = 1/pow(w->nonZeroFractionAfterPercentile,2);*/
    for(j=0;j<nj;j++)
      {
	if(q[j]){q[j]++;}
	else if(nc==0 && p[j]){q[j]++;}
	else { p[j]=0; }
      }
    /*    _freeREAL4TimeSeries(&a);*/
  }

  for(i=0; i<ni; i++){
    q  = XY[i];
    p  = FT[i];
    for(j=0; j<nj; j++){
      if(q[j]) {
	*t = j; *f = i;              
	pix.core = TRUE;             
	_pMaskPushBack(w, &pix);    
	p[j] = ++L;                 

	/*	printf("setMask: 2a\n");fflush(stdout); */

	if(aura){                 
	  pix.core = FALSE;       

/* 	  printf("i=%d j=%d ni=%d nj=%d\n",i,j,ni,nj);fflush(stdout); */

	  if(i>0 && j>0) { 
	    *t=j-1; *f=i-1; 
	    if(!FT[*f][*t]) {
	      _pMaskPushBack(w, &pix);  		    
	      FT[*f][*t] = ++L;
	    }
	  }
	  if(i>0) {
	    *t=j;   *f=i-1; 
	    if(!FT[*f][*t]) {
	      _pMaskPushBack(w, &pix);   		    
	      FT[*f][*t] = ++L;
	    }
	  }
	  if(i>0 && j<m) { 
	    *t=j+1; *f=i-1; 
	    if(!FT[*f][*t]) {
	      _pMaskPushBack(w, &pix);    		    
	      FT[*f][*t] = ++L;
	    }
	  }

	  /*	   	  printf("setMask: 2b\n");fflush(stdout); */

	  if(j>0)        { 
	    *t=j-1; *f=i;   
	    if(!FT[*f][*t]) {
	      _pMaskPushBack(w, &pix);    		    
	      FT[*f][*t] = ++L;
	    }
	  }
	  if(j<m)        { 
	    *t=j+1; *f=i;   
	    if(!FT[*f][*t]) {
	      _pMaskPushBack(w, &pix);   		    
	      FT[*f][*t] = ++L;
	    }
	  }
	  if(i<n && j>0) { 
	    *t=j-1; *f=i+1; 
	    if(!FT[*f][*t]) {
	      _pMaskPushBack(w, &pix);    		    
	      FT[*f][*t] = ++L;
	    }
	  }
	  if(i<n)        { 
	    *t=j;   *f=i+1; 
	    if(!FT[*f][*t]) {
	      _pMaskPushBack(w, &pix);    		    
	      FT[*f][*t] = ++L;
	    }
	  }

	  /*	   	  printf("setMask: 2c\n");fflush(stdout); */

	  if(i<n && j<m) { 
	    *t=j+1; *f=i+1; 
	    if(!FT[*f][*t]) {
	      _pMaskPushBack(w, &pix);   		    
	      FT[*f][*t] = ++L;
	    }
	  }

	  /*	   	  printf("setMask: 2d\n");fflush(stdout); */

	}             
      }
    }
  }

  nM = w->pMaskCount;

  /*
     printf("setMask: 3\n");fflush(stdout); 
     printf("original=%p\n", original); fflush(stdout);
     printf("original->data=%p",original->data); fflush(stdout);
     printf("original->data->data=%p\n",original->data->data);fflush(stdout);
     printf("original->data->data->data=%p\n",original->data->data->data); fflush(stdout);
  */

  for(k=0; k<nM; k++){

    i = w->pMask[k]->frequency;
    j = w->pMask[k]->time;

    _getSliceF(i,w->wavelet,&S); 
    w->pMask[k]->amplitude=-1.0;
    w->pMask[k]->amplitudeOriginal=-1.0;
    w->pMask[k]->amplitudeAfterCalibration=-1.0;
    w->pMask[k]->amplitude=w->wavelet->data->data->data[S.start+S.step*j];
    w->pMask[k]->amplitudeOriginal=original->data->data->data[S.start+S.step*j];
    w->pMask[k]->amplitudeAfterCalibration=
      afterCalibration->data->data->data[S.start+S.step*j];

    if(w->pMask[k]->amplitude>=2*w->wavelet->data->data->length-1)
      {
	w->pMask[k]->amplitude=0.0;
	w->pMask[k]->amplitudeOriginal=0.0;
	w->pMask[k]->amplitudeAfterCalibration=0.0;
	w->pMask[k]->core=FALSE;
	w->wavelet->data->data->data[S.start+S.step*j]=0.0;
	original->data->data->data[S.start+S.step*j]=0.0;
	afterCalibration->data->data->data[S.start+S.step*j]=0.0;
      }

    w->pMask[k]->neighborsCount=0;

    pN = &(w->pMask[k]->neighbors[0]);
    L = 0;

    if(i==0 || i==n){                        
      if(i==0){ p = FT[0]; q = FT[1];}
      if(i==n){ p = FT[n]; q = FT[n-1];}

      if(j==0){                             
	if(p[1]) pN[L++] = p[1];
	if(q[1]) pN[L++] = q[1];
	if(q[0]) pN[L++] = q[0];
      }
      else if(j==m){                       
	if(p[m-1]) pN[L++] = p[m-1];
	if(q[m-1]) pN[L++] = q[m-1];
	if(q[m]<0)   pN[L++] = q[m];
      }
      else{                                
	if(p[j-1]) pN[L++] = p[j-1];
	if(p[j+1]) pN[L++] = p[j+1];
	if(q[j-1]) pN[L++] = q[j-1];
	if(q[j])   pN[L++] = q[j];
	if(q[j+1]) pN[L++] = q[j+1];
      }
    }

    else{          
      pp = FT[i+1];
      p  = FT[i];
      pm = FT[i-1];

      if(j==0){                              
	if(pm[0]) pN[L++] = pm[0];
	if(pp[0]) pN[L++] = pp[0];
	if( p[1]) pN[L++] =  p[1];
	if(pm[1]) pN[L++] = pm[1];
	if(pp[1]) pN[L++] = pp[1];
      }
      else if(j==m){
	if(pm[m])   pN[L++] = pm[m];        
	if(pp[m])   pN[L++] = pp[m];
	if( p[m-1]) pN[L++] =  p[m-1];
	if(pm[m-1]) pN[L++] = pm[m-1];
	if(pp[m-1]) pN[L++] = pp[m-1];
      }
      else{
	if(pm[j-1]) pN[L++] = pm[j-1];
	if(pm[j])   pN[L++] = pm[j];
	if(pm[j+1]) pN[L++] = pm[j+1];
	if( p[j-1]) pN[L++] =  p[j-1];
	if( p[j+1]) pN[L++] =  p[j+1];
	if(pp[j-1]) pN[L++] = pp[j-1];
	if(pp[j])   pN[L++] = pp[j];
	if(pp[j+1]) pN[L++] = pp[j+1];
      }
    }

    w->pMask[k]->neighborsCount=L;

    if(!aura){
      x = XY[i][j]-1;
      
      if(/*x != L ||*/ L>8){ 
	printf("pMask size error: L=%d, x=%d, k=%d, i=%d, j=%d\n",L,x,k,i,j);
      }
    }
  }
  _destroy2DintArray(&FT,ni);
  _destroy2DintArray(&XY,ni);

  w->pMask=(PixelWavelet**)LALRealloc(w->pMask,w->pMaskCount*sizeof(PixelWavelet*));

  return (double)(w->pMaskCount+1)/(double)(w->wavelet->data->data->length);
}


static void _pMaskPushBack(ClusterWavelet *w, PixelWavelet *pix)
{
  PixelWavelet *newPix=(PixelWavelet*)LALCalloc(1,sizeof(PixelWavelet));
  if(newPix==NULL)
    {
      fprintf(stderr,"Cannot allocate memory 2\n");
      exit(1);
    }
  _copyPixel(newPix,pix);
  w->pMask[++w->pMaskCount-1]=newPix;
}

static void _copyPixel(PixelWavelet *to, PixelWavelet *from)
{
  int i;
  to->time=from->time;
  to->frequency=from->frequency;
  to->clusterID=from->clusterID;
  to->core=from->core;
  to->amplitude=from->amplitude;
  to->amplitudeOriginal=from->amplitudeOriginal;
  to->amplitudeAfterCalibration=from->amplitudeAfterCalibration;
  to->neighborsCount=from->neighborsCount;
  for(i=0;i<8;i++){
    to->neighbors[i]=from->neighbors[i];
  }
}

static void _assignPixel(PixelWavelet **to, PixelWavelet *from)
{
  if(*to!=NULL) 
    {
      LALFree(*to);
      *to=NULL;
    }
  *to=(PixelWavelet*)LALCalloc(1,sizeof(PixelWavelet));
  _copyPixel(*to,from);
}

static BOOLEAN _create2DintArray(int ***a, int n1, int n2)
{
  int i;
  BOOLEAN result=TRUE;

  *a=(int**)LALCalloc(n1,sizeof(int*));


  if(*a==NULL){ 
    fprintf(stderr,"Cannot allocate memory 3\n");
    exit(1);
  }

  for(i=0;i<n1;i++){
    (*a)[i]=(int*)LALCalloc(n2,sizeof(int));
    if((*a)[i]==NULL)
      {
	fprintf(stderr,"Cannot allocate memory 4\n");
	exit(1);
      }
  }

  return result;
}

#if 0 /* NOT USED */
static void _print2DintArray(int ***a, FILE *out, int n1, int n2)
{
  int i,j;
  for(i=0;i<n1;i++)
    {
      for(j=0;j<n2;j++)
	{
	  fprintf(out,"%d ",(*a)[i][j]);
	}
      fprintf(out,"\n");
    }
}
#endif



static void _destroy2DintArray(int ***a, int n1)
{
  int i;
  for(i=0;i<n1;i++){
    if((*a)[i]!=NULL) LALFree((*a)[i]);
    (*a)[i]=NULL;
  }
  if((*a)!=NULL) LALFree((*a));
  (*a)=NULL;
}

static int _clusterMain(ClusterWavelet *w)
{
  int volume;
  size_t i,m;
  size_t ncluster = 0;
  size_t n = w->pMaskCount;
  UINT4 k;


  w->cList=(UINT4**)LALCalloc(n,sizeof(UINT4*));
  if(w->cList==NULL)
    {
      fprintf(stderr,"Cannot allocate memory 5\n");
      exit(1);
    }
  w->sCuts=(UINT4*)LALCalloc(n,sizeof(UINT4));
  if(w->sCuts==NULL)
    {
      fprintf(stderr,"Cannot allocate memory 6\n");
      exit(1);
    }
  w->volumes=(UINT4*)LALCalloc(n,sizeof(UINT4));
  if(w->volumes==NULL)
    {
      fprintf(stderr,"Cannot allocate memory 7\n");
      exit(1);
    }

  m=0;
  for(i=0; i<n; i++){
    if(w!=NULL && w->pMask!=NULL && w->pMask[i]!=NULL && !w->pMask[i]->clusterID){
      w->pMask[i]->clusterID = ++ncluster;
      volume = _clusterR(w,i);
      w->cList[m]=(UINT4*)LALCalloc(volume,sizeof(UINT4));
      if(w->cList[m]==NULL)
	{
	  fprintf(stderr,"Cannot allocate memory 8\n");
	  exit(1);
	}
      w->volumes[m]=volume;
      w->sCuts[m]=0;
      m++;
    }
  }

  
  w->clusterCount=ncluster;

  for(k=0;k<ncluster;k++){
    m=0;
    for(i=0;i<n;i++){
      if(w->pMask[i]->clusterID==k+1)
	{
	  w->cList[k][m++]=i;
	}
    }

    if(w->volumes[k]!=m){
      fprintf(stderr,"Size mismatch: m=%d, volume=%d\n",(int)m,w->volumes[k]);
    }
  }

  return ncluster;
}

static int _clusterR(ClusterWavelet *w, int k)
{
  UINT4 i,j;
  int volume = 1;
  int ncluster;
  UINT4 n;
  UINT4 *p;

  if(w==NULL || w->pMask==NULL || w->pMask[k]==NULL  )
    {
      fprintf(stderr,"ERROR in _clusterR: something is NULL"); fflush(stderr);
      exit(1);
    }

  if(k>=(int)w->pMaskCount)
    {
      fprintf(stderr,"ERROR in _clusterR: k=%d,pMaskCount=%d\n",k,w->pMaskCount); fflush(stderr);
      exit(1);
    }

  ncluster = w->pMask[k]->clusterID;
  n = w->pMask[k]->neighborsCount;
  p = n ? &(w->pMask[k]->neighbors[0]) : NULL;

  for(i=0; i<n; i++){
    j = p[i]-1;
    if(w!=NULL && w->pMask!=NULL && w->pMask[j]!=NULL && !w->pMask[j]->clusterID){
      w->pMask[j]->clusterID = ncluster;
      volume += _clusterR(w,j);
    }
  }
  return volume;
}

static void _freeREAL4TimeSeries(REAL4TimeSeries **t)
{
  if(*t!=NULL)
    {
      if((*t)->data!=NULL)
	{
	  if((*t)->data->data!=NULL)
	    {
	      LALFree((*t)->data->data);
	      (*t)->data->data=NULL;
	    }
	  LALFree((*t)->data);
	  (*t)->data=NULL;
	}
      LALFree((*t));
      *t=NULL;
    }
}


static void _freeREAL8TimeSeries(REAL8TimeSeries **t)
{
  if(*t!=NULL)
    {
      if((*t)->data!=NULL)
        {
          if((*t)->data->data!=NULL)
            {
	      LALFree((*t)->data->data);
	      (*t)->data->data=NULL;
            }
          LALFree((*t)->data);
          (*t)->data=NULL;
	}
      LALFree((*t));
      *t=NULL;
    }
}


static void _freeREAL4FrequencySeries(REAL4FrequencySeries **psd)
{
  if(*psd!=NULL)
    {
      if((*psd)->data!=NULL && (*psd)->data->data!=NULL)
        {
          LALFree((*psd)->data->data);
          (*psd)->data->data=NULL;
        }
      if((*psd)->data!=NULL)
        {
          LALFree((*psd)->data);
          (*psd)->data=NULL;
        }
      LALFree((*psd));
      *psd=NULL;
    }
}



static void _freeCOMPLEX8FrequencySeries(COMPLEX8FrequencySeries **psd)
{
  if(*psd!=NULL)
    {
      if((*psd)->data!=NULL && (*psd)->data->data!=NULL)
	{
	  LALFree((*psd)->data->data);
	  (*psd)->data->data=NULL;
	}
      if((*psd)->data!=NULL)
	{
	  LALFree((*psd)->data);
	  (*psd)->data=NULL;
	}
      LALFree((*psd));
      *psd=NULL;
    }
}


static void _freeWavelet(Wavelet **w)
{
  if(*w!=NULL)
    {
      _freeREAL4TimeSeries(&(*w)->data);
      if((*w)->PForward!=NULL) 
	{
	  LALFree((*w)->PForward);
	  (*w)->PForward=NULL;
	}
      if((*w)->PInverse!=NULL) 
	{
	  LALFree((*w)->PInverse);
	  (*w)->PInverse=NULL;
	}
      if((*w)->UForward!=NULL) 
	{
	  LALFree((*w)->UForward);
	  (*w)->UForward=NULL;
	}
      if((*w)->UInverse!=NULL) 
	{
	  LALFree((*w)->UInverse);
	  (*w)->UInverse=NULL;
	}
      if((*w)->pLForward!=NULL) 
	{
	  LALFree((*w)->pLForward);
	  (*w)->pLForward=NULL;
	}
      if((*w)->pLInverse!=NULL) 
	{
	  LALFree((*w)->pLInverse);
	  (*w)->pLInverse=NULL;
	}
      if((*w)->pHForward!=NULL) 
	{
	  LALFree((*w)->pHForward);
	  (*w)->pHForward=NULL;
	}
      if((*w)->pHInverse!=NULL) 
	{
	  LALFree((*w)->pHInverse);
	  (*w)->pHInverse=NULL;
	}
      LALFree((*w));
      *w=NULL;
    }
}


/*  static void _freeWavelet_TS_PM(Wavelet **w) */
/*  { */
/*    UINT4 i; */
/*    for(i=0;i<(*w)->pMaskCount;i++) */
/*      { */
/*        LALFree((*w)->pMask[i]); */
/*      } */
/*    LALFree((*w)->pMask); */
/*    _freeWavelet(w); */
/*  } */

/*  static void _freeWavelet_ALL(Wavelet **w) */
/*  { */
/*    UINT4 i; */

/*    for(i=0;i<(*w)->clusterCount;i++) */
/*      { */
/*        LALFree((*w)->cList[i]); */
/*      } */
/*    LALFree((*w)->cList); */
/*    LALFree((*w)->volumes); */
/*    LALFree((*w)->sCuts); */
/*    _freeWavelet_TS_PM(w); */
/*  } */

static BOOLEAN _allocateWavelet(Wavelet **wavelet)
{
  *wavelet=(Wavelet*)LALCalloc(1,sizeof(Wavelet));
  if(*wavelet==NULL) return FALSE;
  (*wavelet)->data=(REAL4TimeSeries*)LALCalloc(1,sizeof(REAL4TimeSeries));
  if((*wavelet)->data==NULL) return FALSE;
  (*wavelet)->data->data=(REAL4Sequence*)LALCalloc(1,sizeof(REAL4Sequence));
  if((*wavelet)->data->data==NULL) return FALSE;
  (*wavelet)->PForward=NULL;
  (*wavelet)->PInverse=NULL;
  (*wavelet)->UForward=NULL;
  (*wavelet)->UInverse=NULL;
  (*wavelet)->pLForward=NULL;
  (*wavelet)->pLInverse=NULL;
  (*wavelet)->pHForward=NULL;
  (*wavelet)->pHInverse=NULL;
  return TRUE;
}

static void _freeOutPercentile(OutputPercentileWavelet **p)
{
  if(*p!=NULL)
    {
      _freeClusterWavelet(&(*p)->out);
      LALFree(*p);
      *p=NULL;
    }
}

static void _freeOutPixelSwap(OutputPixelSwapWavelet **ps)
{
  if(*ps!=NULL)
    {
      _freeClusterWavelet(&(*ps)->out);
      LALFree(*ps);
      *ps=NULL;
    }
}

static void _freeOutCoincidence(OutputCoincidenceWavelet **co)
{
  if(*co!=NULL)
    {
      _freeClusterWavelet(&(*co)->one);
      _freeClusterWavelet(&(*co)->two);
      LALFree(*co);
      *co=NULL;
    }
}

static void _freeOutPixelMixer(OutputPixelMixerWavelet **pm)
{
  if(*pm!=NULL)
    {
      _freeClusterWavelet(&(*pm)->out);
      LALFree(*pm);
      *pm=NULL;
    }
}

static void _freeOutCluster(OutputClusterWavelet **cl)
{
  /*  printf("_freeOutCluster: at the beginning\n");fflush(stdout);*/
  if(*cl!=NULL)
    {
      _freeClusterWavelet(&(*cl)->w);
      /*      printf("_freeOutCluster: after _freeClusterWavelet\n");fflush(stdout);*/
      LALFree(*cl);
      /*      printf("_freeOutCluster: after LALFree\n");fflush(stdout);*/
      *cl=NULL;
    }
}


static void _interpolate(InputPercentileWavelet  *input)
{
  static LALStatus status;
  Inputt2wWavelet in1;
  Outputt2wWavelet *out1=(Outputt2wWavelet *)LALCalloc(1,sizeof(Outputt2wWavelet));
  Inputw2tWavelet in2;
  Outputw2tWavelet *out2=(Outputw2tWavelet *)LALCalloc(1,sizeof(Outputw2tWavelet));
  INT4 i, M, j, k;
  REAL4TimeSeries *a, *b;
  REAL4 *pb, *pa;

  in1.w=input->in;
  in1.ldeep=input->int_extradeep;
  LALt2wWavelet(&status,&in1,&out1);

  M = _getMaxLayer(out1->w)+1;

  /*
  printf("-->Interpolate: M=%d, m=%d, n=%d, length=%d\n",M,input->int_m,input->int_n,
	 input->in->data->data->length);fflush(stdout);
  */
  for(i=0; i<M; i++)
    {
      /*
      printf("i=%d\n");fflush(stdout);
      */
      _getLayer(&a,i,out1->w);
      _assignREAL4TimeSeries(&b,a);
      for(k=input->int_n;
	  k<a->data->length - input->int_n;
	  k++)
	{
	  /*
	  printf("-->k=%d\n",k);fflush(stdout);
	  */
	  b->data->data[k] = 
	    _polypredict(a->data->data + k  - input->int_n, 
			 a->data->data + k, 
			 a->data->data + k + input->int_n, 
			 input->int_m);
	  /*
	  printf("predict=%f real=%f\n",b->data->data[k], a->data->data[k]);
	  fflush(stdout);
	  */
	} 
      for(j=0;j<a->data->length;j++)
	{
	  /*	  printf("-->j=%d\n",j);fflush(stdout);*/
	  a->data->data[j]-=b->data->data[j];
	}
      _putLayer(a, i, out1->w);
      _freeREAL4TimeSeries(&a);
      _freeREAL4TimeSeries(&b);
    }

  in2.w=out1->w;
  in2.ldeep=input->int_extradeep;
  LALw2tWavelet(&status,&in2,&out2);

  _freeWavelet(&input->in);
  _assignWavelet(&input->in, out2->w);
  _freeWavelet(&out1->w);
  _freeWavelet(&out2->w);
  LALFree(out1);
  LALFree(out2);

}

static REAL4 _polypredict(REAL4 *pL, REAL4 *pC, REAL4 *pR, int m)
{
  REAL4* pl, *pr;

  /*  printf("polypredict pR-pL=%d pC-pL=%d pR-pC=%d\n",pR-pL,pC-pL,pR-pC);
      fflush(stdout);
  */

  if(pL==pR) return *pL; 
  pl =  pL==pC-m ? pC+m : pL+1;
  pr =  pR==pC+m ? pC-m : pR-1;

  return ((pC-pL)*_polypredict(pl,pC,pR,m) +
	  (pR-pC)*_polypredict(pL,pC,pr,m))/(pR-pL);
}


static void _calibrate(Wavelet *in, COMPLEX8FrequencySeries *R,
		       COMPLEX8FrequencySeries *C,
		       REAL8TimeSeries *alpha, REAL8TimeSeries *gamma,
		       ClusterWavelet *w, UINT4 offset)
{
  UINT4 i, j, k, M;
  UINT4 j_start, m, m2;
  REAL4TimeSeries *a;
  COMPLEX8 one, tmp1, tmp2, tmp3;
  COMPLEX8 R0, C0;
  REAL4* pR;

  /*
  printf("_calibrate: R=%p C=%p alpha=%p gamma=%p w=%p in->data=%p\n", R, C, alpha, gamma, w, in->data);fflush(stdout);
  printf("_calibrate: R->data=%p C->data=%p alpha->data=%p gamma->data=%p in->data->data=%p\n", 
	 R->data, C->data,alpha->data, gamma->data,in->data->data);fflush(stdout);
  printf("_calibrate: R->data->data=%p C->data->data=%p alpha->data->data=%p gamma->data->data=%p in->data->data->data=%p\n", 
	 R->data->data, C->data->data, alpha->data->data, gamma->data->data,in->data->data->data);fflush(stdout);
  printf("_calibrate: R->data->length=%d C->data->length=%d alpha->data->length=%d gamma->data->length=%d in->data->data->length=%d\n",
         R->data->length, C->data->length, alpha->data->length, gamma->data->length, in->data->data->length);fflush(stdout);
  */

  _initCOMPLEX8(&one,1,0);

  M = _getMaxLayer(in)+1;

  w->M=M;
  w->nalpha = in->data->deltaT*in->data->data->length/alpha->deltaT + 0.5;

  /*
  printf("_calibrate: M=%d w->nalpha=%d in->data->data->length=%d in->data->deltaT=%f alpha->deltaT=%f\n", 
	 M, w->nalpha, in->data->data->length, in->data->deltaT, alpha->deltaT);fflush(stdout);
  */

  w->Rij=(REAL4*)LALCalloc(M*w->nalpha,sizeof(REAL4));

  for(j=0;j<alpha->data->length;j++)
    {
      if(alpha->epoch.gpsSeconds+j*alpha->deltaT >
	 in->data->epoch.gpsSeconds) break;
    }
  j_start = j;


  for(i=0;i<M;i++)
    {
      pR = &w->Rij[i*w->nalpha];
      for(j=0;j<w->nalpha;j++)
	{
          R0 = i>=R->data->length ? R->data->data[R->data->length-1] : R->data->data[i];
          C0 = i>=C->data->length ? C->data->data[C->data->length-1] : C->data->data[i];
	  
          _multiplyCOMPLEX8(&R0, &C0, &tmp1);
          _minusCOMPLEX8(&tmp1,&one,&tmp2);
          _initCOMPLEX8(&tmp3,gamma->data->data[j+j_start],0);
          _multiplyCOMPLEX8(&tmp3,&tmp2,&tmp1);
          _plusCOMPLEX8(&tmp1,&one,&tmp2);
	  
	  
	  if(j+j_start>=alpha->data->length)
	    {
	      printf("_calibrate: j+j_start=%d\n"); fflush(stdout);
	      exit(5);
	    }
	  
          if(alpha->data->data[j+j_start]==0.0)
	    {
	      w->error=ZERO_ALPHA_ERROR;
	      alpha->data->data[j+j_start]=1.0;
	    }
          if(C0.re==0.0 && C0.im==0.0)
	    {
	      w->error=ZERO_C_ERROR;
	      C0.re=1.0;
	    }
	  
	  
          _initCOMPLEX8(&tmp3,alpha->data->data[j+j_start],0);
          _multiplyCOMPLEX8(&tmp3, &C0, &tmp1);
          _divideCOMPLEX8(&tmp2,&tmp1,&tmp3);
	  
          pR[j] = _normCOMPLEX8(&tmp3)*pow(10,20);
	  
	}
            
      _getLayer(&a,i,in);
      
      m = a->data->length/w->nalpha;
      m2 = m/2;


      for(j=0;j<a->data->length;j++)
	{
	  k = (j+m2)/m; 
	  
	  if(k==0) a->data->data[j] *= pR[0];
	  else if(k >= w->nalpha) a->data->data[j] *= pR[w->nalpha - 1];  
	  else a->data->data[j] *= pR[k] - 
		 ((REAL4)(j)-(REAL4)(k*m+m2))*(pR[k-1]-pR[k])/m;
	}

      _putLayer(a, i, in);
      _freeREAL4TimeSeries(&a);
    }
}


static void _initCOMPLEX8(COMPLEX8 *n, REAL4 a, REAL4 b)
{
  n->re=a;
  n->im=b;
}

static void _plusCOMPLEX8(COMPLEX8 *one, COMPLEX8 *two, COMPLEX8 *result)
{
  result->re=one->re + two->re;
  result->im=one->im + two->im;
}

static void _minusCOMPLEX8(COMPLEX8 *one, COMPLEX8 *two,COMPLEX8 *result)
{
  result->re=one->re - two->re;
  result->im=one->im - two->im;
}

static void _multiplyCOMPLEX8(COMPLEX8 *one, COMPLEX8 *two,COMPLEX8 *result)
{
  result->re=one->re*two->re - one->im*two->im;
  result->im=one->im*two->re + one->re*two->im;
}

static void _divideCOMPLEX8(COMPLEX8 *one, COMPLEX8 *two,COMPLEX8 *result)
{
  result->re=(one->re*two->re + one->im*two->im)/(two->re*two->re + two->im*two->im);
  result->im=(one->im*two->re - one->re*two->im)/(two->re*two->re + two->im*two->im);
}

static REAL4 _normCOMPLEX8(COMPLEX8 *one)
{
  return sqrt(one->re*one->re + one->im*one->im);
}


static void _whiteAlone(Wavelet *wavelet, 
			REAL4 **median,
			REAL4 **norm50, UINT4 k, UINT4 offset)
{
  INT4 i, M;
  REAL4TimeSeries *a;

  M = _getMaxLayer(wavelet)+1;

  *median=(REAL4*)LALCalloc(M*k,sizeof(REAL4));
  *norm50=(REAL4*)LALCalloc(M*k,sizeof(REAL4));

  for(i=0; i<M; i++)
    {
      _getLayer(&a,i,wavelet);
      _white(k,a,*norm50+i*k,*median+i*k,offset);
      _putLayer(a, i, wavelet);
      _freeREAL4TimeSeries(&a);
    }
}


static int _white(UINT4 k, REAL4TimeSeries *data, REAL4 *norm50, 
		  REAL4 *median, UINT4 offset)
{
  UINT4 i,j;
  UINT4 n=data->data->length;
  UINT4 noffset = (UINT4)(offset/data->deltaT+0.5); 
  UINT4 m=(n-2*noffset)/k;                         
  UINT4 m2=m/2+noffset;                            
  REAL4 **aptr;
  REAL4 *p;
  REAL4 a,b;
  UINT4 mL, mR;

  mL=0.1565*m+0.5;
  mR=m-mL;

  /*  printf("_white: n=%d m=%d m2=%d mL=%d mR=%d\n",n,m,m2,mL,mR);fflush(stdout);*/

  if(m>0)
    {
      aptr=(REAL4**)calloc(m,sizeof(REAL4*));
    }
  else
    {
      
      fprintf(stderr,"_white: m=%d\n",m);
      exit(1);
    }

  for(j=0;j<k;j++)
    {
      for(i=0;i<m;i++)
	{
	  if(i + j*m >= data->data->length)
	    {
	      fprintf(stderr,"_white i+j*m=%d i=%d, j=%d, m=%d\n",i+j*m,i,j,m);
	      exit(1);
	    }
	  aptr[i]=data->data->data + i + j*m + noffset; 
	}
      qsort(aptr, m, sizeof(REAL4*),_compare);
      median[j]=*aptr[m/2];                             
      norm50[j]=(*(aptr[mR]) - *(aptr[mL]))/2.;
      if(norm50[j]==0)
	{
	  fprintf(stderr,"_white: norm50=0\n"); fflush(stderr);
	  exit(1);
	}
    }

  for(i=0;i<m2;i++)
    {
      data->data->data[i]= (data->data->data[i]-median[0])/norm50[0];
    }

  for(j=0;j<k-1;j++)
    {
      for(i=0;i<m;i++)
	{
	  a=(median[j+1]*i+median[j]*(m-i))/m;
	  b=(norm50[j+1]*i+norm50[j]*(m-i))/m;
	  p=data->data->data + i + m2 + j*m;

	  if(i + j*m + m2 >= data->data->length)
	    {
	      fprintf(stderr,"_white i+j*m+m2=%d i=%d, j=%d, m=%d m2=%d\n",
		      i+j*m,i,j,m,m2);
	      exit(1);
	    }

	  *p=(*p-a)/b;
	}
    }

  for(i=n-m2;i<n;i++)
    {
      data->data->data[i]=(data->data->data[i]-median[k-1])/norm50[k-1];
    }

  free(aptr);
  return 0;
}


static void _waveFilter(Wavelet **in, ClusterWavelet *w, UINT4 offset, UINT4 extradeep,
			UINT4 wf_LPFilterLength, UINT4 wf_HPFilterLength)
{
  static LALStatus status;
  Inputt2wWavelet in1;
  Outputt2wWavelet *out1=(Outputt2wWavelet *)LALCalloc(1,sizeof(Outputt2wWavelet));
  Inputw2tWavelet in2;
  Outputw2tWavelet *out2=(Outputw2tWavelet *)LALCalloc(1,sizeof(Outputw2tWavelet));
  UINT4 M, i, j;
  REAL4 *rms=NULL;
  REAL4 norm;
  REAL4TimeSeries *a;
  UINT4 split;
  UINT4 oldLPFilterLength=(*in)->LPFilterLength;
  UINT4 oldHPFilterLength=(*in)->HPFilterLength;

  (*in)->LPFilterLength=wf_LPFilterLength;
  (*in)->HPFilterLength=wf_HPFilterLength;

  in1.w=*in;
  in1.ldeep=extradeep;

  LALt2wWavelet(&status,&in1,&out1);

  M=_getMaxLayer(out1->w)+1;
  split=1<<extradeep;

  rms=(REAL4*)LALCalloc(M,sizeof(REAL4));

  for(i=0;i<M;i++)
    {
      _getLayer(&a, i, out1->w);
      rms[i]=_computeRMS(a,offset);

      for(j=0;j<a->data->length;j++)
	{
	  a->data->data[j]/=rms[i];
	}

      _putLayer(a, i, out1->w);
      _freeREAL4TimeSeries(&a);
    }
  
  in2.w=out1->w;
  in2.ldeep=extradeep;
  LALw2tWavelet(&status,&in2,&out2);

  M=_getMaxLayer(out2->w)+1;

  for(i=0;i<M;i++)
    {
      norm=0.0;
      for(j=0;j<split;j++)
	{
	  norm+=1/pow(rms[i*split+j],2);
	}
      norm=sqrt(split/norm);

      for(j=0;j<w->nsubintervals;j++)
	{
	  w->norm50[i*w->nsubintervals+j]*=norm;
	}
    }

  _freeWavelet(in);
  _assignWavelet(in,out2->w);
  LALFree(rms);
  _freeWavelet(&out1->w);
  _freeWavelet(&out2->w);
  LALFree(out1);
  LALFree(out2);
  (*in)->LPFilterLength=oldLPFilterLength;
  (*in)->HPFilterLength=oldHPFilterLength;                                                                                                                            
}

static REAL4 _computeRMS(REAL4TimeSeries *a, UINT4 offset)
{
  REAL4 result;
  REAL4 **aptr;
  UINT4 noffset=(UINT4)(offset/a->deltaT + 0.5);
  UINT4 m=a->data->length-2*noffset;
  UINT4 mL, mR;
  UINT4 i;
  REAL4 median;

  aptr=(REAL4**)LALCalloc(m,sizeof(REAL4*));
  for(i=0;i<m;i++)
    {
      aptr[i]=a->data->data+i+noffset;
    }
  qsort(aptr, m, sizeof(REAL4*),_compare);
  mL=0.1565*m+0.5;
  mR=m-mL;
  result=(*(aptr[mR]) - *(aptr[mL]))/2.;
  median=*aptr[m/2];

  LALFree(aptr);
  return result;
}

static double _percentile(Wavelet *wavelet, double nonZeroFraction, 
			  BOOLEAN keepAmplitudes, 
			  REAL4 **norm10L, REAL4 **norm10R)
{

  INT4 i, j, M, nS, mS, boundaryL, boundaryR;
  REAL4TimeSeries *a;
  REAL4 **aPtr, **bPtr;
  REAL4 x;

  M = _getMaxLayer(wavelet)+1;
  nS=wavelet->data->data->length/M;
  boundaryL=nonZeroFraction*nS/2+0.5;
  boundaryR=nS-boundaryL;

  mS = 2*boundaryL;

  /*
  printf("_percentile: M=%d, length=%d, nS=%d boundaryL=%d boundaryR=%d mS=%d\n",
	 M, wavelet->data->data->length, nS, boundaryL, boundaryR, mS);fflush(stdout);
  */

  aPtr=(REAL4**)LALCalloc(nS,sizeof(REAL4*));
  bPtr=(REAL4**)LALCalloc(mS,sizeof(REAL4*));

  *norm10L=(REAL4*)LALCalloc(M,sizeof(REAL4));
  *norm10R=(REAL4*)LALCalloc(M,sizeof(REAL4));

  for(i=0; i<M; i++){
    _getLayer(&a,i,wavelet);

    for(j=0;j<nS;j++){
      aPtr[j]=a->data->data+j;
    }

    qsort(aPtr,nS,sizeof(REAL4*),_compare);

    (*norm10L)[i]=-*aPtr[boundaryL];
    (*norm10R)[i]=*aPtr[boundaryR];
    
    for(j=boundaryL;j<boundaryR;j++)
      {
	*aPtr[j]=0.0;
      }
    for(j=0;j<boundaryL;j++)
      {
	*aPtr[j]+=(*norm10L)[i];
	if(j>=mS || j<0)
	  {
	    fprintf(stderr,"_percentile 1: j=%d, mS=%d\n",j,mS);
	    exit(1);
	  }
	bPtr[j] = aPtr[j];
      }
    for(j=boundaryR;j<nS;j++)
      {
	*aPtr[j]-=(*norm10R)[i];
	if(j-boundaryR+boundaryL>=mS || j-boundaryR+boundaryL<0)
	  {
	    fprintf(stderr,"_percentile 1: j=%d, mS=%d\n",j,mS);
	    exit(1);
	  }
	bPtr[j-boundaryR+boundaryL] = aPtr[j];
      }

    qsort(bPtr,mS,sizeof(REAL4*),_compareAbs);

    for(j=0;j<mS;j++)
      {
	x=log(((REAL4)mS)/((REAL4)mS-j));
	*bPtr[j] = *bPtr[j]>0 ? x : -x;
      }

    _putLayer(a, i, wavelet);
    _freeREAL4TimeSeries(&a);
  }

  _getLayer(&a,0,wavelet);
  bzero(a->data->data, a->data->length*sizeof(REAL4));
  _putLayer(a,0,wavelet);
  _freeREAL4TimeSeries(&a);
  LALFree(aPtr);
  aPtr=NULL;
  LALFree(bPtr);
  bPtr=NULL;
  return nonZeroFraction;
}

static int _compare(const void *a, const void *b)
{
  REAL4 **A=(REAL4 **)a;
  REAL4 **B=(REAL4 **)b;
  if(**A < **B) return -1;
  if(**A == **B) return 0;
  if(**A > **B) return 1;
  return -2;
}

static int _compareAbs(const void *a, const void *b)
{
  REAL4 **A=(REAL4 **)a;
  REAL4 **B=(REAL4 **)b;

  REAL4 AA=fabs(**A);
  REAL4 BB=fabs(**B);

  if(AA < BB) return -1;
  if(AA == BB) return 0;
  if(AA > BB) return 1;
  return -2;
  
}

static void _clusterProperties(ClusterWavelet *w)
{
  UINT4 i, j, f, ff, t, count;
  double a,b;
  double delta_t, delta_f;
  double x;
  UINT4 N,M,min,max;
  Slice s;
  UINT4 time_steps_in_layer, time_steps_in_sublayer;

  delta_t=w->wavelet->data->deltaT*(1<<w->wavelet->level);
  delta_f=1/w->wavelet->data->deltaT/(1<<w->wavelet->level)/2.;
  N=w->wavelet->data->data->length/(1<<w->wavelet->level);
  w->delta_t=delta_t;
  w->delta_f=delta_f;

  /* printf("delta_f=%g\n",delta_f);*/


  M = _getMaxLayer(w->wavelet)+1;
  time_steps_in_layer=w->wavelet->data->data->length/M;
  time_steps_in_sublayer=time_steps_in_layer/w->nsubintervals;

  /*
  printf("norm50=\n");
  for(i=0;i<M*w->nsubintervals;i++)
    {
      printf("%f ",w->norm50[i]);
    }
  printf("\n");fflush(stdout);
  */
  
  /*
  if(w->noise_rms_flag)
    {
      w->avgPSD=(REAL4*)LALCalloc(M,sizeof(REAL4));
      for(i=0;i<M;i++)
	{
	  w->avgPSD[i]=0.0;
	  count=0;
	  min=(int)(i*delta_f/w->psd->deltaF);
	  if(min==0) min++;
	  max=(int)((i+1)*delta_f/w->psd->deltaF);
	  if(max<w->psd->data->length)
	    {
	      for(j=min;j<max;j++)
		{
		  count++;
		  w->avgPSD[i]+=w->psd->data->data[j];
		}
	      if(count!=0) w->avgPSD[i] /= count;
	    }
	  else
	    {
	      w->avgPSD[i]=w->avgPSD[i-1];
	    }
	}
    }
  */

  if(w->coreSize!=NULL) 
    {
      LALFree(w->coreSize);
      w->coreSize=NULL;
    }
  if(w->correlation!=NULL) 
    {
      LALFree(w->correlation);
      w->correlation=NULL;
    }
  if(w->likelihood!=NULL) 
    {
      LALFree(w->likelihood);
      w->likelihood=NULL;
    }
  if(w->power!=NULL) 
    {
      LALFree(w->power);
      w->power=NULL;
    }
  if(w->confidence!=NULL) 
    {
      LALFree(w->confidence);
      w->confidence=NULL;
    }
  if(w->maxAmplitude!=NULL) 
    {
      LALFree(w->maxAmplitude);
      w->maxAmplitude=NULL;
    }
  if(w->relativeStartTime!=NULL) 
    {
      LALFree(w->relativeStartTime);
      w->relativeStartTime=NULL;
    }
  if(w->relativeStopTime!=NULL) 
    {
      LALFree(w->relativeStopTime);
      w->relativeStopTime=NULL;
    }
  if(w->centralTime!=NULL)
    {
      LALFree(w->centralTime);
      w->centralTime=NULL;
    }
  if(w->centralFrequency!=NULL)
    {
      LALFree(w->centralFrequency);
      w->centralFrequency=NULL;
    }                                                                                                                           
  if(w->duration!=NULL)  
    {
      LALFree(w->duration);
      w->duration=NULL;
    }
  if(w->absoluteStartTime!=NULL) 
    {
      LALFree(w->absoluteStartTime);
      w->absoluteStartTime=NULL;
    }
  if(w->absoluteStopTime!=NULL) 
    {
      LALFree(w->absoluteStopTime);
      w->absoluteStopTime=NULL;
    }
  if(w->startFrequency!=NULL) 
    {
      LALFree(w->startFrequency);
      w->startFrequency=NULL;
    }
  if(w->stopFrequency!=NULL) 
    {
      LALFree(w->stopFrequency);
      w->stopFrequency=NULL;
    }
  if(w->bandwidth!=NULL) 
    {
      LALFree(w->bandwidth);
      w->bandwidth=NULL;
    }
  if(w->noise_rms!=NULL) 
    {
      LALFree(w->noise_rms);
      w->noise_rms=NULL;
    }
  if(w->blobs!=NULL)
    {
      for(i=0;i<w->clusterCount;i++)
	{
	  if(w->blobs[i].pBlob!=NULL) 
	    {
	      LALFree(w->blobs[i].pBlob);
	      w->blobs[i].pBlob=NULL;
	    }
	  if(w->blobs[i].oBlob!=NULL) 
	    {
	      LALFree(w->blobs[i].oBlob);
	      w->blobs[i].oBlob=NULL;
	    }
	}
      LALFree(w->blobs);
      w->blobs=NULL;
    }

  w->coreSize=(UINT4*)LALCalloc(w->clusterCount,sizeof(UINT4));
  w->correlation=(REAL4*)LALCalloc(w->clusterCount,sizeof(REAL4));
  w->likelihood=(REAL4*)LALCalloc(w->clusterCount,sizeof(REAL4));
  w->power=(REAL4*)LALCalloc(w->clusterCount,sizeof(REAL4));
  w->confidence=(REAL4*)LALCalloc(w->clusterCount,sizeof(REAL4));
  w->maxAmplitude=(REAL4*)LALCalloc(w->clusterCount,sizeof(REAL4));
  w->relativeStartTime=(REAL8*)LALCalloc(w->clusterCount,sizeof(REAL8));
  w->relativeStopTime=(REAL8*)LALCalloc(w->clusterCount,sizeof(REAL8));
  w->centralTime=(REAL8*)LALCalloc(w->clusterCount,sizeof(REAL8));
  w->centralFrequency=(REAL4*)LALCalloc(w->clusterCount,sizeof(REAL4));
  w->absoluteStartTime=(LIGOTimeGPS*)LALCalloc(w->clusterCount,sizeof(LIGOTimeGPS));
  w->absoluteStopTime=(LIGOTimeGPS*)LALCalloc(w->clusterCount,sizeof(LIGOTimeGPS));
  w->duration=(REAL8*)LALCalloc(w->clusterCount,sizeof(REAL8));
  w->startFrequency=(REAL4*)LALCalloc(w->clusterCount,sizeof(REAL4));
  w->stopFrequency=(REAL4*)LALCalloc(w->clusterCount,sizeof(REAL4));
  w->bandwidth=(REAL4*)LALCalloc(w->clusterCount,sizeof(REAL4));
  w->noise_rms=(REAL4*)LALCalloc(w->clusterCount,sizeof(REAL4));
  w->blobs=(ClusterBlobWavelet*)LALCalloc(w->clusterCount,sizeof(ClusterBlobWavelet));

  for(i=0;i<w->clusterCount;i++)
    {
      REAL8 weight=0.0;
      w->coreSize[i]=0;
      w->correlation[i]=0.0;
      w->likelihood[i]=0.0;
      w->power[i]=0.0;
      w->confidence[i]=0.0;
      w->maxAmplitude[i]=0.0;
      w->relativeStartTime[i]=N*delta_t;
      w->relativeStopTime[i]=0.0;
      w->centralTime[i]=0.0;
      w->centralFrequency[i]=0.0;
      w->startFrequency[i]=((REAL4)w->wavelet->data->data->length)/((REAL4)2.0);
      w->stopFrequency[i]=0.0;

      for(j=0;j<w->volumes[i];j++)
	{
	  if(w->pMask[w->cList[i][j]]->core) 
	    {
	      w->coreSize[i]++;
	      a=w->pMask[w->cList[i][j]]->amplitude;
	      b=w->pMask[w->cList[i][j]]->amplitudeOriginal;
	      if(a>0) w->correlation[i]++;
	      if(a<0) w->correlation[i]--;
	      w->likelihood[i]+=fabs(a);
	      w->power[i]+=b*b;
	      if(b<0)
		{
		  w->confidence[i]+=b*b - 
		    w->norm10L[w->pMask[w->cList[i][j]]->frequency]*
		    w->norm10L[w->pMask[w->cList[i][j]]->frequency];
		}
	      else
		{
		  w->confidence[i]+=b*b -
		    w->norm10R[w->pMask[w->cList[i][j]]->frequency]*
		    w->norm10R[w->pMask[w->cList[i][j]]->frequency];
		}

	      if(w->maxAmplitude[i]<fabs(a)) w->maxAmplitude[i]=fabs(a);

	      f=w->pMask[w->cList[i][j]]->frequency;
	      _getSliceF(f,w->wavelet,&s);
	      ff=s.size/N;

	      t=w->pMask[w->cList[i][j]]->time/((double)ff);
	      x=delta_t*t;
	      if(x<w->relativeStartTime[i]) 
		{
		  w->relativeStartTime[i]=x;
		  w->blobs[i].start_time_indx=t;
		}
	      if(x>w->relativeStopTime[i])
		{
		  w->relativeStopTime[i]=x;
		  w->blobs[i].stop_time_indx=t;
		}
	      w->centralTime[i]+=x*b*b;
	      weight+=b*b;
	      x=delta_f*f*ff;
	      w->centralFrequency[i]+=x*b*b;
	      if(x<w->startFrequency[i]) 
		{
		  w->startFrequency[i]=x;
		  w->blobs[i].start_freq_indx=f*ff;
		}
	      if(x>w->stopFrequency[i]) 
		{
		  w->stopFrequency[i]=x;
		  w->blobs[i].stop_freq_indx=f*ff;
		}
	    }
	}

      if(weight>0)
	{
	  w->centralTime[i]/=weight;
	  w->centralFrequency[i]/=weight;
	  /*
	  printf("ct=%e cf=%e\n",w->centralTime[i],w->centralFrequency[i]);
	  */
	  w->centralTime[i]+=delta_t/2;
	  w->centralFrequency[i]+=delta_f*ff/2;
	  /*
	  printf("ctd=%e cfd=%e\n",w->centralTime[i],w->centralFrequency[i]);
	  */
	  w->centralTime[i]+=_secNanToDouble(w->wavelet->data->epoch.gpsSeconds,
					     w->wavelet->data->epoch.gpsNanoSeconds);
	  /*
	  printf("ctda=%e\n",w->centralTime[i]);
	  fflush(stdout);
	  */
	}

      w->blobs[i].time_width = w->blobs[i].stop_time_indx - 
	w->blobs[i].start_time_indx + 1;

      w->blobs[i].freq_width = w->blobs[i].stop_freq_indx -
	w->blobs[i].start_freq_indx + 1;

      w->blobs[i].pBlob = 
	(REAL4*)LALCalloc(w->blobs[i].time_width*w->blobs[i].freq_width,
			  sizeof(REAL4));
      w->blobs[i].oBlob =
	(REAL4*)LALCalloc(w->blobs[i].time_width*w->blobs[i].freq_width,
			  sizeof(REAL4));

      for(j=0;j<w->volumes[i];j++)
	{
	  if(w->pMask[w->cList[i][j]]->core) 
	    {
	      INT4 bindex=(w->pMask[w->cList[i][j]]->frequency - w->blobs[i].start_freq_indx) *
		w->blobs[i].time_width + (w->pMask[w->cList[i][j]]->time -w->blobs[i].start_time_indx );

	      if(bindex<0 || ((UINT4)bindex) >=w->blobs[i].time_width*w->blobs[i].freq_width)
		{
		  fprintf(stderr,"Blob's index is out of range\n");fflush(stderr);
		  exit(1);
		}

	      w->blobs[i].pBlob[bindex] = 
		w->pMask[w->cList[i][j]]->amplitude;
	      w->blobs[i].oBlob[bindex] = 
		w->pMask[w->cList[i][j]]->amplitudeAfterCalibration;
	    }
	}

      /*      w->likelihood[i]/=w->coreSize[i];*/
      if(w->coreSize[i]) w->correlation[i]/=w->coreSize[i];
      if(w->coreSize[i]) w->power[i]/=w->coreSize[i];
      w->confidence[i]/=sqrt(3);

      x=_secNanToDouble(w->wavelet->data->epoch.gpsSeconds, 
			w->wavelet->data->epoch.gpsNanoSeconds) + 
	w->relativeStartTime[i];
      _doubleToSecNan(x, &w->absoluteStartTime[i].gpsSeconds, 
		      &w->absoluteStartTime[i].gpsNanoSeconds);

      x=_secNanToDouble(w->wavelet->data->epoch.gpsSeconds, 
			w->wavelet->data->epoch.gpsNanoSeconds) + 
	w->relativeStopTime[i];
      _doubleToSecNan(x, &w->absoluteStopTime[i].gpsSeconds, 
		      &w->absoluteStopTime[i].gpsNanoSeconds);

      w->duration[i]=w->relativeStopTime[i] - w->relativeStartTime[i] + delta_t;
      w->bandwidth[i]=w->stopFrequency[i] - w->startFrequency[i] + delta_f;

      if(w->noise_rms_flag) w->noise_rms[i]=_noise(w,i,time_steps_in_sublayer);
    }
}

static REAL4 _noise(ClusterWavelet *w, INT4 number, INT4 time_steps_in_sublayer)
{
  REAL4 noise=0.0;
  UINT4 i;
  UINT4 freq, gtime;
  UINT4 gindex;

  for(i=0;i<w->volumes[number];i++)
    {
      freq=w->pMask[w->cList[number][i]]->frequency;
      gtime=w->pMask[w->cList[number][i]]->time;
      gindex=freq*w->nsubintervals + gtime/time_steps_in_sublayer;

      if(gindex>=w->pMaskCount)
	{
	  fprintf(stderr,"_noise: gindex=%d pMaskCount=%d\n",gindex,w->pMaskCount);
	  exit(1);
	}

      if(w->pMask[w->cList[number][i]]->core && freq!=0)
	{
	  noise+=1/(w->norm50[gindex]*w->norm50[gindex]);
	}
    }

  return 1/sqrt(noise/w->coreSize[number]);
}

static void _doubleToSecNan(double t, INT4 *sec, INT4 *nan)
{
  *sec=(INT4)t;
  *nan=(INT4)((t-*sec)*pow(10,9));
}

static double _secNanToDouble(UINT4 sec, UINT4 nan)
{
  double t= ((double)sec + (double)nan/pow(10,9));
  return t;
}

static void _createClusterWavelet(ClusterWavelet **w)
{
  *w=(ClusterWavelet*)LALCalloc(1,sizeof(ClusterWavelet));
  (*w)->wavelet=NULL;
  (*w)->original=NULL;
  (*w)->afterCalibration=NULL;
  /*  (*w)->psd=NULL;*/
  (*w)->medians=NULL;
  (*w)->norm50=NULL;
  (*w)->Rij=NULL;
  (*w)->norm10L=NULL;
  (*w)->norm10R=NULL;
  /*  (*w)->avgPSD=NULL;*/
  (*w)->pMaskCount=0;
  (*w)->clusterCount=0;
  (*w)->clusterCountFinal=0;
  (*w)->clusterType=ORIGINAL_CL;
  (*w)->simulationType=0;
  (*w)->pMask=NULL;
  (*w)->sCuts=NULL;  
  (*w)->cList=NULL;
  (*w)->volumes=NULL;
  (*w)->coreSize=NULL;
  (*w)->correlation=NULL;
  (*w)->likelihood=NULL;
  (*w)->power=NULL;
  (*w)->confidence=NULL;
  (*w)->maxAmplitude=NULL;
  (*w)->relativeStartTime=NULL;
  (*w)->relativeStopTime=NULL;
  (*w)->centralTime=NULL;
  (*w)->centralFrequency=NULL;
  (*w)->duration=NULL;
  (*w)->absoluteStartTime=NULL;
  (*w)->absoluteStopTime=NULL;
  (*w)->startFrequency=NULL;
  (*w)->stopFrequency=NULL;
  (*w)->bandwidth=NULL;
  (*w)->noise_rms=NULL;
  (*w)->noise_rms_flag=FALSE;
  (*w)->calibration_max_freq=-1.0;
  (*w)->nonZeroFractionAfterPercentile=-1.0;
  (*w)->nonZeroFractionAfterCoincidence=-1.0;
  (*w)->nonZeroFractionAfterSetMask=-1.0;
  (*w)->nonZeroFractionAfterClustering=-1.0;
  (*w)->nonZeroFractionAfterCuts=-1.0;
  (*w)->nonZeroFractionAfterVetoes=-1.0;
  (*w)->pixelSwapApplied=FALSE;
  (*w)->pixelMixerApplied=FALSE;
  (*w)->clusterType=0;
  (*w)->blobs=NULL;
  (*w)->delta_t=1.0;
  (*w)->delta_f=1.0;
  (*w)->nsubintervals=1;
  (*w)->M=0;
  (*w)->nalpha;
  (*w)->error=NO_ERRORS;
}


static void _freeClusterWavelet(ClusterWavelet **w)
{
  UINT4 i;
  /*printf("_freeClusterWavelet 0\n");fflush(stdout);*/
  if(*w!=NULL)
    {
      if((*w)->wavelet!=NULL)
	{
	  /*printf("_freeClusterWavelet 1-1\n");fflush(stdout);*/
	  _freeWavelet(&(*w)->wavelet);
	  /*printf("_freeClusterWavelet 1\n");fflush(stdout);*/
	  (*w)->wavelet=NULL;
	}
      if((*w)->original!=NULL)
	{
	  /*printf("_freeClusterWavelet 2-1\n");fflush(stdout);*/
	  _freeWavelet(&(*w)->original);
	  /*printf("_freeClusterWavelet 2\n");fflush(stdout);*/
	  (*w)->original=NULL;
	}
      if((*w)->afterCalibration!=NULL)
        {
	  _freeWavelet(&(*w)->afterCalibration);
	  (*w)->afterCalibration=NULL;
        }
      /*
      if((*w)->psd!=NULL)
	{
	  _freeREAL4FrequencySeries(&(*w)->psd);
	  (*w)->psd=NULL;
	}
      */
      if((*w)->medians!=NULL)
	{
	  /*printf("_freeClusterWavelet 4-1\n");fflush(stdout);*/
	  /*printf("medians=%p\n",(*w)->medians);fflush(stdout);*/
	  LALFree((*w)->medians);
	  /*printf("_freeClusterWavelet 4\n");fflush(stdout);*/
	  (*w)->medians=NULL;
	}
      if((*w)->norm50!=NULL)
	{
	  /*printf("_freeClusterWavelet 5-1\n");fflush(stdout);*/
	  LALFree((*w)->norm50);
	  /*printf("_freeClusterWavelet 5\n");fflush(stdout);*/
	  (*w)->norm50=NULL;
	}
      if((*w)->Rij!=NULL)
        {
          LALFree((*w)->Rij);
	  (*w)->Rij=NULL;
        }
      if((*w)->norm10L!=NULL)
	{
	  /*printf("_freeClusterWavelet 6-1\n");fflush(stdout);*/
	  LALFree((*w)->norm10L);
	  /*printf("_freeClusterWavelet 6\n");fflush(stdout);*/
	  (*w)->norm10L=NULL;
	}
      if((*w)->norm10R!=NULL)
        {
	  /*printf("_freeClusterWavelet 7-1\n");fflush(stdout);*/
          LALFree((*w)->norm10R);
	  /*printf("_freeClusterWavelet 7\n");fflush(stdout);*/
          (*w)->norm10R=NULL;
        }
      /*
      if((*w)->avgPSD!=NULL)
	{
	  LALFree((*w)->avgPSD);
	  (*w)->avgPSD=NULL;
	}
      */
      if((*w)->pMask!=NULL)
	{
	  /*	  printf("freeClusterWavelet 9-1\n");fflush(stdout);*/
	  for(i=0;i<(*w)->pMaskCount;i++)
	    {
	      if((*w)->pMask[i]!=NULL)
		{
		  /* printf("pMaskCount=%d i=%d (*w)->pMask[i]=%p\n",(*w)->pMaskCount, i, (*w)->pMask[i]);fflush(stdout); */
		  LALFree((*w)->pMask[i]);
		  /* printf("after freeing (*w)->pMask[i]");fflush(stdout);*/
		  (*w)->pMask[i]=NULL;
		}
	    }
	  /*printf("_freeClusterWavelet 9\n");fflush(stdout);*/
	  LALFree((*w)->pMask);
	  (*w)->pMask=NULL;
	}
      if((*w)->sCuts!=NULL)
	{
	  /*printf("_freeClusterWavelet 10-1\n");fflush(stdout);*/
	  LALFree((*w)->sCuts);
	  /*printf("_freeClusterWavelet 10\n");fflush(stdout);*/
	  (*w)->sCuts=NULL;
	}
      if((*w)->cList!=NULL)
	{
	  /*printf("_freeClusterWavelet 11-1\n");fflush(stdout);*/
	  for(i=0;i<(*w)->clusterCount;i++)
	    {
	      if((*w)->cList[i]!=NULL)
		{
		  LALFree((*w)->cList[i]);
		  (*w)->cList[i]=NULL;
		}
	    }
	  /*printf("_freeClusterWavelet 11\n");fflush(stdout);*/
	  LALFree((*w)->cList);
	  (*w)->cList=NULL;
	}
      if((*w)->volumes!=NULL)
	{
	  /*printf("_freeClusterWavelet 12-1\n");fflush(stdout);*/
	  LALFree((*w)->volumes);
	  /*printf("_freeClusterWavelet 12\n");fflush(stdout);*/
	  (*w)->volumes=NULL;
	}
      if((*w)->coreSize!=NULL)
	{
	  /*printf("_freeClusterWavelet 13-1\n");fflush(stdout);*/
	  LALFree((*w)->coreSize);
	  /*printf("_freeClusterWavelet 13\n");fflush(stdout);*/
	  (*w)->coreSize=NULL;
	}
      if((*w)->correlation!=NULL)
	{
	  /*printf("_freeClusterWavelet 14-1\n");fflush(stdout);*/
	  LALFree((*w)->correlation);
	  /*printf("_freeClusterWavelet 14\n");fflush(stdout);*/
	  (*w)->correlation=NULL;
	}
      if((*w)->likelihood!=NULL)
	{
	  /*printf("_freeClusterWavelet 15-1\n");fflush(stdout);*/
	  LALFree((*w)->likelihood);
	  /*printf("_freeClusterWavelet 15\n");fflush(stdout);*/
	  (*w)->likelihood=NULL;
	}
      if((*w)->power!=NULL)
	{
	  /*printf("_freeClusterWavelet 16-1\n");fflush(stdout);*/
	  LALFree((*w)->power);
	  /*printf("_freeClusterWavelet 16\n");fflush(stdout);*/
	  (*w)->power=NULL;
	}
      if((*w)->confidence!=NULL)
        {
	  /*printf("_freeClusterWavelet 17-1\n");fflush(stdout);*/
          LALFree((*w)->confidence);
	  /*printf("_freeClusterWavelet 17\n");fflush(stdout);*/
	  (*w)->confidence=NULL;
        }

      if((*w)->maxAmplitude!=NULL)
	{
	  /*printf("_freeClusterWavelet 18-1\n");fflush(stdout);*/
	  LALFree((*w)->maxAmplitude);
	  /*printf("_freeClusterWavelet 18\n");fflush(stdout);*/
	  (*w)->maxAmplitude=NULL;
	}
      if((*w)->relativeStartTime!=NULL)
	{
	  /*printf("_freeClusterWavelet 19-1\n");fflush(stdout);*/
	  LALFree((*w)->relativeStartTime);
	  /*printf("_freeClusterWavelet 19\n");fflush(stdout);*/
	  (*w)->relativeStartTime=NULL;
	}
      if((*w)->relativeStopTime!=NULL)
	{
	  /*printf("_freeClusterWavelet 20-1\n");fflush(stdout);*/
	  LALFree((*w)->relativeStopTime);
	  /*printf("_freeClusterWavelet 20\n");fflush(stdout);*/
	  (*w)->relativeStopTime=NULL;
	}
      if((*w)->centralTime!=NULL)
	{
	  LALFree((*w)->centralTime);
	  (*w)->centralTime;
	}
      if((*w)->centralFrequency!=NULL)
        {
          LALFree((*w)->centralFrequency);
          (*w)->centralFrequency;
        }
                                                                                                                            
      if((*w)->duration!=NULL)
	{
	  /*printf("_freeClusterWavelet 21-1\n");fflush(stdout);*/
	  LALFree((*w)->duration);
	  /*printf("_freeClusterWavelet 21\n");fflush(stdout);*/
	  (*w)->duration=NULL;
	}
      if((*w)->absoluteStartTime!=NULL)
	{
	  /*printf("_freeClusterWavelet 22-1\n");fflush(stdout);*/
	  LALFree((*w)->absoluteStartTime);
	  /*printf("_freeClusterWavelet 22\n");fflush(stdout);*/
	  (*w)->absoluteStartTime=NULL;
	}
      if((*w)->absoluteStopTime!=NULL)
	{
	  /*printf("_freeClusterWavelet 23-1\n");fflush(stdout);*/
	  LALFree((*w)->absoluteStopTime);
	  /*printf("_freeClusterWavelet 23\n");fflush(stdout);*/
	  (*w)->absoluteStopTime=NULL;
	}
      if((*w)->startFrequency!=NULL)
	{
	  /*printf("_freeClusterWavelet 24-1\n");fflush(stdout);*/
	  LALFree((*w)->startFrequency);
	  /*printf("_freeClusterWavelet 24\n");fflush(stdout);*/
	  (*w)->startFrequency=NULL;
	}
      if((*w)->stopFrequency!=NULL)
	{
	  /*printf("_freeClusterWavelet 25-1\n");fflush(stdout);*/
	  LALFree((*w)->stopFrequency);
	  /*printf("_freeClusterWavelet 25\n");fflush(stdout);*/
	  (*w)->stopFrequency=NULL;
	}
      if((*w)->bandwidth!=NULL)
	{
	  /*printf("_freeClusterWavelet 26-1\n");fflush(stdout);*/
	  LALFree((*w)->bandwidth);
	  /*printf("_freeClusterWavelet 26\n");fflush(stdout);*/
	  (*w)->bandwidth=NULL;
	}
      if((*w)->noise_rms!=NULL)
	{
	  /*printf("_freeClusterWavelet 27-1\n");fflush(stdout);*/
	  LALFree((*w)->noise_rms);
	  /*printf("_freeClusterWavelet 27\n");fflush(stdout);*/
	  (*w)->noise_rms=NULL;
	}
      
      if((*w)->blobs!=NULL)
	{
	  /*printf("_freeClusterWavelet 28-1\n");fflush(stdout);*/
	  for(i=0;i<(*w)->clusterCount;i++)
	    {
	      if((*w)->blobs[i].pBlob!=NULL) 
		{
		  LALFree((*w)->blobs[i].pBlob);
		  (*w)->blobs[i].pBlob=NULL;
		}
	      if((*w)->blobs[i].oBlob!=NULL) 
		{
		  LALFree((*w)->blobs[i].oBlob);
		  (*w)->blobs[i].oBlob=NULL;
		}
	    }
	  /*printf("_freeClusterWavelet 28\n");fflush(stdout);*/
	  LALFree((*w)->blobs);
	  (*w)->blobs=NULL;
	}
      (*w)->pMaskCount=0;
      (*w)->clusterCount=0;
      LALFree(*w);
      *w=NULL;
    }
  /*printf("_freeClusterWavelet end\n");fflush(stdout);*/
}


static void _setAmplitudes(ClusterWavelet *w)
{
  UINT4 i,k,f,t;
  Slice s;

  bzero(w->wavelet->data->data->data,w->wavelet->data->data->length*sizeof(REAL4));

  for(i=0;i<w->pMaskCount;i++)
    {
      f=w->pMask[i]->frequency;
      t=w->pMask[i]->time;
      _getSliceF(f,w->wavelet,&s);
      k=s.start+s.step*t;
      w->wavelet->data->data->data[k]=w->pMask[i]->amplitude;
    }
}

static int _countNonZeroes(REAL4TimeSeries *t)
{
  int sum=0;
  UINT4 i;
  for(i=0;i<t->data->length;i++)
    {
      if(t->data->data[i]!=0.0) sum++;
    }
  return sum;
}


static void _predict(Wavelet *w, int level, int layer, const double *p_H)
{

  /*------------------predict border handling-----------------------
   * use even samples to predict odd samples
   * an example for m_H=8 and 20 samples
   * i index limits     nL............nM....nR-1
   * i index         :  -3 -2 -1 0 1 2 3 4 5 6
   * j index (approx):  -3 -2 -1 0 1 2 3 4 5 6 7 8 9 | 10 11 12 13
   * odd samples:                 0 1 2 3 4 5 6 7 8 9
   *                              L L L M M M R R R R
   * L,R - samples affected by borders
   *   M - not affected samples
   *---------------------------------------------------------*/

  int nS = w->data->data->length>>(++level);         /* nS - number of samples in the layer */
  int nL = 1-w->HPFilterLength/2;	         /* nL - left limit of predict i index */
  int nR = nS+nL;	                         /* nR - right limit of predict i index */
  int nM = nS-w->HPFilterLength+1;	         /* nM - number of M samples (first aR sample) */
  int mM = nM<<level;                            /* (number of M samples)<<level  */

  double data;
  double hsum = 0.;             /* filter sum */
   
  register int i,j,k;
  register double sum = 0.;          

  register const double *h;	         /* pointer to filter coefficient */
  register const REAL4 *dataL;           /* pointer to left data sample */
  register const REAL4 *dataR;           /* pointer to right data sample */
  register const int stride = 1<<level;  /* stride parameter */

  REAL4 *dataA, *dataD; 

  double *pBorder;                       /* border array */
  double *pB;

  pBorder=(double*)LALCalloc(2*(w->HPFilterLength-1),sizeof(double));

  dataA=w->data->data->data + _getOffset(level,layer<<1);     /* pointer to approximation layer */
  dataD=w->data->data->data + _getOffset(level,(layer<<1)+1); /* pointer to detail layer */

  for(k=0; k<(int)w->HPFilterLength; k++) hsum += p_H[k];

  /* left border */

  pB = pBorder;
  dataL = dataA;                            /* first (left) sample */
   for(k=0; k<((int)w->HPFilterLength-nL); k++){ 
      j = k + nL;
      pB[k] = *(dataL + abs(j<<level)); 

      if(j>=0) continue;

      data = *(dataL + ((j+nS)<<level));
      switch (w->border) {		 
      case B_PAD_ZERO : pB[k] = 0.;     break;  /* pad zero */
      case B_PAD_EDGE : pB[k] = *dataL; break;  /* pad by edge value */
      case B_CYCLE    : pB[k] = data;   break;  /* cycle data*/
      default    :                 break;  /* mirror or interpolate */
      }
   }

   for(i=nL; i<0; i++) {                    /* i index */

     if(w->border != B_POLYNOM){
       sum = 0.;
       for(k=0; k<(int)w->HPFilterLength/2; k++) 
	 sum += p_H[k] * (pB[k] + pB[w->HPFilterLength-1-k]);
       pB++;
     }
     else{
       pB = pBorder - nL;                                 /* point to dataA */
       sum = hsum*_Nevill(i+0.5-nL, w->HPFilterLength+2*i, pB, pB+w->HPFilterLength);  /* POLYNOM2*/
     }
     *dataD -= sum;
     dataD += stride;
   }

   /* regular case (no borders) */

   k = (w->HPFilterLength-1)<<level;

   for(i=0; i<mM; i+=stride) { 
     dataL = dataA+i;
     dataR = dataL+k;
     h = p_H;
     sum  = *(h++) * (*dataL + *dataR);
     if ((dataL+=stride) > (dataR-=stride)) goto P0;
     sum  += *(h++) * (*dataL + *dataR);
     if ((dataL+=stride) > (dataR-=stride)) goto P0;
     sum  += *(h++) * (*dataL + *dataR);
     if ((dataL+=stride) > (dataR-=stride)) goto P0;
     sum  += *(h++) * (*dataL + *dataR);
     if ((dataL+=stride) > (dataR-=stride)) goto P0;
     sum  += *(h++) * (*dataL + *dataR);
     if ((dataL+=stride) > (dataR-=stride)) goto P0;
     sum  += *(h++) * (*dataL + *dataR);
     if ((dataL+=stride) > (dataR-=stride)) goto P0;
     sum  += *(h++) * (*dataL + *dataR);
     if ((dataL+=stride) > (dataR-=stride)) goto P0;
     sum  += *(h++) * (*dataL + *dataR);
     if ((dataL+=stride) > (dataR-=stride)) goto P0;
     sum  += *(h++) * (*dataL + *dataR);
     if ((dataL+=stride) > (dataR-=stride)) goto P0;
     sum  += *(h++) * (*dataL + *dataR);
     if ((dataL+=stride) > (dataR-=stride)) goto P0;
     sum  += *(h++) * (*dataL + *dataR);
     if ((dataL+=stride) > (dataR-=stride)) goto P0;
     sum  += *(h++) * (*dataL + *dataR);
     if ((dataL+=stride) > (dataR-=stride)) goto P0;
     sum  += *(h++) * (*dataL + *dataR);
     if ((dataL+=stride) > (dataR-=stride)) goto P0;
     sum  += *(h++) * (*dataL + *dataR);
     if ((dataL+=stride) > (dataR-=stride)) goto P0;
     sum  += *(h++) * (*dataL + *dataR);
     
   P0: *dataD -= sum;
     dataD += stride;
   }
   
   /* right border */

   pB = pBorder;
   dataR = dataA + ((nS-1)<<level);     /* last (right) sample */
   
   for(k=0; k<((int)w->HPFilterLength-nL+1); k++){ 
     j = w->HPFilterLength - 1 - k;
     pB[k] = *(dataR - abs(j<<level));

     if(j>=0) continue;

     data = *(dataR - ((j+nS)<<level));
     switch (w->border) {		 
     case B_PAD_ZERO : pB[k] = 0.;     break;  /* pad zero */
     case B_PAD_EDGE : pB[k] = *dataR; break;  /* pad by edge value */
     case B_CYCLE    : pB[k] = data;   break;  /* cycle data */
     default    :                 break;  /* mirror or interpolate */
     }
   }

   k = 0;
   for(i=nM; i<nR; i++) {                     

      if(w->border != B_POLYNOM){
	 sum = 0.; pB++;

	 for(k=0; k<(int)w->HPFilterLength/2; k++)
	    sum += p_H[k] * (pB[k] + pB[(int)w->HPFilterLength-1-k]);
      }
      else{
	 k += 2;
	 sum = hsum*_Nevill(((int)w->HPFilterLength-k-1)/2., (int)w->HPFilterLength-k, pB+k, pBorder+(int)w->HPFilterLength+1);
	 if(k == (int)w->HPFilterLength) sum = *(pB+k-1) * hsum;
      }
      
      *dataD -= sum;
      dataD += stride;
   }

  LALFree(pBorder);
  pBorder=NULL;

}

static void _update(Wavelet *w, int level, int layer, const double *p_L)
{

  /*------------------update border handling-----------------------
   * use odd samples to update even samples
   * an example for m_H=8 and 20 samples
   *                               L L L L M M M R R R
   * even samples  :               0 1 2 3 4 5 6 7 8 9
   * j index (detail):  -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 | 10 11 12
   * i index         :  -4 -3 -2 -1 0 1 2 3 4 5
   * i index limits     nL...............nM..nR-1
   * L,R - samples affected by borders
   *   M - not affected samples
   *---------------------------------------------------------*/

  int nS = w->data->data->length>>(++level);     /* nS - number of samples in the layer */
  int nL = -(int)w->LPFilterLength/2;	         /* nL - left limit of update i index */
  int nR = nS+nL;	                         /* nR - right limit of update i index */
  int nM = nS - (int)w->LPFilterLength+1;	         /* nM - number of M samples */
  int mM = nM<<level;                            /* (number of M samples)<<level  */

  double data;
  double hsum = 0.;             /* filter sum */
   
  register int i,j,k;
  register double sum = 0.;

  register const double *h;	         /* pointer to filter coefficient */
  register const REAL4 *dataL;           /* pointer to left data sample */
  register const REAL4 *dataR;           /* pointer to right data sample */
  register const int stride = 1<<level;  /* stride parameter */
   
  REAL4 *dataA, *dataD; 

  double *pB;
  double *pBorder=(double*)LALCalloc(2*((int)w->LPFilterLength-nL),sizeof(double));  /* border array */

  dataA=w->data->data->data + _getOffset(level,layer<<1);     /* pointer to approximation layer */
  dataD=w->data->data->data + _getOffset(level,(layer<<1)+1); /* pointer to detail layer */

   for(k=0; k<(int)w->LPFilterLength; k++) hsum += p_L[k];

   /* left border */

   pB = pBorder;
   dataL = dataD;                            /* first (left) sample */
   for(k=0; k<((int)w->LPFilterLength-nL); k++){ 
      j = k + nL;
      pB[k] = *(dataL + abs(j<<level)); 

      if(j>=0) continue;

      data = *(dataL + ((j+nS)<<level));
      switch (w->border) {		 
      case B_PAD_ZERO : pB[k] = 0.;     break;  /* pad zero */
      case B_PAD_EDGE : pB[k] = *dataL; break;  /* pad by edge value */
      case B_CYCLE    : pB[k] = data;   break;  /* cycle data */
      default    :                 break;  /* mirror or interpolate */
      }
   }

   for(i=nL; i<0; i++) {                    /* i index */

      if(w->border != B_POLYNOM){
	sum = 0.;
	for(k=0; k<(int)w->LPFilterLength/2; k++) 
	  sum += p_L[k] * (pB[k] + pB[(int)w->LPFilterLength-1-k]);
	pB++;
      }
      else{
	pB = pBorder - nL;                                 /* point to dataD */
	sum = hsum*_Nevill(i-0.5-nL, w->LPFilterLength+2*i, pB, pB+w->LPFilterLength);  /* POLYNOM2 */
      }

      *dataA += sum;
      dataA += stride;
   }

   /* regular case (no borders) */

  k = ((int)w->LPFilterLength-1)<<level;

  for(i=0; i<mM; i+=stride) {
    dataL = dataD+i;
    dataR = dataL+k;
    h = p_L;

    sum  = *(h++) * (*dataL + *dataR);
    if ((dataL+=stride) > (dataR-=stride)) goto U0;
    sum  += *(h++) * (*dataL + *dataR);
    if ((dataL+=stride) > (dataR-=stride)) goto U0;
    sum  += *(h++) * (*dataL + *dataR);
    if ((dataL+=stride) > (dataR-=stride)) goto U0;
    sum  += *(h++) * (*dataL + *dataR);
    if ((dataL+=stride) > (dataR-=stride)) goto U0;
    sum  += *(h++) * (*dataL + *dataR);
    if ((dataL+=stride) > (dataR-=stride)) goto U0;
    sum  += *(h++) * (*dataL + *dataR);
    if ((dataL+=stride) > (dataR-=stride)) goto U0;
    sum  += *(h++) * (*dataL + *dataR);
    if ((dataL+=stride) > (dataR-=stride)) goto U0;
    sum  += *(h++) * (*dataL + *dataR);
    if ((dataL+=stride) > (dataR-=stride)) goto U0;
    sum  += *(h++) * (*dataL + *dataR);
    if ((dataL+=stride) > (dataR-=stride)) goto U0;
    sum  += *(h++) * (*dataL + *dataR);
    if ((dataL+=stride) > (dataR-=stride)) goto U0;
    sum  += *(h++) * (*dataL + *dataR);
    if ((dataL+=stride) > (dataR-=stride)) goto U0;
    sum  += *(h++) * (*dataL + *dataR);
    if ((dataL+=stride) > (dataR-=stride)) goto U0;
    sum  += *(h++) * (*dataL + *dataR);
    if ((dataL+=stride) > (dataR-=stride)) goto U0;
    sum  += *(h++) * (*dataL + *dataR);
    if ((dataL+=stride) > (dataR-=stride)) goto U0;
    sum  += *(h++) * (*dataL + *dataR);

U0: *dataA += sum;
     dataA += stride;
  }

  /* right border */

   pB = pBorder;
   dataR = dataD + ((nS-1)<<level);     /* last detail sample */

   for(k=0; k<((int)w->LPFilterLength-nL); k++){ 
      j = (int)w->LPFilterLength - 1 - k;
      pB[k] = *(dataR - abs(j<<level));

      if(j>=0) continue;

      data = *(dataR - ((j+nS)<<level));
      switch (w->border) {		 
      case B_PAD_ZERO : pB[k] = 0.;     break;  /* pad zero */
      case B_PAD_EDGE : pB[k] = *dataR; break;  /* pad by edge value */
      case B_CYCLE    : pB[k] = data;   break;  /* cycle data */
      default    :                 break;       /* mirror or interpolate */
      }
   }

   k = 0;
   for(i=nM; i<nR; i++) {                     

      if(w->border != B_POLYNOM){
	 sum = 0.; pB++;
	 for(k=0; k<(int)w->LPFilterLength/2; k++) 
	    sum += p_L[k] * (pB[k] + pB[(int)w->LPFilterLength-1-k]);
      }
      else{
	 k += 2;
	 sum = hsum*_Nevill(((int)w->HPFilterLength-k-1)/2., (int)w->HPFilterLength-k, pB+k, pBorder+w->HPFilterLength+1);
      }

      *dataA += sum;
       dataA += stride;
   }

  LALFree(pBorder);
  pBorder=NULL;
}

static void _forward(Wavelet *w, int level, int layer)
{
  register int stride;
  unsigned int i;
  register REAL4 *dataA;
  register REAL4 *dataD; 

  switch(w->type)
    {
    case BIORTHOGONAL:
      _predict(w, level, layer, w->PForward);
      _update(w, level, layer, w->UForward);
      break;
    case DAUBECHIES:
      _forwardFWT(w, level, layer, w->pLForward, w->pHForward); 
      break;
    case SYMLET:
      _forwardFWT(w, level, layer, w->pLForward, w->pHForward); 
      break;
    case HAAR:
      stride = 1<<(++level);    /* stride parameter */
      dataA=w->data->data->data + _getOffset(level,layer<<1);     /* pointer to approximation layer */
      dataD=w->data->data->data + _getOffset(level,(layer<<1)+1); /* pointer to detail layer */
      /* predict */
      for(i=0; i<w->data->data->length; i+=stride) {
	*(dataD+i) -= *(dataA+i);
      }
      /* update */
      for(i=0; i<w->data->data->length; i+=stride) {
	*(dataA+i) += *(dataD+i) * 0.5;
      }
      break;
    case DMEYER:

      break;
    }

}

static void _inverse(Wavelet *w, int level, int layer)
{
  register int stride;
  unsigned int i;
  register REAL4 *dataA;
  register REAL4 *dataD; 

  switch(w->type)
    {
    case BIORTHOGONAL:
      _update(w, level, layer, w->UInverse);
      _predict(w, level, layer, w->PInverse);
      break;
    case DAUBECHIES:
      _inverseFWT(w, level, layer, w->pLInverse, w->pHInverse); 
      break;
    case SYMLET:
      _inverseFWT(w, level, layer, w->pLInverse, w->pHInverse); 
      break;
    case HAAR:
      stride = 1<<(++level);      /* stride parameter */
      dataA=w->data->data->data + _getOffset(level,layer<<1);     /* pointer to approximation layer */
      dataD=w->data->data->data + _getOffset(level,(layer<<1)+1); /* pointer to detail layer */
      /* undo update */
      for(i=0; i<w->data->data->length; i+=stride) {
	*(dataA+i) -= *(dataD+i) * 0.5;
      }
      /* undo predict */
      for(i=0; i<w->data->data->length; i+=stride) {
	*(dataD+i) += *(dataA+i);
      }
      break;
    case DMEYER:

      break;
    }

}

static double _Lagrange(const int n, const int i, const double x)
{
    double c = 1.;
    int j;
    double xn = x+n/2.-0.5;	/*shift to the center of interpolation interval*/

    for(j=0; j<n; j++) 
       if(j!=i) c *= (xn-j)/(i-j);

    return c;
}

/*   Nevill's polynomial interpolation. */
/*   x - polynom argument (x stride is allways 1)  */
/*   n - number of interpolation samples */
/*   p - pointer to a sample with x=0. */
/*   q - double array of length n */
static double _Nevill(const double x0, int n, double *p, double *q)
{
   register int i;
   register double x = x0;
   register double xm = 0.5;

   n--;
   *q = *p;

   for(i=0; i<n; i++)
      q[i] = p[i] + (x--)*(p[i+1]-p[i]);

   while(--n >= 1){
      x = x0;

      q[0] += xm*(x--)*(q[1]-q[0]);
      if(n == 1) goto M0;
      q[1] += xm*(x--)*(q[2]-q[1]);
      if(n == 2) goto M0;
      q[2] += xm*(x--)*(q[3]-q[2]);
      if(n == 3) goto M0;
      q[3] += xm*(x--)*(q[4]-q[3]);
      if(n == 4) goto M0;
      q[4] += xm*(x--)*(q[5]-q[4]);
      if(n == 5) goto M0;
      q[5] += xm*(x--)*(q[6]-q[5]);
      if(n == 6) goto M0;

      for(i=6; i<n; i++)
	 q[i] += xm*(x--)*(q[i+1]-q[i]);

M0:   xm /= (1.+xm);
   }

   return *q;
}

static void _setFilter(Wavelet *w)
{
  switch(w->type)
    {
    case BIORTHOGONAL:
      _setFilterB(w);
      break;
    case DAUBECHIES:
      _setFilterD(w);
      break;
    case SYMLET:
      _setFilterS(w);
      break;
    case HAAR:
      _setFilterH(w);
      break;
    case DMEYER:
      _setFilterM(w);
      break;
    }
}

static void _setFilterB(Wavelet *w)
{
  int i;
  int n = w->HPFilterLength;
  
  n = (n>>1)<<1;
  if(n < 2) n=4;
  if(n > 30) n=30;   /* limit is due to the unrolled code length */
  
  w->PForward=(REAL8*)LALCalloc(n,sizeof(REAL8));
  w->PInverse=(REAL8*)LALCalloc(n,sizeof(REAL8));
  w->UForward=(REAL8*)LALCalloc(n,sizeof(REAL8));
  w->UInverse=(REAL8*)LALCalloc(n,sizeof(REAL8));
  
  for(i=0; i<n; i++) 
    {
      w->PForward[i] = _Lagrange(n,i,0.);
      w->UForward[i] = 0.5*w->PForward[i];
      w->PInverse[i] = -w->PForward[i];
      w->UInverse[i] = -w->UForward[i];
    }
  w->HPFilterLength = n;
  w->LPFilterLength = n;
}

static void _setFilterS(Wavelet *w)
{
   const double* pF;
   int n,i;
   w->HPFilterLength = (w->HPFilterLength>>1)<<1;
   n = w->HPFilterLength/2;
   switch(n)
   {
      case  2: pF =  sym2; w->HPFilterLength =  4; break;
      case  3: pF =  sym3; w->HPFilterLength =  6; break;
      case  4: pF =  sym4; w->HPFilterLength =  8; break;
      case  5: pF =  sym5; w->HPFilterLength = 10; break;
      case  6: pF =  sym6; w->HPFilterLength = 12; break;
      case  7: pF =  sym7; w->HPFilterLength = 14; break;
      case  8: pF =  sym8; w->HPFilterLength = 16; break;
      case  9: pF =  sym9; w->HPFilterLength = 18; break;
      case 10: pF = sym10; w->HPFilterLength = 20; break;
      case 11: pF = sym11; w->HPFilterLength = 22; break;
      case 12: pF = sym12; w->HPFilterLength = 24; break;
      case 13: pF = sym13; w->HPFilterLength = 26; break;
      case 14: pF = sym14; w->HPFilterLength = 28; break;
      case 15: pF = sym15; w->HPFilterLength = 30; break;
      case 16: pF = sym16; w->HPFilterLength = 32; break;
      case 17: pF = sym17; w->HPFilterLength = 34; break;
      case 18: pF = sym18; w->HPFilterLength = 36; break;
      case 19: pF = sym19; w->HPFilterLength = 38; break;
      case 20: pF = sym20; w->HPFilterLength = 40; break;
      case 21: pF = sym21; w->HPFilterLength = 42; break;
      case 22: pF = sym22; w->HPFilterLength = 44; break;
      case 23: pF = sym23; w->HPFilterLength = 46; break;
      case 24: pF = sym24; w->HPFilterLength = 48; break;
      case 25: pF = sym25; w->HPFilterLength = 50; break;
      case 26: pF = sym26; w->HPFilterLength = 52; break;
      case 27: pF = sym27; w->HPFilterLength = 54; break;
      case 28: pF = sym28; w->HPFilterLength = 56; break;
      case 29: pF = sym29; w->HPFilterLength = 58; break;
      case 30: pF = sym30; w->HPFilterLength = 60; break;
      default: pF =  sym4; w->HPFilterLength =  8; break;
   }

   w->pLInverse = (REAL8*)LALCalloc(w->HPFilterLength,sizeof(REAL8));
   w->pLForward = (REAL8*)LALCalloc(w->HPFilterLength,sizeof(REAL8));
   w->pHInverse = (REAL8*)LALCalloc(w->HPFilterLength,sizeof(REAL8));
   w->pHForward = (REAL8*)LALCalloc(w->HPFilterLength,sizeof(REAL8));

   for(i=0; i<(int)w->HPFilterLength; i+=2){
      w->pLForward[i]   = pF[i];
      w->pLForward[i+1] = pF[i+1];
      w->pHForward[i]   = pF[(int)w->HPFilterLength-1-i];
      w->pHForward[i+1] = -pF[(int)w->HPFilterLength-2-i];
      if(n&1){
	 w->pLInverse[i]   = pF[(int)w->HPFilterLength-2-i];
	 w->pLInverse[i+1] = pF[i+1];
	 w->pHInverse[i]   = pF[(int)w->HPFilterLength-1-i];
	 w->pHInverse[i+1] = -pF[i];	 
      }
      else{
	 w->pLInverse[i]   = pF[(int)w->HPFilterLength-1-i];
	 w->pLInverse[i+1] = -pF[i];
	 w->pHInverse[i]   = pF[(int)w->HPFilterLength-2-i];
	 w->pHInverse[i+1] = pF[i+1];
      }
   }
}

static void _setFilterD(Wavelet *w)
{
   const double* pF;
   int n,i;
   w->HPFilterLength = (w->HPFilterLength>>1)<<1;
   n = w->HPFilterLength/2;
   switch(n)
   {
      case  1: pF =  dbc1; w->HPFilterLength =  2; break;
      case  2: pF =  dbc2; w->HPFilterLength =  4; break;
      case  3: pF =  dbc3; w->HPFilterLength =  6; break;
      case  4: pF =  dbc4; w->HPFilterLength =  8; break;
      case  5: pF =  dbc5; w->HPFilterLength = 10; break;
      case  6: pF =  dbc6; w->HPFilterLength = 12; break;
      case  7: pF =  dbc7; w->HPFilterLength = 14; break;
      case  8: pF =  dbc8; w->HPFilterLength = 16; break;
      case  9: pF =  dbc9; w->HPFilterLength = 18; break;
      case 10: pF = dbc10; w->HPFilterLength = 20; break;
      case 11: pF = dbc11; w->HPFilterLength = 22; break;
      case 12: pF = dbc12; w->HPFilterLength = 24; break;
      case 13: pF = dbc13; w->HPFilterLength = 26; break;
      case 14: pF = dbc14; w->HPFilterLength = 28; break;
      case 15: pF = dbc15; w->HPFilterLength = 30; break;
      case 16: pF = dbc16; w->HPFilterLength = 32; break;
      case 17: pF = dbc17; w->HPFilterLength = 34; break;
      case 18: pF = dbc18; w->HPFilterLength = 36; break;
      case 19: pF = dbc19; w->HPFilterLength = 38; break;
      case 20: pF = dbc20; w->HPFilterLength = 40; break;
      case 21: pF = dbc21; w->HPFilterLength = 42; break;
      case 22: pF = dbc22; w->HPFilterLength = 44; break;
      case 23: pF = dbc23; w->HPFilterLength = 46; break;
      case 24: pF = dbc24; w->HPFilterLength = 48; break;
      case 25: pF = dbc25; w->HPFilterLength = 50; break;
      case 26: pF = dbc26; w->HPFilterLength = 52; break;
      case 27: pF = dbc27; w->HPFilterLength = 54; break;
      case 28: pF = dbc28; w->HPFilterLength = 56; break;
      case 29: pF = dbc29; w->HPFilterLength = 58; break;
      case 30: pF = dbc30; w->HPFilterLength = 60; break;
      default: pF =  dbc4; w->HPFilterLength =  8; break;
   }
   
   w->pLInverse = (REAL8*)LALCalloc(w->HPFilterLength,sizeof(REAL8));
   w->pLForward = (REAL8*)LALCalloc(w->HPFilterLength,sizeof(REAL8));
   w->pHInverse = (REAL8*)LALCalloc(w->HPFilterLength,sizeof(REAL8));
   w->pHForward = (REAL8*)LALCalloc(w->HPFilterLength,sizeof(REAL8));

   for(i=0; i<(int)w->HPFilterLength; i+=2){
      w->pLForward[i]   = pF[i];
      w->pLForward[i+1] = pF[i+1];
      w->pHForward[i]   = pF[(int)w->HPFilterLength-1-i];
      w->pHForward[i+1] = -pF[(int)w->HPFilterLength-2-i];
      if(n&1){
	 w->pLInverse[i]   = pF[(int)w->HPFilterLength-2-i];
	 w->pLInverse[i+1] = pF[i+1];
	 w->pHInverse[i]   = pF[(int)w->HPFilterLength-1-i];
	 w->pHInverse[i+1] = -pF[i];	 
      }
      else{
	 w->pLInverse[i]   = pF[(int)w->HPFilterLength-1-i];
	 w->pLInverse[i+1] = -pF[i];
	 w->pHInverse[i]   = pF[(int)w->HPFilterLength-2-i];
	 w->pHInverse[i+1] = pF[i+1];
      }
   }
}

static void _setFilterH(Wavelet *w)
{
  w = NULL;
}

static void _setFilterM(Wavelet *w)
{
  w = NULL;
}

static void _forwardFWT(Wavelet *w, int level, int layer, 
			const double *pLPF, const double *pHPF)
{
  const int nS = 
    w->data->data->length>>level;           /* number of samples in the layer*/
  const int kL = -((int)w->HPFilterLength/2-1);               /* k left limit */
  const int iL = nS-(int)w->HPFilterLength;                   /* i left limit */
  const int iR = nS-(int)w->HPFilterLength/2-1;	         /* i right limit */

  register int i,j,k;
  register double sumA, sumD, data;
  register const double *p = pLPF;           
  register const double *q = pHPF;
  register REAL4 *pD;
  register int stride = 1<<level; /*stride parameter*/
  double *temp;
  REAL4 *pData;

  /*------------------ border handling-----------------------
   *                  
   * LP matrix     [h0] | h1  h2 h3   0  0   0  0  h0 |
   *   for              |  0  h0 h1  h2 h3   0  0   0 | 
   *   DB2              |  0   0  0  h0 h1  h2 h3   0 | 
   *                    |  0   0  0   0  0  h0 h1  h2 | [h3] 
   *
   * HP matrix     [h3] |-h2  h1 -h0  0   0  0   0 h3 |
   *   for              |  0  h3 -h2 h1 -h0  0   0  0 | 
   *   DB2              |  0   0   0 h3 -h2 h1 -h0  0 | 
   *                    |-h0   0   0  0   0 h3 -h2 h1 | [-h0]
   *
   * temp array:  a d a d a d ..... a d a d a d
   * a - approximations, d - details
   *---------------------------------------------------------
   *
   *------------------ border handling-----------------------
   *
   * index  i:   -2 -1     0   1  2   3  4   5  6   7  8
   *   limits:                                 iL     iR
   *
   * index  k:  [-2 -1]    0   1  2   3  4   5  6   7  8   9 10  11   [12 13]  14
   *   limits:   kL                                                            kR
   *                  
   * LP matrix  [h0 h1] | h2  h3 h4  h5  0   0  0   0  0   0 h0  h1 |
   *   for              | h0  h1 h2  h3 h4  h5  0   0  0   0  0   0 | 
   *   DB3              |  0   0 h0  h1 h2  h3 h4  h5  0   0  0   0 | 
   *                    |  0   0  0   0 h0  h1 h2  h3 h4  h5  0   0 | 
   *                    |  0   0  0   0  0   0 h0  h1 h2  h3 h4  h5 | 
   *                    | h4  h5  0   0  0   0  0   0 h0  h1 h2  h3 | [h4 h5]  
   *
   * HP matrix [h5 -h4] | h3 -h2 h1 -h0  0   0  0   0  0   0 h5 -h4 |
   *   for              | h5 -h4 h3 -h2 h1 -h0  0   0  0   0  0   0 | 
   *   DB3              |  0   0 h5 -h4 h3 -h2 h1 -h0  0   0  0   0 | 
   *                    |  0   0  0   0 h5 -h4 h3 -h2 h1 -h0  0   0 | 
   *                    |  0   0  0   0  0   0 h5 -h4 h3 -h2 h1 -h0 | 
   *                    | h1 -h0  0   0  0   0  0   0 h5 -h4 h3 -h2 | [h1 -h0]  
   *
   * temp array:  a d a d a d ..... a d a d a d
   * a - approximations, d - details
   *---------------------------------------------------------*/

   if(pLPF==NULL || pHPF==NULL) return;

   
   /* pointer to the first sample in the layer */
   pData = w->data->data->data+_getOffset(level,layer);

   temp = (double*)LALCalloc(nS,sizeof(double));

   /* left border*/

   i = kL;

   while(i<0) {
      sumA=0.; sumD=0.;

      for(j=0; j<(int)w->HPFilterLength; j++) {
	 k = i+j;
	 if(k < 0) k += nS;
	 data = pData[k<<level];
	 sumA += *p++ * data;
	 sumD += *q++ * data;
      }

      *temp++ = sumA;
      *temp++ = sumD;
      i += 2;
      p -= (int)w->HPFilterLength;
      q -= (int)w->HPFilterLength;
   }

   /* processing data in the middle of array*/

   while(i<=iL) {
      pD = pData + (i<<level);
      data = *pD;
      sumA=0.; sumD=0.;

      for(j=0; j<(int)w->HPFilterLength; j+=2) {
	 sumA += *p++ * data;
	 sumD += *q++ * data;
	 data = *(pD += stride);
	 sumA += *p++ * data;
	 sumD += *q++ * data;
	 data = *(pD += stride);
      } 

      *temp++ = sumA;
      *temp++ = sumD;
      i += 2;
      p -= (int)w->HPFilterLength;
      q -= (int)w->HPFilterLength;
   }
   
   /* right border */
   
   while(i<=iR) {
      sumA=0.; sumD=0.;

      for(j=0; j<(int)w->HPFilterLength; j++) {
	 k = i+j;
	 if(k >= nS) k -= nS;
	 data = pData[k<<level];
	 sumA += *p++ * data;
	 sumD += *q++ * data;
      }

      *temp++ = sumA;
      *temp++ = sumD;
      i += 2;
      p -= (int)w->HPFilterLength;
      q -= (int)w->HPFilterLength;
   }

   /* writing data back from temporary storage */
   for(i=nS-1; i>=0; i--)
      pData[i<<level] = *(--temp);

   LALFree(temp);
   temp=NULL;
}

static void _inverseFWT(Wavelet *w, int level, int layer, const double *pLPF, const double *pHPF)
{
  BOOLEAN EVM;
  const int nS = w->data->data->length>>level;           /* number of samples in the layer*/
  const int kL = -((int)w->HPFilterLength>>2<<1);             /* k left limit */
  const int iR = nS+kL;	                                 /* i right limit*/
  const int iL = nS-(int)w->HPFilterLength;                   /* i left limit*/

  register int i,j,k;
  register double sumA, sumD, data;           
  register const double *p = pLPF;           
  register const double *q = pHPF;
  register REAL4 *pD;
  register int stride = 1<<level; /* stride parameter */

  REAL4 *pData;
  double *temp;

  if(pLPF==NULL || pHPF==NULL) return;

  EVM = (w->HPFilterLength/2&1) ? FALSE : TRUE;/* true if Even Vanishing Moments */


  /* LP filter for db2:  h3 -h0  h1 -h2
   * HP filter for db2:  h2  h1  h0  h3
   * LP filter for db3:  h4  h1  h2  h3  h0  h5
   * HP filter for db3:  h5 -h0  h3 -h2  h1 -h4
   *------------------ border handling-----------------------
   *
   * index  i:         -2 -1    0   1  2  3  4   5  6  
   *   limits:                              iL     iR
   *
   * index  k:        [-2 -1]   0   1  2  3  4   5  6  7   8  9 
   *   limits:         kL                                        
   * inverse matrix  [h0 h1] | h2  h3  0  0  0   0  0  0 |
   *   for DB2               | h0  h1 h2 h3  0   0  0  0 | 
   *                         | h0  h1 h2 h3  0   0  0  0 | 
   *                         |  0   0 h0 h1 h2  h3  0  0 | 
   *                         |  0   0 h0 h1 h2  h3  0  0 | 
   *                         |  0   0  0  0 h0  h1 h2 h3 | 
   *                         |  0   0  0  0 h0  h1 h2 h3 | 
   *                         |  0   0  0  0  0   0 h0 h1 | h2  h3 
   *
   */                  
   
  /* pointer to the first sample in the layer */
   pData = w->data->data->data + _getOffset(level,layer);

   temp = (double*)LALCalloc(nS,sizeof(double)); /* temporary array */

   /* left border */

   i = kL;

   if(EVM){               /* db2, db4, db8, ..... */
      p = pLPF;
      *temp = 0;

      for(j=0; j<(int)w->HPFilterLength; j++) {
	 k = i+j;
	 if(k < 0) k += nS;
	 *temp += *p++ * pData[k<<level];
      }
      temp++;
      i += 2;
      p = pHPF;
      q = pLPF;
   }
      
   while(i<0) {
      sumA = 0.; sumD = 0.;

      for(j=0; j<(int)w->HPFilterLength; j++) {
	 k = i+j;
	 if(k < 0) k += nS;
	 data = pData[k<<level];
	 sumA += *p++ * data;
	 sumD += *q++ * data;
      }

      *temp++ = sumA;
      *temp++ = sumD;
      i += 2;
      p -= (int)w->HPFilterLength;
      q -= (int)w->HPFilterLength;
   }

   /* processing data in the middle of array */

   while(i<=iL) {
      pD = pData + (i<<level);
      data = *pD;
      sumA = 0.; sumD = 0.;

      for(j=0; j<(int)w->HPFilterLength; j+=2) {
	 sumA += *p++ * data;
	 sumD += *q++ * data;
	 data = *(pD += stride);
	 sumD += *q++ * data;
	 sumA += *p++ * data;
	 data = *(pD += stride);
      } 

      *temp++ = sumA;
      *temp++ = sumD;
      i += 2;
      p -= (int)w->HPFilterLength;  
      q -= (int)w->HPFilterLength;
   }
   
   /* right border */

   while(i<iR) {
      sumA = 0.; sumD = 0.;

      for(j=0; j<(int)w->HPFilterLength; j++) {
	 k = i+j;
	 if(k >= nS) k -= nS;
	 data = pData[k<<level];
	 sumA += *p++ * data;
	 sumD += *q++ * data;
      }

      *temp++ = sumA;
      *temp++ = sumD;
      i += 2;
      p -= (int)w->HPFilterLength;
      q -= (int)w->HPFilterLength;
   }

   if(EVM){         /* db2, db4, db8, ..... */
      q = pHPF;
      *temp = 0.;

      for(j=0; j<(int)w->HPFilterLength; j++) {
	 k = i+j;
	 if(k >= nS) k -= nS;
	 *temp += *q++ * pData[k<<level];
      }
      temp++;
   }
      
   /* writing data back from temporary storage */
   for(i=nS-1; i>=0; i--)
      pData[i<<level] = *(--temp);

   LALFree(temp);
   temp=NULL;
}


static int _duplicateClusterStructure(OutputClusterWavelet *output, InputReuseClusterWavelet *input)
{
  UINT4 i,j;
  Slice S;

  output->w->pMaskCount=input->another->pMaskCount;
  output->w->clusterCount=input->another->clusterCount;
  output->w->clusterCountFinal=input->another->clusterCountFinal;
  output->w->clusterType=input->another->clusterType;
  output->w->simulationType=input->another->simulationType;
  output->w->delta_t=input->another->delta_t;
  output->w->delta_f=input->another->delta_f;
  output->w->noise_rms_flag=input->another->noise_rms_flag;
  output->w->coreSize=NULL;
  output->w->correlation=NULL;
  output->w->likelihood=NULL;
  output->w->power=NULL;
  output->w->confidence=NULL;
  output->w->maxAmplitude=NULL;
  output->w->relativeStartTime=NULL;
  output->w->relativeStopTime=NULL;
  output->w->centralTime=NULL;
  output->w->centralFrequency=NULL;
  output->w->duration=NULL;
  output->w->absoluteStartTime=NULL;
  output->w->absoluteStopTime=NULL;
  output->w->startFrequency=NULL;
  output->w->stopFrequency=NULL;
  output->w->bandwidth=NULL;
  output->w->noise_rms=NULL;
  output->w->blobs=NULL;
  
  output->w->pMask=(PixelWavelet**)LALCalloc(output->w->pMaskCount,sizeof(PixelWavelet*));

  for(i=0;i<output->w->pMaskCount;i++)
    {
      output->w->pMask[i]=(PixelWavelet*)LALCalloc(1,sizeof(PixelWavelet));
      _copyPixel(output->w->pMask[i],input->another->pMask[i]);
      _getSliceF(output->w->pMask[i]->frequency,input->another->wavelet,&S);
      output->w->pMask[i]->amplitude=
	output->w->wavelet->data->data->data[S.start+S.step*output->w->pMask[i]->time];
      output->w->pMask[i]->amplitudeOriginal=
	output->w->original->data->data->data[S.start+S.step*output->w->pMask[i]->time];
      output->w->pMask[i]->amplitudeAfterCalibration=
	output->w->afterCalibration->data->data->data[S.start+S.step*output->w->pMask[i]->time];
      if(output->w->pMask[i]->amplitude>=2*input->w->wavelet->data->data->length-1)
	{
	  output->w->pMask[i]->amplitude=0.0;
	  output->w->pMask[i]->amplitudeOriginal=0.0;
	  output->w->pMask[i]->amplitudeAfterCalibration=0.0;
	  output->w->pMask[i]->core=FALSE;
	  output->w->wavelet->data->data->data[S.start+S.step*output->w->pMask[i]->time]=0.0;
	  output->w->original->data->data->data[S.start+S.step*output->w->pMask[i]->time]=0.0;
	  output->w->afterCalibration->data->data->data[S.start+S.step*output->w->pMask[i]->time]=0.0;
	}
      if(output->w->pMask[i]->amplitude==0.0)
	{
	  output->w->pMask[i]->amplitude=0.0;
          output->w->pMask[i]->amplitudeOriginal=0.0;
	  output->w->pMask[i]->amplitudeAfterCalibration=0.0;
          output->w->pMask[i]->core=FALSE;
          output->w->wavelet->data->data->data[S.start+S.step*output->w->pMask[i]->time]=0.0;
          output->w->original->data->data->data[S.start+S.step*output->w->pMask[i]->time]=0.0;
	  output->w->afterCalibration->data->data->data[S.start+S.step*output->w->pMask[i]->time]=0.0;
	}
      else
	{
	  output->w->pMask[i]->core=TRUE;
	}
    }

  output->w->volumes=(UINT4*)LALCalloc(output->w->clusterCount,sizeof(UINT4));
  output->w->sCuts=(UINT4*)LALCalloc(output->w->clusterCount,sizeof(UINT4));
  output->w->cList=(UINT4**)LALCalloc(output->w->clusterCount,sizeof(UINT4*));
  for(i=0;i<output->w->clusterCount;i++)
    {
      output->w->volumes[i]=input->another->volumes[i];
      output->w->sCuts[i]=input->another->sCuts[i];
      output->w->cList[i]=(UINT4*)LALCalloc(output->w->volumes[i],sizeof(UINT4));
      for(j=0;j<output->w->volumes[i];j++)
	{
	  output->w->cList[i][j]=input->another->cList[i][j];
	}
    }

  output->w->nonZeroFractionAfterSetMask=
    ((REAL4)_countNonZeroes(output->w->wavelet->data))/((REAL4)output->w->wavelet->data->data->length);
  output->w->nonZeroFractionAfterClustering=output->w->nonZeroFractionAfterSetMask;
  return output->w->nonZeroFractionAfterSetMask;
}

static void _unitCopy(LALUnit *source, LALUnit *destination)
{
  UINT4 i;
  destination->powerOfTen=source->powerOfTen;
  for(i=0;i<LALNumUnits;i++)
    {
      destination->unitNumerator[i]=source->unitNumerator[i];
      destination->unitDenominatorMinusOne[i]=source->unitDenominatorMinusOne[i];
    }
}

static void _writeWavelet(Wavelet *w, FILE *out)
{
  UINT4 i;
  fprintf(out,"%d\n",w->type);
  fprintf(out,"%d\n",w->border);
  fprintf(out,"%d\n",w->treeType);
  fprintf(out,"%d\n",w->level);
  fprintf(out,"%d\n",w->HPFilterLength);
  fprintf(out,"%d\n",w->LPFilterLength);
  fprintf(out,"%s\n",w->data->name);
  fprintf(out,"%d\n",w->data->epoch.gpsSeconds);
  fprintf(out,"%d\n",w->data->epoch.gpsNanoSeconds);
  fprintf(out,"%f\n",w->data->deltaT);
  fprintf(out,"%f\n",w->data->f0);
  fprintf(out,"%d\n",w->data->data->length);

  for(i=0;i<w->data->data->length;i++)
    {
      fprintf(out,"%f ",w->data->data->data[i]);
    }
  fprintf(out,"\n\n");
  fflush(stdout);
}



#endif
