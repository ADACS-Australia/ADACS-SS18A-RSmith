\documentclass{article}
\begin{document}

\section{Comm}

MPI communication utilities.

\subsection{Synopsis}

Types:
\begin{verbatim}
typedef struct
tagMPIId
{
  INT4 numProcs;
  INT4 myId;
  INT4 nameLen;
  CHAR procName[MPI_MAX_PROCESSOR_NAME];
}
MPIId;

typedef struct
tagMPIDebugParams
{
  CHAR *debugger;
  CHAR *progName;
  INT4  delay;
  INT4  myId;
}
MPIDebugParams;

typedef struct
tagMPIMessage
{
  INT4 msg;
  INT4 send;
  INT4 source;
}
MPIMessage;
\end{verbatim}

Functions:
\begin{verbatim}
#include "Comm.h"

void MPIExportEnvironment (Status *status, const CHAR *env, INT4 myId);
void MPIDebug             (Status *status, MPIDebugParams *params);
void MPIKillScript        (Status *status, MPIId *id);

void MPISendMsg (Status *status, MPIMessage *msg, INT4 dest);
void MPIRecvMsg (Status *status, MPIMessage *msg);

void MPISendCHARVector     (Status *status, CHARVector     *vector, INT4 dest);
void MPIRecvCHARVector     (Status *status, CHARVector     *vector, INT4 source);
void MPISendINT2Vector     (Status *status, INT2Vector     *vector, INT4 dest);
void MPIRecvINT2Vector     (Status *status, INT2Vector     *vector, INT4 source);
void MPISendREAL4Vector    (Status *status, REAL4Vector    *vector, INT4 dest);
void MPIRecvREAL4Vector    (Status *status, REAL4Vector    *vector, INT4 source);
void MPISendCOMPLEX8Vector (Status *status, COMPLEX8Vector *vector, INT4 dest);
void MPIRecvCOMPLEX8Vector (Status *status, COMPLEX8Vector *vector, INT4 source);

void MPISendINT2TimeSeries     (Status *status, INT2TimeSeries     *series, INT4 dest);
void MPIRecvINT2TimeSeries     (Status *status, INT2TimeSeries     *series, INT4 source);
void MPISendREAL4TimeSeries    (Status *status, REAL4TimeSeries    *series, INT4 dest);
void MPIRecvREAL4TimeSeries    (Status *status, REAL4TimeSeries    *series, INT4 source);
void MPISendCOMPLEX8TimeSeries (Status *status, COMPLEX8TimeSeries *series, INT4 dest);
void MPIRecvCOMPLEX8TimeSeries (Status *status, COMPLEX8TimeSeries *series, INT4 source);

void MPISendREAL4FrequencySeries    (Status *status, REAL4FrequencySeries    *series, INT4 dest);
void MPIRecvREAL4FrequencySeries    (Status *status, REAL4FrequencySeries    *series, INT4 source);
void MPISendCOMPLEX8FrequencySeries (Status *status, COMPLEX8FrequencySeries *series, INT4 dest);
void MPIRecvCOMPLEX8FrequencySeries (Status *status, COMPLEX8FrequencySeries *series, INT4 source);
\end{verbatim}


\subsection{Description}

The routine \verb+MPIExportEnvironment()+ exports the environment variable
\verb+env+ on the master to all of the slave processes.  The routine
\verb+MPIDebug()+ attatches a debugger to a process.  The routine
\verb+MPIKillScript()+ writes a killscript file that can be executed to
terminate all MPI processes.

Use the routine \verb+MPISendMsg()+ to alert the process \verb+dest+ (which
should call \verb+MPIRecvMsg()+) that there is an incoming message.  Note that
routine \verb+MPIRecvMsg()+ is the only receive that does not require the
source to be identified; the receiver can then identify the source from the
message \verb+msg+ it received.

The remaining routines \verb+MPISend<type>()+ and \verb+MPIRecv<type>()+ send
and receive various LAL types.  The destination and source respectively must
be specified for these routines; thus a communication should begin with the
\verb+MPISendMsg()+ and \verb+MPIRecvMsg()+ routines.


\subsection{Operating Instructions}

File \verb+Main.c+:
\begin{verbatim}
#include <stdlib.h>
#include "mpi.h"
#include "LALStdlib.h"
#include "Comm.h"

/* global variables */
int          debuglevel = 1;
REAL4Vector *vector     = NULL;

void Master (MPIId id);
void Slave  (MPIId id);

int main (int argc, char *argv[])
{
  static Status  status;
  MPIId          id;
  MPIDebugParams debug;

  /* allocate memory */
  
  CreateVector (&status, &vector, 16);

  /* initialize mpi */

  MPI_Init (&argc, &argv);
  MPI_Comm_size (MPI_COMM_WORLD, &id.numProcs);
  MPI_Comm_rank (MPI_COMM_WORLD, &id.myId);
  MPI_Get_processor_name (id.procName, &id.nameLen);

  /* write kill script */

  MPIKillScript (&stat, &id);

  /* attatch Data Display Debugger (ddd) to master */

  MPIExportEnvironment (&stat, "DISPLAY", id.myId);
  debug.debugger = id.myId == 0 ? "ddd" : NULL ; /* attatch ddd to master */
  debug.progName = argv[0];
  debug.delay    = 15;
  debug.myId     = id.myId;
  MPIDebug (&stat, &debug);

  /* startup master or slave */

  if (id.myId == 0)
  {
    Master (id);
  }
  else
  {
    Slave (id);
  }

  /* finalize mpi, free memory, and exit */

  DestroyVector (&status, &vector);
  MPI_Finalize ();
  return 0;
}
\end{verbatim}

File \verb+Master.c+:
\begin{verbatim}
#include <stdlib.h>
#include "LALStdlib.h"
#include "Comm.h"

/* global variable */
extern REAL4Vector *vector;

void Master (MPIId id)
{
  static Status status;
  MPIMessage    message;
  INT4          numProcs = id.numProcs;

  /* while there are slaves left */
  while (numProcs > 1)
  {
    /* receive a message from a slave */
    MPIRecvMsg (&status, &message)

    /* handle the message code */
    switch (message.msg)
    {
      case 0: /* slave is quitting */
        --numProcs;
        break;

      case 1: /* slave is sending data */
        MPIRecvREAL4Vector (&status, vector, message.source);
        break;

      default: /* should never happen */
        abort ();
    }
  }

  return;
}
\end{verbatim}

File \verb+Slave.c+:
\begin{verbatim}
#include "LALStdlib.h"
#include "Comm.h"

/* global variable */
extern REAL4Vector *vector;

void Slave (MPIId id)
{
  static Status status;
  MPIMessage    message;

  /* fill the vector with some data */
  for (i = 0; i < vector->length; ++i)
  {
    vector->data[i] = (id.myId + i) % 5 + 2;
  }

  /* send message to master indicating that slave is ready to send data */
  message.msg    = 1;       /* indicates that data is being sent        */
  message.send   = 1;       /* indicates that slave will send data      */
  message.source = id.myId; /* slave's id                               */
  MPISendMsg (&status, &message, 0);

  /* master now knows data is coming so send it to master */
  MPISendREAL4Vector (&status, vector, 0);

  /* send message to master indicating that slave is quitting   */
  message.msg    = 0;       /* indicates that slave is quitting */
  message.source = id.myId; /* slave's id                       */
  MPISendMsg (&status, &message, 0);

  /* slave is done */
  return;
}
\end{verbatim}

\subsubsection{Options}

\subsubsection{Error conditions}

These functions all set the universal status structure on return.
Error conditions are described in the following table.

\begin{table}
\begin{tabular}{|r|l|p{2in}|}\hline
status  & status          & Description\\
code    & description     & \\\hline
\verb+COMM_ENULL 1 + & Null pointer & \\
\verb+COMM_ESIZE 2 + & Invalid size & \\
\verb+COMM_ESTRL 4 + & String too long & \\
\verb+COMM_EMPIE 8 + & MPI error & \\
\verb+COMM_ESENV 16+ & Couldn't set environment variable & \\
\verb+COMM_ESYSC 32+ & Error executing system command & \\
\hline
\end{tabular}
\caption{Error conditions for all Comm functions}\label{tbl:CV}
\end{table}

\subsection{Algorithms}

\subsection{Accuracy}

\subsection{Tests}

The script \verb+CommTest+ executes a simple MPI test program.

\subsection{Uses}

\subsection{Notes}

\subsection{References}

\end{document}
