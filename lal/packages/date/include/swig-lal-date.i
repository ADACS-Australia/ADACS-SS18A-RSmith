//
//  Copyright (C) 2011 Karl Wette
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with with program; see the file COPYING. If not, write to the
//  Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
//  MA  02111-1307  USA
//

// SWIG extensions to LAL date and time module
// Author: Karl Wette, 2011

// only if included as a SWIG interface file
#ifdef SWIG

///// Methods and operators for LAL GPS time class /////

// Uses code from pylal/src/xlal/datatypes/ligotimegps.c: Copyright (C) 2009 Kipp Cannon

// Make sure LIGOTimeGPS is defined.
%include <lal/LALDatatypes.h>

// Make sure LAL time functions are included.
%header %{
  #include <lal/Date.h>
%}

%extend LIGOTimeGPS {

  // Construct a new LIGOTimeGPS. SWIG doesn't provide its usual
  // default constructor if custom constructors are supplied (as
  // they are below); a destructor is still generated, however,
  // as is a copy constructor if %copyctor is enabled globally.
  LIGOTimeGPS() {
    return new LIGOTimeGPS();
  }

  // Construct a LIGOTimeGPS from a real number.
  LIGOTimeGPS(REAL8 t) {
    return XLALGPSSetREAL8(new LIGOTimeGPS(), t);
  }

  // Construct a LIGOTimeGPS from integer seconds and nanoseconds.
  LIGOTimeGPS(INT4 gpssec) {
    return XLALGPSSet(new LIGOTimeGPS(), gpssec, 0);
  }
  LIGOTimeGPS(INT4 gpssec, INT4 gpsnan) {
    return XLALGPSSet(new LIGOTimeGPS(), gpssec, gpsnan);
  }

  // Construct a LIGOTimeGPS from a string
  LIGOTimeGPS(const char* str) {
    LIGOTimeGPS *gps = new LIGOTimeGPS();
    char *end = NULL;
    if (XLALStrToGPS(gps, str, &end) < 0 || end == str) {
      delete gps;
      return NULL;
    }
    return gps;
  }

  // We implement numeric operators by directly defining Python-style
  // __operator__ methods. While we could have also used C++ operators,
  // it seems that many SWIG language modules simply rename them to the
  // equivalent Python __operator__s, which are then called by the SWIG
  // run-time code for that language when a call to that operator is
  // generated. Using Pythons __operator__s directly also allows us to
  // use some nice __operator__s which do not exist in C++. For example,
  // a class X can provide __roperator__s for binary operations where X
  // appears on the right-hand side, e.g. '3.7 + X'; in this way all
  // binary operations on X can be implemented as methods of the class X.
  // Unfortunately, it seems that not all Python operators are currently
  // supported by other SWIG modules, e.g. Octave does not support the
  // __roperator__s as of SWIG 2.0.3.

  // Numeric unary operators
  %newobject __pos__;
  LIGOTimeGPS* __pos__() {
    return XLALINT8NSToGPS(new LIGOTimeGPS(), +XLALGPSToINT8NS($self));
  }
  %newobject __neg__;
  LIGOTimeGPS* __neg__() {
    return XLALINT8NSToGPS(new LIGOTimeGPS(), -XLALGPSToINT8NS($self));
  }

  // Additive binary operators are generated by the following SWIG macro.
  // NAME is the name of the Python operator; the macros calls the macro
  // named swiglal_LIGOTimeGPS_NAME to perform the C binary operation.
  // If both operands are either LIGOTimeGPSs or integers, an integer op.
  // is performed on the GPS time converted to nanoseconds; otherwise, if
  // either operand is a real number, a floating-point op. is performed on
  // the GPS time converted to seconds.
  %define swiglal_LIGOTimeGPS_additive_operator(NAME)

    // All __operator__s must be declared %newobject since
    // they allocate and return new LIGOTimeGPS instances.
    %newobject __##NAME##__;
    %newobject __r##NAME##__;
    %newobject __i##NAME##__;

    // Perform op. between two LIGOTimeGPSs, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __##NAME##__(LIGOTimeGPS* tgps) {
      return XLALINT8NSToGPS(new LIGOTimeGPS(), swiglal_LIGOTimeGPS_##NAME(XLALGPSToINT8NS($self), XLALGPSToINT8NS(tgps)));
    }

    // Perform op. between a LIGOTimeGPS and an INT4, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __##NAME##__(INT4 t) {
      return XLALINT8NSToGPS(new LIGOTimeGPS(), swiglal_LIGOTimeGPS_##NAME(XLALGPSToINT8NS($self), t * XLAL_BILLION_INT8));
    }

    // Perform op. between an INT4 and a LIGOTimeGPS, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __r##NAME##__(INT4 t) {
      return XLALINT8NSToGPS(new LIGOTimeGPS(), swiglal_LIGOTimeGPS_##NAME(t * XLAL_BILLION_INT8, XLALGPSToINT8NS($self)));
    }

    // Perform op. between a LIGOTimeGPS and a REAL8, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __##NAME##__(REAL8 t) {
      return XLALGPSSetREAL8(new LIGOTimeGPS(), swiglal_LIGOTimeGPS_##NAME(XLALGPSGetREAL8($self), t));
    }

    // Perform op. between a REAL8 and a LIGOTimeGPS, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __r##NAME##__(REAL8 t) {
      return XLALGPSSetREAL8(new LIGOTimeGPS(), swiglal_LIGOTimeGPS_##NAME(t, XLALGPSGetREAL8($self)));
    }

    // Perform op. between two LIGOTimeGPSs, and
    // store the result on the left-hand side.
    LIGOTimeGPS* __i##NAME##__(LIGOTimeGPS* tgps) {
      return XLALINT8NSToGPS(new LIGOTimeGPS(), swiglal_LIGOTimeGPS_##NAME(XLALGPSToINT8NS($self), XLALGPSToINT8NS(tgps)));
    }

    // Perform op. between a LIGOTimeGPS and an INT4, and
    // store the result on the left-hand side.
    LIGOTimeGPS* __i##NAME##__(INT4 t) {
      return XLALINT8NSToGPS(new LIGOTimeGPS(), swiglal_LIGOTimeGPS_##NAME(XLALGPSToINT8NS($self), t * XLAL_BILLION_INT8));
    }

    // Perform op. between a LIGOTimeGPS and a REAL8, and
    // store the result on the left-hand side.
    LIGOTimeGPS* __i##NAME##__(REAL8 t) {
      return XLALGPSSetREAL8(new LIGOTimeGPS(), swiglal_LIGOTimeGPS_##NAME(XLALGPSGetREAL8($self), t));
    }

  %enddef // swiglal_LIGOTimeGPS_additive_operator

  // Addition
  #define swiglal_LIGOTimeGPS_add(X, Y) (X) + (Y)
  swiglal_LIGOTimeGPS_additive_operator(add);

  // Subtraction
  #define swiglal_LIGOTimeGPS_sub(X, Y) (X) - (Y)
  swiglal_LIGOTimeGPS_additive_operator(sub);

  // Multiplicative binary operators are generated by the following SWIG macro.
  // NAME is the name of the Python operator; the macros calls the macro
  // named swiglal_LIGOTimeGPS_NAME to perform the C binary operation. These
  // always perform a floating-point op. on the GPS time converted to seconds.
  %define swiglal_LIGOTimeGPS_multiplicative_operator(NAME)

    // All __operator__s must be declared %newobject since
    // they allocate and return new LIGOTimeGPS instances.
    %newobject __##NAME##__;
    %newobject __r##NAME##__;
    %newobject __i##NAME##__;

    // Perform op. between two LIGOTimeGPSs, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __##NAME##__(LIGOTimeGPS* tgps) {
      return XLALGPSSetREAL8(new LIGOTimeGPS(), swiglal_LIGOTimeGPS_##NAME(XLALGPSGetREAL8($self), XLALGPSGetREAL8(tgps)));
    }

    // Perform op. between a LIGOTimeGPS and a REAL8, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __##NAME##__(REAL8 t) {
      return XLALGPSSetREAL8(new LIGOTimeGPS(), swiglal_LIGOTimeGPS_##NAME(XLALGPSGetREAL8($self), t));
    }

    // Perform op. between a REAL8 and a LIGOTimeGPS, and
    // return the result as a new LIGOTimeGPS.
    LIGOTimeGPS* __r##NAME##__(REAL8 t) {
      return XLALGPSSetREAL8(new LIGOTimeGPS(), swiglal_LIGOTimeGPS_##NAME(t, XLALGPSGetREAL8($self)));
    }

    // Perform op. between two LIGOTimeGPSs, and
    // store the result on the left-hand side.
    LIGOTimeGPS* __i##NAME##__(LIGOTimeGPS* tgps) {
      return XLALGPSSetREAL8(new LIGOTimeGPS(), swiglal_LIGOTimeGPS_##NAME(XLALGPSGetREAL8($self), XLALGPSGetREAL8(tgps)));
    }

    // Perform op. between a LIGOTimeGPS and a REAL8, and
    // store the result on the left-hand side.
    LIGOTimeGPS* __i##NAME##__(REAL8 t) {
      return XLALGPSSetREAL8(new LIGOTimeGPS(), swiglal_LIGOTimeGPS_##NAME(XLALGPSGetREAL8($self), t));
    }

  %enddef // swiglal_LIGOTimeGPS_multiplicative_operator

  // Multiplication
  #define swiglal_LIGOTimeGPS_mul(X, Y) (X) * (Y)
  swiglal_LIGOTimeGPS_multiplicative_operator(mul);

  // Floating-point division
  #define swiglal_LIGOTimeGPS_div(X, Y) (X) / (Y)
  swiglal_LIGOTimeGPS_multiplicative_operator(div);

  // Modulus
  #define swiglal_LIGOTimeGPS_mod(X, Y) fmod( (X), (Y) )
  swiglal_LIGOTimeGPS_multiplicative_operator(mod);

  // Integer division
  #define swiglal_LIGOTimeGPS_floordiv(X, Y) floor( (X) / (Y) )
  swiglal_LIGOTimeGPS_multiplicative_operator(floordiv);

  // Comparison operators are generated by the following SWIG macro.
  // NAME is the name of the Python operator and OP is the C operator.
  // The correct comparison NAME is obtained by comparing the result
  // of the result of XLALGPSCmp() against zero using OP.
  %define swiglal_LIGOTimeGPS_comparison_operator(NAME, OP)

    // Compare two LIGOTimeGPSs
    bool __##NAME##__(LIGOTimeGPS *tgps) {
      return XLALGPSCmp($self, tgps) OP 0;
    }

    // Compare a LIGOTimeGPS and an INT4
    bool __##NAME##__(INT4 t) {
      LIGOTimeGPS tmp;
      return XLALGPSCmp($self, XLALGPSSet(&tmp, t, 0)) OP 0;
    }

    // Compare a LIGOTimeGPS and a REAL8
    bool __##NAME##__(REAL8 t) {
      LIGOTimeGPS tmp;
      return XLALGPSCmp($self, XLALGPSSetREAL8(&tmp, t)) OP 0;
    }

  %enddef

  swiglal_LIGOTimeGPS_comparison_operator(lt, < );
  swiglal_LIGOTimeGPS_comparison_operator(le, <=);
  swiglal_LIGOTimeGPS_comparison_operator(eq, ==);
  swiglal_LIGOTimeGPS_comparison_operator(ne, !=);
  swiglal_LIGOTimeGPS_comparison_operator(gt, > );
  swiglal_LIGOTimeGPS_comparison_operator(ge, >=);

  ///// Additional methods /////

  // Return whether a LIGOTimeGPS is non-zero.
  bool __nonzero__() {
    return $self->gpsSeconds || $self->gpsNanoSeconds;
  }

  // Return integer representations of the LIGOTimeGPS seconds.
  int __int__() {
    return $self->gpsSeconds;
  }
  long __long__() {
    return $self->gpsSeconds;
  }

  // Return the total nanoseconds of a LIGOTimeGPS.
  INT8 ns() {
    return XLALGPSToINT8NS($self);
  }

  // Return a floating-point representation of a LIGOTimeGPS.
  REAL8 __float__() {
    return XLALGPSGetREAL8($self);
  }

  // Return the absolute value of a LIGOTimeGPS.
  %newobject __abs__;
  LIGOTimeGPS* __abs__() {
    return XLALINT8NSToGPS(new LIGOTimeGPS(), llabs(XLALGPSToINT8NS($self)));
  }

  // Return the hash value of a LIGOTimeGPS.
  long __hash__() {
    long hash = (long)$self->gpsSeconds ^ (long)$self->gpsNanoSeconds;
    return hash == -1 ? -2 : hash;
  }

  // Return a string representation of a LIGOTimeGPS. Because
  // XLALGPSToStr() allocates a new string using LAL memory,
  // we use %newobject to make SWIG use a 'newfree' typemap,
  // where we free the string; SWIG will have already copied it
  // to a native scripting-language string to return as output.
  %newobject __str__;
  %typemap(newfree) char* __str__ %{
    if ($1) {
      XLALFree($1);
    }
  %}
  char* __str__() {
    return XLALGPSToStr(NULL, $self);
  }

} // %extend LIGOTimeGPS

#endif // SWIG
