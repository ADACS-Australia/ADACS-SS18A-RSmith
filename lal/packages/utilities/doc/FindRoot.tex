\documentclass{article}
\begin{document}

\section{Find Root}

Brackets and finds roots of a univariate function.

\subsection{Synopsis}
\begin{verbatim}
typedef void (REAL4LALFunction) (Status *s, REAL4 *y, REAL4 x, void *p);

typedef struct
tagFindRootIn
{
  REAL4LALFunction *function;   /* the function             */
  REAL4             xmax;       /* domain maximum           */
  REAL4             xmin;       /* domain minimum           */
  REAL4             xacc;       /* desired accuracy of root */
}
FindRootIn;

void BracketRoot (Status *status, FindRootIn *inout, void *params);

void BisectionFindRoot (Status *status, REAL4 *root, FindRootIn *input, void *params);
\end{verbatim}

\subsection{Description}

The structure \verb+FindRootIn+ contains the function, the domain, and the
accuracy to which the root is to be found.

The routine \verb+BracketRoot+ expands the specified domain until a root is
contained.

The routine \verb+FindRoot+ bisects the domain (which must contain one root)
until the root is found with the desired accuracy.

\subsection{Operating Instructions}

Suppose we want to find the root of the function $y = F(x;y_0) = y_0 + x^2$.
Define the function:
\begin{verbatim}
void F (Status *status, REAL4 *y, REAL4 x, void *y0)
{
  INITSTATUS (status);
  ASSERT (y0, status, 1, "Null pointer");
  *y = *(REAL4 *)y0 + x*x;
  RETURN (status);
}
\end{verbatim}

Then use the following code to bracket and find the root $x_0=1$ where
$F(x_0;y_0=-1)=0$:
\begin{verbatim}
static Status status;
FindRootIn    input;
REAL4         y0;
REAL4         x0;

y0             = -1;
input.function = F;
input.xmin     = 0.1;
input.xmax     = 0.2;
input.xacc     = 1e-5;

/* expand domain until a root is bracketed */
BracketRoot (&status, &input, &y0);

/* bisect domain until root is found */
BisectionFindRoot (&status, &x0, &input, &y0);
\end{verbatim}

\begin{itemize}
\item\verb+input+ is a structure containing (i) the function, (ii) the domain
of the function, and (iii) the accuracy to which you will find the root.  The
domain must contain one root for the bisection to work; this root can be
bracketed using an initial-guess domain and the bracketing routine.
\item\verb+y0+ is a function parameter (set to \verb+NULL+ for functions that
don't require parameters).  Function is responsible for parsing the
parameters---the root finding code just passes them along!
\item\verb+x0+ is the root (to within the specified accuracy).
\end{itemize}

\subsubsection{Options}

\subsubsection{Error conditions}

These functions all set the universal status structure on return.
Error conditions are described in the following table.

\begin{table}
\begin{tabular}{|r|l|p{2in}|}\hline
status  & status          & Description\\
code    & description     & \\\hline
\verb+FINDROOT_ENULL 1+ & Null pointer & \\
\verb+FINDROOT_EIDOM 2+ & Invalid initial domain & \\
\verb+FINDROOT_EMXIT 4+ & Maximum iterations exceeded & \\
\verb+FINDROOT_EBRKT 8+ & Root not bracketed & \\
\hline
\end{tabular}
\caption{Error conditions for all FindRoot functions}\label{tbl:CV}
\end{table}

\subsection{Algorithms}

This is an implementation of the root bracketing and bisection finding
routines \verb+zbrac+ and \verb+rtbis+ in Numerical Recipes~\cite{ptvf:1992}.

\subsection{Accuracy}

\subsection{Tests}

The program \verb+FindRootTest+ tests that a root is correctly bracketed and
found (to within the desired accuracy) and tests the various error conditions.

\subsection{Uses}

\subsection{Notes}

\subsection{References}
\begin{thebibliography}{0}
\bibitem{ptvf:1992}
  W. H. Press, S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery,
  \textit{Numerical Recipes in C: The Art of Scientific Computing}, 2nd ed.
  (Cambridge University Press, Cambridge, England, 1992).
\end{thebibliography}

\end{document}
