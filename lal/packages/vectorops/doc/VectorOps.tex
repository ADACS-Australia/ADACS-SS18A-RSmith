\documentclass{article}
\begin{document}
\section{VectorOps}

\subsection{Purpose}

Multiply and divide vectors.

\subsection{Synopsis}

% Syntax: argument definitions, calling signature

\begin{verbatim}
#include "VectorOps.h"

void CCVectorMultiply (
    Status               *status,
    COMPLEX8Vector       *out, 
    const COMPLEX8Vector *in1,
    const COMPLEX8Vector *in2
    );

void CCVectorMultiplyConjugate (
    Status               *status,
    COMPLEX8Vector       *out, 
    const COMPLEX8Vector *in1,
    const COMPLEX8Vector *in2
    );

void CCVectorDivide (
    Status               *status,
    COMPLEX8Vector       *out, 
    const COMPLEX8Vector *in1,
    const COMPLEX8Vector *in2
    );

void SCVectorMultiply(
    Status               *status,
    COMPLEX8Vector       *out,
    const REAL4Vector    *in1,
    const COMPLEX8Vector *in2
    );

void SSVectorMultiply(
    Status               *status,
    REAL4Vector          *out,
    const REAL4Vector    *in1,
    const REAL4Vector    *in2
    );

\end{verbatim}

\subsection{Description}

Let \texttt{u}, \texttt{v}, and \texttt{w} be objects of type
\texttt{COMPLEX8Vector}, and let \texttt{a}, \texttt{b}, and \texttt{c} be
objects of type \texttt{REAL4Vector}.

The \verb:CCVectorMultiply (&status, &w, &u, &v): function computes
$\texttt{w.data[i]}=\texttt{u.data[i]}\times\texttt{v.data[i]}$.

The \verb:CCVectorMultiplyConjugate (&status, &w, &u, &v): function computes
$\texttt{w.data[i]}=\texttt{u.data[i]}\times\texttt{v.data[i]}^\ast$.

The \verb:CCVectorDivide (&status, &w, &u, &v): function computes
$\texttt{w.data[i]}=\texttt{u.data[i]}/\texttt{v.data[i]}$.

The \verb:SCVectorMultiply (&status, &w, &a, &v): function computes
$\texttt{w.data[i]}=\texttt{a.data[i]}\times\texttt{v.data[i]}$.

The \verb:SSVectorMultiply (&status, &c, &a, &b): function computes
$\texttt{c.data[i]}=\texttt{a.data[i]}\times\texttt{b.data[i]}$.

\subsection{Operating Instructions}

% Detailed usage 

\begin{verbatim}
Status *status; 

COMPLEX8Vector *u;
COMPLEX8Vector *v;
COMPLEX8Vector *w;

REAL4Vector *a;
REAL4Vector *b;
REAL4Vector *c;

(void) CCVectorMultiply          (status, w, u, v);
(void) CCVectorMultiplyConjugate (status, w, u, v);
(void) CCVectorDivide            (status, w, u, v);
(void) SCVectorMultiply          (status, w, a, v);
(void) SSVectorMultiply          (status, c, a, b);
\end{verbatim}

\subsubsection{Arguments}

% Describe meaning of each argument

\begin{itemize}
\item \texttt{status} is pointer to a universal status strucure. Its contents
are assigned by the functions.
\item \texttt{u}, \texttt{v}, and \texttt{w} are a pointers to complex vectors
of type \texttt{<COMPLEX8Vector>}.  They must be non-NULL, have positive length
($\texttt{w->length}>0$), and have allocated memory for data
($\texttt{w->data}\neq\texttt{NULL}$).
\item \texttt{a}, \texttt{b}, and \texttt{c} are a pointers to real vectors
of type \texttt{<REAL4Vector>}.  They must be non-NULL, have positive length
($\texttt{c->length}>0$), and have allocated memory for data
($\texttt{c->data}\neq\texttt{NULL}$).
\end{itemize}

\subsubsection{Options}

None. 

\subsubsection{Error conditions}

% What constitutes an error condition? What do the error codes mean?

These functions all set the universal status structure on return.
Error conditions are described in the following table.

\begin{table}
\begin{tabular}{|r|l|r|}\hline
status & status        & Description\\
code   & description   & \\\hline
ENULL  & null pointer  & address of vector and data must be non-NULL\\
ESIZE  & invalid size  & vector length must be positive\\
ESZMM  & size mismatch & vector lengths must agree\\
\hline
\end{tabular}
\caption{Error conditions for all VectorOperations}\label{tbl:CV}
\end{table}
                                
\subsection{Algorithms}

The algorithm for complex division is described in
Sec.~5.4 of Ref.~\cite{ptvf:1992}.  The formula used is:
\[
  \frac{a + ib}{c + id} = \left\{
  \begin{array}{ll}
    \frac{[a + b(d/c)] + i[b - a(d/c)]}{c + d(d/c)} & |c| \ge |d| \\
    \frac{[a(c/d) + b] + i[b(c/d) - a]}{c(c/d) + d} & |c| < |d|.
  \end{array}
  \right.
\]

% Describe algorithm by which work is done

\subsection{Accuracy}

% For numerical routines address issues related to accuracy:
% approximations, argument ranges, etc.

Standard accuracy for 4-byte floating point arithmetic.

\subsection{Tests}

% Describe the tests that are part of the test suite

The test program \texttt{VectorOpsTest} performs the following tests of
the vector operations:
\begin{itemize}
\item Sample calculations of
\begin{itemize}
\item complex-complex multiplication using \texttt{ccVectorMultiply()}
\item complex-complex conjugate multiplication using
  \texttt{ccVectorMultiplyConjugate()}
\item complex-complex division using \texttt{ccVectorDivide()}
\item scalar-complex multiplication using \texttt{scVectorMultiply()}
\item scalar-scalar multiplication using \texttt{ssVectorMultiply()}
\end{itemize}
\item Error return tests
\begin{itemize}
\item NULL vector argument
\item vector argument with NULL data field
\item vector argument with zero length field
\item vector arguments with different length fields
\end{itemize}
\end{itemize}

\subsection{Uses}

% What LAL, other routines does this one call?

\texttt{InitStatus}, \texttt{StatusHandler}

\subsection{Notes}

\subsection{References}

% Any references for algorithms, tests, etc.
\begin{thebibliography}{0}
\bibitem{ptvf:1992}
  W. H. Press, S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery,
  \textit{Numerical Recipes in C: The Art of Scientific Computing}, 2nd ed.
  (Cambridge University Press, Cambridge, 1992).
\end{thebibliography}

\end{document}
