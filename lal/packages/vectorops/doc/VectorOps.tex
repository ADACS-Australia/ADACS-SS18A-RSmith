\documentclass{article}
\begin{document}
\section{VectorOps}

\subsection{Purpose}

Multiply and divide vectors.

\subsection{Synopsis}

% Syntax: argument definitions, calling signature

\begin{verbatim}
#include "VectorOps.h"

void CCVectorMultiply (
    Status               *status,
    COMPLEX8Vector       *out, 
    const COMPLEX8Vector *in1,
    const COMPLEX8Vector *in2
    );

void CCVectorMultiplyConjugate (
    Status               *status,
    COMPLEX8Vector       *out, 
    const COMPLEX8Vector *in1,
    const COMPLEX8Vector *in2
    );

void CCVectorDivide (
    Status               *status,
    COMPLEX8Vector       *out, 
    const COMPLEX8Vector *in1,
    const COMPLEX8Vector *in2
    );

void SCVectorMultiply(
    Status               *status,
    COMPLEX8Vector       *out,
    const REAL4Vector    *in1,
    const COMPLEX8Vector *in2
    );

void SSVectorMultiply(
    Status               *status,
    REAL4Vector          *out,
    const REAL4Vector    *in1,
    const REAL4Vector    *in2
    );

void CVectorAbs (
    Status               *status,
    REAL4Vector          *out,
    const COMPLEX8Vector *in
    );


void CVectorAngle (
    Status               *status,
    REAL4Vector          *out,
    const COMPLEX8Vector *in
    );


void UnwrapREAL4Angle (
    Status               *status,
    REAL4Vector          *out,
    const REAL4Vector    *in
    );


void ZVectorAbs (
    Status                *status,
    REAL8Vector           *out,
    const COMPLEX16Vector *in
    );


void ZVectorAngle (
    Status                *status,
    REAL8Vector           *out,
    const COMPLEX16Vector *in
    );


void UnwrapREAL8Angle (
    Status               *status,
    REAL8Vector          *out,
    const REAL8Vector    *in
    );
\end{verbatim}

\subsection{Description}

Let \texttt{u}, \texttt{v}, and \texttt{w} be objects of type
\texttt{COMPLEX8Vector}, and let \texttt{a}, \texttt{b}, and \texttt{c} be
objects of type \texttt{REAL4Vector}.

The \verb:CCVectorMultiply (&status, &w, &u, &v): function computes
$\texttt{w.data[i]}=\texttt{u.data[i]}\times\texttt{v.data[i]}$.

The \verb:CCVectorMultiplyConjugate (&status, &w, &u, &v): function computes
$\texttt{w.data[i]}=\texttt{u.data[i]}\times\texttt{v.data[i]}^\ast$.

The \verb:CCVectorDivide (&status, &w, &u, &v): function computes
$\texttt{w.data[i]}=\texttt{u.data[i]}/\texttt{v.data[i]}$.

The \verb:SCVectorMultiply (&status, &w, &a, &v): function computes
$\texttt{w.data[i]}=\texttt{a.data[i]}\times\texttt{v.data[i]}$.

The \verb:SSVectorMultiply (&status, &c, &a, &b): function computes
$\texttt{c.data[i]}=\texttt{a.data[i]}\times\texttt{b.data[i]}$.

The \verb:CVectorAbs (&status, &a, &u): function computes
the magnitude of a complex vector \texttt{u}.
$\texttt{a.data[i]}=\texttt{sqrt} (
\texttt{u.data[i].re}^2 + \texttt{v.data[i].im}^2 ) $.


The \verb:CVectorAngle (&status, &a, &u): function computes
the phase angle of a complex vector \texttt{u}
 in the interval $[-\pi, \pi]$ radians.\\
$\texttt{a.data[i]}=\texttt{atan2} (
\texttt{u.data[i].im}, \texttt{v.data[i].re} ) $.

The \verb:UnwrapREAL4Angle (&status, &a, &b): function
 corrects the radian phase angles of a real vector  \texttt{b}
 by adding multiples of
 $\pm\pi$ when the absolute jumps between consecutive
 angle elements are greater than $\pi$ radians.
This function detects branch cut crossings, but it can be 
 fooled by sparse, rapidly changing phase values.


\subsection{Operating Instructions}

% Detailed usage 

\begin{verbatim}
Status *status; 

COMPLEX8Vector *u;
COMPLEX8Vector *v;
COMPLEX8Vector *w;

REAL4Vector *a;
REAL4Vector *b;
REAL4Vector *c;

(void) CCVectorMultiply          (status, w, u, v);
(void) CCVectorMultiplyConjugate (status, w, u, v);
(void) CCVectorDivide            (status, w, u, v);
(void) SCVectorMultiply          (status, w, a, v);
(void) SSVectorMultiply          (status, c, a, b);
(void) CVectorAbs                (status, a, u);
(void) CVectorAngle              (status, a, u);
(void) UnwrapREAL4Angle          (status, a, b);
\end{verbatim}

\subsubsection{Arguments}

% Describe meaning of each argument

\begin{itemize}
\item \texttt{status} is pointer to a universal status strucure. Its contents
are assigned by the functions.
\item \texttt{u}, \texttt{v}, and \texttt{w} are a pointers to complex vectors
of type \texttt{<COMPLEX8Vector>}.  They must be non-NULL, have positive length
($\texttt{w->length}>0$), and have allocated memory for data
($\texttt{w->data}\neq\texttt{NULL}$).
\item \texttt{a}, \texttt{b}, and \texttt{c} are a pointers to real vectors
of type \texttt{<REAL4Vector>}.  They must be non-NULL, have positive length
($\texttt{c->length}>0$), and have allocated memory for data
($\texttt{c->data}\neq\texttt{NULL}$).
For the UnwrapREAL4Angle function, \texttt{a}, and \texttt{b} should  not
point to the same memory location ($\texttt{a != b}$).
\end{itemize}

\subsubsection{Options}

None. 

\subsubsection{Error conditions}

% What constitutes an error condition? What do the error codes mean?

These functions all set the universal status structure on return.
Error conditions are described in the following table.

\begin{table}
\begin{tabular}{|r|l|r|}\hline
status & status        & Description\\
code   & description   & \\\hline
ENULL  & null pointer  & address of vector and data must be non-NULL\\
ESIZE  & invalid size  & vector length must be positive\\
ESZMM  & size mismatch & vector lengths must agree\\
ESAME & invalid pointer & Input/Output addresses must be different\\
\hline
\end{tabular}
\caption{Error conditions for all VectorOperations}\label{tbl:CV}
\end{table}
                                
\subsection{Algorithms}

The algorithm for complex division is described in
Sec.~5.4 of Ref.~\cite{ptvf:1992}.  The formula used is:
\[
  \frac{a + ib}{c + id} = \left\{
  \begin{array}{ll}
    \frac{[a + b(d/c)] + i[b - a(d/c)]}{c + d(d/c)} & |c| \ge |d| \\
    \frac{[a(c/d) + b] + i[b(c/d) - a]}{c(c/d) + d} & |c| < |d|.
  \end{array}
  \right.
\]

The algorithm for UnwrapREAL4Angle
 (Inspired from the MATLAP function unwrap):
\begin{verbatim}

  a = in->data;
  b = out->data;
  n = out->length;
  
  cumsum = 0.0;
  phaseI = *a;
  *b = phaseI;
  --n;

  while (n-- > 0)
  {
    ++a;
    ++b;
    phaseII = *a;
    diffph = phaseII - phaseI;
    phaseI = phaseII;
    
    cumsum += LAL_TWOPI*( (diffph < - LAL_PI) - (diffph > LAL_PI) );
    
    *b= phaseII + cumsum;
  }

\end{verbatim}


% Describe algorithm by which work is done

\subsection{Accuracy}

% For numerical routines address issues related to accuracy:
% approximations, argument ranges, etc.

Standard accuracy for 4-byte floating point arithmetic.

\subsection{Tests}

% Describe the tests that are part of the test suite

The test program \texttt{VectorOpsTest} performs the following tests of
the vector operations:
\begin{itemize}
\item Sample calculations of
\begin{itemize}
\item complex-complex multiplication using \texttt{ccVectorMultiply()}
\item complex-complex conjugate multiplication using
  \texttt{ccVectorMultiplyConjugate()}
\item complex-complex division using \texttt{ccVectorDivide()}
\item scalar-complex multiplication using \texttt{scVectorMultiply()}
\item scalar-scalar multiplication using \texttt{ssVectorMultiply()}
\item compute  the magnitude of a complex vector using
      \texttt{CVectorAbs2()}
\item compute  the phase angle of a complex vector using
      \texttt{CVectorAngle()}
\item correct  the phase angle  using
           \texttt{UnwrapREAL4Angle()}
\end{itemize}
\item Error return tests
\begin{itemize}
\item NULL vector argument
\item vector argument with NULL data field
\item vector argument with zero length field
\item vector arguments with different length fields
\item Input/Output arguments are pointing to the same memory location
\end{itemize}
\end{itemize}

\subsection{Uses}

% What LAL, other routines does this one call?

\subsection{Notes}

\subsection{References}

% Any references for algorithms, tests, etc.
\begin{thebibliography}{0}
\bibitem{ptvf:1992}
  W. H. Press, S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery,
  \textit{Numerical Recipes in C: The Art of Scientific Computing}, 2nd ed.
  (Cambridge University Press, Cambridge, 1992).
\end{thebibliography}

\end{document}
