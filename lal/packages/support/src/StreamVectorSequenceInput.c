/******************** <lalVerbatim file="StreamVectorSequenceInputCV">
Author: Creighton, T. D.
$Id$
**************************************************** </lalVerbatim> */

/********************************************************** <lalLaTeX>

\subsection{Module \texttt{StreamVectorSequenceInput.c}}
\label{ss:StreamVectorSequenceInput.c}

Reads the entire contents of an input stream into a vector sequence.

\subsubsection*{Prototypes}
\vspace{0.1in}
\input{StreamVectorSequenceInputCP}
\idx{LALCHARReadVectorSequence()}
\idx{LALI2ReadVectorSequence()}
\idx{LALI4ReadVectorSequence()}
\idx{LALI8ReadVectorSequence()}
\idx{LALU2ReadVectorSequence()}
\idx{LALU4ReadVectorSequence()}
\idx{LALU8ReadVectorSequence()}
\idx{LALSReadVectorSequence()}
\idx{LALDReadVectorSequence()}

\subsubsection*{Description}

These routines read data from the I/O stream \verb@*stream@ until the
end-of-input is reached.  Each line is stored as a data vector, and
the vectors are combined into a LAL vector sequence structure
\verb@**sequence@.  Each line vector is padded with zeros to match the
length of the longest line.  The routine passes back a pointer to the
new structure.

The routine \verb@LALCHARReadVectorSequence()@ essentially stores an
image of the I/O stream as a sequence of lines padded with \verb@'\0'@
characters.  However, it will skip over any empty lines, which occur,
for instance, when the end-of-input or a null character \verb@'\0'@
occurs immediately following a newline character \verb@'\n'@.  The
numeric routines will additionally skip blank lines, comment lines, or
other input lines that have no parseable numbers in them.  (As with
the routines in \verb@StreamVectorInput.c@, comment in sindicated by a
\verb@#@ sign at the beginning of a line or a \verb@%@ sign anywhere
in the line, signifying that the remainder of the line is to be
ignored.)  However, if an input line contains \emph{any} parseable
data, then the corresponding vector in the vector sequence will be
allocated (and padded with zeros, if it is shorter than the longest
line).

\subsubsection*{Algorithm}

These functions first create a linked list of vectors, using the
routines in \verb@StreamVectorInput.c@ to read them in.  Once the list
is complete, the longest vector length is determined, and the vector
sequence is created and filled.

The numeric routines skip over blank, comment, or otherwise
unparseable lines by catching and handling the \verb@LEN@ error code
generated by the vector input routine.  However, it is worth pointing
out that the vector input routine will have generated an error message
if the error reporting bit in \verb@lalDebugLevel@ was set.  The
vector sequence input routines will therefore generate a followup
messages indicating that the preceding error was successfully dealt
with.  So you may see pairs of \verb@ABORT:@ and \verb@CONTINUE:@
error messages when reading files containing blank or comment lines.

\subsubsection*{Uses}
\begin{verbatim}
LALCalloc()         LALFree()
LALCHARReadVector() LALCHARDestroyVector() LALCHARCreateVectorSequence()
LALI2ReadVector()   LALI2DestroyVector()   LALI2CreateVectorSequence()
LALI4ReadVector()   LALI4DestroyVector()   LALI4CreateVectorSequence()
LALI8ReadVector()   LALI8DestroyVector()   LALI8CreateVectorSequence()
LALU2ReadVector()   LALU2DestroyVector()   LALU2CreateVectorSequence()
LALU4ReadVector()   LALU4DestroyVector()   LALU4CreateVectorSequence()
LALU8ReadVector()   LALU8DestroyVector()   LALU8CreateVectorSequence()
LALSReadVector()    LALSDestroyVector()    LALSCreateVectorSequence()
LALDReadVector()    LALDDestroyVector()    LALDCreateVectorSequence()
\end{verbatim}

\subsubsection*{Notes}

\vfill{\footnotesize\input{StreamVectorSequenceInputCV}}

******************************************************* </lalLaTeX> */

#include <lal/LALStdlib.h>
#include <lal/AVFactories.h>
#include <lal/SeqFactories.h>
#include <lal/StreamInput.h>

NRCSID( STREAMVECTORSEQUENCEINPUTC, "$Id$" );

/* Define linked-list of pointers to vectors of arbitrary type. */
typedef union tagVector {
  CHARVector *CHV;
  INT2Vector *I2V;
  INT4Vector *I4V;
  INT8Vector *I8V;
  UINT2Vector *U2V;
  UINT4Vector *U4V;
  UINT8Vector *U8V;
  REAL4Vector *SV;
  REAL8Vector *DV;
} Vector;
typedef struct tagVectorList {
  Vector vector;
  struct tagVectorList *next;
} VectorList;

static const VectorList empty;


#define FREECHARVECTORLIST                                           \
do {                                                                 \
  if ( head.vector.CHV ) {                                           \
    TRY( LALCHARDestroyVector( stat->statusPtr,                      \
			     &(head.vector.CHV) ), stat );           \
  }                                                                  \
  here = head.next;                                                  \
  while ( here ) {                                                   \
    VectorList *nextPtr = here->next;                                \
    if ( here->vector.CHV ) {                                        \
      TRY( LALCHARDestroyVector( stat->statusPtr,                    \
			       &(here->vector.CHV) ), stat );        \
    }                                                                \
    LALFree( here );                                                 \
    here = nextPtr;                                                  \
  }                                                                  \
} while (0)

/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALCHARReadVectorSequence( LALStatus          *stat,
			   CHARVectorSequence **sequence,
			   FILE               *stream )
{ /* </lalVerbatim> */
  VectorList head = empty;   /* head of linked list of vectors */
  VectorList *here;          /* pointer to current position in list */
  CHAR *data;                /* pointer to vector data */
  UINT4 nRows, nCols;        /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALCHARReadVectorSequence",
	      STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    TRY( LALCHARReadVector( stat->statusPtr, &(head.vector.CHV), stream ),
	 stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    if ( !here->next ) {
      FREECHARVECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    here = here->next;
    LALCHARReadVector( stat->statusPtr, &(here->vector.CHV), stream );
    BEGINFAIL( stat ) {
      FREECHARVECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    } ENDFAIL( stat );
  }

  /* Lines have been read.  Now determine the maximum line length, and
     allocate the vector sequence.  Ignore lines containing only a
     single '\0' character. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.CHV->length > 1 ) {
      nRows++;
      if ( here->vector.CHV->length > nCols )
	nCols = here->vector.CHV->length;
    }
    here = here->next;
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALCHARCreateVectorSequence( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREECHARVECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    UINT4 length = here->vector.CHV->length;
    if ( length > 1 ) {
      memcpy( data, here->vector.CHV->data, length );
      if ( nCols - length > 0 )
	memset( data + length, 0, nCols - length );
      data += nCols;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREECHARVECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define \
FREEI2VECTORLIST \
do { \
  if ( head.vector.I2V ) { \
    TRY( LALI2DestroyVector ( stat->statusPtr, &(head.vector.I2V) ), stat ); \
  } \
  here = head.next; \
  while ( here ) { \
    VectorList *nextPtr = here->next; \
    if ( here->vector.I2V ) { \
      TRY( LALI2DestroyVector ( stat->statusPtr, &(here->vector.I2V) ), stat ); \
    } \
    LALFree( here ); \
    here = nextPtr; \
  } \
} while (0)

/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALI2ReadVectorSequence ( LALStatus  *stat, INT2VectorSequence **sequence, FILE *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  INT2 *data;           /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALI2ReadVectorSequence", STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    TRY( LALI2ReadVector ( stat->statusPtr, &(head.vector.I2V), stream, 0 ),
	 stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    here = here->next;
    if ( !here ) {
      FREEI2VECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    LALI2ReadVector ( stat->statusPtr, &(here->vector.I2V), stream, 0 );
    BEGINFAIL( stat ) {
      FREEI2VECTORLIST;
    } ENDFAIL( stat );
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.I2V ) {
      if ( here->vector.I2V->length > nCols )
	nCols = here->vector.I2V->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREEI2VECTORLIST;
    ABORT( stat, STREAMINPUTH_ELEN, STREAMINPUTH_MSGELEN );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALI2CreateVectorSequence ( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREEI2VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.I2V ) {
      UINT4 i;
      UINT4 length = here->vector.I2V->length;
      INT2 *hereData = here->vector.I2V->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 2*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREEI2VECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define \
FREEI4VECTORLIST \
do { \
  if ( head.vector.I4V ) { \
    TRY( LALI4DestroyVector ( stat->statusPtr, &(head.vector.I4V) ), stat ); \
  } \
  here = head.next; \
  while ( here ) { \
    VectorList *nextPtr = here->next; \
    if ( here->vector.I4V ) { \
      TRY( LALI4DestroyVector ( stat->statusPtr, &(here->vector.I4V) ), stat ); \
    } \
    LALFree( here ); \
    here = nextPtr; \
  } \
} while (0)

/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALI4ReadVectorSequence ( LALStatus  *stat, INT4VectorSequence **sequence, FILE *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  INT4 *data;           /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALI4ReadVectorSequence", STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    TRY( LALI4ReadVector ( stat->statusPtr, &(head.vector.I4V), stream, 0 ),
	 stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    here = here->next;
    if ( !here ) {
      FREEI4VECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    LALI4ReadVector ( stat->statusPtr, &(here->vector.I4V), stream, 0 );
    BEGINFAIL( stat ) {
      FREEI4VECTORLIST;
    } ENDFAIL( stat );
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.I4V ) {
      if ( here->vector.I4V->length > nCols )
	nCols = here->vector.I4V->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREEI4VECTORLIST;
    ABORT( stat, STREAMINPUTH_ELEN, STREAMINPUTH_MSGELEN );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALI4CreateVectorSequence ( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREEI4VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.I4V ) {
      UINT4 i;
      UINT4 length = here->vector.I4V->length;
      INT4 *hereData = here->vector.I4V->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 4*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREEI4VECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define \
FREEI8VECTORLIST \
do { \
  if ( head.vector.I8V ) { \
    TRY( LALI8DestroyVector ( stat->statusPtr, &(head.vector.I8V) ), stat ); \
  } \
  here = head.next; \
  while ( here ) { \
    VectorList *nextPtr = here->next; \
    if ( here->vector.I8V ) { \
      TRY( LALI8DestroyVector ( stat->statusPtr, &(here->vector.I8V) ), stat ); \
    } \
    LALFree( here ); \
    here = nextPtr; \
  } \
} while (0)

/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALI8ReadVectorSequence ( LALStatus  *stat, INT8VectorSequence **sequence, FILE *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  INT8 *data;           /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALI8ReadVectorSequence", STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    TRY( LALI8ReadVector ( stat->statusPtr, &(head.vector.I8V), stream, 0 ),
	 stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    here = here->next;
    if ( !here ) {
      FREEI8VECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    LALI8ReadVector ( stat->statusPtr, &(here->vector.I8V), stream, 0 );
    BEGINFAIL( stat ) {
      FREEI8VECTORLIST;
    } ENDFAIL( stat );
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.I8V ) {
      if ( here->vector.I8V->length > nCols )
	nCols = here->vector.I8V->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREEI8VECTORLIST;
    ABORT( stat, STREAMINPUTH_ELEN, STREAMINPUTH_MSGELEN );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALI8CreateVectorSequence ( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREEI8VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.I8V ) {
      UINT4 i;
      UINT4 length = here->vector.I8V->length;
      INT8 *hereData = here->vector.I8V->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 8*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREEI8VECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define \
FREEU2VECTORLIST \
do { \
  if ( head.vector.U2V ) { \
    TRY( LALU2DestroyVector ( stat->statusPtr, &(head.vector.U2V) ), stat ); \
  } \
  here = head.next; \
  while ( here ) { \
    VectorList *nextPtr = here->next; \
    if ( here->vector.U2V ) { \
      TRY( LALU2DestroyVector ( stat->statusPtr, &(here->vector.U2V) ), stat ); \
    } \
    LALFree( here ); \
    here = nextPtr; \
  } \
} while (0)

/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALU2ReadVectorSequence ( LALStatus  *stat, UINT2VectorSequence **sequence, FILE *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  UINT2 *data;           /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALU2ReadVectorSequence", STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    TRY( LALU2ReadVector ( stat->statusPtr, &(head.vector.U2V), stream, 0 ),
	 stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    here = here->next;
    if ( !here ) {
      FREEU2VECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    LALU2ReadVector ( stat->statusPtr, &(here->vector.U2V), stream, 0 );
    BEGINFAIL( stat ) {
      FREEU2VECTORLIST;
    } ENDFAIL( stat );
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.U2V ) {
      if ( here->vector.U2V->length > nCols )
	nCols = here->vector.U2V->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREEU2VECTORLIST;
    ABORT( stat, STREAMINPUTH_ELEN, STREAMINPUTH_MSGELEN );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALU2CreateVectorSequence ( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREEU2VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.U2V ) {
      UINT4 i;
      UINT4 length = here->vector.U2V->length;
      UINT2 *hereData = here->vector.U2V->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 2*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREEU2VECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define \
FREEU4VECTORLIST \
do { \
  if ( head.vector.U4V ) { \
    TRY( LALU4DestroyVector ( stat->statusPtr, &(head.vector.U4V) ), stat ); \
  } \
  here = head.next; \
  while ( here ) { \
    VectorList *nextPtr = here->next; \
    if ( here->vector.U4V ) { \
      TRY( LALU4DestroyVector ( stat->statusPtr, &(here->vector.U4V) ), stat ); \
    } \
    LALFree( here ); \
    here = nextPtr; \
  } \
} while (0)

/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALU4ReadVectorSequence ( LALStatus  *stat, UINT4VectorSequence **sequence, FILE *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  UINT4 *data;           /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALU4ReadVectorSequence", STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    TRY( LALU4ReadVector ( stat->statusPtr, &(head.vector.U4V), stream, 0 ),
	 stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    here = here->next;
    if ( !here ) {
      FREEU4VECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    LALU4ReadVector ( stat->statusPtr, &(here->vector.U4V), stream, 0 );
    BEGINFAIL( stat ) {
      FREEU4VECTORLIST;
    } ENDFAIL( stat );
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.U4V ) {
      if ( here->vector.U4V->length > nCols )
	nCols = here->vector.U4V->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREEU4VECTORLIST;
    ABORT( stat, STREAMINPUTH_ELEN, STREAMINPUTH_MSGELEN );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALU4CreateVectorSequence ( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREEU4VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.U4V ) {
      UINT4 i;
      UINT4 length = here->vector.U4V->length;
      UINT4 *hereData = here->vector.U4V->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 4*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREEU4VECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define \
FREEU8VECTORLIST \
do { \
  if ( head.vector.U8V ) { \
    TRY( LALU8DestroyVector ( stat->statusPtr, &(head.vector.U8V) ), stat ); \
  } \
  here = head.next; \
  while ( here ) { \
    VectorList *nextPtr = here->next; \
    if ( here->vector.U8V ) { \
      TRY( LALU8DestroyVector ( stat->statusPtr, &(here->vector.U8V) ), stat ); \
    } \
    LALFree( here ); \
    here = nextPtr; \
  } \
} while (0)

/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALU8ReadVectorSequence ( LALStatus  *stat, UINT8VectorSequence **sequence, FILE *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  UINT8 *data;           /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALU8ReadVectorSequence", STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    TRY( LALU8ReadVector ( stat->statusPtr, &(head.vector.U8V), stream, 0 ),
	 stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    here = here->next;
    if ( !here ) {
      FREEU8VECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    LALU8ReadVector ( stat->statusPtr, &(here->vector.U8V), stream, 0 );
    BEGINFAIL( stat ) {
      FREEU8VECTORLIST;
    } ENDFAIL( stat );
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.U8V ) {
      if ( here->vector.U8V->length > nCols )
	nCols = here->vector.U8V->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREEU8VECTORLIST;
    ABORT( stat, STREAMINPUTH_ELEN, STREAMINPUTH_MSGELEN );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALU8CreateVectorSequence ( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREEU8VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.U8V ) {
      UINT4 i;
      UINT4 length = here->vector.U8V->length;
      UINT8 *hereData = here->vector.U8V->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 8*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREEU8VECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define \
FREESVECTORLIST \
do { \
  if ( head.vector.SV ) { \
    TRY( LALSDestroyVector ( stat->statusPtr, &(head.vector.SV) ), stat ); \
  } \
  here = head.next; \
  while ( here ) { \
    VectorList *nextPtr = here->next; \
    if ( here->vector.SV ) { \
      TRY( LALSDestroyVector ( stat->statusPtr, &(here->vector.SV) ), stat ); \
    } \
    LALFree( here ); \
    here = nextPtr; \
  } \
} while (0)

/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALSReadVectorSequence ( LALStatus  *stat, REAL4VectorSequence **sequence, FILE *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  REAL4 *data;           /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALSReadVectorSequence", STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    TRY( LALSReadVector ( stat->statusPtr, &(head.vector.SV), stream, 0 ),
	 stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    here = here->next;
    if ( !here ) {
      FREESVECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    LALSReadVector ( stat->statusPtr, &(here->vector.SV), stream, 0 );
    BEGINFAIL( stat ) {
      FREESVECTORLIST;
    } ENDFAIL( stat );
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.SV ) {
      if ( here->vector.SV->length > nCols )
	nCols = here->vector.SV->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREESVECTORLIST;
    ABORT( stat, STREAMINPUTH_ELEN, STREAMINPUTH_MSGELEN );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALSCreateVectorSequence ( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREESVECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.SV ) {
      UINT4 i;
      UINT4 length = here->vector.SV->length;
      REAL4 *hereData = here->vector.SV->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 4*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREESVECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define \
FREEDVECTORLIST \
do { \
  if ( head.vector.DV ) { \
    TRY( LALDDestroyVector ( stat->statusPtr, &(head.vector.DV) ), stat ); \
  } \
  here = head.next; \
  while ( here ) { \
    VectorList *nextPtr = here->next; \
    if ( here->vector.DV ) { \
      TRY( LALDDestroyVector ( stat->statusPtr, &(here->vector.DV) ), stat ); \
    } \
    LALFree( here ); \
    here = nextPtr; \
  } \
} while (0)

/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALDReadVectorSequence ( LALStatus  *stat, REAL8VectorSequence **sequence, FILE *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  REAL8 *data;           /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALDReadVectorSequence", STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    TRY( LALDReadVector ( stat->statusPtr, &(head.vector.DV), stream, 0 ),
	 stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    here = here->next;
    if ( !here ) {
      FREEDVECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    LALDReadVector ( stat->statusPtr, &(here->vector.DV), stream, 0 );
    BEGINFAIL( stat ) {
      FREEDVECTORLIST;
    } ENDFAIL( stat );
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.DV ) {
      if ( here->vector.DV->length > nCols )
	nCols = here->vector.DV->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREEDVECTORLIST;
    ABORT( stat, STREAMINPUTH_ELEN, STREAMINPUTH_MSGELEN );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALDCreateVectorSequence ( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREEDVECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.DV ) {
      UINT4 i;
      UINT4 length = here->vector.DV->length;
      REAL8 *hereData = here->vector.DV->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 8*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREEDVECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}
