% This file is meant to be included in another 
\documentclass{article}
\begin{document}
\section{ExcessPower}

\subsection{Purpose}

A set of functions to implement the excess power search
technique which was suggested in Ref.~\cite{fh:1998} and
later independently invented in Ref.~\cite{acdhp:1999}.  The implementation
here is described in detail in Ref.~\cite{abcf:2000}. 



 
\subsection{Synopsis}

% Syntax: argument definitions, calling signature

\begin{verbatim}
#include "ExcessPower.h"

typedef struct
tagTFTile
{
  INT4                             fstart;
  INT4                             fend;
  INT4                             tstart;
  INT4                             tend;
  INT4                             whichPlane;
  REAL8                            excessPower;
  REAL8                            alpha;
  REAL8                            weight;
  BOOLEAN                          firstCutFlag;  
  struct tagTFTile                 *nextTile;
}
TFTile;


typedef struct
tagTFTiling
{
  TFTile                           *firstTile;  /* linked list of Tiles */
  INT4                             numTiles;
  COMPLEX8TimeFrequencyPlane       **tfp;       /* Vector of pointers */
  ComplexDFTParams                 **dftParams; /* Vector of pointers */
  INT4                             numPlanes;
  BOOLEAN                          planesComputed;      
  BOOLEAN                          excessPowerComputed;
  BOOLEAN                          tilesSorted;
}
TFTiling;


typedef struct
tagCreateTFTilingIn
{
  INT4                             overlapFactor;
  INT4                             minFreqBins;
  INT4                             minTimeBins;
  REAL8                            flow;    /* lowest freq to search       */
  REAL8                            deltaF;  
  INT4                             length;  
}
CreateTFTilingIn;


typedef struct
tagComputeExcessPowerIn
{
  REAL8                            numSigmaMin;
  REAL8                            alphaDefault;                             
}
ComputeExcessPowerIn;





void
AddWhiteNoise (
               Status                               *status,
               COMPLEX8Vector                       *v,
               REAL8                                noiseLevel
               );


void
CreateTFTiling (
                Status                              *status,
                TFTiling                            **tfTiling,
                CreateTFTilingIn                    *input
                );


void
DestroyTFTiling (
                 Status                             *status,
                 TFTiling                           **tfTiling
                 );


void
ComputeTFPlanes (
                 Status                             *status,
                 TFTiling                           *tfTiling,
                 COMPLEX8FrequencySeries            *freqSeries
                 );


void
ComputeExcessPower (
                    Status                          *status,
                    TFTiling                        *tfTiling,
                    ComputeExcessPowerIn            *input
                    );


void
SortTFTiling (
              Status                                *status,
              TFTiling                              *tfTiling
              );


void
CountEPEvents (
               Status                               *status,
               INT4                                 *numEvents,
               TFTiling                             *tfTiling,
               REAL8                                alphaThreshold
               );


void
ComputeLikelihood (
                   Status                           *status,
                   REAL8                            *lambda,
                   TFTiling                         *tfTiling
                   );


void 
PrintTFTileList (
                 Status                             *status,
                 FILE                               *fp,
                 TFTiling                           *tfTiling,
                 INT4                               maxTiles
                 );
\end{verbatim}





\subsection{Description}

This package provides a set of functions for implementing the excess
power search method described in \cite{abcf:2000}.  We refer to
that paper for the derivation of and motivation for the search method.
Here we give a brief description of the method.

\subsubsection{General description}

One starts with $N$ complex data points in the frequency domain, so the input
to the search method is a \verb+COMPLEX8FrequencySeries+.  
The current implementation requires that the input noise be white, and
that the real and imaginary parts of each frequency bin have rms value 1
, so frequency domain data should be multiplied by an appropriately
normalized pre-whitening filter before being input to the routines in
the \verb+ExcessPower+ package.  
The implementation also requires that $N$ be a power of 2, so that 
$N =2^p$ for some $p$.  For each integer $i$ with $0 \le i \le p$, one
performs a time-frequency transform of the data (see the package
\verb+TFTransform+) to obtain a time-frequency plane with $N_T$ time bins
and $N_F$ frequency bins, where
\begin{equation}
N_T = 2^i \ \ \ , \ \ N_F = 2^{p-i}.
\label{tfplanes}
\end{equation}
One thus constructs of order $\log_2 N$ different time-frequency
planes. 

The $i$th time-frequency (TF) plane will consist of a $N_T \times N_F$
matrix of complex numbers $H_{J\Gamma}$.  The time resolution
${\overline {\Delta t}}^{(i)}$ and frequency resolution ${\overline
{\Delta f}}^{(i)}$ of the $i$th plane will be given by
\begin{equation}
{\overline {\Delta t}}^{(i)} = 2^{-i} {\overline {\Delta t}}^{(0)} \ \
\ , \ \ \ 
{\overline {\Delta f}}^{(i)} = 2^{i} {\overline {\Delta f}}^{(0)}.
\label{resolutions}
\end{equation}
We will call a submatrix
of any one of these matrices a {\it time-frequency tile}.  A tile will
be specified by giving the TF plane $i$,
and by giving the initial and final times $J_1, J_2$ and initial and
final frequencies $\Sigma_1$, $\Sigma_2$.  We will label tiles
by ${\cal T}$, thus 
\begin{equation}
{\cal T} \equiv (i,J_1,J_2,\Sigma_1,\Sigma_2).
\end{equation}
The tile ${\cal T}$ will consist
of the complex numbers $H_{J\Sigma}$ with $J_1 \le J \le J_2$ and
$\Sigma_1 \le \Sigma \le \Sigma_2$, so there will be 
\begin{equation}
N_{\cal T} = (\Delta J+1) (\Delta \Sigma+1)
\end{equation}
complex numbers in all, where $\Delta J = J_2 - J_1$, $\Delta \Sigma =
\Sigma_2 - \Sigma_1$. 


For any given time-frequency tile 
${\cal T}$ one computes the total power
\begin{equation}
P_{\cal T} = \sum_{J = J_1}^{J_2} \ \sum_{\Sigma=\Sigma_1}^{\Sigma_2}
\ | H_{J\Sigma} |^2.
\label{power}
\end{equation}
In the absence of a signal, $P_{\cal T}$ will be distributed a
chi-squared distribution with $2 N_{\cal T}$ degrees of freedom
\cite{abcf:2000}, so we can compute from $P_{\cal T}$ a probability
\begin{equation}
\alpha_{\cal T} = 1 - p(P_{\cal T},2 N_{\cal T}).
\label{alphadef}
\end{equation}
Here $p(\chi^2,n)$ is the cumulative distribution function for a
chisquared distribution, given by
\begin{equation}
p(\chi^2,n) = {1 \over \Gamma(n/2)} \int_0^{\chi^2/2} dx \, x^{n/2-1} e^{-x};
\end{equation}
see the package \verb+Thresholds+.  We compute the right hand side of
Eq.\ (\ref{alphadef}) using the routine \verb+OneMinusChisqCdf()+.
The expected power for any tile is $\langle P_{\cal T} \rangle = 2
N_{\cal T}$, so the {\it excess power} is
\begin{equation}
\Delta P_{\cal T} = P_{\cal T} - 2 N_{\cal T}.
\label{ep}
\end{equation}







The essential idea of the search method is to search through time
frequency tiles ${\cal T}$, and for each tile to compare the
probability $\alpha_{\cal T}$ to some threshold value $\alpha_*$;
tiles with $\alpha_{\cal T} \le \alpha_*$ will be selected as possible
events.  Of course, the method will zero in on non-Gaussian noise
events in the data as well as on genuine gravitational wave events; it
is only when one coincidences between several detectors (using future
versions of this package) that one can hope to detect genuine
signals.  Thus, the current version of the package is useful mostly
for characterizing the non-Gaussian noise in detector data.


\subsubsection{Tricks for saving computation time}

It would be computationally prohibitive as well as unnecessary to compute
the probability $\alpha_{\cal T}$ for all possible TF tiles ${\cal
T}$.  The strategy adopted to reduce the computational burden is
twofold:  
\begin{itemize}
\item We compute the total power $P_{\cal T}$ only for a discrete set
${\cal T}_j$ of all possible tiles that samples sufficiently finely
the space of all possible tiles.
\item For each tile ${\cal T}_j$, we compute the probability
$\alpha_{\cal T}$ only if the quantity
\begin{equation}
n_{\cal T} \equiv {\Delta P_{\cal T} \over \sqrt{2 N_{\cal T}}}
\label{nsigma}
\end{equation}
satisfies 
\begin{equation}
n_{\cal T} \ge N_{\rm min},
\label{firstcut}
\end{equation}
where $N_{\rm min}$ is a fixed
constant (eg 2 or 3).  The quantity $n_{\cal T}$ is 
roughly the ``number of sigma'' for the detection, and is much less costly
to compute that $\alpha_{\cal T}$.  Since in realistic searches the
threshold $\alpha_*$ will be very small, all tiles that qualify as
events will have $n_{\cal T} \ge$ (a few), so computing
$\alpha_{\cal T}$ only for tiles with $n_{\cal T} \ge N_{\rm min}$
saves a lot of computation time.  [Note though that we cannot in
general threshold on $n_{\cal T}$ as the precise value of the
threshold would depend on $N_{\cal T}$].
\end{itemize}


The algorithm used to select the set of tiles ${\cal T}_j$ is as
follows.  For each TF plane $i$, one loops through values of $J_1$
and $\Delta J$ with
\begin{equation}
0 \le J_1 \le J_1 + \Delta J < N_T,
\end{equation}
where the step size for both $J_1$ and $\Delta J$ is
\begin{equation}
\delta J = 1 + \left[\Delta J / N_{\rm ov} \right].
\end{equation}
Here the brackets mean ``round down to the nearest integer'', and
$N_{\rm ov}$ is a fixed integer of order a few.  The idea is that
successive tiles that differ only in their value of $J_1$ and have
identical values of $\Delta J$ (for example) can have a fractional
overlap as small as $N_{\rm ov} / (N_{\rm ov} + 1)$.  For large $N_T$,
the spacing of the tiles is exhaustive (all possible tiles covered)
for $\Delta J \le $ a few, while the spacing becomes uniform in $\log
(\Delta J)$ for large $\Delta J$.  Similarly, the set of frequencies
$\Sigma_1$ and $\Delta \Sigma$ is determined by 
looping through values of $\Sigma_1$
and $\Delta \Sigma$ with
\begin{equation}
0 \le \Sigma_1 \le \Sigma_1 + \Delta \Sigma < N_F,
\end{equation}
where the step size for both $\Sigma_1$ and $\Delta \Sigma$ is
\begin{equation}
\delta \Sigma = 1 + \left[\Delta \Sigma / N_{\rm ov} \right].
\end{equation}
More detailed explanation of and justification for this method of
sampling the space of TF tiles can be found in \cite{abcf:2000}.
The number $N_{\rm tiles}$ of tiles generated with $N_{\rm ov}=3$ (for
example) is
approximately 
\begin{equation}
N_{\rm tiles} \sim 100 N
\end{equation}
for large $N$, where $N$ is the original number of data points in the
frequency domain.  [By
contrast, an exhaustive search over all possible tiles would give
$N_{\rm tiles} \sim N^2$ for large $N$, neglecting logarithmic factors.]


\subsubsection{The two search methods provided}
\label{twomethods}

This package provides two types of search routines:
\begin{itemize}
\item Routines for which the user specifies the threshold $\alpha_*$.
Then, the routine searches through all tiles ${\cal T}_j$ in the
discrete set discussed above, and returns a list of tiles (candidate
events) for which $\alpha_{\cal T} \le \alpha_*$, sorted in order of
probability.  A drawback of this
approach is that the appropriate value of the threshold $\alpha_*$
depends on how 
statistically independent the individual statistics $\alpha_{\cal T}$
are, and also on how many tiles are being computed.  The correct way
to determine the value of the threshold $\alpha_*$ would be to perform
Monte Carlo simulations.  However, one would need to repeat the Monte
Carlo simulations whenever one changed the search parameters (for
example, the total number of points in the frequency domain, the
number of tiles generated etc.)

\item A more powerful search method is to compute an average ${\bar
\Lambda}$ of the quantity 
\begin{equation}
\Lambda_{\cal T} \equiv {1 \over \alpha_{\cal T}}
\end{equation}
over the space of all TF tiles, and to threshold on the average value
${\bar \Lambda}$.  We will refer to ${\bar \Lambda}$ as the mean likelihood.
Motivation for this can be found in Ref.\ \cite{abcf:2000}.
Data segments for which ${\bar \Lambda} \le {\bar
\Lambda}_*$ are then rejected, while data segments for which
${\bar \Lambda} \ge {\bar \Lambda}_*$ are tagged for further
analysis.  Here ${\bar \Lambda}_*$ is a threshold.  An approximate but
sufficiently accurate formula for the average is \cite{abcf:2000}
\begin{equation}
{\bar \Lambda} = {1 \over N_{\rm tiles}} \, \sum_j \left[{2 N_{{\cal
T}_j} \over (\Delta P_{{\cal T}_j})^2 } \right] \, {1 \over
\alpha_{{\cal T}_j}},
\label{meanlikelihood}
\end{equation}
where $N_{\rm tiles}$ is the total number of tiles in the sum.  Under
suitable assumed prior probability for signals (roughly speaking,
``uniform'' in each tile and ``uniformly distributed'' over all tiles)  
, it can be shown that the probability $p$ that a signal is present in
the data is related to the prior probability $p_0$ that a signal is
present by \cite{abcf:2000}
\begin{equation}
{p \over 1 - p} = {\bar \Lambda} \ {p_0 \over 1 - p_0}.
\label{ff1}
\end{equation}
Thus the user can specify a desired value of $p$ for a given $p_0$, or
equivalently can specify ${\bar \Lambda}$.  

\end{itemize}

In the second method, {\it if} the noise were purely Gaussian and
stationary, the threshold ${\bar \Lambda}_*$ could be prescribed 
without any Monte Carlo simulations, with the (Bayesian)
interpretation being given by Eq.\ (\ref{ff1}).  However, due to the
ubiquitous presence of nonGaussian noise, it will be necessary to
resort to Monte Carlo simulations to determine a (frequentist)
threshold ${\bar \Lambda}_*$.  Even so, the second method will have
significant advantages over the first method \cite{abcf:2000}. 
 

\subsubsection{Explanation of individual routines}
\label{individual}

We now turn to a description of the various routines.  The first
routine, \verb+AddWhiteNoise()+, adds white Gaussian noise to a
\verb+COMPLEX8Vector+.  It takes as an 
input parameter a real number \verb+noiseLevel+, and an input/output
parameter \verb+v+ which is pointer to a \verb+COMPLEX8Vector+.  On
exit from the routine, the vector has been augmented by a random
complex vector of which the real and imaginary parts of each element
are independent, zero-mean Gaussian deviates with rms value
\verb+noiseLevel+.


The next two routines are \verb+CreateTFTiling()+ and
\verb+DestroyTFTiling()+, which create and destroy a data structure of
type \verb+TFTiling+ (time-frequency tiling).  A \verb+TFTiling+
structure consists of the following elements:
\begin{itemize}

\item A pointer \verb+firstTile+ to a structure of type \verb+TFTile+,
which the first in a linked list of such structures.  The
\verb+TFTile+ structure describing time-frequency tiles is described
below.

\item An integer \verb+numTiles+ giving the total number of tiles in
the linked list pointed to by \verb+firstTile+.

\item A integer \verb+numPlanes+ giving the total number $p+1$ of
time-frequency planes.

\item A variable \verb+tfp+ of type 
\verb+COMPLEX8TimeFrequencyPlane**+ (see the package
\verb+TFTransform+).  The quantities *(tfp+i) for $0 \le 
i < p$ constitute a vector of pointers to the $p+1$ frequency planes.

\item A variable \verb+dftParams+ of type 
\verb+ComplexDFTParams**+.  The quantities *(tfp+i) for $0 \le
i < p$ constitute a vector of pointers to the $p+1$ \verb+ComplexDFTParams+
structures (see package \verb+TFTransform+) used to compute the
corresponding TF planes.  The idea is that these structures are set up
once initially and then used to analyze many segments of data.

\item Three boolean flags \verb+planesComputed+,
\verb+excessPowerComputed+, and \verb+tilesSorted+ which are used to
keep track of which procedures have been applied to the
\verb+tfTiling+ data structure.

\end{itemize}



As indicated above, the first element in the \verb+TFTiling+ structure
is a linked list of \verb+TFTile+ structures.  A \verb+TFTile+
structure consists of the following elements.

\begin{itemize}

\item Integers \verb+fstart+, \verb+fend+, \verb+tstart+ and
\verb+tend+ giving the starting and ending times and frequencies of
the TF tile, which are denoted here as $\Sigma_1$, $\Sigma_2$, $J_1$
and $J_2$ respectively.

\item An integer \verb+whichPlane+ indicating which TF plane the TF
tile belongs to.

\item Real numbers \verb+excessPower+ and \verb+alpha+ to store the
quantities $\Delta P_{\cal T}$ and $\alpha_{\cal T}$ for the tile.

\item A real number \verb+weight+ which will be used in future
versions of \verb+ExcessPower+ to compute the average
(\ref{meanlikelihood}) over all TF tiles more accurately.

\item A boolean flag \verb+firstCutFlag+ which is set to \verb+TRUE+
if the tile satisfies the criterion (\ref{firstcut}) and thus passes
the ``first cut'' in the data analysis.  

\end{itemize}




The routine \verb+CreateTFTiling()+ takes as input a pointer
\verb+input+ to a data structure of type \verb+CreateTFTilingIn+,
which consists of the following elements.

\begin{itemize}

\item An integer \verb+overlapFactor+ which was denoted $N_{\rm ov}$
above, and is used in the algorithm to construct a discrete grid of TF
tiles.

\item An integers \verb+minFreqBins+ and giving the smallest extent in
frequency of TF tiles to be searched over.  Only tiles with $\Delta
\Sigma +1$ larger than this parameter will be included in the set of
tiles generated.

\item An analogous parameter \verb+minTimeBins+ governing the smallest
extent in the time direction of tiles to be searched over.

\item A real number \verb+flow+ giving the lowest frequency in Hz to
be searched.

\item A real number \verb+deltaF+ and an integer \verb+length+ giving
the frequency resolution and length $N_F$ of the first (trivial) TF
plane, for which the number $N_T$ of time bins is $1$.


\end{itemize}


The routines \verb+CreateTFTiling()+ and \verb+DestroyTFTiling()+ both
have an input/output parameter \verb+tfTiling+ of type
\verb+TFTiling**+.  On exit from \verb+CreateTFTiling+, the pointer
\verb+*tfTiling+ will point to the newly created \verb+TFTiling+
structure.  The routine \verb+CreateTFTiling+ also assigns memory for
and creates the $p+1$ time frequency planes and the $p+1$
\verb+ComplexDFTParams+ structures, and the linked list of TF tiles.
When \verb+DestroyTFTiling()+ is called, 
\verb+*tfTiling+ should point to the structure to be destroyed, and on
exit \verb+*tfTiling+ will be \verb+NULL+.






The next routine is \verb+ComputeTFPlanes()+.  It takes as input a
pointer \verb+freqSeries+ to a \verb+COMPLEX8FrequencySeries+, and as
input/output a pointer \verb+tfTiling+ to a \verb+TFTiling+ structure.  It
computes the $p+1$ time frequency transforms according to the parameters
(\ref{tfplanes}) and (\ref{resolutions}), using the routine
\verb+FreqSeriesToTFPlane()+, and stores the resulting TF planes in the
structure \verb+*tfTiling+.


The routine \verb+ComputeExcessPower()+ computes the excess
power $\Delta P_{\cal T}$ for each tile, according to Eqs.\ (\ref{power})
and (\ref{ep}).  It also computes for each tile the ``number of
sigma'' parameter $n_{\cal T}$ given by Eq.\ (\ref{nsigma}).  For
those tiles which satisfy 
the first cut criterion (\ref{firstcut}), the routine computes the probability
$\alpha_{\cal T}$ given by Eq.\ (\ref{alphadef}) and stores it in the field
\verb+alpha+ of the TF tile.  For tiles which fail the first cut
criterion, the field \verb+alpha+ is assigned a default value
$\alpha_{\rm default}$.  The arguments of the routine are (i) and
input/output argument consisting of a pointer
\verb+tfTiling+ to a \verb+TFTiling+ structure, and (ii)
a pointer \verb+input+ to a data structure of
type \verb+ComputeExcessPowerIn+.  The structure of type
\verb+ComputeExcessPowerIn+ consists of
(i) an integer \verb+numSigmaMin+ or $N_{\rm min}$,
the minimum ``number of sigma'' in the first cut criterion
(\ref{firstcut}), and (ii) a real number \verb+alphaDefault+, or
$\alpha_{\rm default}$.  The value assigned to $\alpha_{\rm default}$
should be of order unity, since the tiles will eventually be sorted
(see below) in order of their $\alpha_{\cal T}$ values, and the interesting
tiles will have very small values of $\alpha_{\cal T}$.  Aside from
this, the exact value assigned to $\alpha_{\rm default}$  is
unimportant.  The routine \verb+ComputeExcessPower()+ must be called
after calling \verb+ComputeTFPlanes()+; calling the routines out of
sequence will give rise to an error.



The linked list of TF tiles in a \verb+TFTiling+ structure is
sorted in order of increasing $\alpha_{\cal T}$ by the routine
\verb+SortTFTiling()+, which has as an input/output argument a pointer
\verb+tfTiling+ to the \verb+TFTiling+ structure.  After the routine
\verb+SortTFTiling()+ is called, the linked list has as its first
element the tile with the lowest value of $\alpha_{\cal T}$, and
consequently the highest probability of being an event.
The routine \verb+SortTFTiling()+ must be called
after calling \verb+ComputeExcessPower()+; calling the routines out of
sequence will give rise to an error.


Next, the routine \verb+CountEPEvents()+ (count excess power events)
allows the user to specify a 
threshold value $\alpha_*$ of the probability $\alpha$, and returns
the number $n_{\rm events}$ of tiles with $\alpha_{\cal T} \le
\alpha_*$.  Since the tiles have been sorted, the relevant tiles will
be the first $n_{\rm events}$ tiles in the linked list.  This routine
thus allows the user to perform the first of the two types of searches
of Sec.\ \ref{twomethods} above.  The input argument is a real number
\verb+alphaThreshold+ or $\alpha_*$, and a pointer \verb+tfTiling+ to
a \verb+TFTiling+ structure.  There is also an output parameter
\verb+numEvents+ of type \verb+INT4*+.  On exit, \verb+*numEvents+ is
the number $n_{\rm events}$ of files that pass the threshold. 
The routine \verb+CountEPEvents()+ must be called
after calling \verb+SortTFTiling()+; calling the routines out of 
sequence will give rise to an error.

The routine \verb+PrintTFTileList()+ outputs the details of a specified
number of TF tiles to a file.  Its input parameters are (i) an integer
\verb+maxTiles+ giving the maximum number of tiles to be output, (ii)
a pointer 
\verb+tfTiling+ to a \verb+TFTiling+ structure, and (iii) a pointer
\verb+fp+ to a \verb+FILE+.  Information on each of the first
\verb+maxTiles+ tiles in the linked list are then output to the file
in a text format.  The information includes:
\begin{itemize}

\item The index $i$ of the time-frequency plane
to which the tile belongs.

\item The tile's frequency and time intervals, both in absolute units
(Hertz and seconds) and in bins on the time frequency plane.

\item The number of degrees of freedom $2 N_{\cal T}$.

\item The excess power $\Delta P_{\cal T}$.

\item The probability $\alpha_{\cal T}$.  

\item The ``effective number of sigma'', $z$, corresponding to the
probability $\alpha_{\cal T}$, defined by ${\rm erfc}(z/\sqrt{2}) =
\alpha_{\cal T}$.  This is useful for comparisons with matched
filtering signal-to-noise ratios.

\end{itemize}

By calling this routine after calling \verb+SortTFTiling()+, and by
passing to it the parameter $n_{\rm events}$ obtained from the routine
\verb+CountEPEvents()+, one can obtain an ordered list of all tiles
passing a specified threshold $\alpha_*$.








The last routine \verb+ComputeLikelihood()+ computes the mean
likelihood given in Eq.\ (\ref{meanlikelihood}).  It takes as input a
pointer \verb+tfTiling+ to a \verb+TFTiling+ structure, and returns
the mean likelihood ${\bar \Lambda}$ in the output parameter
\verb+lambda+ of type \verb+REAL8*+.  It can only be called after calling
\verb+ComputeExcessPower()+.  The routine actually returns not the
value (\ref{meanlikelihood}) but instead the more approximate
quantity  
\begin{equation}
{\bar \Lambda} = {1 \over N_{\rm tiles}} \, \sum_j^\prime \left[{2 N_{{\cal
T}_j} \over (\Delta P_{{\cal T}_j})^2 } \right] \, {1 \over
\alpha_{{\cal T}_j}},
\label{meanlikelihood1}
\end{equation}
Here the notation $\sum^\prime$ means that the sum is taken only over
those tiles that satisfy the first cut condition (\ref{firstcut}).
The reason that this approximation is justified is that reasonable
thresholds ${\bar \Lambda}_*$ will be very large compared to unity,
and the contribution of tiles with $n_{\cal T} \le N_{\rm min}$ to
${\bar \Lambda}$ is bounded above by a number of order unity.  In
other words, tiles for 
which the probability $\alpha_{\cal T}$ is of order unity will
contribute negligibly to the final value of the mean likelihood ${\bar
\Lambda}$ for those data segments which exceed the threshold.  So, we
can omit such tiles in computing the sum.  [Clearly it does not matter
if we compute ${\bar \Lambda}$ somewhat inaccurately for ${\bar
\Lambda} \ll {\bar \Lambda}_*$.] 

The routine \verb+ComputeLikelihood()+ must be called
after calling \verb+ComputeExcessPower()+; calling the routines out of 
sequence will give rise to an error.  However, it does not require
a prior execution of \verb+SortTFTiling()+ or of \verb+CountEPEvents()+.  



The routine \verb+ComputeLikelihood()+ allows the user to the second
type of search discussed in Sec.\ \ref{twomethods} above.  Namely, one
can compute ${\bar \Lambda}$ for successive segments of data in the
time domain [whose fractional overlap could be taken to be $N_{\rm ov} /
(N_{\rm ov} +1)$ say].  Only those data segments with ${\bar \Lambda}$
above threshold are tagged for further analysis.  In this further
analysis, one can examine the first few elements of the sorted linked
list to find the most probable time-frequency windows for a putative
event.  Or, in the likely scenario where one is using the
\verb+ExcessPower+ routines to help characterize the non-Gaussian
noise in detector data, one can 
amass statistics of the ``loudest'' TF tiles over many data segments,
which could yield information as to the typical time-frequency
characteristics of the most common/loudest non-Gaussian noise events.







\subsection{Operating Instructions}

% Detailed usage 

\begin{verbatim}
static Status status;

{
    /*  
     *  the following code for brevity omits the necessary checking 
     *  of the status structure after every function call.
     *
     */

    TFTiling                  *tfTiling=NULL;
    CreateTFTilingIn          params;
    COMPLEX8FrequencySeries   fseries;
    ComputeExcessPowerIn      input;
    INT4                      numEvents;
    INT4                      i;
    REAL8                     barLambda;

    /* set up parameter structure for CreateTFTiling() */
    params.overlapFactor = 3;
    params.minFreqBins = 1;
    params.minTimeBins = 1;
    params.flow = 0.0;
    params.deltaF = 1.0;
    params.length = 16;

    /* Create TF Tiling */  
    CreateTFTiling (&status, &tfTiling, &params);

    /* now set up frequency series */
    fseries.epoch.gpsSeconds=0;
    fseries.epoch.gpsNanoSeconds=0;
    fseries.deltaF = 1.0;
    fseries.f0 = 0.0;
    fseries.name = NULL;
    fseries.sampleUnits=NULL;
    fseries.data=NULL;
    CCreateVector( &status, &(fseries.data), 1000);

    /* put some data in frequency series */
    for(i=0; i<1000; i++)
       {
          fseries.data->data[i].re=0.0;
          fseries.data->data[i].im=0.0;
       }

    /*  compute the set of TF planes */    
    ComputeTFPlanes( &status, tfTiling, &fseries);

    /*  compute the excess power and probability for each tile */
    /* first set up input parameters for ComputeExcessPower() */
    input.numSigmaMin=2.0;
    input.alphaDefault=0.5;
    ComputeExcessPower( &status, tfTiling, &input);

    /* Sort the linked list of tiles */
    SortTFTiling( &status, tfTiling);

    /* count the tiles above a certain threshold in 1/alpha */
    CountEPEvents( &status, &numEvents, tfTiling, 0.01);

    /* Print out details of those tiles to stdout */
    PrintTFTileList( &status, stdout, tfTiling, numEvents);      

    /* compute the mean likelihood */
    ComputeLikelihood( &status, &barLambda, tfTiling);

    /* clean up */

    CDestroyVector( &status, &(fseries.data));
    DestroyTFTiling (&status, &tfTiling);
  }
\end{verbatim}

\subsubsection{Arguments}

% Describe meaning of each argument

\begin{itemize}
\item \texttt{status} is a universal status structure.  Its contents are
assigned by the functions.


\item \texttt{tfTiling} is an input/output parameter of type
\verb+TFTiling**+ for the routines \verb+CreateTFTiling()+ and
\verb+DestroyTFTiling()+.  When calling \verb+CreateTFTiling()+,
\verb+*tfTiling+ should be \verb+NULL+, and on exit it will point to
the newly created structure.  On calling \verb+DestroyTFTIling()+, 
\verb+*tfTiling+ should point to the structure to be destroyed, and on
exit it will have been set to \verb+NULL+.


\item \texttt{tfTiling} is an input/output parameter of type
\verb+TFTiling*+ for several routines:
\begin{itemize}
\item For the routine \verb+ComputeTFPlanes()+, the fields
\verb+numPlanes+ and \verb+dftParams+ of the \verb+TFTiling+ structure
are inputs.  The fields \verb+tfp+, \verb+planesComputed+,
\verb+excessPowerComputed+ and \verb+tilesSorted+ are output
parameters.  [The last two are set to FALSE on exit].  The fields
\verb+firstTile+ and \verb+numTiles+ are unaffected. 

\item For the routine \verb+ComputeExcessPower()+, the only output
field in the \verb+TFTiling+ structure is \verb+firstTile+, that is,
only the linked list of TF tiles is altered.  In each tile, the fields
\verb+excessPower+, \verb+alpha+ 
and \verb+firstCutFlag+ are assigned.  The remaining fields in the
\verb+TFTiling+ structure are inputs.

\item Similarly, for the routine \verb+SortTFTiling()+, 
only the linked list of TF tiles is altered.  The remaining fields in the
\verb+TFTiling+ structure are inputs.

\item In the routines \verb+CountEPEvents()+,
\verb+ComputeLikelihood()+ and \verb+PrintTFTileList()+, all of the
fields of the \verb+TFTiling+ structure are inputs.

\end{itemize}






\item \texttt{v} is input/output parameter of type
\verb+COMPLEX8Vector*+ for the routine \verb+AddWhiteNoise()+.  On
calling the routine, \verb+v+ should point to a \verb+COMPLEX8Vector+.
On exit, \verb+v+ will still point to the same location but the vector
will have been altered by the addition of white noise.

\item \texttt{noiseLevel} is an input argument of type \verb+REAL8+
for the routine \verb+AddWhiteNoise()+.  The real and imaginary parts
of each element of the complex vector will be augmented by
independent, zero-mean Gaussian deviates of rms value \verb+noiseLevel+.


\item \texttt{input} is an input argument to the routine
\verb+CreateTFTiling()+ of type \verb+CreateTFTilingIn*+ (see Sec.\
\ref{individual} above).

\item \texttt{freqSeries} is an input argument of type
\verb+COMPLEX8FrequencySeries*+ to the routine
\verb+ComputeTFPlanes()+, which points to the frequency series whose
TF transforms are to be computed.

\item \texttt{input} is an input argument to the routine
\verb+ComputeExcessPower()+ of type \verb+ComputeExcessPowerIn*+ (see Sec.\
\ref{individual} above).

\item \texttt{alphaThreshold} is an input \verb+REAL8+ parameter to
the routine \verb+CountEPEvents()+, which specifies the threshold
$\alpha_*$.  

\item \texttt{numEvents} is an output parameter of type \verb+REAL8*+ to
the routine \verb+CountEPEvents()+.  On exit, \verb+*numEvents+ is the
number of TF tiles which have passed the threshold.

\item \texttt{lambda}is an output parameter of type \verb+REAL8*+ to
the routine \verb+ComputeLikelihood()+.  On exit, \verb+*lambda+ is the
approximate version of the mean likelihood ${\bar \Lambda}$ given by
Eq.\ (\ref{meanlikelihood1}).
 
\item \texttt{fp} is an input/output parameter of the
routine \verb+PrintTFTileList()+ of type \verb+FILE*+.  The routine
writes textual information to the file pointed to by \verb+fp+.

\end{itemize}

\subsubsection{Options}

None. 

\subsubsection{Error conditions}

% What constitutes an error condition? What do the error codes mean?

These functions all set the universal status structure on return.
Error conditions are described in the following table.





\begin{table}
\begin{tabular}{|r|l|p{2in}|}\hline
status  & status          & Description\\
code    & description     & \\\hline
TFTRANSFORM\_ENULLP 1   & Null pointer
  & an argument is NULL or contains a NULL pointer\\
TFTRANSFORM\_EPOSARG 2   & Arguments must be non-negative
  & Illegal zero or negative arguments encountered \\
TFTRANSFORM\_EPOW2   4  & Length of supplied data
  & length should be $2^p$ for some $p$\\ 
 \, & must be a power of 2 & \, \\
TFTRANSFORM\_EMALLOC 8   & LALMalloc error
  & Failure to allocate memory\\
TFTRANSFORM\_EINCOMP 16   & Incompatible arguments
  & Arguments are inconsistent\\
TFTRANSFORM\_EORDER 32   & Routines called in illegal order
  & Routines out of correct order\\
TFTRANSFORM\_ENONNULL 64   & Null pointer expected
  & Pointer should have been NULL\\


\hline
\end{tabular}
\caption{Error conditions for all TFTRANSFORM functions}\label{tbl:CV}
\end{table}
                                
\subsection{Algorithms}


% Describe algorithm by which work is done

\subsection{Accuracy}

% For numerical routines address issues related to accuracy:
% approximations, argument ranges, etc.


\subsection{Tests}

% Describe the tests that are part of the test suite

The program \verb+ExcessPowerTest+ applies the routines to a frequency
series consisting of the Fourier transform of a specific waveform plus
white Gaussian noise.  The waveform chosen has a Gaussian envelope and
has a well defined local frequency which changes by a factor of about
3 as time evolves.  The matched filtering signal to noise ratio for
the waveform is about 10.  The mean likelihood is computed, and the
details of the top few tiles are printed out.  

In addition, all the error conditions for all the routines provided
are checked.


\subsection{Uses}

% What LAL, other routines does this one call?

\begin{itemize}
\item\texttt{Chi2Threshold()}
\item\texttt{CreateRandomParams()}
\item\texttt{SCreateVector()}
\item\texttt{NormalDeviates()}
\item\texttt{SDestroyVector()}
\item\texttt{DestroyRandomParams()}
\item\texttt{CreateTFPlane()}
\item\texttt{CreateComplexDFTParams()}
\item\texttt{DestroyTFPlane()}
\item\texttt{DestroyComplexTDFTParams()}
\item\texttt{FreqSeriesToTFPlane()}
\item\texttt{OneMinusChisqCdf()}
\end{itemize}

\subsection{Notes}

\subsection{References}

% Any references for algorithms, tests, etc.
\begin{thebibliography}{0}
\bibitem{fh:1998}
\'Eanna~\'E.~Flanagan and S. A. Hughes, Phys. Rev. D {\bf 57},
4535-4565 (1998) (also gr-qc/9701039).  

\bibitem{acdhp:1999}
N. Arnaud, F. Cavalier, M. Davier, P. Hello, and T. Pradier,
\textit{Triggers for the Detection of Gravitational Wave Bursts},
gr-qc/9903035.  

\bibitem{abcf:2000}
Warren G. Anderson, Patrick R. Brady, Jolien D. E. Creighton and 
{\'E}anna {\'E}. Flanagan, 
\textit{An excess power statistic for detection of burst sources of
gravitational radiation}, Phys Rev D., in preparation (gr-qc/2004???).
For a short version see {\it ibid}, \textit{A power filter for the
detection of burst sources of gravitational radiation in
interferometric detectors}, gr-qc/0001044, submitted to
Int. J. Modern. Phys. D. 


\end{thebibliography}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

