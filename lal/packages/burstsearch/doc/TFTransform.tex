% This file is meant to be included in another 
\documentclass{article}
\begin{document}
\section{TFTransform}

\subsection{Purpose}

A set of functions to compute time-frequency planes from either
time-domain or frequency-domain data, for use in the excess
power search technique.   


 
\subsection{Synopsis}

% Syntax: argument definitions, calling signature

\begin{verbatim}
#include "TFTransform.h"

typedef enum {
  verticalPlane,      
  /*
   *  Constructed by dividing time domain data into chunks
   *  and FFTing each chunk, thus producing a vertical line (the FFT) 
   *  in the TF plane for each chunk in the time domain
   *
   */
  horizontalPlane 
  /*
   *  Constructed by dividing frequency domain data into chunks
   *  and FFTing each chunk back to time domain, thus producing a horizontal
   *  line (the FFT) in the TF plane for each chunk in the frequency domain
   *
   */
}
TFPlaneType;


typedef struct tagTFPlaneParams
{
  INT4             timeBins;    /* Number of time bins in TF plane    */
  INT4             freqBins;    /* Number of freq bins in TF plane    */
  REAL8            deltaT;      /* deltaF will always be 1/deltaT     */
  REAL8            flow;        
  /* 
   * frequencies f will lie in range flow <= f <= flow + freqBins * deltaF
   * flow is in Hertz
   */
}
TFPlaneParams;


typedef struct tagRealDFTParams
{
  WindowType               windowType;
  REAL4Vector              *window;
  REAL4                    sumofsquares;
  RealFFTPlan              *plan;
}
RealDFTParams;

typedef struct tagComplexDFTParams
{
  WindowType               windowType;
  REAL4Vector              *window;
  REAL4                    sumofsquares;
  ComplexFFTPlan           *plan;
}
ComplexDFTParams;


typedef struct tagCOMPLEX8TimeFrequencyPlane
{
  CHAR                     *name;
  LIGOTimeGPS              epoch;
  CHARVector               *sampleUnits;
  TFPlaneParams            *params;
  TFPlaneType              planeType;
  COMPLEX8                 *data;
  /* 
   * data[i*params->freqBins+j] is a complex number 
   * corresponding to a time t_i = epoch + i*(deltaT)
   * and a frequency f_j = flow + j / (deltaT)
   */
}
COMPLEX8TimeFrequencyPlane;


typedef struct tagVerticalTFTransformIn
{
  RealDFTParams                *dftParams;
  INT4                         startT;
}
VerticalTFTransformIn;


typedef struct tagHorizontalTFTransformIn
{
  ComplexDFTParams             *dftParams;
  INT4                         startT;
}
HorizontalTFTransformIn;




void
CreateRealDFTParams ( 
                     Status                         *status, 
                     RealDFTParams                  **dftParams, 
                     WindowParams                   *params,
                     INT2                           sign
                     );


void
DestroyRealDFTParams (
                      Status                        *status, 
                      RealDFTParams                 **dftParams
                      );


void
CreateComplexDFTParams ( 
                        Status                      *status, 
                        ComplexDFTParams            **dftParams, 
                        WindowParams                *params,
                        INT2                        sign
                        );


void
DestroyComplexDFTParams (
                         Status                     *status, 
                         ComplexDFTParams           **dftParams
                         );


void
ComputeFrequencySeries (
                        Status                      *status,
                        COMPLEX8FrequencySeries     *freqSeries,
                        REAL4TimeSeries             *timeSeries,
                        RealDFTParams               *dftParams
                        );


void
CreateTFPlane (
               Status                               *status,
               COMPLEX8TimeFrequencyPlane           **tfp,
               TFPlaneParams                        *input
               );


void
DestroyTFPlane (
               Status                               *status,
               COMPLEX8TimeFrequencyPlane           **tfp
                );


void
TimeSeriesToTFPlane (
                     Status                         *status,
                     COMPLEX8TimeFrequencyPlane     *tfp,
                     REAL4TimeSeries                *timeSeries,
                     VerticalTFTransformIn         *input
                     );


void
FreqSeriesToTFPlane (
                     Status                         *status,
                     COMPLEX8TimeFrequencyPlane     *tfp,
                     COMPLEX8FrequencySeries        *freqSeries,
                     HorizontalTFTransformIn        *input
                     );
\end{verbatim}



\subsection{Description}

This package provides a suite for functions for computing 
time-frequency representations of data using stacked Fourier
transforms.


The first few functions simply combine together some of the
functionality of the packages \verb+fft+ and \verb+Window+ in a
convenient way.  They are designed to streamline the task of setting
up structures to prepare for taking many discrete Fourier transforms
(DFTs), including windows and ``plans'' for FFTW.
The routine \verb+CreateRealDFTParams()+ creates a structure of type
\verb+RealDFTParams+, which 
consists of (i) a pointer \verb+plan+ to a
\verb+RealFFTPlan+, (ii) a parameter \verb+windowType+ of type
\verb+WindowType+ which specifies the type of windowing to be used
(rectangular, Welch, ...),  (iii) a pointer
\verb+window+ to a \verb+REAL4Vector+ which contains the window for
the DFT, and (iv) a parameter \verb+sumofsquares+ containing the sum
of the squares of the elements of \verb+*window+.  The function
\verb+CreateRealDFTParams()+ calls the routines
\verb+MeasureFwdRealFFTPlan()+ to create the FFT plan, and
\verb+Window()+ to compute the window parameters.  
The inputs to \verb+CreateDFTParams()+ consist of (i) a
parameter \verb+winParams+ of type \verb+WindowParams*+ giving the
length of the vectors to be Fourier  
transformed and the type of windowing to be used, (ii) a pointer
\verb+dftParams+ to a pointer to a \verb+RealDFTParams+ 
structure, and (iii) an integer \verb+sign+ specifying the direction
of the transform, with $+1$ indicating forward transform and $-1$
indicating inverse transform.  On exit, \verb+*dftParams+ will point
to the newly created 
structure.  The routine \verb+DestroyRealDFTParams()+ destroys a structure
of type \verb+DFTParams+. 
The routines \verb+CreateComplexDFTParams()+ and
\verb+DestroyComplexDFTParams()+ are analogous, except that they use
\verb+ComplexFFTPlan+ structures instead of \verb+RealFFTPlan+ structures.




The routine \verb+ComputeFrequencySeries()+ takes as input a
\verb+REAL4TimeSeries+ and a structure \verb+RealDFTParams+.  It Fourier
transforms the time series according to the information (window and
FFT plan) in the \verb+RealDFTParams+ structure, using
\verb+FwdRealFFT()+.  It then 
multiplies the frequency domain data by a normalization
factor which is $1/\sqrt{n}$ for rectangular windowing, 
where $n$ is the length of the time series,
and returns the data as a \verb+COMPLEX8FrequencySeries+.
The length of the frequency
series is $[n/2]+1$, where $[n/2]$ means $n/2$ rounded down to the
nearest integer.  Appropriate values for the various fields in the
\verb+COMPLEX8FrequencySeries+ structure (\verb+deltaF+ etc.~) are
computed from the corresponding fields in the input
\verb+REAL4TimeSeries+. 



A general description of the time-frequency (TF) transform provided by
TFTransform is as follows.  Suppose that one starts with some data
$h_j$, $0 \le j < n$ in the time domain, with sampling time $\Delta
t$, so that the data point $h_j$ corresponds to a time $t_j = t_{\rm
start} + j \Delta t$.  Taking the standard DFT yields complex data
\begin{equation}
{\tilde h}_\gamma = \sum_{j=0}^{n-1} \, e^{2 \pi i j \gamma / n} \, h_j
\label{standarddft}
\end{equation}
in the Fourier domain, for $0 \le \gamma \le [n/2]+1$.
Here the data point ${\tilde h}_\gamma$ corresponds to a frequency
$f_\gamma = \gamma \Delta f$, where $\Delta f= 1/(n \Delta t)$ is the
frequency resolution.  


Now suppose that we can factorize the number $n$ of data points as
\begin{equation}
n = 2 N_T N_F.
\end{equation}
Then, by a time-frequency plane we shall mean a set of $N_T N_F$
complex numbers $H_{I\Gamma}$ with $0 \le I < N_T$ and $0 \le \Gamma <
N_F$, obtained by an invertible linear transformation from the
original data, such  
that the data point $H_{I\Gamma}$ corresponds approximately to a time
$t_I = t_{\rm start} + I {\overline {\Delta t}}$ and to a frequency 
$f_\Gamma = \Gamma {\overline {\Delta f}}$.  Here $N_F$ is the number
of frequency bins in the TF plane, and $N_T$ is the number of time
bins.  The time resolution ${\overline {\Delta t}}$ and frequency
resolution ${\overline {\Delta f}}$ are related by 
${\overline {\Delta t}} \ {\overline {\Delta f}} =1$, and are given by
${\overline {\Delta t}} = 2 N_F \Delta t$ and 
${\overline {\Delta f}} = N_T \Delta f$.  Note that there are many
other ``time-frequency'' representations of data that are not of this
type; see \cite{ab:1999}.


There are many possible choices of linear transformations from the
data $h_j$ to data $H_{J\Gamma}$ satisfying the above properties.
Here we have implemented two simple choices.  The first choice consists of
dividing the time-domain data $h_j$ into $N_T$ equal-sized chunks,
each of length $n/N_T$, and then taking the forward DFT of each chunk.
Then, 
$H_{J\Gamma}$ is just the $\Gamma$th element of the $J$th chunk.
In terms of formulae this corresponds to
\begin{equation}
H_{J\Sigma} = \sum_{k=0}^{2 N_F-1} \, \exp \left[ 2 \pi i k \Sigma / (2
N_F) \right] \, h_{2 N_F J + k},
\label{verticalTFP}
\end{equation}
for $0 \le J < N_T$ and $0 \le \Sigma < N_F$.  We call this first type
of TF plane a vertical TF plane, since it corresponds to a series of
vertical lines if the time axis is horizontal and the frequency axis
vertical. 

The second type of TF plane is obtained by first taking a DFT of all
the time domain data to obtain frequency domain data, then dividing
the frequency domain data into $N_F$ equal-sized chunks, then taking
the inverse DFT of each chunk.  We call the resulting TF plane a
horizontal TF plane. In terms of formulae the TF plane elements are
\begin{equation}
H_{J\Sigma} = \sum_{\gamma=0}^{N_T-1} \, \exp \left[ -2 \pi i J \gamma
/ N_T \right] \, {\tilde h}_{N_T \Sigma + \gamma},
\label{horizontalTFP}
\end{equation}
for $0 \le J < N_T$ and $0 \le \Sigma < N_F$, where ${\tilde
h}_\gamma$ is given by Eq.\ (\ref{standarddft}).

We now describe the various routines used in the computation of TF planes.
The routine \verb+CreateTFPlane()+ allocates the memory for a TF plane.
It takes as input a pointer to a structure \verb+TFPlaneParams+, which
consists of (i) an integer \verb+timeBins+ or $N_T$, (ii) an integer
\verb+freqBins+ or $N_F$, (iii) a real number \verb+deltaT+ which is
the time resolution ${\overline {\Delta t}}$ of the TF plane in seconds, and 
(iv) a real number \verb+flow+ giving the lowest frequency $f_{\rm
low}$ in the TF plane in Hertz [such that the data point $H_{J\Gamma}$
corresponds to a time $t_J = t_{\rm start} + J {\overline {\Delta t}}$
and to a frequency 
$f_\Gamma = f_{\rm low} + \Gamma {\overline {\Delta f}}$, in a slight
generalization of the above correspondence].  The 
\verb+CreateTFPlane()+ routine returns a
pointer to a structure \verb+COMPLEX8TimeFrequencyPlane+.  This
structure has some fields that also appear in the structures
\verb+REAL4TimeSeries+ and \verb+COMPLEX8FrequencySeries+:
\begin{itemize}
\item A field \verb+epoch+ of type \verb+LIGOTimeGPS+ giving the initial
time $t_{\rm start}$.
\item A character string \verb+name+ giving the
name of the TF plane.
\item A character string \verb+sampleUnits+
giving the units of the quantities $H_{J\Gamma}$.
\end{itemize}
The other fields in \verb+COMPLEX8TimeFrequencyPlane+ are as follows:
\begin{itemize}
\item A variable \verb+planeType+ of type \verb+PlaneType+, which is
an enumerated type that can be either \verb+verticalPlane+ or
\verb+horizontalPlane+, corresponding to the two types of TF plane. 
\item A structure \verb+params+ of the type \verb+TFPlaneParams+
discussed above, containing $N_T$, $N_F$, ${\overline {\Delta t}}$ and
$f_{\rm low}$.
\item A pointer \verb+data+ to the $N_T \times N_F$ array of complex
numbers $H_{J\Sigma}$.
\end{itemize}
  
The routine \verb+CreateTFPlane()+ allocates memory for all of these
fields, and copies into the \verb+params+ structure the values of
$N_F$, $N_T$, ${\overline {\Delta t}}$ and $f_{\rm low}$ from its 
input structure.  It assigns nominal values to all the other fields in
the \verb+COMPLEX8TimeFrequencyPlane+ structure.  The routine
\verb+DestroyTFPlane()+ frees all the memory associated with a
\verb+COMPLEX8FrequencyPlane+ and destroys the TF plane.


The routine \verb+TimeSeriesToTFPlane()+ computes a TF plane from an input 
\verb+REAL4TimeSeries+.  It takes as input a structure \verb+input+ of type
\verb+VerticalTFTransformIn+ which consists of a structure \verb+dftParams+ of
type \verb+RealDFTParams+ and an integer \verb+startT+ giving the 
offset from the beginning of the time series at which to start the
computation of the time frequency plane.  The other input is a pointer
\verb+timeSeries+ to a \verb+REAL4TimeSeries+.  There is also an
argument \verb+tfp+ which is a pointer to a
\verb+COMPLEX8TimeFrequencyPlane+ which is both an input and an
output.  The structure \verb+tfp->params+ (containing $N_T$, $N_F$,
${\overline {\Delta t}}$ and $f_{\rm low}$) is an input, while the
remaining fields of the structure \verb+*tfp+ are outputs.

The input parameters to the routine \verb+TimeSeriesToTFPlane()+ are the
parameters $N_T$, $N_F$, ${\overline {\Delta t}}$ and $f_{\rm low}$ of
the TF plane (from \verb+tfp->params+), and also the parameters
$\Delta t$ and $f_0$ of the input time series.  The routine takes the
data in the time domain starting at time $t_{\rm start}$
specified by the parameter \verb+startT+, and breaks
it up into $N_T$ chunks of length $2 {\tilde N}_F$, where
\begin{equation}
{\tilde N}_F = { {\overline {\Delta t}} \over 2 \Delta t}.
\end{equation}
This choice of chunk-size is necessary so that the frequency resolution of
the TF plane is $1/{\overline {\Delta t}}$.  
The final time sample used is at the time $t = t_{\rm start} + (2 N_T
{\tilde N}_F-1) \Delta t$; the input time series can extend beyond this.
After computing the DFT of each chunk, only $N_F$ frequency bins are
retained and stored, namely the frequency bins from
$f = f_{\rm low} - f_0$ to $f = f_{\rm low} - f_0 + {\overline {\Delta
f}} N_F$, where ${\overline {\Delta f}} = 1 / {\overline {\Delta t}}$.
The input parameters must be such that the high end of this  
frequency interval is smaller than the Nyquist frequency $1 / (2
\Delta t) = {\tilde N}_F {\overline {\Delta f}}$.  In particular, if
$f_{\rm low} = f_0 =0$, then we must have $N_F \le {\tilde N}_F$.
The TF plane elements are computed according to the formula
(\ref{verticalTFP}), except that they are multiplied by a
normalization factor of $1/\sqrt{2 {\tilde N}_F}$.  
[This
normalization convention
insures that if the input data is white noise with rms power 1 in each
time bin, then the real and imaginary parts of the data points in the
TF plane are also independent Gaussian random variables with rms value
1.]  




The routine \verb+FreqSeriesToTFPlane()+ computes a TF plane from an input 
\verb+COMPLEX8FrequencySeries+.  
It takes as input a structure \verb+input+ of type
\verb+HorizontalTFTransformIn+ which consists of a structure
\verb+dftParams+ of type \verb+ComplexDFTParams+ and an integer \verb+startT+,
which is not used in the current implementation.
Another argument is a pointer
\verb+freqSeries+ to the \verb+COMPLEX8FrequencySeries+.
Lastly there is a pointer \verb+tfp+ to a \verb+COMPLEX8FrequencyPlane+
which as before is both an input and an output; the fields
$N_T$, $N_F$, ${\overline {\Delta t}}$ and $f_{\rm low}$ are inputs and
the remaining fields are outputs.


The input parameters to the routine \verb+FreqSeriesToTFPlane()+ are the
parameters $N_T$, $N_F$, ${\overline {\Delta t}}$ and $f_{\rm low}$ of
the TF plane (from \verb+tfp->params+), and also the parameters
$\Delta f$ and $f_0$ of the input frequency series.  
The routine takes the data in the frequency domain starting at
frequency $f_{\rm low} - f_0$, breaks it up into $N_F$ chunks of
length ${\tilde N}_T$, and performs an inverse DFT on each chunk.
The chunk size ${\tilde N}_T$ is given by
\begin{equation}
{\tilde N}_T =  1 /( \Delta f  {\overline {\Delta t}}),
\end{equation}
where the right hand side is rounded off to the nearest integer.  
This choice of chunk-size is necessary so that the time resolution of
the TF plane is ${\overline {\Delta t}}$.  
After computing the inverse DFT of each chunk, the first $N_T$ time
bins out of the ${\tilde N}_T$ time bins are
retained and stored, and the remainder are discarded.
The input parameters must be such that $N_T \le {\tilde N}_T$.
The input frequency series can extend beyond the highest frequency used
which is $f_{\rm low} - f_0 + (N_F {\tilde N}_T -1){\Delta f}$.
The TF plane elements are computed according to the formula
(\ref{horizontalTFP}), except that they are multiplied by a
normalization factor of $1/\sqrt{{\tilde N}_T}$.  
[This
normalization convention insures that if the input data is white noise
with rms power 1 in the 
real and imaginary parts of each frequency bin, then the real and
imaginary parts of the data points in the TF plane are also
independent Gaussian random variables with rms value 1.]  





\subsection{Operating Instructions}

% Detailed usage 

\begin{verbatim}

static Status status;

const INT4 ntot=100;



{
  /* use of CreateRealDFTParams() and DestroyRealDFTParams() */

  WindowParams winParams;
  RealDFTParams *dftParams=NULL;

  winParams.type=Rectangular;
  winParams.length=ntot;
  CreateRealDFTParams( &status, &dftParams, &winParams, 1);

  /* now dftParams can be used ... */

  DestroyRealDFTParams( &status, &dftParams);
}



{
  /* use of CreateComplexDFTParams() and DestroyComplexDFTParams() */

  WindowParams winParams;
  ComplexDFTParams *dftParams=NULL;

  winParams.type=Rectangular;
  winParams.length=ntot;
  CreateComplexDFTParams( &status, &dftParams, &winParams, 1);

  /* now dftParams can be used ... */

  DestroyComplexDFTParams( &status, &dftParams);
}


{
  /* use of ComputeFrequencySeries */

  REAL4TimeSeries              tseries;
  COMPLEX8FrequencySeries      fseries;
  RealDFTParams                *dftParams=NULL;
  WindowParams                 winParams;
  /* 
   *  
   *  Set up input time series
   *
   */

  tseries.epoch.gpsSeconds=0;
  tseries.epoch.gpsNanoSeconds=0;
  tseries.deltaT = 0.001;  /* 1 kHz sampling */
  tseries.f0 = 0.0;
  tseries.name = NULL;
  tseries.sampleUnits=NULL;
  tseries.data=NULL;
  fseries.data=NULL;

  SCreateVector (&status, &(tseries.data), ntot);
  CCreateVector( &status, &(fseries.data), ntot/2+1);

  winParams.type=Rectangular;
  winParams.length=ntot;
  CreateRealDFTParams( &status, &dftParams, &winParams,1);
  ComputeFrequencySeries ( &status, &fseries, &tseries, dftParams);

  DestroyRealDFTParams( &status, &dftParams);
  CDestroyVector (&status, &(fseries.data));
  CDestroyVector (&status, &(tseries.data));

}


{
  /* use of CreateTFPlane() and DestroyTFPlane() */

  TFPlaneParams                params;
  COMPLEX8TimeFrequencyPlane   *tfp=NULL;

  /* setup parameters structure for creating TF plane */
  params.timeBins = 2;
  params.freqBins = 5;  /* for example */
  params.deltaT = 0.01;
  params.flow = 0.0;

  /* Create TF plane  */
  CreateTFPlane( &status, &tfp, &params);

  DestroyTFPlane( &status, &tfp);

}	


  
{
  /* use of TimeSeriesToTFPlane */

  REAL4TimeSeries              tseries;
  TFPlaneParams                params;
  COMPLEX8TimeFrequencyPlane   *tfp=NULL;
  VerticalTFTransformIn        input;
  INT4                         i;
  INT4                         tseglength;

  /* create TF plane */
  params.timeBins = 10;
  params.freqBins = 5;  
  params.deltaT = 0.01;
  params.flow = 0.0;
  CreateTFPlane( &status, &tfp, &params);

  /* create time series */
  tseries.epoch.gpsSeconds=0;
  tseries.epoch.gpsNanoSeconds=0;
  tseries.f0 = 0.0;
  tseries.name = NULL;
  tseries.sampleUnits=NULL;
  tseries.data=NULL;
  /* tseries.deltaT must not exceed params.deltaT / (2*params.freqBins) */
  tseries.deltaT = 0.0001; 
  /* length of time series must be at least
     params.timeBins * params.deltaT / tseries.deltaT */
  SCreateVector (&status, &(tseries.data), 2000);
  for(i=0; i<2000; i++) tseries.data->data[i] = 0.0;

  /* compute length of data segments in time domain */  
  tseglength = 2 * (INT4)( (params.deltaT) / (2.0*(tseries.deltaT)) );

  /* set up parameter structure for TimeSeriesToTFPlane() */
  input.startT=0;
  input.dftParams=NULL;
  {
    WindowParams winParams;
    winParams.type=Rectangular;
    winParams.length=tseglength;
    CreateRealDFTParams( &status, &(input.dftParams), &winParams, 1); 
  }

  /* compute TF transform */
  TimeSeriesToTFPlane( &status, tfp, &tseries, &input);

  /* clean up */
  DestroyRealDFTParams( &status, &(input.dftParams));
  SDestroyVector (&status, &(tseries.data));
  DestroyTFPlane( &status, &tfp);
}


{
  /* use of FreqSeriesToTFPlane */

  COMPLEX8FrequencySeries      fseries;
  TFPlaneParams                params;
  COMPLEX8TimeFrequencyPlane   *tfp=NULL;
  HorizontalTFTransformIn      input;
  INT4                         i;
  INT4                         fseglength;

  /* create TF plane */
  params.timeBins = 10;
  params.freqBins = 5;  
  params.deltaT = 0.01;
  params.flow = 0.0;
  CreateTFPlane( &status, &tfp, &params);


  /* create frequency series */
  fseries.epoch.gpsSeconds=0;
  fseries.epoch.gpsNanoSeconds=0;
  fseries.f0 = 0.0;
  fseries.name = NULL;
  fseries.sampleUnits=NULL;
  fseries.data=NULL;
  /*
   *  fseries.deltaF must not exceed 
   *   1/(params.timeBins * params.deltaT)
   */
  fseries.deltaF = 1.0; 
  /*
   *  length of frequency series must be at least
   *   params.freqBins / (params.deltaT * fseries.deltaF)
   */
  CCreateVector (&status, &(fseries.data), 2000);
  for(i=0; i<2000; i++)
     {
       fseries.data->data[i].re = 0.0;
       fseries.data->data[i].im = 0.0;
     }
       
  /* compute length of data segments in frequency domain */  
  fseglength = (INT4)( 0.5+ 1.0/(params.deltaT * fseries.deltaF));  

  /* set up parameter structure for TimeSeriesToTFPlane() */
  input.startT=0;   /* not used by FreqSeriesToTFPlane() */
  input.dftParams=NULL;

  {
    WindowParams winParams;
    winParams.type=Rectangular;
    winParams.length=fseglength;
    CreateComplexDFTParams( &status, &(input.dftParams), &winParams, -1); 
  }

  /* compute TF transform */
  FreqSeriesToTFPlane( &status, tfp, &fseries, &input);

  /* clean up */
  DestroyComplexDFTParams( &status, &(input.dftParams));
  CDestroyVector (&status, &(fseries.data));
  DestroyTFPlane( &status, &tfp);
  
}



\end{verbatim}

\subsubsection{Arguments}

% Describe meaning of each argument

\begin{itemize}
\item \texttt{status} is a universal status structure.  Its contents are
assigned by the functions.

\item \texttt{length} is input of type \verb+INT4+ to the routine
\verb+CreateDFTParams()+ giving the length of the windows and FFT
plans to be created.   

\item \texttt{dftParams} is an output argument for the routine
\verb+CreateDFTParams()+ of type \verb+DFTParams**+.  On input,
\verb+dftParams+ should point to a variable of type \verb+DFTParams*+.
On output \verb+*dftParams+ will point to the newly created structure.  
Similarly, \verb+dftParams+ is an input parameter to the routine
\verb+DestroyDFTParams()+, which destroys the structure pointed to by
\verb+*dftParams+.  On output, \verb+*dftParams+ is set to \verb+NULL+.

\item \texttt{dftParams} is also an input argument to the routine
\verb+ComputeFrequencySeries()+ of type \verb+DFTParams*+, which points
to the structure containing the window and FFT plan used to compute
the DFT.

\item \texttt{plan} is an input argument of the routine
\verb+COMPLEX8VectorFFT()+ of type \verb+RealFFTPlan*+, which points
to the plan to be used to compute the DFT.  

\item \texttt{vinp} is an input argument of the routine
\verb+COMPLEX8VectorFFT()+ of type \verb+COMPLEX8Vector*+, which points
to the input vector.

\item \texttt{vout} is an output argument of the routine
\verb+COMPLEX8VectorFFT()+ of type \verb+COMPLEX8Vector*+, which points
to the output vector.

\item \texttt{timeSeries} is an input argument of the routines
\verb+ComputeFrequencySeries()+ and \verb+TimeSeriesToTFPlane()+
of type \verb+REAL4FrequencySeries*+, which points to the input time
series. 

\item \texttt{freqSeries} is an input argument of the routine
\verb+FreqSeriesToTFPlane()+ of type
\verb+COMPLEX8FrequencySeries*+ which points to the input frequency
series, and also an output argument of \verb+ComputeFrequencySeries()+.

\item \texttt{input} is an input argument of the routine
\verb+CreateTFPlane()+ of type \verb+TFPlaneParams+.  It points to a
structure containing the fields \verb+timeBins+ or $N_T$,
\verb+freqBins+ or $N_F$, \verb+deltaT+ or ${\overline {\Delta t}}$,
and \verb+flow+ or $f_{\rm low}$.  These variables are explained
above.

\item \texttt{tfp} is an input/output argument of the routines
\verb+CreateTFPlane()+ and \verb+DestroyTFPlane()+ of type 
\verb+COMPLEX8TimeFrequencyPlane**+.  On input to the routine
\verb+CreateTFPlane()+, \verb+tfp+ should point to a variable of type 
\verb+COMPLEX8TimeFrequencyPlane*+, and on output \verb+*tfp+ will
point to the newly created structure.  On input to the routine 
\verb+DestroyTFPlane()+, \verb+*tfp+ should point to the structure to
be destroyed, and on output \verb+*tfp+ will have been set to \verb+NULL+.

\item \texttt{input} is an input argument of the routines
\verb+TimeSeriesToTFPlane()+ and \verb+FreqSeriesToTFPlane()+ of type
\verb+TFTransformIn*+.  It points to a structure containing (i) the field
\verb+startT+, which is used only by \verb+TimeSeriesToTFPlane()+ 
and gives the offset from the beginning of the time series at which
to start the computation of the TF plane, and (ii) the field
\verb+dftParams+ of type \verb+DFTParams*+ which points to an input
structure containing information on how to take the DFT.  

\item \texttt{tfp} is an input/output argument of the routines
\verb+TimeSeriesToTFPlane()+ and \verb+FreqSeriesToTFPlane()+ of type 
\verb+COMPLEX8TimeFrequencyPlane*+.  The \verb+params+ field of the
\verb+COMPLEX8TimeFrequencyPlane+ structure is an input, and the
remaining fields are outputs. 



\end{itemize}

\subsubsection{Options}

None. 

\subsubsection{Error conditions}

% What constitutes an error condition? What do the error codes mean?

These functions all set the universal status structure on return.
Error conditions are described in the following table.

\begin{table}
\begin{tabular}{|r|l|p{2in}|}\hline
status  & status          & Description\\
code    & description     & \\\hline
TFTRANSFORM\_ENULLP 1   & Null pointer
  & an argument is NULL or contains a NULL pointer\\
TFTRANSFORM\_EPOSARG 2   & Arguments must be non-negative
  & Illegal zero or negative arguments encountered \\
TFTRANSFORM\_EALLOCP 4  & Pointer has already been
  & Non-null pointer\\ 
 \, & allocated, should be null & \, \\
TFTRANSFORM\_EINCOMP 8   & Incompatible arguments
  & Arguments to routine are inconsistent\\
\hline
\end{tabular}
\caption{Error conditions for all TFTRANSFORM functions}\label{tbl:CV}
\end{table}
                                
\subsection{Algorithms}


% Describe algorithm by which work is done

\subsection{Accuracy}

% For numerical routines address issues related to accuracy:
% approximations, argument ranges, etc.


\subsection{Tests}

% Describe the tests that are part of the test suite

\subsection{Uses}

% What LAL, other routines does this one call?

\begin{itemize}
\item\texttt{CreateVector()}
\item\texttt{CCreateVector()}
\item\texttt{FwdRealFFT()}
\item\texttt{CDestroyVector()}
\item\texttt{DestroyVector()}
\item\texttt{MeasureFwdRealFFTPlan()}
\item\texttt{SCreateVector()}
\item\texttt{Window()}
\item\texttt{SDestroyVector()}
\item\texttt{DestroyRealFFTPlan()}
\item\texttt{COMPLEX8VectorFFT()}
\end{itemize}

\subsection{Notes}

\subsection{References}

% Any references for algorithms, tests, etc.
\begin{thebibliography}{0}

\bibitem{ab:1999}
Warren G. Anderson and R. Balasubramanian, \textit{Time-frequency
detection of gravitational waves}, gr-qc/9905023, and references
therein. 

\end{thebibliography}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

