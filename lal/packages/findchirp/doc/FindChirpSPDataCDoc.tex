Provides functions to condition the input data from the interferometer
to a form that can be used by the \texttt{FindChirpFilter()} function.

At the present time this also includes the template independent part of the
stationary phase filter.

\subsubsection*{Prototypes}
\vspace{0.1in}
\input{FindChirpSPDataCP}
\idx{LALFindChirpSPData()}

\begin{description}
\item[\texttt{LALFindChirpSPDataInit()}] takes as input the address
of a structure of type \texttt{FindChirpInitParams} containing the correct
values to intialize a search. It creates a structure of type
\texttt{FindChirpSPDataParams} as described above and returns its address.

\item[\texttt{LALFindChirpSPDataFinalize()}] takes as the address
of a structure of type \texttt{FindChirpSPDataParams} destroys this
structure and sets the address to NULL.

\item[\texttt{LALFindChirpSPData()}] conditions the interferometer data
as described by the algorithm below.

\item[\texttt{LALFindChirpBCVData()}] conditions the interferometer data
as described by the algorithm below.
\end{description}

\subsubsection*{Algorithm for SP templates}

The \texttt{LALFindChirpSPData()} function takes as input three quantities
\begin{enumerate}
\item An uncallibrated input data channel $v_j$ (typically LSC-AS\_Q).
\item A one sided power spectral density of the input data $S_v(|f_k|)$.
\item The frequency domain response function of the input data channel
$R(f_k)$ which is used to convert from an uncallibrated input data into
strain.
\end{enumerate}

The input parameters also contain a dynmaic range scaling parameter
\texttt{dynRange}. This is used to keep the quantities in the range of
\texttt{REAL4} and cancells from the filter output. It is typically $2^{69}$
for the LIGO channel \texttt{AS\_Q}.

The discrete low frequency cutoff is computed from \texttt{fLow} by
\begin{equation}
k_{\mathrm{low}} = \frac{\mathtt{fLow}}{\Delta f}.
\end{equation}
$k_{\mathrm{low}}$ is set to unity if this quantity is less than one.

\paragraph*{Computation of strain and inverse power spectrum}

The uncallibrated input data channel $v_j$ is Fourier transformed into the
frequency domain to obtain $\tilde{v}_k$. This is then converted into strain
$\tilde{h}_k$ by computing
\begin{equation}
\tilde{h}_k = \mathtt{dynRange} \times R(f_k) \tilde{v}_k.
\end{equation}
The inverse power spectrum $S^{-1}_v(|f_k|)$ is computed between the low
frequency cutoff $f_{\mathrm{low}}$ and the Nyquist frequency. Below
$f_{\mathrm{low}}$, the inverse power spectrum is set to zero. If the low
frequency cutoff is set to $0$, then the DC component of the spectrum is
set to zero.

\paragraph*{Truncation of the Inverse Power Spectrum in the Time Domain}

Recall that the FFT we use to compute the match filter treats the data as
being periodic and that we had to ignore part of the filter output that was
corrupted due to wraparound of the filter output from the chirp signal.

As well as the chirp, we are also filtering the data against the inverse power
spectrum. The chirp has a duration that is typically much less than then
length of the data segment. It only corrupts a region that is the length of
the chirp at the start of the data segment. However, in the time domain the
inverse power spectrum is the same length of the data segmemt. This will cause
the filter output to be corrupted for all times, as it is non-zero over the
entire data segment.

To prevent this, we truncate the inverse power spectrum to a specified length
in the time domain. This has the effect of smoothing out the high $Q$ features
which and restructing the corruption of the filter to the part of the data
segment where the power spectrum is non-zero. These regions can then be
ignored when searching for chirps in the filter output.

The parameter that controls the duration of the power spectrum in the time
domain is \texttt{invSpecTrunc} and the algorithm used to perform the
truncation is as follows:
\begin{enumerate}
\item Compute the square root of the inverse power spectrum,
$\sqrt{S^{-1}_v(|f_k|)}$.
\item Set the Nyquist, $k = N/2$ and DC $k = 0$ components of this to zero.
\item Inverse FFT to to obtain the time domain inverse PSD of length $N$
points.
\item Zero the spectrum between the points $j = \mathtt{invSpecTrunc}/2$ and
$j = N - \mathtt{invSpecTrunc}/2$. This sets the length of the inverse
spectrum in the time domain to be \texttt{invSpecTrunc} points.
\item FFT the time domain quantity back to the frequency domain.
\item Divide by $N$ so that to recover the quantity before the inverse FFT.
\item Square this quantity to recover $S^{-1}_v(|f_k|)$.
\item Set the Nyqist and DC frequencies to zero and zero the inverse power
spectrum below $f_{\mathrm{low}}$.
\end{enumerate}

The strain inverse power spectral density is then computed by
\begin{equation}
S^{-1}_h(|f_k|) = \frac{1}{\left|\mathtt{dynRange} \times R(f_k)\right|^2}
 S^{-1}_v(|f_k|).
\end{equation}

\paragraph*{Output Data}
The quantity \texttt{segNorm} is computed by
\begin{equation}
\mathtt{segNorm} =
   \sum_{k = k_{\mathrm{low}}}^{N/2} \frac{k^{-\frac{7}{3}}}
   {\left|\mathtt{dynRange}\times R(f_k)\right|^2 S_v(|f_k|)}.
\end{equation}

The output data is given by
\begin{equation}
\mathtt{outputData[k]} =
\frac{k^{-7/6} \times \mathtt{dynRange} \times R(f_k)\tilde{v}_k}
{\left|\mathtt{dynRange} \times R(f_k)\right|^2 S_v(|f_k|)}
\end{equation}
and is stored in the \texttt{FindChirpSegmentVector} structure. Note the
quantity $k^{-\frac{7}{6}}$ which is specific to the stationary phase chirps
used.

\paragraph*{Calculation of the $\chi^2$ Bins}

If a $\chi^2$ veto is requested, the bin boundaries for the veto are computed
at this point. The indices $k$ in the frequency domain that divide the power
in the quantity
\begin{equation}
\frac{k^{-\frac{7}{3}}}
{\left|\mathtt{dynRange}\times R(f_k)\right|^2 S_v(|f_k|)}.
\end{equation}
into equal intervals are stored in the array \texttt{chisqBin}.

\subsubsection*{Algorithm for BCV templates}

The \texttt{LALFindChirpBCVData()} function takes as input...

\subsubsection*{Uses}
\begin{verbatim}
LALCalloc()
LALFree()
LALCreateVector()
LALDestroyVector()
LALCreateForwardRealFFTPlan()
LALDestroyRealFFTPlan()
LALCCreateVector()
LALCDestroyVector()
LALForwardRealFFT()
LALReverseRealFFT()
\end{verbatim}

\subsubsection*{Notes}

