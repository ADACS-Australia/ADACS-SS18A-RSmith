\newcommand{\ospsd}{\ensuremath{S\left(\left|f_{k}\right|\right)}}

\chapter{Package \texttt{findchirp}}

This package contains LAL routines to search for binary inspiral chirps
using templatated matched filtering and the $\chi^2$ veto. The
\texttt{findchirp} package is designed to allow the user to construct code to
filter interferometer data and produce a list of candidate inspiral events. It
also contains functionality to perform simulation and testing of the inspiral
search. Conceptually the package is divided into the following parts:

\begin{itemize}
\item Processing the raw interferometer input data into a form that can be
used for the filtering process.

\item Processing an inspiral chirp template into a form that can be used by
the filter, generating the chirp template internally, if necessary.

\item Using the processed input data, construction of a statistic on which to
search for chirps and searching for candidate events.

\item Constructing a veto statistic to apply to candidate events to reduce the
possibility of false alarms.

\item Code to tie all this functionality together and provide an engine to
execute these functions and perform a full flat or hierarchical inspiral
search.

\item Functionality to search for an inspiral waveform in the outputs of a
pair of interferometers.
\end{itemize}

We introduce the conventions used in the package and then describe the theory
and implementation of the code. An overview of the package is as follows:
\begin{enumerate}
\item The header \texttt{FindChirp.h} and modules grouped therein provide the
core functionality of the package. This includes the code to perform matched
filtering and search for chirps with a signal to noise ratio above a given
threshold.

\item The header \texttt{FindChirpChisq.h} and associated module provide
functionality to perform a $\chi^2$ veto on candidate events generated by the
\texttt{FindChirpFilter()} function.

\item The header \texttt{FindChirpSP.h} provides functionality to condition
the input interferometer data so that it can be used by the 
\texttt{FindChirpFilter()} function. It also provides code to generate 2.5
post-Newtonian inspiral chirps using the stationary phase approximation to the
inspiral waveform.

\item The header \texttt{FindChirpEngine.h} and associated modules provide an
engine to perform a flat or heirarchical search using the other functions in
the package. 

Simulation code is also provided in the engine, so that various Monte Carlo
simulations may be run using the same code that is used to actually search for
the chirps.

If LAL is configured with the \texttt{--enable-mpi} option it can
be used in an MPI environment, such the LDAS \texttt{wrapperAPI}. An
implementation of this is provided in the \texttt{inspiral} package of
LALWrapper. The MPI code required the modules grouped under the header
\texttt{FindChirpExch.h}, which are built when the appropriate configure
options are specified.

The \texttt{findchirp} engine called from standalone code, such as code
written to run under the Condor enviornment, although the functionality for
this ths not yet complete. An implementation of this is under development in
the \texttt{finchirp} program in LALApps. To run under Condor, LAL must be
configured with the \texttt{--disable-mpi} option.

\item The header{TwoInterfFindChirp.h} provides code to search for an inspiral
waveform in the outputs of a pair of interferometers.
\end{enumerate}

At the present time, the conditioning of the input data is performed by the
function \texttt{FindChirpSPData()}, so the order of the documentation is
silightly reversed. Documantation of the algorithm used to condition the input
data appears after the documentation of the filtering functions that use this
data.

The next stage of development will be to modify the package so that the code
that performs conditioning of the input data that is indepenent of the
implementation used for chirp generation is moved from the
\texttt{FindChirpSPData()} to a function \texttt{FindChirpData()} under the
\texttt{FindChirp.h} header. The function \texttt{FindChirpSPData()} will then
be reduced to contain only the code that performs data conditioning specific
to the stationary phase approximation. A new header will be created called
\texttt{FindChirpTD.h} that contains the necessary functions
\texttt{FindChirpTDData()} and \texttt{FindChirpTDFilter()} to allow the use
of different time domain generate inspiral signal, such as those provided by
the \texttt{inspiral} package. At this stage, the ordering of the
documentation will be corrected.
\newpage

\section{Conventions}

As mandated, we follow the standards for LSC code in the standards
document T010095. Before we discuss the code itself, we present a detailed
overview of the standards. The reason for this is two fold; frist, this code is
designed to interoperate with other code used by the LSC, such as recieving
power spectral densities computed by the LDAS \texttt{datacondAPI}. Second, it
is very easy to loose track of normalisation of the filter output, causing
events to be reported with incorrect parameters. Without strict adherence to
the standards interoperability and accuracy would not be possible.

All the \texttt{findchirp} functions measure mass in units of $M_\odot$ 
and time in units of seconds.

\subsection{The Fourier Transform}

We define the forward Fourier transform $\tilde{h}(f)$ of a time domain
quantity $h(t)$ to be
\begin{equation}
\tilde{h}(f)=\int_{-\infty}^\infty dt\,h(t)\, e^{- 2 \pi i f t}
\end{equation}
and the inverse Fourier transform to be 
\begin{equation}
h(t)=\int_{-\infty}^\infty df\,\tilde{h}(f)\, e^{2 \pi i f t}.
\end{equation}
If the function $h(t)$ is sampled at $N$ consecitive points with sampling
interval $\Delta t$, that is
\begin{equation}
h_j \equiv h(t_j)\ ,\quad t_j = j\Delta t,
\end{equation}
we only have $N$ input values, so we can only produce $N$ independent values
for the Fourier transform. Further, we can only produce values in the interval
$(-f_c,f_c)$ where $f_c$ is the Nyquist critical frequency
\begin{equation}
f_c = \frac{1}{2\Delta t}.
\end{equation}
We compute estimates of the Fourier transform at the $N + 1$ discrete values
\begin{equation}
f_k \equiv \frac{k}{N\Delta t}\quad k = -\frac{N}{2},\ldots,\frac{N}{2}.
\end{equation}
There are only $N$ independent values here as the extremevales of $k$
correspond to the upper and lower limites of the Nyquist critical frequency
range and are equal. We now proceed to define the discrete Fourier transform.
Consider
\begin{eqnarray}
\tilde{h}(f_k) &=& \int_{-\infty}^\infty dt\,h(t)\, e^{-2 \pi i f t} \\
&\approx& \sum_{j=0}^{N-1} \Delta t\, h(t_j) e^{-2 \pi i f_k t_j} \\
&\approx& \Delta t \sum_{j=0}^{N-1} h_j e^{-2 \pi i j k / N} .
\end{eqnarray}
According to T010095, we define the discrete Fourier transform (DFT) to be
\begin{equation}
\tilde{h}_k = \sum_{j=0}^{N-1} h_j e^{-i 2 \pi j k / N}
\end{equation}
and then we can recover $\tilde{h}(f_k)$ by
\begin{equation}
\tilde{h}(f_k) = \Delta t\, \tilde{h}_k.
\end{equation}
The inverse Fourier transform is
\begin{equation}
h(t)=\int_{-\infty}^\infty dt\,\tilde{h}(f)\, e^{2 \pi i f t} .
\end{equation}
Using
\begin{equation}
\Delta f = f_{k+1} - f_k = \frac{k+1}{N\Delta t} - \frac{k}{N\Delta t} =
\frac{1}{N\Delta t}
\end{equation}
we may write
\begin{eqnarray}
h(t_j) &\approx& \sum_{k=0}^{N-1} \tilde{h}(f_k) e^{2 \pi i f_k t_j / N}
\Delta f \\
&=& \sum_{k=0}^{N-1} \Delta \tilde{h}_k e^{2 \pi i j k / N}\frac{1}{N\Delta t}
\\
&=& \frac{1}{N} \sum_{k=0}^{N-1} \tilde{h}_k e^{2 \pi i j k / N}
\end{eqnarray}
which is the inverse DFT according to T010095. Note that the LAL ``reverse''
DFT functions do not include the factor $1/N$ in their output.

\subsection{Power Spectral Densities}

Consider a signal, $n(t)$, containing Gaussian noise and dimensions $U$, which
may be voltage, strain, etc. We define the (one sided) power spectral density,
$S(|f|)$, of this signal by the equation
\begin{equation}
\left\langle\tilde{n}(f) \tilde{n}^\ast(f')\right\rangle = 
\frac{1}{2}S\left(\left|f\right|\right)\delta(f-f).
\end{equation}
The total power in a signal is independent of whether it is computed in the
time or the frequency domain (Parseval's theorem). The power in a signal in
the interval $(0,T)$  is given by
\begin{equation}
P = \frac{1}{T} \int_{0}^{T} dt\, \left|h(t)\right|^2 = 
\int_{0}^{f_c} df\, S\left(\left|f\right|\right).
\end{equation}
For discretely sampled quantities we have
\begin{equation}
\left\langle\tilde{n}(f_k) \tilde{n}^\ast(f_{k'})\right\rangle = 
\frac{1}{2}\ospsd\delta(f_k-f_{k'})
\end{equation}
which gives
\begin{equation}
\label{findchirp:eq:ospsddef}
\left\langle\tilde{n}_k \tilde{n}_{k'}^\ast\right\rangle = 
\frac{N}{2\Delta t}\ospsd\delta_{kk'}
\end{equation}
which defines \ospsd in terms of the discrete frequency domain quantities.
Parsevals theorem becomes
\begin{equation}
\Delta t \sum_{j=0}^{N-1} |h_j|^2 
= \sum_{k=0}^{[N/2]} S\left(\left|f_k\right|\right),
\end{equation}
the power spectral density having units of $\mathrm{time}\times U^2$. The
definition in equation [\ref{findchirp:eq:psddef}] is equivalent to that in
the standards document T010095%
\footnote{Note that we write \ospsd insted of $S_k$.}:
\begin{equation}
\ospsd = \left\{
\begin{array}{ll}
\frac{\Delta t}{N} | \tilde{h}_0 |^2 & k = 0, \\
\\
\frac{\Delta t}{N} \left[ | \tilde{h}_k |^2 + | \tilde{h}_{N-k} |^2 \right] &
k\neq 0.
\end{array}
\right.
\end{equation}

\newpage\input{FindChirpH}
\newpage\input{FindChirpChisqH}
\newpage\input{FindChirpSPH}
\newpage\input{FindChirpEngineH}
\newpage\input{FindChirpExchH}
\newpage\input{TwoInterfFindChirpH}
