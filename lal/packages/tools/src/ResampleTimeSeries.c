/**** <lalVerbatim file="ResampleTimeSeriesCV">
 * Author: Brown, D. A., Brady, P. R. and Fritschel, P. F.
 * $Id$
 **** </lalVerbatim> */

/**** <lalLaTeX>
 *
 * \subsection{Module \texttt{ResampleTimeSeries.c}}
 * \label{ss:ResampleTimeSeries.c}
 *
 * The module contains functions to resample time series. 
 *
 * \textcolor{red}{Warning: these functions have not yet been tested}
 *
 * \textcolor{red}{Danger: In fact this function is very unsafe. It is only a
 * placeholder until I get new code from Isabel.}
 *
 * \subsection*{Prototypes}
 * \input{ResampleTimeSeriesCP}
 *
 * \vfill{\footnotesize\input{ResampleTimeSeriesCV}}
 *
 **** </lalLaTeX> */

/* <lalVerbatim file="ResampleTimeSeriesCP"> */

#include <math.h>
#include <lal/LALStdlib.h>
#include <lal/LALStdio.h>
#include <lal/AVFactories.h>
#include <lal/LALConstants.h>
#include <lal/IIRFilter.h>
#include <lal/BandPassTimeSeries.h>
#include <lal/ResampleTimeSeries.h>

NRCSID( RESAMPLETIMESERIESC, "$Id$" );

void
LALResampleREAL4TimeSeries(
    LALStatus          *status,
    REAL4TimeSeries    *ts, 
    ResampleTSParams   *params
    )
{ /* </lalVerbatim> */
  UINT4         resampleFactor;
  UINT4         i;
  REAL4        *dataPtr = NULL;
  INT8          startTimeNS = 0;

  INITSTATUS( status, "LALResampleREAL4TimeSeries", RESAMPLETIMESERIESC );
  ATTATCHSTATUSPTR( status );

  ASSERT( ts, status, 
      RESAMPLETIMESERIESH_ENULL, RESAMPLETIMESERIESH_MSGENULL );
  ASSERT( ts->deltaT > 0, status,
      RESAMPLETIMESERIESH_ERATE, RESAMPLETIMESERIESH_MSGERATE );
  ASSERT( ts->data, status, 
      RESAMPLETIMESERIESH_ENULL, RESAMPLETIMESERIESH_MSGENULL );
  ASSERT( ts->data->length, status, 
      RESAMPLETIMESERIESH_EZERO, RESAMPLETIMESERIESH_MSGEZERO );
  ASSERT( ts->data->data, status, 
      RESAMPLETIMESERIESH_ENULL, RESAMPLETIMESERIESH_MSGENULL );
  ASSERT( params, status,
      RESAMPLETIMESERIESH_ENULL, RESAMPLETIMESERIESH_MSGENULL );
  ASSERT( params->deltaT > 0, status,
      RESAMPLETIMESERIESH_ERATE, RESAMPLETIMESERIESH_MSGERATE );

  /* determine the factor by which to resample */
  resampleFactor = floor( params->deltaT / ts->deltaT + 0.5 );

  /* check that the resampling factor is valid */
  if ( resampleFactor < 1 ||
      fabs( params->deltaT - resampleFactor * ts->deltaT ) 
      > 1e-3 * ts->deltaT )
  {
    ABORT( status, RESAMPLETIMESERIESH_EINVD, RESAMPLETIMESERIESH_MSGEINVD );
  }

  /* just return if no resampling is required */
  if ( resampleFactor == 1 )
  {
    LALInfo( status, "No resampling required" );
    DETATCHSTATUSPTR( status );
    RETURN( status );
  }

  /* check that we are resampling by a power of two */
  if ( ! ( resampleFactor == 0x1 || resampleFactor == 0x2 || 
        resampleFactor == 0x4 || resampleFactor == 0x8 ||
        resampleFactor == 0x10 || resampleFactor == 0x20 || 
        resampleFactor == 0x40 || resampleFactor == 0x80 ) )
  {
    ABORT( status, RESAMPLETIMESERIESH_ELOG2, RESAMPLETIMESERIESH_MSGELOG2 );
  }

  if ( params->filterType == defaultButterworth )
  {
    params->filterParams.butterworth.nMax = 20;
    params->filterParams.butterworth.f1   = 0.5 / params->deltaT;
    params->filterParams.butterworth.a1   = 0.1;
    params->filterParams.butterworth.f2   = LAL_REAL4_MAX;
    params->filterParams.butterworth.a1   = 0.0;

    LALDButterworthREAL4TimeSeries( status->statusPtr, ts, 
        &(params->filterParams.butterworth) );
    CHECKSTATUSPTR( status );
  }
  else if ( params->filterType == LDASorderTen )
  {
#include "ldasfircoefs.h"
    INT8        n = 10;
    REAL8Vector recursCoef;
    REAL8Vector directCoef;
    REAL8       recursd0 = -1;
    CHAR        msg[256];

    recursCoef.length = 1;
    recursCoef.data = &recursd0;
    params->filterParams.iirfilter.name = "FIR filter";
    params->filterParams.iirfilter.deltaT = ts->deltaT;
    params->filterParams.iirfilter.recursCoef = &recursCoef;
    params->filterParams.iirfilter.directCoef = &directCoef;
    params->filterParams.iirfilter.history = NULL;

    if ( resampleFactor == 2 )
    {
      directCoef.data = ldasByTwo;
      directCoef.length = 41;
      LALInfo( status, "Using LDAS FIR filter generated by firlp(0.5,40)" );
    }
    else if ( resampleFactor == 4 )
    {
      directCoef.data = ldasByFour;
      directCoef.length = 81;
      LALInfo( status, "Using LDAS FIR filter generated by firlp(0.25,80)" );
    }
    else if ( resampleFactor == 8 )
    {
      directCoef.data = ldasByEight;
      directCoef.length = 161;
      LALInfo( status, "Using LDAS FIR filter generated by firlp(0.125,160)" );
    }
    else
    {
      ABORT( status, RESAMPLETIMESERIESH_ELDAS, RESAMPLETIMESERIESH_MSGELDAS );
    }

    LALSnprintf( msg, 256, "Filter length is %d points\n", directCoef.length );
    LALInfo( status, msg );

    LALDCreateVector( status->statusPtr, 
        &(params->filterParams.iirfilter.history), directCoef.length - 1 );
    CHECKSTATUSPTR( status );

    LALDIIRFilterREAL4Vector( status->statusPtr, ts->data,
        &(params->filterParams.iirfilter) );
    CHECKSTATUSPTR( status );

    LALGPStoINT8( status->statusPtr, &startTimeNS, &(ts->epoch) );
    CHECKSTATUSPTR( status );
    startTimeNS -= (INT8) floor( 10 * 1.0e9 * params->deltaT + 0.5 );
    LALINT8toGPS( status->statusPtr, &(ts->epoch), &startTimeNS );
    CHECKSTATUSPTR( status );
    
    LALDDestroyVector( status->statusPtr, 
        &(params->filterParams.iirfilter.history) );
    CHECKSTATUSPTR( status );
  }

  /* decimate the time series */
  ts->deltaT = params->deltaT;
  ts->data->length /= resampleFactor;
  dataPtr = ts->data->data;
  for ( i = 0; i < ts->data->length; ++i )
  {
    ts->data->data[i] = *dataPtr;
    dataPtr += resampleFactor;
  }
  LALRealloc( ts->data->data, ts->data->length * sizeof(REAL4) );

  DETATCHSTATUSPTR( status );
  RETURN( status );

}
