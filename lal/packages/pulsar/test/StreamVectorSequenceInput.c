/******************** <lalVerbatim file="StreamVectorSequenceInputCV">
Author: Creighton, T. D.
$Id$
**************************************************** </lalVerbatim> */

/********************************************************** <lalLaTeX>

\subsection{Module \texttt{StreamVectorSequenceInput.c}}
\label{ss:StreamVectorSequenceInput.c}

Reads the entire contents of a file into a vector sequence.

\subsubsection*{Prototypes}
\vspace{0.1in}
\input{StreamVectorSequenceInputCP}
\idx{LALCHARReadVectorSequence()}
\idx{LALI2ReadVectorSequence()}
\idx{LALI4ReadVectorSequence()}
\idx{LALI8ReadVectorSequence()}
\idx{LALU2ReadVectorSequence()}
\idx{LALU4ReadVectorSequence()}
\idx{LALU8ReadVectorSequence()}
\idx{LALSReadVectorSequence()}
\idx{LALDReadVectorSequence()}

\subsubsection*{Description}

These routines read data from the I/O stream \verb@*stream@ until an
end-of-file is reached.  Each line is stored as a data vector, and the
vectors are combined into a LAL vector sequence structure
\verb@**sequence@.  Each line vector is padded with zeros to match the
length of the longest line.  The routine passes back a pointer to the
new structure.

The routine \verb@LALCHARReadVectorSequence()@ essentially stores an
image of the file as a sequence of lines padded with \verb@'\0'@
characters.

The numeric routines add an extra consideration: When they read a line
with no data (either a blank line or one containing only comments),
they will skip that line rather than storing it as a vector of zeros.
As with the routines in \verb@StreamVectorInput.c@, a \verb@#@ sign at
the beginning of a line, or a \verb@%@ sign anywhere in the line,
indicates that the remainder of the line is a comment and will be
ignored.

\subsubsection*{Algorithm}

These functions first create a linked list of vectors, using the
routines in \verb@StreamVectorInput.c@ to read them in.  Once the list
is complete, the longest vector length is determined, and the vector
sequence is created and filled.

As noted above, the numeric routines skip over blank lines.  They do
this by catching and handling the \verb@LEN@ error code generated by
the vector input routine.  However, it is worth pointing out that the
vector input routine will have generated an error message if the error
reporting bit in \verb@lalDebugLevel@ was set.  Thus you can in
general expect to see a number of \verb@ABORT:@ error messages when
reading files that have blank or comment lines.

\subsubsection*{Uses}
\begin{verbatim}
LALCalloc()         LALFree()
LALCHARReadVector() LALCHARDestroyVector() LALCHARCreateVectorSequence()
LALI2ReadVector()   LALI2DestroyVector()   LALI2CreateVectorSequence()
LALI4ReadVector()   LALI4DestroyVector()   LALI4CreateVectorSequence()
LALI8ReadVector()   LALI8DestroyVector()   LALI8CreateVectorSequence()
LALU2ReadVector()   LALU2DestroyVector()   LALU2CreateVectorSequence()
LALU4ReadVector()   LALU4DestroyVector()   LALU4CreateVectorSequence()
LALU8ReadVector()   LALU8DestroyVector()   LALU8CreateVectorSequence()
LALSReadVector()    LALSDestroyVector()    LALSCreateVectorSequence()
LALDReadVector()    LALDDestroyVector()    LALDCreateVectorSequence()
\end{verbatim}

\subsubsection*{Notes}

\vfill{\footnotesize\input{StreamVectorSequenceInputCV}}

******************************************************* </lalLaTeX> */

#include <lal/LALStdlib.h>
#include <lal/AVFactories.h>
#include <lal/SeqFactories.h>
#include "StreamInput.h"

NRCSID(STREAMVECTORSEQUENCEINPUTC,"$Id$");

/* Define linked-list of pointers to vectors of arbitrary type. */
typedef union tagVector {
  CHARVector *chv;
  INT2Vector *i2v;
  INT4Vector *i4v;
  INT8Vector *i8v;
  UINT2Vector *u2v;
  UINT4Vector *u4v;
  UINT8Vector *u8v;
  REAL4Vector *sv;
  REAL8Vector *dv;
} Vector;
typedef struct tagVectorList {
  Vector vector;
  struct tagVectorList *next;
} VectorList;


#define FREECHARVECTORLIST                                           \
do {                                                                 \
  if ( head.vector.chv ) {                                           \
    TRY( LALCHARDestroyVector( stat->statusPtr,                      \
			     &(head.vector.chv) ), stat );           \
  }                                                                  \
  here = head.next;                                                  \
  while ( here ) {                                                   \
    VectorList *nextPtr = here->next;                                \
    if ( here->vector.chv ) {                                        \
      TRY( LALCHARDestroyVector( stat->statusPtr,                    \
			       &(here->vector.chv) ), stat );        \
    }                                                                \
    LALFree( here );                                                 \
    here = nextPtr;                                                  \
  }                                                                  \
} while (0)
/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
static const VectorList empty;
void
LALCHARReadVectorSequence( LALStatus          *stat,
			   CHARVectorSequence **sequence,
			   FILE               *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  CHAR *data;           /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALCHARReadVectorSequence",
	      STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    TRY( LALCHARReadVector( stat->statusPtr, &(head.vector.chv), stream ),
	 stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    if ( !here->next ) {
      FREECHARVECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    here = here->next;
    LALCHARReadVector( stat->statusPtr, &(here->vector.chv), stream );
    BEGINFAIL( stat ) {
      FREECHARVECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    } ENDFAIL( stat );
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    nRows++;
    if ( here->vector.chv->length > nCols )
      nCols = here->vector.chv->length;
    here = here->next;
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALCHARCreateVectorSequence( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREECHARVECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    UINT4 length = here->vector.chv->length;
    memcpy( data, here->vector.chv->data, length );
    if ( nCols - length > 0 )
      memset( data + length, 0, nCols - length );
    data += nCols;
    here = here->next;
  }

  /* Free memory and exit. */
  FREECHARVECTORLIST;
  RETURN( stat );
}


#define FREEI2VECTORLIST                                             \
do {                                                                 \
  if ( head.vector.i2v ) {                                           \
    TRY( LALI2DestroyVector( stat->statusPtr,                        \
			     &(head.vector.i2v) ), stat );           \
  }                                                                  \
  here = head.next;                                                  \
  while ( here ) {                                                   \
    VectorList *nextPtr = here->next;                                \
    if ( here->vector.i2v ) {                                        \
      TRY( LALI2DestroyVector( stat->statusPtr,                      \
			       &(here->vector.i2v) ), stat );        \
    }                                                                \
    LALFree( here );                                                 \
    here = nextPtr;                                                  \
  }                                                                  \
} while (0)
/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALI2ReadVectorSequence( LALStatus  *stat,
			 INT2VectorSequence **sequence,
			 FILE *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  INT2 *data;           /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALI2ReadVectorSequence",
	      STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    LALI2ReadVector( stat->statusPtr, &(head.vector.i2v), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else
      CHECKSTATUSPTR( stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    if ( !here->next ) {
      FREEI2VECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    here = here->next;
    LALI2ReadVector( stat->statusPtr, &(here->vector.i2v), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else {
      BEGINFAIL( stat ) {
	FREEI2VECTORLIST;
      } ENDFAIL( stat );
    }
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.i2v ) {
      if ( here->vector.i2v->length > nCols )
	nCols = here->vector.i2v->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREEI2VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALI2CreateVectorSequence( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREEI2VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.i2v ) {
      UINT4 i;
      UINT4 length = here->vector.i2v->length;
      INT2 *hereData = here->vector.i2v->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 2*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREEI2VECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define FREEI4VECTORLIST                                             \
do {                                                                 \
  if ( head.vector.i4v ) {                                           \
    TRY( LALI4DestroyVector( stat->statusPtr,                        \
			     &(head.vector.i4v) ), stat );           \
  }                                                                  \
  here = head.next;                                                  \
  while ( here ) {                                                   \
    VectorList *nextPtr = here->next;                                \
    if ( here->vector.i4v ) {                                        \
      TRY( LALI4DestroyVector( stat->statusPtr,                      \
			       &(here->vector.i4v) ), stat );        \
    }                                                                \
    LALFree( here );                                                 \
    here = nextPtr;                                                  \
  }                                                                  \
} while (0)
/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALI4ReadVectorSequence( LALStatus          *stat,
			 INT4VectorSequence **sequence,
			 FILE               *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  INT4 *data;           /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALI4ReadVectorSequence",
	      STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    LALI4ReadVector( stat->statusPtr, &(head.vector.i4v), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else
      CHECKSTATUSPTR( stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    if ( !here->next ) {
      FREEI4VECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    here = here->next;
    LALI4ReadVector( stat->statusPtr, &(here->vector.i4v), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else {
      BEGINFAIL( stat ) {
	FREEI4VECTORLIST;
      } ENDFAIL( stat );
    }
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.i4v ) {
      if ( here->vector.i4v->length > nCols )
	nCols = here->vector.i4v->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREEI4VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALI4CreateVectorSequence( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREEI4VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.i4v ) {
      UINT4 i;
      UINT4 length = here->vector.i4v->length;
      INT4 *hereData = here->vector.i4v->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 4*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREEI4VECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define FREEI8VECTORLIST                                             \
do {                                                                 \
  if ( head.vector.i8v ) {                                           \
    TRY( LALI8DestroyVector( stat->statusPtr,                        \
			     &(head.vector.i8v) ), stat );           \
  }                                                                  \
  here = head.next;                                                  \
  while ( here ) {                                                   \
    VectorList *nextPtr = here->next;                                \
    if ( here->vector.i8v ) {                                        \
      TRY( LALI8DestroyVector( stat->statusPtr,                      \
			       &(here->vector.i8v) ), stat );        \
    }                                                                \
    LALFree( here );                                                 \
    here = nextPtr;                                                  \
  }                                                                  \
} while (0)
/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALI8ReadVectorSequence( LALStatus          *stat,
			 INT8VectorSequence **sequence,
			 FILE               *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  INT8 *data;           /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALI8ReadVectorSequence",
	      STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    LALI8ReadVector( stat->statusPtr, &(head.vector.i8v), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else
      CHECKSTATUSPTR( stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    if ( !here->next ) {
      FREEI8VECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    here = here->next;
    LALI8ReadVector( stat->statusPtr, &(here->vector.i8v), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else {
      BEGINFAIL( stat ) {
	FREEI8VECTORLIST;
      } ENDFAIL( stat );
    }
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.i8v ) {
      if ( here->vector.i8v->length > nCols )
	nCols = here->vector.i8v->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREEI8VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALI8CreateVectorSequence( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREEI8VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.i8v ) {
      UINT4 i;
      UINT4 length = here->vector.i8v->length;
      INT8 *hereData = here->vector.i8v->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 8*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREEI8VECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define FREEU2VECTORLIST                                             \
do {                                                                 \
  if ( head.vector.u2v ) {                                           \
    TRY( LALU2DestroyVector( stat->statusPtr,                        \
			     &(head.vector.u2v) ), stat );           \
  }                                                                  \
  here = head.next;                                                  \
  while ( here ) {                                                   \
    VectorList *nextPtr = here->next;                                \
    if ( here->vector.u2v ) {                                        \
      TRY( LALU2DestroyVector( stat->statusPtr,                      \
			       &(here->vector.u2v) ), stat );        \
    }                                                                \
    LALFree( here );                                                 \
    here = nextPtr;                                                  \
  }                                                                  \
} while (0)
/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALU2ReadVectorSequence( LALStatus           *stat,
			 UINT2VectorSequence **sequence,
			 FILE                *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  UINT2 *data;          /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALU2ReadVectorSequence",
	      STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    LALU2ReadVector( stat->statusPtr, &(head.vector.u2v), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else
      CHECKSTATUSPTR( stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    if ( !here->next ) {
      FREEU2VECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    here = here->next;
    LALU2ReadVector( stat->statusPtr, &(here->vector.u2v), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else {
      BEGINFAIL( stat ) {
	FREEU2VECTORLIST;
      } ENDFAIL( stat );
    }
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.u2v ) {
      if ( here->vector.u2v->length > nCols )
	nCols = here->vector.u2v->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREEU2VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALU2CreateVectorSequence( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREEU2VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.u2v ) {
      UINT4 i;
      UINT4 length = here->vector.u2v->length;
      UINT2 *hereData = here->vector.u2v->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 2*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREEU2VECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define FREEU4VECTORLIST                                             \
do {                                                                 \
  if ( head.vector.u4v ) {                                           \
    TRY( LALU4DestroyVector( stat->statusPtr,                        \
			     &(head.vector.u4v) ), stat );           \
  }                                                                  \
  here = head.next;                                                  \
  while ( here ) {                                                   \
    VectorList *nextPtr = here->next;                                \
    if ( here->vector.u4v ) {                                        \
      TRY( LALU4DestroyVector( stat->statusPtr,                      \
			       &(here->vector.u4v) ), stat );        \
    }                                                                \
    LALFree( here );                                                 \
    here = nextPtr;                                                  \
  }                                                                  \
} while (0)
/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALU4ReadVectorSequence( LALStatus           *stat,
			 UINT4VectorSequence **sequence,
			 FILE                *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  UINT4 *data;          /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALU4ReadVectorSequence",
	      STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    LALU4ReadVector( stat->statusPtr, &(head.vector.u4v), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else
      CHECKSTATUSPTR( stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    if ( !here->next ) {
      FREEU4VECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    here = here->next;
    LALU4ReadVector( stat->statusPtr, &(here->vector.u4v), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else {
      BEGINFAIL( stat ) {
	FREEU4VECTORLIST;
      } ENDFAIL( stat );
    }
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.u4v ) {
      if ( here->vector.u4v->length > nCols )
	nCols = here->vector.u4v->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREEU4VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALU4CreateVectorSequence( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREEU4VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.u4v ) {
      UINT4 i;
      UINT4 length = here->vector.u4v->length;
      UINT4 *hereData = here->vector.u4v->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 4*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREEU4VECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define FREEU8VECTORLIST                                             \
do {                                                                 \
  if ( head.vector.u8v ) {                                           \
    TRY( LALU8DestroyVector( stat->statusPtr,                        \
			     &(head.vector.u8v) ), stat );           \
  }                                                                  \
  here = head.next;                                                  \
  while ( here ) {                                                   \
    VectorList *nextPtr = here->next;                                \
    if ( here->vector.u8v ) {                                        \
      TRY( LALU8DestroyVector( stat->statusPtr,                      \
			       &(here->vector.u8v) ), stat );        \
    }                                                                \
    LALFree( here );                                                 \
    here = nextPtr;                                                  \
  }                                                                  \
} while (0)
/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALU8ReadVectorSequence( LALStatus           *stat,
			 UINT8VectorSequence **sequence,
			 FILE                *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  UINT8 *data;          /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALU8ReadVectorSequence",
	      STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    LALU8ReadVector( stat->statusPtr, &(head.vector.u8v), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else
      CHECKSTATUSPTR( stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    if ( !here->next ) {
      FREEU8VECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    here = here->next;
    LALU8ReadVector( stat->statusPtr, &(here->vector.u8v), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else {
      BEGINFAIL( stat ) {
	FREEU8VECTORLIST;
      } ENDFAIL( stat );
    }
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.u8v ) {
      if ( here->vector.u8v->length > nCols )
	nCols = here->vector.u8v->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREEU8VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALU8CreateVectorSequence( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREEU8VECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.u8v ) {
      UINT4 i;
      UINT4 length = here->vector.u8v->length;
      UINT8 *hereData = here->vector.u8v->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 8*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREEU8VECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define FREESVECTORLIST                                              \
do {                                                                 \
  if ( head.vector.sv ) {                                            \
    TRY( LALSDestroyVector( stat->statusPtr,                         \
		            &(head.vector.sv) ), stat );             \
  }                                                                  \
  here = head.next;                                                  \
  while ( here ) {                                                   \
    VectorList *nextPtr = here->next;                                \
    if ( here->vector.sv ) {                                         \
      TRY( LALSDestroyVector( stat->statusPtr,                       \
			       &(here->vector.sv) ), stat );         \
    }                                                                \
    LALFree( here );                                                 \
    here = nextPtr;                                                  \
  }                                                                  \
} while (0)
/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALSReadVectorSequence( LALStatus           *stat,
			REAL4VectorSequence **sequence,
			FILE                *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  REAL4 *data;          /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALSReadVectorSequence",
	      STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    LALSReadVector( stat->statusPtr, &(head.vector.sv), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else
      CHECKSTATUSPTR( stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    if ( !here->next ) {
      FREESVECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    here = here->next;
    LALSReadVector( stat->statusPtr, &(here->vector.sv), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else {
      BEGINFAIL( stat ) {
	FREESVECTORLIST;
      } ENDFAIL( stat );
    }
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.sv ) {
      if ( here->vector.sv->length > nCols )
	nCols = here->vector.sv->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREESVECTORLIST;
    ABORT( stat, STREAMINPUTH_ELEN, STREAMINPUTH_MSGELEN );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALSCreateVectorSequence( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREESVECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.sv ) {
      UINT4 i;
      UINT4 length = here->vector.sv->length;
      REAL4 *hereData = here->vector.sv->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 4*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREESVECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}


#define FREEDVECTORLIST                                              \
do {                                                                 \
  if ( head.vector.dv ) {                                            \
    TRY( LALDDestroyVector( stat->statusPtr,                         \
			    &(head.vector.dv) ), stat );             \
  }                                                                  \
  here = head.next;                                                  \
  while ( here ) {                                                   \
    VectorList *nextPtr = here->next;                                \
    if ( here->vector.dv ) {                                         \
      TRY( LALDDestroyVector( stat->statusPtr,                       \
			       &(here->vector.dv) ), stat );         \
    }                                                                \
    LALFree( here );                                                 \
    here = nextPtr;                                                  \
  }                                                                  \
} while (0)
/* <lalVerbatim file="StreamVectorSequenceInputCP"> */
void
LALDReadVectorSequence( LALStatus           *stat,
			REAL8VectorSequence **sequence,
			FILE                *stream )
{ /* </lalVerbatim> */
  VectorList head = empty; /* head of linked list of vectors */
  VectorList *here;     /* pointer to current position in list */
  REAL8 *data;          /* pointer to vector data */
  UINT4 nRows, nCols;   /* number and length of lines */
  CreateVectorSequenceIn in; /* parameters for creating sequence */

  INITSTATUS( stat, "LALDReadVectorSequence",
	      STREAMVECTORSEQUENCEINPUTC );
  ATTATCHSTATUSPTR( stat );

  /* Read the first line. */
  if ( !feof( stream ) ) {
    LALDReadVector( stat->statusPtr, &(head.vector.dv), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else
      CHECKSTATUSPTR( stat );
  }
  here = &head;

  /* As long as lines remain... */
  while ( !feof( stream ) ) {

    /* Allocate space for next line. */
    here->next = (VectorList *)LALCalloc( 1, sizeof(VectorList) );
    if ( !here->next ) {
      FREEDVECTORLIST;
      ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
    }

    /* Read in next line. */
    here = here->next;
    LALDReadVector( stat->statusPtr, &(here->vector.dv), stream );
    if ( stat->statusPtr->statusCode == STREAMINPUTH_ELEN ) {
      DETATCHSTATUSPTR( stat );
      ATTATCHSTATUSPTR( stat );
    } else {
      BEGINFAIL( stat ) {
	FREEDVECTORLIST;
      } ENDFAIL( stat );
    }
  }

  /* Lines have been read.  Now determine minimum common line length,
     and allocate the vector sequence. */
  nRows = nCols = 0;
  here = &head;
  while ( here ) {
    if ( here->vector.dv ) {
      if ( here->vector.dv->length > nCols )
	nCols = here->vector.dv->length;
      nRows++;
    }
    here = here->next;
  }
  if ( ( nRows == 0 ) || ( nCols == 0 ) ) {
    FREEDVECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  }
  in.length = nRows;
  in.vectorLength = nCols;
  LALDCreateVectorSequence( stat->statusPtr, sequence, &in );
  BEGINFAIL( stat ) {
    FREEDVECTORLIST;
    ABORT( stat, STREAMINPUTH_EMEM, STREAMINPUTH_MSGEMEM );
  } ENDFAIL( stat );

  /* Now assign data to the sequence, padding with zeros as
     necessary. */
  here = &head;
  data = (*sequence)->data;
  while ( here ) {
    if ( here->vector.dv ) {
      UINT4 i;
      UINT4 length = here->vector.dv->length;
      REAL8 *hereData = here->vector.dv->data;
      for ( i = 0; i < length; i++ )
	*(data++) = *(hereData++);
      if ( nCols - length > 0 )
	memset( data, 0, 8*( nCols - length ) );
      data += nCols - length;
    }
    here = here->next;
  }

  /* Free memory and exit. */
  FREEDVECTORLIST;
  DETATCHSTATUSPTR( stat );
  RETURN( stat );
}
