#!@PYTHON@
#
# git_version - determine git version info
#
# Based on generateGitID.sh by Reinhard Prix
#
# Copyright (C) 2009, Adam Mercer <adam.mercer@ligo.org>
# Copyright (C) 2009, Nickolas Fotopoulos <nvf@gravity.phys.uwm.edu>
# Copyright (C) 2008-2009, John T. Whelan <john.whelan@ligo.org>
# Copyright (C) 2008, Reinhard Prix <reinhard.ligo.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

#
# preamble
#

# metadata
__author__ = 'Adam Mercer <adam.mercer@ligo.org>'

# import required system modules
import exceptions
import os
import sys
import time
import re
import optparse
import filecmp
import shutil
try:
  import subprocess
except ImportError:
  sys.exit("Python-2.4, or higher is required")

#
# class definitions
#

# version info class
class git_info:
  def __init__(self):
    id = None
    date = None
    branch = None
    tag = None
    author = None
    committer = None
    status = None

# git invocation error exception handler
class GitInvocationError(exceptions.Exception):
  pass

#
# helper methods
#

# command line option parsing
def parse_args():
  # usage information
  usage = '%prog [options] project src_dir build_dir'

  # define option parser
  parser = optparse.OptionParser(usage=usage)
  parser.add_option('--sed', action='store_true', default=False,
      help='output sed commands for version replacement')
  parser.add_option('--file', action='store_true', default=False,
      help='output sed file for version replacement')

  # parse command line options
  opts, args = parser.parse_args()

  # check for positional arguments
  if (len(args) != 3):
    parser.error('incorrect number of command line options specified')

  # check that both --sed and --file are not specified
  if (opts.sed is True) and (opts.file is True):
    parser.error('cannot specify both --sed and --file')

  return opts, args[0], args[1], args[2]

#
# process management methods
#

# return output from running given command
def run_external_command(command, honour_ret_code=True):
  # start external command process
  p = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE,
      stderr=subprocess.PIPE, close_fds=True)

  # get outputs
  try:
    output = p.stdout.read()
    err = p.stderr.read()
    ret_code = p.wait()
  finally:
    p.stdout.close()
    p.stderr.close()

  # throw exception if process failed
  if honour_ret_code and (ret_code != 0):
    raise GitInvocationError, 'failed to run "%s"' % command

  return ret_code, output

#
# git version method
#

# generate sed command file containing version info
def generate_git_version_info():
  # info object
  info = git_info()

  # determine git id
  id_cmd = 'git log -1 --pretty="format:%H"'
  git_id = run_external_command(id_cmd)[1].strip()

  # determine commit date, iso utc
  date_cmd = 'git log -1 --pretty="format:%ct"'
  git_udate = float(run_external_command(date_cmd)[1].strip())
  git_date = time.strftime('%Y-%m-%d %H:%M:%S +0000', time.gmtime(git_udate))

  # escape '+' in date
  git_date = git_date.replace('+', '\+')

  # determine branch
  branch_cmd = 'git branch --no-color'
  branch_regexp = re.compile(r"\* ((?!\(no branch\)).*)", re.MULTILINE)
  branch_match = branch_regexp.search(run_external_command(branch_cmd)[1].strip())
  if branch_match is None:
    git_branch = None
  else:
    git_branch = branch_match.group(1)

  # determine tag
  tag_cmd = 'git describe --exact-match --tags %s' % git_id
  ret_code, git_tag = run_external_command(tag_cmd, honour_ret_code=False)
  git_tag = git_tag.strip()
  if ret_code != 0:
    git_tag = None

  # determine author and committer
  author_name_cmd = 'git log -1 --pretty="format:%an"'
  author_email_cmd = 'git log -1 --pretty="format:%ae"'
  committer_name_cmd = 'git log -1 --pretty="format:%cn"'
  committer_email_cmd = 'git log -1 --pretty="format:%ce"'
  git_author_name = run_external_command(author_name_cmd)[1].strip()
  git_author_email = run_external_command(author_email_cmd)[1].strip()
  git_author = '%s <%s>' % (git_author_name, git_author_email)
  git_committer_name = run_external_command(committer_name_cmd)[1].strip()
  git_committer_email = run_external_command(committer_email_cmd)[1].strip()
  git_committer = '%s <%s>' % (git_committer_name, git_committer_email)

  # determine tree status
  status_cmd = 'git status'
  status_output = run_external_command(status_cmd, honour_ret_code=False)[1].strip()
  if status_output.endswith('no changes added to commit (use "git add" and/or "git commit -a")'):
    git_status = 'UNCLEAN: Some modifications not committed'
  else:
    git_status = 'CLEAN: All modifications committed'

  # determine version strings
  info.id = 'Id: %s' % git_id
  info.date = 'Date: %s' % git_date
  info.branch = 'Branch: %s' % git_branch
  info.tag = 'Tag: %s' % git_tag
  info.author = 'Author: %s' % git_author
  info.committer = 'Committer: %s' % git_committer
  info.status = 'Status: %s' % git_status

  return info

#
# main program entry point
#

# parse command line options
options, project, src_dir, build_dir = parse_args()

# filenames
basename = '%sVCSInfo.h' % project
infile = '%s/%s.in' % (src_dir, basename)
tmpfile= '%s/%s.tmp' % (build_dir, basename)
srcfile = '%s/%s' % (src_dir, basename)
dstfile = '%s/%s' % (build_dir, basename)

# copy vcs header to build_dir, if appropriate
if os.access(srcfile, os.F_OK) and not os.access(dstfile, os.F_OK):
  shutil.copy(srcfile, dstfile)

# change to src_dir
os.chdir(src_dir)

# check if git is available
ret_code, output = run_external_command('which git', honour_ret_code=False)
git_ok = (ret_code != 1) and not output.startswith('no')

# check if we are in a git repo
if git_ok:
  # FIXME: 128 seems to be a magic number that indicates that the git
  # status command has failed
  git_ok = (run_external_command('git status', honour_ret_code=False)[0] != 128)

# generate version information output, if appropriate
if git_ok:
  info = generate_git_version_info()

  if options.file:
    # output sed command file to stdout
    print 's+@ID@+%s+g' % info.id
    print 's+@DATE@+%s+g' % info.date
    print 's+@BRANCH@+%s+g' % info.branch
    print 's+@TAG@+%s+g' % info.tag
    print 's+@AUTHOR@+%s+g' % info.author
    print 's+@COMMITTER@+%s+g' % info.committer
    print 's+@STATUS@+%s+g' % info.status
  elif options.sed:
    # generate sed command line options
    sed_cmd = ' -e "s/@ID@/%s/"' % info.id
    sed_cmd += ' -e "s/@DATE@/%s/"' % info.date
    sed_cmd += ' -e "s/@BRANCH@/%s/"' % info.branch
    sed_cmd += ' -e "s/@TAG@/%s/"' % info.tag
    sed_cmd += ' -e "s/@AUTHOR@/%s/"' % info.author
    sed_cmd += ' -e "s/@COMMITTER@/%s/"' % info.committer
    sed_cmd += ' -e "s/@STATUS@/%s/"' % info.status

    # create tmp file
    cmd = 'sed %s %s > %s' % (sed_cmd, infile, tmpfile)
    p = subprocess.Popen(cmd, shell=True)
    os.waitpid(p.pid, 0)

    # update vcs header, if appropriate
    if (os.access(dstfile, os.F_OK) and not filecmp.cmp(dstfile, tmpfile)) or not os.access(dstfile, os.F_OK):
      os.rename(tmpfile, dstfile)
    else:
      os.remove(tmpfile)
  else:
    # output version info
    print info.id
    print info.date
    print info.branch
    print info.tag
    print info.author
    print info.committer
    print info.status

# exit
sys.exit(0)

# vim: syntax=python tw=72 ts=2 et
