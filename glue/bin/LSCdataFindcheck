#!/usr/bin/python

"""
This utility checks that the output of LSCdataFind is continguous and spans
a given segment.
"""

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__date__ = "$Date$"[7:-2]
__version__ = "$Revision$"[11:-2]

from optparse import OptionParser
import os
import sys

from glue.lal import CacheEntry
from glue.lal import LIGOTimeGPS
from glue import segments
from glue import segmentsUtils


def parse_command_line():
	parser = OptionParser(version = "%prog CVS $Id$")
	parser.add_option("--gps-start-time", metavar = "seconds", help = "set desired start time")
	parser.add_option("--gps-end-time", metavar = "seconds", help = "set desired end time")
	parser.add_option("--dagman-return", metavar = "value", default = 0, help = "set $RETURN value from dagman")
	parser.add_option("--stat", action = "store_true", default = False, help = "test that files exist and are accessible")
	options, filenames = parser.parse_args()

	if options.dagman_return:
		options.dagman_return = int(options.dagman_return)

	if not (options.gps_start_time and options.gps_end_time):
		raise ValueError, "must set --gps-start-time and --gps-end-time"
	options.seg = segments.segment(LIGOTimeGPS(options.gps_start_time), LIGOTimeGPS(options.gps_end_time))

	return options, (filenames or [None])


try:
	options, filenames = parse_command_line()
except ValueError, e:
	print >>sys.stderr, "LSCdataFindcheck: error: %s" % str(e)
	sys.exit(1)


if options.dagman_return:
	print >>sys.stderr, "LSCdataFindcheck: error: dag job execution failed"
	sys.exit(options.dagman_return)

#
# loop over LAL cache files
#

for filename in filenames:
	#
	# parse file into a list of CacheEntry objects
	#

	if filename is not None:
		cache = [CacheEntry(line) for line in file(filename)]
	else:
		cache = [CacheEntry(line) for line in sys.stdin]

	#
	# check that the cache spans the requested segment
	#

	seglist = segments.segmentlist([c.segment for c in cache]).coalesce()
	if options.seg not in seglist:
		print >>sys.stderr, "LSCdataFindcheck: error: %s does not span %s:  missing %s" % (filename, str(options.seg), str(segments.segmentlist([options.seg]) - seglist))
		sys.exit(1)

	#
	# check that the files spanned by the requested segment are
	# accessible (only local files are tested)
	#

	if options.stat:
		badpaths = []
		seglist &= segments.segmentlist([options.seg])
		for c in cache:
			if not (seglist.intersects_segment(c.segment) and c.host().lower() in ("", "localhost")):
				# not local, or don't need it
				continue
			if not os.access(c.path(), os.R_OK):
				badpaths.append(c.path())
		if badpaths:
			print >>sys.stderr, "LSCdataFindcheck: error: %s lists inaccessible files %s" % (filename, badpaths)
			sys.exit(1)

#
# all OK
#

sys.exit(0)
