#!/usr/bin/python

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

"""
Add (merge) LIGO LW XML files containing LSC tables.
"""

from optparse import OptionParser
import sys
import os
import urllib
from urlparse import urlparse

from glue.lal import CacheEntry
from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import docutils

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__date__ = "$Date$"[7:-2]
__version__ = "$Revision$"[11:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	"""
	Parse the command line, return an options object and a list of URLs.
	"""

	parser = OptionParser(version = "%prog CVS $Id$")
	parser.add_option("-i", "--input-cache", metavar = "CACHEFILE", action = "append", default = [], help = "get input files from trigger cache CACHEFILE")
	parser.add_option("--add-lfn-table", action = "store_true", help = "add an lfn entry for each process")
	parser.add_option("--lfn-start-time", metavar = "START", help = "set lft start_time to START (optional)")
	parser.add_option("--lfn-end-time", metavar = "END", help = "set lfn end_time to END (optional)")
	parser.add_option("--lfn-comment", metavar = "STRING", help = "set lfn comment to STRING (optional)")
	parser.add_option("--non-lsc-tables-ok", action = "store_true", help = "OK to merge documents containing non-LSC tables")
	parser.add_option("-o", "--output", metavar = "FILENAME", help = "write output to FILENAME (default = stdout)")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	parser.add_option("-r", "--remove-input", action = "store_true", help = "remove input files after loading")
	options, urls = parser.parse_args()

	if options.lfn_start_time:
		options.lfn_start_time = int(options.lfn_start_time)
	if options.lfn_end_time:
		options.lfn_end_time = int(options.lfn_end_time)

	for cache in options.input_cache:
		urls += [c.url for c in map(CacheEntry, file(cache))]

	return options, urls


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

def load_documents(urls, verbose = False):
	if len(urls) < 1:
		raise Exception, "no input files!"
	doc = ligolw.Document()
	handler = lsctables.LIGOLWContentHandler(doc)
	for n, url in enumerate(urls):
		if verbose:
			print >>sys.stderr, "loading %d/%d: %s" % (n + 1, len(urls), url)
		ligolw.make_parser(handler).parse(urllib.urlopen(url))
	return doc


def urlremove(url):
	(scheme, location, path, params, query, frag) = urlparse(url)
	if scheme.lower() in ("", "file") and location.lower() in ("", "localhost"):
		os.remove(path)


#
# =============================================================================
#
#                                Document Merge
#
# =============================================================================
#

def reassign_ids(doc):
	"""
	Reassign IDs to all rows in all LSC tables in doc so that there are
	no collisions when the LIGO_LW elements are merged.
	"""
	ilwditers = {}
	for tablename, ilwdclass in lsctables.ILWDGeneratorByTableName.iteritems():
		ilwditers[tablename] = ilwdclass()
	for elem in doc.getElementsByTagName(ligolw.LIGO_LW.tagName):
		docutils.makeReference(elem)
		docutils.NewIDs(elem, ilwditers)
		docutils.deReference(elem)
	return doc


def element_merge(doc):
	# LIGO_LW elements
	reduce(docutils.MergeElements, doc.getElementsByTagName(ligolw.LIGO_LW.tagName))

	# Table elements
	docutils.MergeCompatibleTables(doc)

	return doc


def ligolw_merge(doc):
	"""
	Convenience wrapper of the reassign_ids() and element_merge()
	functions.
	"""
	return element_merge(reassign_ids(doc))


#
# =============================================================================
#
#                                  LFN Table
#
# =============================================================================
#

def make_lfn_table(doc, pathname, start_time = None, end_time = None, comment = None):
	"""
	Generate an LFN table for a document.
	"""
	cols = ["process_id", "lfn_id", "name"]
	if start_time != None:
		cols.append("start_time")
	if end_time != None:
		cols.append("end_time")
	if comment != None:
		cols.append("comment")
	lfn_table = lsctables.New(lsctables.LfnTable, cols)
	name = os.path.basename(pathname)
	ids = lsctables.LfnIDs()
	for process_table in lsctables.getTablesByType(doc, lsctables.ProcessTable):
		for pid in process_table.dict.keys():
			row = lsctables.Lfn()
			row.process_id = pid
			row.lfn_id = ids.next()
			row.name = name
			row.start_time = start_time
			row.end_time = end_time
			row.comment = comment
			lfn_table.append(row)
	return lfn_table


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

if __name__ == "__main__":
	# Command line
	options, urls = parse_command_line()

	# Input
	try:
		doc = load_documents(urls, options.verbose)
	except Exception, e:
		print >>sys.stderr, "error: %s" % str(e)
		sys.exit(1)

	# ID reassignment
	if not options.non_lsc_tables_ok and docutils.HasNonLSCTables(doc):
		print >>sys.stderr, "error:  non-LSC tables found.  Use --non-lsc-tables-ok to force"
		sys.exit(1)
	if options.verbose:
		print >>sys.stderr, "reasigning row IDs ..."
	reassign_ids(doc)

	# Document merge
	if options.verbose:
		print >>sys.stderr, "merging elements ..."
	element_merge(doc)

	# LFN table
	try:
		if options.add_lfn_table:
			if not options.output:
				raise Exception, "cannot add LFN table when no output filename is given"
			doc.getElementsByTagName(ligolw.LIGO_LW.tagName)[0].appendChild(make_lfn_table(doc, options.output, options.lfn_start_time, options.lfn_end_time, options.comment))
	except Exception, e:
		print >>sys.stderr, "error: %s" % str(e)
		sys.exit(1)

	# Output
	if options.verbose:
		print >>sys.stderr, "writing output..."
	if options.output:
		doc.write(file(options.output, "w"))
	else:
		doc.write(sys.stdout)

	# Remove input
	if options.remove_input:
		for url in urls:
			if options.verbose:
				print >>sys.stderr, "removing %s ..." % url
			try:
				urlremove(url)
			except:
				pass
