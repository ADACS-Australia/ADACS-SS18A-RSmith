#!/usr/bin/python

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

"""
Add (merge) LIGO LW XML files containing LSC tables.
"""

from optparse import OptionParser
import sys
import os
import urllib
from urlparse import urlparse

from glue.lal import CacheEntry
from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import docutils

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__date__ = "$Date$"[7:-2]
__version__ = "$Revision$"[11:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#

def parse_command_line():
	"""
	Parse the command line, return an options object and a list of URLs.
	"""
	parser = OptionParser(version = "%prog CVS $Id$")
	parser.add_option("-i", "--input-cache", metavar = "CACHEFILE", action = "append", default = [], help = "get input files from trigger cache CACHEFILE")
	parser.add_option("--add-lfn-table", action = "store_true", help = "add an lfn entry for each process")
	parser.add_option("--lfn-start-time", metavar = "START", help = "set lft start_time to START (optional)")
	parser.add_option("--lfn-end-time", metavar = "END", help = "set lfn end_time to END (optional)")
	parser.add_option("--lfn-comment", metavar = "STRING", help = "set lfn comment to STRING (optional)")
	parser.add_option("--non-lsc-tables-ok", action = "store_true", help = "OK to merge documents containing non-LSC tables")
	parser.add_option("-o", "--output", metavar = "FILENAME", help = "write output to FILENAME (default = stdout)")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	parser.add_option("-r", "--remove-input", action = "store_true", help = "remove input files after loading")
	options, urls = parser.parse_args()

	if options.lfn_start_time:
		options.lfn_start_time = int(options.lfn_start_time)
	if options.lfn_end_time:
		options.lfn_end_time = int(options.lfn_end_time)

	for cache in options.input_cache:
		urls += [c.url for c in map(CacheEntry, file(cache))]

	if len(urls) < 1:
		raise Exception, "no input files!"

	return options, urls


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

def append_document(doc, file):
	ligolw.make_parser(lsctables.LIGOLWContentHandler(doc)).parse(file)
	return doc


def url2path(url):
	(scheme, location, path, params, query, frag) = urlparse(url)
	if scheme.lower() in ("", "file") and location.lower() in ("", "localhost"):
		return path
	raise ValueError, url


#
# =============================================================================
#
#                                Document Merge
#
# =============================================================================
#

def reassign_ids(doc):
	"""
	Reassign IDs to all rows in all LSC tables in doc so that there are
	no collisions when the LIGO_LW elements are merged.
	"""
	ilwditers = {}
	for tablename, ilwdclass in lsctables.ILWDGeneratorByTableName.iteritems():
		ilwditers[tablename] = ilwdclass()
	for elem in doc.getElementsByTagName(ligolw.LIGO_LW.tagName):
		docutils.makeReference(elem)
		docutils.NewIDs(elem, ilwditers)
		docutils.deReference(elem)
	return doc


def element_merge(doc):
	# LIGO_LW elements
	reduce(docutils.MergeElements, doc.getElementsByTagName(ligolw.LIGO_LW.tagName))

	# Table elements
	docutils.MergeCompatibleTables(doc)

	return doc


#
# =============================================================================
#
#                                  LFN Table
#
# =============================================================================
#

def make_lfn_table(doc, pathname, start_time = None, end_time = None, comment = None):
	"""
	Generate an LFN table for a document.
	"""
	cols = ["process_id", "lfn_id", "name"]
	if start_time != None:
		cols.append("start_time")
	if end_time != None:
		cols.append("end_time")
	if comment != None:
		cols.append("comment")
	lfn_table = lsctables.New(lsctables.LfnTable, cols)
	name = os.path.basename(pathname)
	ids = lsctables.LfnIDs()
	for process_table in lsctables.getTablesByType(doc, lsctables.ProcessTable):
		for pid in process_table.dict.keys():
			row = lsctables.Lfn()
			row.process_id = pid
			row.lfn_id = ids.next()
			row.name = name
			row.start_time = start_time
			row.end_time = end_time
			row.comment = comment
			lfn_table.append(row)
	return lfn_table


#
# =============================================================================
#
#                                 Library API
#
# =============================================================================
#

def ligolw_add(doc, urls, **kwargs):
	"""
	An implementation of the LIGO LW add algorithm.  urls is a list of
	URLs to load.
	"""
	# Input
	for n, url in enumerate(urls):
		if kwargs["verbose"]:
			print >>sys.stderr, "loading %d/%d: %s" % (n + 1, len(urls), url)
		append_document(doc, urllib.urlopen(url))

	# ID reassignment
	if not kwargs["non_lsc_tables_ok"] and docutils.HasNonLSCTables(doc):
		print >>sys.stderr, "error:  non-LSC tables found.  Use --non-lsc-tables-ok to force"
		sys.exit(1)
	if kwargs["verbose"]:
		print >>sys.stderr, "reasigning row IDs ..."
	reassign_ids(doc)

	# Document merge
	if kwargs["verbose"]:
		print >>sys.stderr, "merging elements ..."
	element_merge(doc)

	return doc


def remove_input(urls, output, verbose = False):
	for path in map(url2path, urls):
		if output and os.path.samefile(path, output):
			continue
		if verbose:
			print >>sys.stderr, "removing %s ..." % path
		try:
			os.remove(path)
		except:
			pass


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

try:
	# Command line
	options, urls = parse_command_line()

	# Input
	doc = ligolw_add(ligolw.Document(), urls, **options.__dict__)

	# LFN table
	if options.add_lfn_table:
		if not options.output:
			raise Exception, "cannot add LFN table when no output filename is given"
		doc.getElementsByTagName(ligolw.LIGO_LW.tagName)[0].appendChild(make_lfn_table(doc, options.output, options.lfn_start_time, options.lfn_end_time, options.comment))

	# Output
	if options.verbose:
		if options.output:
			print >>sys.stderr, "writing %s..." % options.output
		else:
			print >>sys.stderr, "writing stdout..."
	if options.output:
		doc.write(file(options.output, "w"))
	else:
		doc.write(sys.stdout)

	# Remove input
	if options.remove_input:
		remove_input(urls, options.output, options.verbose)
except Exception, e:
	print >>sys.stderr, "error: %s" % str(e)
	sys.exit(1)
