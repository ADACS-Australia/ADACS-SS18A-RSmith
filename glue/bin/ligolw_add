#!/usr/bin/python

"""
Add (merge) LIGO LW XML files containing LSC tables.
"""

__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__date__ = "$Date$"
__version__ = "$Revision$"


#
# Preamble.
#

from optparse import OptionParser
import sys
import os
import urllib

from glue import lal
from glue import segments
from glue.ligolw import ligolw
from glue.ligolw import metaio
from glue.ligolw import lsctables
from glue.ligolw import docutils


#
# Parse command line.
#

parser = OptionParser(version = "%prog CVS $Id$")
parser.add_option("-i", "--input-cache", metavar = "CACHEFILE", action = "append", help = "get input files from trigger cache CACHEFILE")
parser.add_option("--add-lfn-table", action = "store_true", help = "add an lfn entry for each process")
parser.add_option("--lfn-start-time", metavar = "START", help = "set lft start_time to START (optional)")
parser.add_option("--lfn-end-time", metavar = "END", help = "set lfn end_time to END (optional)")
parser.add_option("--lfn-comment", metavar = "STRING", help = "set lfn comment to STRING (optional)")
parser.add_option("--non-lsc-tables-ok", action = "store_true", help = "OK to merge documents containing non-LSC tables")
parser.add_option("-o", "--output", metavar = "FILENAME", help = "write output to FILENAME (default = stdout)")
parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
options, urls = parser.parse_args()
del parser

# add urls from cache files
if options.input_cache:
	for cache in options.input_cache:
		urls += [c.url for c in map(lal.CacheEntry, file(cache))]


#
# Load all input documents.  The top-level LIGO_LW elements are all
# appended to a single in-RAM document.
#

if len(urls) < 1:
	raise Exception, "no input files!"

def LoadDocuments(urls):
	doc = ligolw.Document()
	handler = lsctables.LIGOLWContentHandler(doc)
	for url in urls:
		if options.verbose:
			print >>sys.stderr, "Reading %s" % url
		ligolw.make_parser(handler).parse(urllib.urlopen(url))
	return doc

doc = LoadDocuments(urls)


#
# Reassign row IDs to prevent collisions.
#

if not options.non_lsc_tables_ok and docutils.HasNonLSCTables(doc):
	print >>sys.stderr, "error:  non-LSC tables found.  Use --non-lsc-tables-ok to force"
	sys.exit(1)

def reassign_ids(doc):
	ilwditers = {}
	for tablename, ilwdclass in lsctables.ILWDGeneratorByTableName.iteritems():
		ilwditers[tablename] = ilwdclass()
	for elem in doc.getElementsByTagName(ligolw.LIGO_LW.tagName):
		docutils.makeReference(elem)
		docutils.NewIDs(elem, ilwditers)
		docutils.deReference(elem)

reassign_ids(doc)


#
# Merge LIGO_LW elements.
#

reduce(docutils.MergeElements, doc.getElementsByTagName(ligolw.LIGO_LW.tagName))


#
# Merge tables of like type.
#

docutils.MergeCompatibleTables(doc)


#
# add an lfn table for each process
#

if options.add_lfn_table:
	if not options.output:
		raise Exception, "Cannot add LFN table when no output filename is given"

	lfntablecols = ['process_id','lfn_id','name']
	if options.lfn_start_time:
		lfntablecols.append('start_time')
	if options.lfn_end_time:
		lfntablecols.append('end_time')
	if options.lfn_comment:
		lfntablecols.append('comment')
	lfntable = lsctables.New(lsctables.LfnTable,lfntablecols)

	lfn_name = os.path.basename(options.output)
	lfn_id = lsctables.LfnIDs()
	pids = docutils.ProcessList(doc).keys()

	for p in pids:
		l = lsctables.Lfn()
		l.process_id = p
		l.lfn_id = str(lfn_id.next())
		l.name = lfn_name
		if options.lfn_start_time:
			l.start_time = int(options.lfn_start_time)
		if options.lfn_end_time:
			l.end_time = int(options.lfn_end_time)
		if options.lfn_comment:
			l.comment = options.lfn_comment
		lfntable.append(l)

	doc.getElementsByTagName(ligolw.LIGO_LW.tagName)[0].appendChild(lfntable)

#
# Write output.
#

if options.verbose:
	print >>sys.stderr, "Writing output..."
if options.output:
	doc.write(file(options.output, "w"))
else:
	doc.write(sys.stdout)
