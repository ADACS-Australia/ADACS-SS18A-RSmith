#!/usr/bin/env python

# FIXME:  move all imports to the top of the file
import os
import sys
import glob
from optparse import OptionParser

# Default variable names
DEFAULT_DB = "cvs::pserver:gravity.phys.uwm.edu:2401/usr/local/cvs/larsdb?file=inspiral/advertising.cache"

# FIXME:  don't start manipulating tstuff until after the options have
# been parsed
if os.environ.has_key('LARS_LIB'):
    sys.path.insert(0, os.environ['LARS_LIB'])

searchDbPath = os.environ.get("LARS_DB")

if os.environ.has_key("LARS_DIR"):
    basedir = os.environ["LARS_DIR"]
else:
    homedir = os.environ["HOME"]
    basedir = os.path.join(homedir, ".lars")



# make sure we have these things:
#   lars temp area
#   search database
#   mount db
#   mount point

# maybe check for fuse, fuse permissions, sshfs, ssh, scp, cvs (etc?)

mountdir = os.path.join(basedir, "mnt")
tmpdir = os.path.join(basedir, "tmp")


# Options
#

usage = "%prog: TBD"

parser = OptionParser(\
            usage=usage, \
            version= "%prog CVS\n" +
                "$Id$\n" +
                "$Name$\n" \
         )

parser.add_option("", "--search-db",
                  metavar="SEARCHDB",
                  action="store",
                  default=None,
                  help="location of search database")

parser.add_option("-D", "--search-description",
                  action="store",
                  type="string",
                  default="",
                  help="search description pattern of interest" )

parser.add_option("-I", "--search-ifos",
                  action="store",
                  type="string",
                  default="",
                  help="ifos of interest" )

parser.add_option("-T", "--search-time",
                  action="store",
                  type="int",
                  default=0)

parser.add_option("-d", "--file-description",
                  action="store",
                  type="string",
                  default="",
                  help="file description pattern of interest" )

parser.add_option("-m", "--mount-directory",
                  action="store",
                  type="string",
                  default=None,
                  help="where to mount found items")

parser.add_option("-n", "--mount",
                  action="store_true",
                  default=False,
                  help="mount the remote directory")

parser.add_option("-c", "--clear-mounts",
                  action="store_true",
                  default=False,
                  help="mount the remote directory")

parser.add_option("-v", "--verbose",
                  action="store_true",
                  default=False,
                  help="be chatty about what's going on")

parser.add_option("-C","--clone",
                  action="store",
		  help="copy the data to a directory" )

#parser.add_option("-f","--file-type",action="store",type="string",\
#    default=None,help="file type" )

(options,args) = parser.parse_args()

verbose = options.verbose

## check for the existence of $HOME/.lars If it does not exist create
## the directory hierarchy needed for working
if not os.access(basedir,os.F_OK):
  if verbose: print "Creating .lars directory hierarchy at " + basedir
  try:
    os.makedirs(basedir)
  except:
    print "Directory " + basedir + " does not exist and could not be created"
    sys.exit(1)
  try:    
    os.mkdir(mountdir)
  except: 
    print "Directory " + mountdir + " does not exist and could not be created"
    sys.exit(1)
  try:    
    os.mkdir(basedir+"/tmp")
  except: 
    print "Directory " + mountdir + " does not exist and could not be created"
    sys.exit(1)
# make the above things exist now

# FIXME: all searchDBPath manipulations can go here
searchDbPath = options.search_db or os.environ.get("LARS_DB")

if not searchDbPath:
    searchDbPath = DEFAULT_DB

# FIXME: move these imports to the top of the file
from tempfile import TemporaryFile, mkdtemp
from urlparse import urlsplit, urlunsplit
from subprocess import Popen, PIPE

from glue.lars import Cache, copyFile


def mountSearch(searchUrl, targetDir):
    global verbose
    (scheme, netloc, path, query, frag) = urlsplit(searchUrl)
    # netloc is just host -- we didn't put user/port in there right?
    fs = "%s:%s" % (netloc, path)
    try:    os.mkdir(targetDir)
    except: pass
    if verbose:
        print "Mounting '%s' on '%s'" % (fs, targetDir)
    p = Popen(["sshfs", fs, os.path.abspath(targetDir)], cwd=basedir)
    p.wait()
    del p

def mkUrl(loc):
    (scheme, netloc, path, query, frag) = urlsplit(loc)
    if not scheme:
        scheme = "file"
    if not netloc:
        netloc = "localhost"
    if path:
        path = os.path.abspath(path)
    return urlunsplit( (scheme, netloc, path, query, frag) )

def clearMounts():
  dirs = glob.glob(mountdir+"/tmp*")
  for dir in dirs:
    try:
      os.popen("fusermount -u " + dir)
    except:
      print "Could not unmount " + dir
      print "Resource is probably in use, please fix and try again"
      sys.exit(1)
    os.rmdir(dir)

#
#
if verbose:
    print "Using search DB:", searchDbPath

if options.clear_mounts:
  clearMounts()
  sys.exit(0)

if options.search_db:
    searchDbPath = mkUrl(options.search_db)

searchDb = Cache.get(searchDbPath)

if verbose:
    print "Searching on: "
    print "        IFOs: ", options.search_ifos
    print " description: ", options.search_description

result = searchDb.sieve(ifos=options.search_ifos,
                        #segment=options.search_time,
                        description=options.search_description)

cloneDir = options.clone

if cloneDir:
    try:
        os.mkdir(cloneDir)
    except OSError, e:
        from errno import EEXIST
	if e.errno != EEXIST:
	    raise

mountPoint = None
if options.mount:
    #if options.file_description: # we only want selected files -> mount in a scratchy place
    if options.mount_directory:
        mountPoint = os.path.abspath(options.mount_directory)
    else:
        mountPoint = mkdtemp(dir=mountdir)

    # the users working directory for later use in linking
    userDir = os.path.abspath(os.getcwd())

    # make mount point if it does not exist
    if verbose: print "Creating mount dir: ", mountPoint
    try:    os.mkdir(mountPoint)
    except: 
      print mountPoint, " already exists, continuing ..."
      pass

if len(result) == 1:
    result=result[0]
    print "Found search:", result.description, "at", result.url

    if mountPoint:
        if verbose: print "Mounting search:", result.description, "at", mountPoint
        mountSearch(result.url, mountPoint)

    if options.file_description: # link selected files to target dir

        filecache = Cache.getSearch(result.url,tmpdir)
        interestingFileCache = filecache.sieve(description=options.file_description)

        if len(interestingFileCache) == 0:
            print "No interesting files:"
        (_, remotehost, remotepath, _, _) = urlsplit(result.url)

        # remove any trailing '/' in url from search db.
        if remotepath[-1] == "/":
            remotepath = remotepath[:-1]

        if verbose:
            print "Found %d files of interest." % len(interestingFileCache)
        for entry in interestingFileCache:
            if mountPoint:
                (_, _, remoteFile, _, _) = urlsplit(entry.url)
                remoteFile = remoteFile.split(remotepath)[-1]
                if remoteFile[0] == "/":
                  remoteFile = remoteFile[1:]
                mountedFile = os.path.join(mountPoint,remoteFile)
                baseFile = os.path.basename(mountedFile)
                linkedFile = os.path.join(userDir, baseFile)
                if os.access(mountedFile, os.F_OK):
                    #print "linking:",  mountedFile, linkedFile
                    os.symlink(mountedFile, linkedFile)
                else:
                    print "Warning:", mountedFile, "does not exist"
	    elif cloneDir:
                (scheme, host, remoteFile, _, _) = urlsplit(entry.url)
		if host == "localhost":
		    host = remotehost
                localFile = os.path.basename(remoteFile)
		localFile = os.path.join(cloneDir, localFile)
                url = urlunsplit( (scheme, host, remoteFile, "", "") )
	        print "Retrieving %s => %s" % (url, localFile)
		copyFile(url, localFile)
            else:
                # no mounting, so print results
                print entry.description, entry.url
elif len(result) > 1:
    print "More than one search found:"
    for r in result:
        print "   ", str(r)
else:
    print "No search found"
