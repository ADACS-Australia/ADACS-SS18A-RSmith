#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


"""
Print things from LIGO LW XML files.  Inspired by lwtprint from LIGOTools.
"""


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__date__ = "$Date$"[7:-2]
__version__ = "$Revision$"[11:-2]


from optparse import OptionParser


from glue.lal import CacheEntry
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog [options] [url [url ...]]",
		description = "%prog prints the contents of table elements from a LIGO Light Weight XML files to stdout in delimited ASCII format.  In addition to standard files, the program can read from many common URLs such as http:// and ftp://.  Any file name or URL that ends in \".gz\" is assumed to be gzip-compressed, and will be decompressed on input.  If no file names or URLs are given, then input is read from stdin."
	)
	parser.add_option("-i", "--input-cache", metavar = "name", action = "append", help = "get URLs from the LAL cache file;  can be provided multiple times to name several caches to iterate over")
	parser.add_option("-c", "--column", metavar = "name", action = "append", help = "print only the contents of the given column;  can be provided multiple times to print multiple columns (default is to print all columns from each table)")
	parser.add_option("-d", "--delimiter", metavar = "string", default = ",", help = "delimit output with the given string (default is \",\")")
	parser.add_option("-r", "--rows", metavar = "rowspec", default = ":", help = "print rows in the given range(s);  the format is first:last[,first:last,...] where if the start or stop boundary of a individual range is omited it means the first or last row in the table (default is \":\", or to print all rows)")
	parser.add_option("-t", "--table", metavar = "name", action = "append", help = "dump rows from the given table;  can be provided multiple times to dump rows from multiple tables (default is to dump the contents of all tables)")
	parser.add_option("-v", "--verbose", action = "store_true", help = "be verbose")
	options, urls = parser.parse_args()

	# add urls from cache files
	if options.input_cache:
		for cache in options.input_cache:
			urls += [c.url for c in map(CacheEntry, file(cache))]

	# strip table names
	if options.table:
		options.table = map(table.StripTableName, options.table)

	# turn row requests into a segment list
	try:
		options.rows = segmentsUtils.from_range_strings(options.rows.split(","))
	except ValueError, e:
		raise ValueError, "invalid rowspec: %s" % str(e)

	# success
	return options, (urls or [None])


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#

#
# Enable column interning
#


table.RowBuilder = table.InterningRowBuilder


#
# If specific table names have been asked for, don't parse other tables so
# as to improve parsing speed and reduce memory requirements.  Because we
# do this, we can assume later that we should print all the tables that can
# be found in the document.
#


def ContentHandler(doc):
	if options.table:
		return ligolw.PartialLIGOLWContentHandler(doc, lambda name, attrs: (name == ligolw.Table.tagName) and (table.StripTableName(attrs["Name"]) in options.table))
	else:
		return ligolw.LIGOLWContentHandler(doc)


utils.ContentHandler = ContentHandler


#
# =============================================================================
#
#                         How to find things to print
#
# =============================================================================
#


#
# How to print a row
#


def row_string(table_elem, row):
	if options.column:
		return options.delimiter.join(map(lambda key: str(getattr(row, key)), options.column))
	else:
		return options.delimiter.join(map(lambda colname: str(getattr(row, colname)), table_elem.columnnames))


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


options, urls = parse_command_line()


for url in urls:
	doc = utils.load_url(url, verbose = options.verbose, gz = (url or "stdin").endswith(".gz"))
	table.InterningRowBuilder.strings.clear()
	for table_elem in doc.getElements(lambda e: (e.tagName == ligolw.Table.tagName)):
		for n, row in enumerate(table_elem):
			if n in options.rows:
				print row_string(table_elem, row)
	doc.unlink()
