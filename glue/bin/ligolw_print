#!/usr/bin/python
#
# $Id$
#
# Copyright (C) 2006  Kipp C. Cannon
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


"""
Print things from LIGO LW XML files.  Inspired by lwtprint from LIGOTools.
"""


__author__ = "Kipp Cannon <kipp@gravity.phys.uwm.edu>"
__date__ = "$Date$"[7:-2]
__version__ = "$Revision$"[11:-2]


from optparse import OptionParser


from glue.lal import CacheEntry
from glue import segmentsUtils
from glue.ligolw import ligolw
from glue.ligolw import table
from glue.ligolw import lsctables
from glue.ligolw import utils


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
	parser = OptionParser(
		version = "%prog CVS $Id$",
		usage = "%prog [options] [url ...]",
		description = "Prints the contents of table elements from one or more LIGO Light Weight XML files to stdout in delimited ASCII format.  In addition to regular files, the program can read from many common URLs such as http:// and ftp://.  Any filename or URL that ends in \".gz\" is assumed to be gzip-compressed, and will be decompressed on input.  If no filenames or URLs are given, then input is read from stdin."
	)
	parser.add_option("-i", "--input-cache", metavar = "name", action = "append", default = [], help = "Get URLs from the LAL cache file.  Can be provided multiple times to name several caches to iterate over.")
	parser.add_option("-c", "--column", metavar = "name", action = "append", help = "Print only the contents of the given column.  Can be provided multiple times to print multiple columns.  The default is to print all columns from each table.")
	parser.add_option("-d", "--delimiter", metavar = "string", default = ",", help = "Delimit output with the given string.  The default is \",\".")
	parser.add_option("-r", "--rows", metavar = "rowspec", default = ":", help = "Print rows in the given range(s).  The format is first:last[,first:last,...].  Rows are numbered from 0.  A single first:last pair requests rows in the range [first, last).  If the first or last value of a pair is omited it means 0 or infinity respectively.  The default is \":\", or to print all rows.")
	parser.add_option("-t", "--table", metavar = "name", action = "append", help = "Dump rows from this table.  Can be provided multiple times to dump rows from multiple tables.  The default is to dump the contents of all tables.")
	parser.add_option("-v", "--verbose", action = "store_true", help = "Be verbose.")
	options, urls = parser.parse_args()

	# add urls from cache files
	urls += [CacheEntry(line).url for cache in options.input_cache for line in file(cache)]

	# strip table names
	if options.table:
		options.table = map(table.StripTableName, options.table)

	# turn row requests into a segment list
	try:
		options.rows = segmentsUtils.from_range_strings(options.rows.split(","))
	except ValueError, e:
		raise ValueError, "invalid rowspec: %s" % str(e)

	# success
	return options, (urls or [None])


#
# =============================================================================
#
#                                    Input
#
# =============================================================================
#


#
# Enable column interning
#


table.RowBuilder = table.InterningRowBuilder


#
# If specific table names have been asked for, don't parse other tables so
# as to improve parsing speed and reduce memory requirements.  Because we
# do this, we can assume later that we should print all the tables that can
# be found in the document.
#


def ContentHandler(xmldoc):
	if options.table:
		return ligolw.PartialLIGOLWContentHandler(xmldoc, lambda name, attrs: (name == ligolw.Table.tagName) and (table.StripTableName(attrs["Name"]) in options.table))
	else:
		return ligolw.LIGOLWContentHandler(xmldoc)


utils.ContentHandler = ContentHandler


#
# =============================================================================
#
#                         How to find things to print
#
# =============================================================================
#


#
# How to print a row
#


def row_string(table_elem, row):
	if options.column:
		return options.delimiter.join(map(lambda key: str(getattr(row, key)), options.column))
	else:
		return options.delimiter.join(map(lambda colname: str(getattr(row, colname)), table_elem.columnnames))


#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#


options, urls = parse_command_line()


for url in urls:
	xmldoc = utils.load_url(url, verbose = options.verbose, gz = (url or "stdin").endswith(".gz"))
	table.InterningRowBuilder.strings.clear()
	for table_elem in xmldoc.getElements(lambda e: (e.tagName == ligolw.Table.tagName)):
		for n, row in enumerate(table_elem):
			if n in options.rows:
				print row_string(table_elem, row)
	xmldoc.unlink()
