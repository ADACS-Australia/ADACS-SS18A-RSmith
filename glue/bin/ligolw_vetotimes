#!/usr/bin/env python
#
# $Id$
#
# Copyright (C) 2009  Larne Pekowsky
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


from optparse import OptionParser

try:
    import sqlite3
except ImportError:
    # pre 2.5.x
    from pysqlite2 import dbapi2 as sqlite3

import sys
import os
import glob

import glue.segments

from glue.ligolw.utils import ligolw_add
from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import utils

PROGRAM_NAME = sys.argv[0].replace('./','')
PROGRAM_PID  = os.getpid()
USER_NAME    = os.getlogin()

__author__ = "Larne Pekowsky <lppekows@physics.syr.edu>"
__date__ = "$Date$"[7:-2]
__version__ = "$Revision$"[11:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
    """
    Parse the command line, return an options object
    """

    parser = OptionParser(
        version = "%prog CVS $Header$",
        usage   = "%prog -v|--veto-file filename [options]",
        description = "Reads one or more segment files and a veto file and generates files of veto segments"        
	)
    
    parser.add_option("-i", "--input-dir",    metavar = "input_dir",    default = '.',     help = "Directory containing segment XML files (default=cwd).")
    parser.add_option("-g", "--glob-pattern", metavar = "glob_pattern", default = '*.xml', help = "Glob pattern for segment XML files (define=*,xml).")
    parser.add_option("-v", "--veto-file",    metavar = "veto_file",    help = "veto XML file (required).")
    parser.add_option("-o", "--output-dir",   metavar = "output_dir",   default = '.',          help = "Directory to write output (default=cwd).")
    parser.add_option("-x", "--keep-xml",     metavar = "keep_xml",     action  = "store_true", help = "Keep temporary XML file.")
    parser.add_option("-d", "--keep-db",      metavar = "keep_db",      action  = "store_true", help = "Keep sqlite database.")
                      
    options, others = parser.parse_args()
    
    if not options.veto_file:
        raise ValueError, "missing required argument --veto-file"
    
    return options



#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

if __name__ == '__main__':
    options      = parse_command_line()    

    # TODO: These should have better names that include the
    # start and end times
    temp_xml     = options.output_dir + '/combined_temp.xml'
    temp_db      = options.output_dir + '/temp.db'

    glob_pattern = options.input_dir
    
    if not glob_pattern.endswith('/'):
        glob_pattern += '/'

    glob_pattern += options.glob_pattern

    xml_files = glob.glob(glob_pattern)
    xml_files.append(options.veto_file)

    #
    # Using the ligolw_sqlite methods to sequentially read in the data
    # doesn't work, because it doesn't keep track of the primary keys
    # (TODO: This should be fixed) so in the meantime use the
    # lilgolw_add methods to merge to a temporary file (TODO: the file
    # isn't really needed, we should be able to just pass the xmldoc
    # to ligolw_sqlite.insert)
    #    
    lsctables.table.RowBuilder = lsctables.table.InterningRowBuilder
    xmldoc = ligolw_add.ligolw_add(ligolw.Document(), xml_files, non_lsc_tables_ok = True)
    utils.write_filename(xmldoc, temp_xml)

    #
    # importing these causes some global attributes to be set, which
    # configures the system to use dbtables, which breaks ligolw_add.
    # So we have to import after the above work is done...
    #
    from glue.ligolw.utils import ligolw_sqlite
    from glue.ligolw import dbtables

    target     = dbtables.get_connection_filename(temp_db, None, True, False)
    connection = ligolw_sqlite.setup(target)

    ligolw_sqlite.insert(connection, [temp_xml])


    # Get start and end times for file names
    cursor        = connection.cursor()
    cursor.execute("select min(start_time), max(end_time) from segment")
    min_start_time, max_end_time = cursor.fetchone()


    #
    # Get the set of veto categories and ifos for which we have segments 
    #
    cursor.execute("select distinct(category) from veto_definer")
    categories = map(lambda row: row[0], cursor)
    cursor.execute("select distinct(ifos) from segment_definer")
    ifos = map(lambda row: row[0], cursor)
    cursor.close()


    for ifo in ifos:
        # Update the IFOs for the segment definer
        cursor = connection.cursor()
        cursor.execute("""UPDATE segment_definer SET ifos=? WHERE name = ?""", (ifo, PROGRAM_NAME))
        connection.commit()
        cursor.close()
        
        for category_num in categories:
            coalesced_segments = {}
            
            cursor = connection.cursor()

            cursor.execute("""SELECT veto_definer.name, veto_definer.version, segment.start_time, segment.end_time 
            FROM segment, segment_definer, veto_definer 
            WHERE segment.segment_def_id = segment_definer.segment_def_id
            AND segment_definer.ifos = veto_definer.ifo
            AND veto_definer.ifo  = ?
            AND (  (segment.start_time BETWEEN veto_definer.start_time AND veto_definer.end_time)  OR
                   (segment.end_time BETWEEN veto_definer.start_time AND veto_definer.end_time)    OR
                   (segment.start_time >= veto_definer.start_time AND veto_definer.end_time = 0)  OR 1 = 1)
            AND veto_definer.category <= ?""",(ifo,category_num))
            
            for row in cursor:
                name, version, start_time, end_time = row
                key = '%s|%d' % (name, version)
                if key not in coalesced_segments:
                    coalesced_segments[key] = glue.segments.segmentlist([])

                coalesced_segments[key] |= glue.segments.segmentlist([glue.segments.segment(start_time, end_time)])


            output_name = "%s/%s-VETOTIME_CAT%d_%d_%d.txt" % (options.output_dir, ifo, category_num, min_start_time, (max_end_time - min_start_time))
            f_out       = open(output_name,'w')

            print >>f_out, "# name\tversion\tgps_start_time\tgps_end_time\tactive"

            for key in coalesced_segments:
                name, version = key.split('|')
                segs          = coalesced_segments[key]

                for seg in segs:
                    print >>f_out, ( "%s\t%s\t%d\t%d\t1" % (name, version, seg[0], seg[1]) )

            f_out.close()
            
