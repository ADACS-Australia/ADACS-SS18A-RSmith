#!/usr/bin/python
# $Id: xsend.py,v 1.8 2006/10/06 12:30:42 normanr Exp $
import sys
import os
import time
import select
import logging
import libxml2
from optparse import *

from pyxmpp.all import JID,Iq,Presence,Message,StreamError,TLSSettings
from pyxmpp.jabber.all import Client
from pyxmpp.jabber.dataforms import Form,DATAFORM_NS
from pyxmpp.interface import implements
from pyxmpp.interfaces import *
from pyxmpp.exceptions import ClientError, FatalClientError
from glue.lvalert import pubsub

"""
A tool to administer the pubsub service of openfire
"""

__version__ = "$Revision: 1.53 $"
__date__ = "$Date: 2008/08/08 15:54:23 $"
__name__ = "gwvoevent"
__Id__ = "$Id: plotinspiral,v 1.53 2008/08/08 15:54:23 nvf Exp $"
__title__ = "Gravitational-wave event feeder"


#################################################################
# help message
usage = """\
%prog [options]
------------------------------------------------------------------------------
  A tool to administer the pubsub service of openfire at
  jabber.phys.uwm.edu. This server is configured to use kerberos for
  authentication. To use it you need to create a kerberos tickey by
  calling

  kinit first.last@LIGO.ORG

  and typing your password. Then you can use this program to do the
  following things:

  1.  create a pubsub node called small_steps

  %prog --username patrick.brady --server jabber.phys.uwm.edu --create-node small_steps

  2.  delete a pubsub node called small_steps

  %prog --username patrick.brady --server jabber.phys.uwm.edu --delete-node small_steps

  4.  subscribe to a pubsub node called small_steps

  %prog --username patrick.brady --server jabber.phys.uwm.edu --subscribe-node small_steps

  The owner (person who creates the node by default) can delete and
  publish information to the node. Others can subscribe. There are two
  example programs called listen.py and publish.py which provide ways
  to listen for content on the node and to publish information to the
  node respectively.

"""

#################################################################
def parse_command_line():
  """
  Parser function dedicated
  """
  parser = OptionParser( usage=usage, \
      version= "%prog CVS\n" +
      "$Id$\n" +
      "$Name:  $\n")

  #username and password
  parser.add_option("-a","--username",action="store",type="string",\
      default="", help="the username of the publisher or listener" )
  parser.add_option("-b","--password",action="store",type="string",\
      default="", help="the password of the publisher or listener" )
  parser.add_option("-c","--server",action="store",type="string",\
      default="jabber.phys.uwm.edu", help="the pubsub server" )

  # access information about root nodes
  parser.add_option("-d","--create-node",action="store",type="string",\
      default=None, help="name of the node to create" )
  parser.add_option("-e","--delete-node",action="store",type="string",\
      default=None, help="name of the node to delete" )
  parser.add_option("-f","--subscribe-node",action="store",type="string",\
      default=None, help="name of the node to subscribe" )
  parser.add_option("-g","--unsubscribe-node",action="store",type="string",\
      default=None, help="name of the node to unsubscribe" )
  parser.add_option("-n","--unsubscribe-subid",action="store",type="string",\
      default=None, help="subid of subscription obtained by running subscriptions" )
  parser.add_option("-i","--subscriptions",action="store_true",\
      default=False, help="return a list of subscriptions" )
  parser.add_option("-j","--add-publisher",action="store",type="string",\
      default=None, help="jabber id of person allowed to publish to node" )
  parser.add_option("-k","--get-node-config",action="store",type="string",\
      default=None, help="name of the node to get config" )

  parser.add_option("-m","--get-nodes",action="store_true",\
      default=False, help="get the list of existing nodes" )
  # debugging options
  parser.add_option("-l","--debug",action="store_true",\
      default=False, help="should  print out lots of information" )
  parser.add_option("-v","--verbose",action="store_true",\
      default=False, help="be verbose as you process the request" )
  
  (options,args) = parser.parse_args()

  if not options.username:
    raise ValueError, "--username must be provided"

  return options, sys.argv[1:]
  
# ============================================================================
# -- get command line arguments
opts, args = parse_command_line()

class MyClient(Client):
    def __init__(self, jid, password):
        # if bare JID is provided add a resource -- it is required
        if not jid.resource:
            jid=JID(jid.node, jid.domain, "PubsubBot")

        # we require a TLS connection
        t=TLSSettings(require=True,verify_peer=False)

        # setup client with provided connection information
        # and identity data
        Client.__init__(self, jid, password, \
            auth_methods=["sasl:GSSAPI","sasl:PLAIN"], tls_settings=t)

    def stream_state_changed(self,state,arg):
        """This one is called when the state of stream connecting the
        component to a server changes. This will usually be used to
        let the user know what is going on."""
        if opts.verbose:
            print "*** State changed: %s %r ***" % (state,arg)
        else:
            pass

    def session_started(self):
        self.stream.send(Presence())
        if opts.get_nodes:
            self.stream.set_response_handlers(pspl, \
                pspl.get_nodes_result,pspl.create_error,\
                pspl.create_timeout)
        if opts.create_node:
            self.stream.set_response_handlers(pspl, \
                pspl.generic_result,pspl.create_error,\
                pspl.create_timeout)
        if opts.subscribe_node:
            self.stream.set_response_handlers(pspl, \
                pspl.subscribe_result,pspl.subscribe_error,\
                pspl.subscribe_timeout)
        if opts.unsubscribe_node:
            self.stream.set_response_handlers(pspl, \
                pspl.generic_result,pspl.subscribe_error,\
                pspl.subscribe_timeout)
        if opts.subscriptions:
            self.stream.set_response_handlers(pspl, \
                pspl.subscriptions_result,pspl.subscribe_error,\
                pspl.subscribe_timeout)
        self.stream.send(pspl)

    def idle(self):
        if self.stream and self.session_established:
            if opts.verbose:
                print "Disconnecting"
            self.disconnect()
        if opts.verbose:
            print "idle"
        time.sleep(4)

    def post_disconnect(self):
        print "Disconnected"
        raise Disconnected


# add a logger so that we can see what's going
if opts.debug:
    logger=logging.getLogger()
    logger.addHandler(logging.StreamHandler())
    logger.setLevel(logging.DEBUG)

# debug the memore
libxml2.debugMemory(1)

# set up the stream
myjid=JID(opts.username+"@"+opts.server+"/Home")
s=MyClient(jid=myjid,password=opts.password)

if opts.verbose:
    print "connecting..."
s.connect()

if opts.verbose:
    print "build pubsub stanza..."
recpt=JID("pubsub."+opts.server)
pspl=pubsub.PubSub(from_jid = myjid, to_jid = recpt, stream = s,\
stanza_type="get")
if opts.get_nodes:
    print "Getting nodes"
    pspl.get_nodes()
elif opts.create_node:
    print "Creating node " + opts.create_node
    pspl.create_node(opts.create_node)
elif opts.delete_node:
    pspl.delete_node(opts.delete_node)
elif opts.subscribe_node:
    pspl.subscribe(myjid,opts.subscribe_node)
elif opts.unsubscribe_node:
    pspl.unsubscribe(myjid,opts.unsubscribe_node,opts.unsubscribe_subid)
elif opts.subscriptions:
    pspl.subscriptions(myjid)
elif opts.add_publisher:
    pass
else:
    pspl.get_nodes()

if opts.verbose:
    print "sending message..."

try:
    s.loop(1)
except KeyboardInterrupt:
    print u"disconnecting..."
    s.disconnect()

# vi: sts=4 et sw=4
