#!/usr/bin/env python
#
# Copyright (C) 2010  Peter Couvares  <pfcouvar@syr.edu>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
This is a drop-in replacement for ligolw_segments_from_cats, but
splits the specified query into multiple, shorter queries (by GPS
time) and recombines the results.  It supports one additional
optional argument, --max_gps_duration, to specify the maxmimum size
of the split (default is one week).
"""

import sys
import os
import pwd
import tempfile
import re

from optparse import OptionParser

import glue.segments
from glue.segmentsUtils import segmentlist_range


# try:
#     import sqlite3
# except ImportError:
#     # pre 2.5.x
#     from pysqlite2 import dbapi2 as sqlite3

# import operator

# import time
# from glue import gpstime

# from glue.ligolw import ligolw
# from glue.ligolw import lsctables
# from glue.ligolw import utils
# from glue.ligolw.utils import ligolw_sqlite
# from glue.ligolw import dbtables

# from glue.segmentdb import query_engine
# from glue.segmentdb import segmentdb_utils

# from glue.ligolw.utils import process

from glue import git_version

# import urllib

PROGRAM_NAME = sys.argv[0].replace('./','')
PROGRAM_PID  = os.getpid()
try:
        USER_NAME = os.getlogin()
except:
        USER_NAME = pwd.getpwuid(os.getuid())[0]


__author__ = "Peter Couvares <pfcouvar@syr.edu>"
__version__ = "git id %s" % git_version.id
__date__ = git_version.date


# lifted from ligolw_segments_from_cats, with --max-gps-duration added
def parse_command_line():
    """
    Parse the command line, return an options object
    """

    parser = OptionParser(
        version = "Name: %%prog\n%s" % git_version.verbose_msg,
        usage   = "%prog -v|--veto-file filename [options]",
        description = "Reads one or more segment files and a veto file and generates files of veto segments"        
	)
    
    parser.add_option("-v", "--veto-file",    metavar = "veto_file",    help = "veto XML file (required).")
    parser.add_option("-o", "--output-dir",   metavar = "output_dir",   default = '.',          help = "Directory to write output (default=cwd).")
    parser.add_option("-k", "--keep-db",      metavar = "keep_db",      action  = "store_true", help = "Keep sqlite database.")
                      
    parser.add_option("-t", "--segment-url",  metavar = "segment_url", help = "Segment URL")
    parser.add_option("-d", "--database",     metavar = "use_database", action = "store_true", help = "use database specified by environment variable S6_SEGMENT_SERVER")
    parser.add_option("-f", "--dmt-file",     metavar = "use_files", action = "store_true", help = "use files in directory specified by environment variable ONLINEDQ")
    parser.add_option("-c", "--cumulative-categories",   action = "store_true", help = "If set the category N files will contain all segments in categories <= N")
    parser.add_option("-p", "--separate-categories",     action = "store_true", help = "If set the category N files will contain only category N")
    
    # Time options
    parser.add_option("-s", "--gps-start-time", metavar = "gps_start_time", help = "Start of GPS time range")
    parser.add_option("-e", "--gps-end-time",   metavar = "gps_end_time", help = "End of GPS time range")

    parser.add_option("--max-gps-duration",   metavar = "max_gps_duration", help = "Maximum duration of an individual query; larger durations will be split into multiple queries and recombined.")

    options, others = parser.parse_args()

#     if not options.veto_file:
#         raise ValueError, "missing required argument --veto-file"
   
#     # User must specify how to treat the categories
#     if not (options.cumulative_categories or options.separate_categories) or (options.cumulative_categories and options.separate_categories):
#         print >>sys.stderr, "Must provide one of --cumulative-categories | --separate-categories"
#         sys.exit(-1)

#     tmp_dir = None

#     # Make sure we have required arguments
#     database_location = None
#     file_location     = None

#     # Make sure we know who to contact for data
#     # (This is redundant with ligolw_segment_query, maybe move to
#     # query_engine)
#     if options.segment_url:
#         if options.segment_url.startswith('ldbd') or options.segment_url.startswith('http'):
#             database_location = options.segment_url
#         elif options.segment_url.startswith('file:'):
#             file_location = options.segment_url[len('file://'):]
#         else:
#             tmp_dir = tempfile.mkdtemp()
        
#             # Grab the part of the name after the last slash
#             pos     = options.segment_url[::-1].find('/')
#             fname   = (pos > -1) and options.segment_url[ -1 * pos:] or "dmt.xml" 

#             inurl   = urllib.urlopen(options.segment_url)
#             outfile = open(tmp_dir + "/" + fname, 'w')
#             for l in inurl:
#                 print >>outfile, l,

#             inurl.close()
#             outfile.close()
#             file_location = tmp_dir
#     elif options.database:
#         if 'S6_SEGMENT_SERVER' not in os.environ:
#             raise ValueError( "--database specified by S6_SEGMENT_SERVER not set" )
#         database_location = os.environ['S6_SEGMENT_SERVER']
#     elif options.dmt_file:
#         if 'ONLINEDQ' not in os.environ:
#             raise ValueError( "--dmt-file specified but ONLINEDQ not set" )

#         tmp = os.environ['ONLINEDQ']
#         if tmp.startswith('file://'):
#             tmp = tmp[len('file://'):]
#         file_location = tmp
#     else:
#         raise ValueError( "One of [ --segment_url | --database | --dmt-file ] must be provided" )


    if not options.gps_start_time:
        raise ValueError( "missing required argument --gps-start-time" )
    
    if not options.gps_end_time:
        raise ValueError( "missing required argument --gps-end-time" )

#    return options, database_location, file_location, loaded_file
    return options


def strip_arg(argv, long_name, short_name=None, remove_value=True):
    argn = 0
    while argn < len(argv):
        arg = argv[argn]
        argsplit = arg.split('=')
        arg = argsplit[0]
        if arg == long_name or arg == short_name:
            # if we are to remove the associated value, and that value
            # is not already inside the arg (via '='), then skip the
            # subsequent argument
            if remove_value and len(argsplit)==1:
                argn += 1
        else:
            yield argv[argn]
        argn += 1


if __name__ == '__main__':

#     # Settings - disable nanoseconds
#     del lsctables.SegmentTable.validcolumns['start_time_ns']
#     del lsctables.SegmentTable.validcolumns['end_time_ns']
#     del lsctables.ProcessTable.validcolumns['domain']
#     del lsctables.ProcessTable.validcolumns['jobid']
#     del lsctables.ProcessTable.validcolumns['is_online']

#     dbtables.get_column_info = kludge_get_column_info

#    options, db_location, file_location, loaded_file = parse_command_line()    
    options = parse_command_line()

    if options.max_gps_duration is None:
        max_gps_duration = 60*60*24*7
    else:
        max_gps_duration = int(options.max_gps_duration)

    gps_start_time = int(options.gps_start_time)
    gps_end_time = int(options.gps_end_time)
    gps_duration = gps_end_time - gps_start_time

    if max_gps_duration > gps_duration:
        max_gps_duration = gps_duration

#    print gps_start_time
#    print gps_end_time

    gps_segmentlist = list(segmentlist_range(gps_start_time, gps_end_time, max_gps_duration))
    if gps_segmentlist[-1][1] != int(gps_end_time):
        gps_segmentlist.append(glue.segments.segment(gps_segmentlist[-1][1],gps_end_time))

    print "segmentlist =", gps_segmentlist

    argv = sys.argv[1:]
    print "original argv =", argv
    argv = list(strip_arg(argv, "-s", "--gps-start-time"))
    argv = list(strip_arg(argv, "-e", "--gps-end-time"))
    argv = list(strip_arg(argv, "-o", "--output-dir"))
    argv = list(strip_arg(argv, "--max-gps-duration"))

    print "stripped argv =", argv

    temp_dirs = []

    for segment in gps_segmentlist:
        temp_dir = tempfile.mkdtemp()
        temp_dirs.append(temp_dir)
        temp_argv = list(argv)
        temp_argv.append("-s %s" % segment[0])
        temp_argv.append("-e %s" % segment[1])
        temp_argv.append("-o %s" % temp_dir)
        print "temp_argv =", temp_argv
        os.system("ligolw_segments_from_cats %s" % ' '.join(temp_argv))

        # for debugging only
#        os.chdir(temp_dir)
#        os.system("touch file1 file2")

    # in theory, the same output files should be present in each temp_dir,
    # so we just need to look in one to figure out their names

#    temp_files = [s[0:16] + "*" for s in os.listdir(temp_dirs[0])]
    # find all file prefixes of the form "<ifo><n>-VETOTIME_CAT<n>"
    # (e.g., "L1-VETOTIME_CAT2")
    prefix = re.compile(r"^[A-Z][0-9]-VETOTIME_CAT[0-9]")
    temp_files = [prefix.match(s).group() for s in os.listdir(temp_dirs[0])]
    
    #    "L1-VETOTIME_CAT2-970271943-259200.xml"
    re.compile(r"^[A-Z][0-9]-VETOTIME_CAT[0-9]").match(s).group()


    for file in temp_files:
        file_instances = ["%s/%s-*-*.xml" % (dir, file) for dir in temp_dirs]
        os.chdir(options.output_dir)
#        os.system("pwd")
        result_file = "%s-%d-%d.xml" % (file, gps_start_time, gps_duration)
        os.system("ligolw_add --output %s %s" % (result_file, ' '.join(file_instances)))
#        os.system("rm -v %s" % ' '.join(file_instances))

#    for dir in temp_dirs:
#        os.rmdir(dir)

    sys.exit(0)

#     now = gpstime.GpsSecondsFromPyUTC(time.time())

#     # 1. Load the veto file into sqlite    
#     handle, temp_db    = tempfile.mkstemp(suffix='.sqlite')
#     os.close(handle)
#     target          = dbtables.get_connection_filename(temp_db, None, True, False)
#     veto_connection = ligolw_sqlite.setup(target)

#     # Create an engine to query veto information
#     veto_query_engine = query_engine.SqliteQueryEngine(veto_connection)
#     xml_files         = [loaded_file or options.veto_file]

#     # 2. If we're working with DMT files load them into sqlite as well
#     min_start_time = int(options.gps_start_time)
#     max_end_time   = int(options.gps_end_time)
    
#     if file_location:
#         xml_files += segmentdb_utils.get_all_files_in_range(file_location, min_start_time, max_end_time)
#         segment_query_engine = veto_query_engine
#     else:
#         segment_connection   = segmentdb_utils.setup_database(db_location)
#         segment_query_engine = query_engine.LdbdQueryEngine(segment_connection)

#     ligolw_sqlite.insert_from_urls(veto_connection, xml_files)

#     # If we're working with DMT files make sure we have a segment table
#     if file_location:
#         segmentdb_utils.ensure_segment_table(veto_connection)
    
#     cli_interval = glue.segments.segmentlist([glue.segments.segment(int(options.gps_start_time), int(options.gps_end_time))])
            
#     #
#     # Get the set of veto categories and ifos for which we have segments 
#     #
#     categories = [row[0] for row in veto_query_engine.query("select distinct(category) from veto_definer")]
#     ifos       = [row[0] for row in veto_query_engine.query("select distinct(ifo) from veto_definer")]

#     category_selection_operator = options.cumulative_categories and ' <= ' or ' = '

#     for ifo in ifos:
#         for category_num in categories:
#             # Start a new document
#             doc = ligolw.Document()
#             doc.appendChild(ligolw.LIGO_LW())

#             # Register ourselves
#             proc_id = process.register_to_xmldoc(doc, PROGRAM_NAME, options.__dict__, version=git_version.id).process_id

#             # Keep the veto_definer for tracking purposes
#             doc.childNodes[0].appendChild(dbtables.get_xml(veto_connection, ['veto_definer']).childNodes[0])

#             # loop over select of name, version where ifo=current ifo and category <= current category
#             cursor = veto_connection.cursor()
#             sql = """SELECT ifo, name, version, start_time, end_time, start_pad, end_pad
#                        FROM veto_definer
#                       WHERE ifo = '%s' AND category %s %s""" % (ifo, category_selection_operator, category_num)

#             segdefs = []
#             for ifo, name, version, start_time, end_time, start_pad, end_pad in cursor.execute(sql):
#                 if end_time == 0:
#                     end_time = now

#                 veto_interval  = glue.segments.segmentlist([glue.segments.segment(start_time, end_time)])
#                 veto_interval.coalesce()
#                 veto_interval &= cli_interval


#                 if len(veto_interval) > 0:
#                     segdefs.append( (ifo, name, version, veto_interval[0][0], veto_interval[0][1], start_pad, end_pad) )


#             vetoed_segments   = segmentdb_utils.query_segments(segment_query_engine, 'segment', segdefs)
#             segment_summaries = segmentdb_utils.query_segments(segment_query_engine, 'segment_summary', segdefs)

#             # We could write out everything we found.  This might help tracking down why a time
#             # or trigger was vetoed.
#             # segmentdb_utils.add_segment_info(doc, proc_id, segdefs, vetoed_segments, segment_summaries)

#             # Form the result
#             vetoed_segments = reduce(operator.or_, vetoed_segments).coalesce()

#             # Add the result type to the segment definer table
#             seg_name   = 'VETO_CAT%d%s' % (category_num, options.cumulative_categories and '_CUMULATIVE' or '')
#             seg_def_id = segmentdb_utils.add_to_segment_definer(doc, proc_id, ifo, seg_name, 1)

#             # and segment summary
#             segmentdb_utils.add_to_segment_summary(doc, proc_id, seg_def_id, [[min_start_time, max_end_time]])

#             # and store the segments
#             segmentdb_utils.add_to_segment(doc, proc_id, seg_def_id, vetoed_segments)
            
#             # Dump to XML
#             output_name = "%s/%s-VETOTIME_CAT%d-%d-%d.xml" % (options.output_dir, ifo, category_num, min_start_time, (max_end_time - min_start_time))
#             utils.write_filename(doc, output_name)

#     # Clean up
#     if loaded_file:
#         os.remove(loaded_file)
#         pos   = loaded_file[::-1].find('/') + 1
#         os.rmdir(loaded_file[:-1 * pos])


#     if not options.keep_db:
#         os.remove(temp_db)

