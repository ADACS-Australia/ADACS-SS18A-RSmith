#!/usr/bin/env python

import httplib, mimetypes
import os, sys

typeCodeMap = {
        "LowMass" : "LM",
        "HighMass" : "HM",
        "GRB"      : "GRB",
        "Ringdown" : "RD",
        "Omega"    : "OM",
        "Q"        : "Q",
        "X"        : "X",
        "CWB"      : "CWB",
        "MBTAOnline": "MBTA",
}
validTypes = typeCodeMap.keys()

def post_multipart(h, selector, fields, files):
    """
    Post fields and files to an http host as multipart/form-data.
    fields is a sequence of (name, value) elements for regular form fields.
    files is a sequence of (name, filename, value) elements for data to be uploaded as files
    Return the server's response page.
    """
    content_type, body = encode_multipart_formdata(fields, files)
    #h = httplib.HTTP(host)
    h.putrequest('POST', selector)
    h.putheader('content-type', content_type)
    h.putheader('content-length', str(len(body)))
    h.endheaders()
    h.send(body)
    errcode, errmsg, headers = h.getreply()
    return h.file.read()

def encode_multipart_formdata(fields, files):
    """
    fields is a sequence of (name, value) elements for regular form fields.
    files is a sequence of (name, filename, value) elements for data to be uploaded as files
    Return (content_type, body) ready for httplib.HTTP instance
    """
    BOUNDARY = '----------ThIs_Is_tHe_bouNdaRY_$'
    CRLF = '\r\n'
    L = []
    for (key, value) in fields:
        L.append('--' + BOUNDARY)
        L.append('Content-Disposition: form-data; name="%s"' % key)
        L.append('')
        L.append(value)
    for (key, filename, value) in files:
        L.append('--' + BOUNDARY)
        L.append('Content-Disposition: form-data; name="%s"; filename="%s"' % (key, filename))
        L.append('Content-Type: %s' % get_content_type(filename))
        L.append('')
        L.append(value)
    L.append('--' + BOUNDARY + '--')
    L.append('')
    body = CRLF.join(L)
    content_type = 'multipart/form-data; boundary=%s' % BOUNDARY
    return content_type, body

def get_content_type(filename):
    return mimetypes.guess_type(filename)[0] or 'application/octet-stream'


def checkProxy(fname):
    """Check to see if this is a pre-RFC proxy.
       Not sure if this is valid in all cases, but it works at
       least sometimes and is better than giving the user a
       "broken pipe" error message.

       Do one of three things:

         (1) If a check cannot be done because the M2Crypto lib is not
             available, say so.

         (2) If it is a RFC 3820 compliant proxy, say and do nothing.

         (3) Otherwise issue a warning.
       """
    try:
        import M2Crypto
        cert = M2Crypto.X509.load_cert(fname)
        try:
            cert.get_ext('proxyCertInfo')
        except LookupError:
            # Really, there shouldn't be an undefined extension.
            print "Warning: You seem to be using a pre-RFC proxy."
            print "Try doing grid-proxy-init -rfc"
    except ImportError:
        print "Warning: Cannot load M2Crypto.  Not able to check proxy"
        print "   If you are getting errors, perhaps you are not using"
        print '   an RFC compliant proxy.  Did you do "grid-proxy-init -rfc"?'
        print "To enable proxy checking, install m2crypto (CentOS, RedHat),"
        print "python-m2crypto (Debian) or py25-m2crypto (MacPorts)"

def findUserCredentials(warnOnOldProxy=1):

    proxyFile = os.environ.get('X509_USER_PROXY')
    certFile = os.environ.get('X509_USER_CERT')
    keyFile = os.environ.get('X509_USER_KEY')

    if proxyFile:
        if warnOnOldProxy:
            checkProxy(proxyFile)
        return proxyFile, proxyFile

    if certFile and keyFile:
        return certFile, keyFile

    # Try default proxy
    proxyFile = os.path.join('/tmp', "x509up_u%d" % os.getuid())
    if os.path.exists(proxyFile):
        if warnOnOldProxy:
            checkProxy(proxyFile)
        return proxyFile, proxyFile

    # Try default cert/key
    homeDir = os.environ.get('HOME')
    certFile = os.path.join(homeDir, '.globus', 'usercert.pem')
    keyFile = os.path.join(homeDir, '.globus', 'keycert.pem')

    if os.path.exists(certFile) and os.path.exists(keyFile):
        return certFile, keyFile

def usage(prog):
    print """%s GROUP TYPE EVENTFILE
   where GROUP is one of CBC, Burst, Stochastic, CW
   and   TYPE is one of %s
   and   EVENTFILE is file containing event data
""" % (prog, ", ".join(validTypes))


if __name__ == "__main__":

    if len(sys.argv) != 4:
        usage(os.path.basename(sys.argv[0]))
        sys.exit(1)

    group = sys.argv[1]
    type = sys.argv[2]
    filename = sys.argv[3]

    if type in typeCodeMap:
        type = typeCodeMap[type]
    else:
        print "Type must be one of: ", ", ".join(typeCodeMap.keys())
        sys.exit(1)

    cred = findUserCredentials(warnOnOldProxy=0)
    if not cred:
        print "No credentials found"
        sys.exit(1)
    cert, key = cred
    host = "archie.phys.uwm.edu"
    h = httplib.HTTPS(host, key_file=key, cert_file=cert)
    fields = [('cli', 'true'),
              ('group', group),
              ('type', type),
             ]
    files = [('eventFile', filename, open(filename, 'r').read())]
    response = post_multipart(h, '/gracedb/cli/create', fields, files)

    if response:
        if response.startswith('ERROR'):
            print response
            sys.exit(1)
        else:
            print "UID: ", response
            sys.exit(0)
    else:
        print "There was a problem.  Did you do grid-proxy-init -rfc?"
        sys.exit(1)
