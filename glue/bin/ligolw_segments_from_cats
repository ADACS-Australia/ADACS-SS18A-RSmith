#!/usr/bin/env python
#
# $Id$
#
# Copyright (C) 2009  Larne Pekowsky
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#


"""
Takes one or more segment XML files and a query file, runs the query against
the segments, and produces veto files as XML
"""


from optparse import OptionParser

try:
    import sqlite3
except ImportError:
    # pre 2.5.x
    from pysqlite2 import dbapi2 as sqlite3

import sys
import os
import glob

import glue.segments

from glue.ligolw import ligolw
from glue.ligolw import lsctables
from glue.ligolw import utils
from glue.ligolw.utils import ligolw_sqlite
from glue.ligolw import dbtables

from glue.segmentdb import query_engine

from glue import LDBDClient
from glue import gsiserverutils
from glue.ligolw.utils import process

import StringIO

PROGRAM_NAME = sys.argv[0].replace('./','')
PROGRAM_PID  = os.getpid()
USER_NAME    = os.getlogin()



__author__ = "Larne Pekowsky <lppekows@physics.syr.edu>"
__date__ = "$Date$"[7:-2]
__version__ = "$Revision$"[11:-2]


#
# =============================================================================
#
#                                 Command Line
#
# =============================================================================
#


def parse_command_line():
    """
    Parse the command line, return an options object
    """

    parser = OptionParser(
        version = "%prog CVS $Header$",
        usage   = "%prog -v|--veto-file filename [options]",
        description = "Reads one or more segment files and a veto file and generates files of veto segments"        
	)
    
    parser.add_option("-g", "--glob-pattern", metavar = "glob_pattern", default = '*.xml', help = "Glob pattern for segment XML files (default=*.xml).")
    parser.add_option("-v", "--veto-file",    metavar = "veto_file",    help = "veto XML file (required).")
    parser.add_option("-o", "--output-dir",   metavar = "output_dir",   default = '.',          help = "Directory to write output (default=cwd).")
    parser.add_option("-k", "--keep-db",      metavar = "keep_db",      action  = "store_true", help = "Keep sqlite database.")
                      
    parser.add_option("-t", "--segment",      metavar = "segment_url", help = "Segment URL")
    parser.add_option("-d", "--database",     metavar = "use_database", action = "store_true", help = "use database specified by environment variable LSC_SEGFIND_SERVER")
    parser.add_option("-f", "--dmt-file",    metavar = "use_files", action = "store_true", help = "use files in directory specified by environment variable DMT_SEGMENT_LOCATION")
    
    # Time options
    parser.add_option("-s", "--gps-start-time", metavar = "gps_start_time", help = "Start of GPS time range")
    parser.add_option("-e", "--gps-end-time",   metavar = "gps_end_time", help = "End of GPS time range")

    options, others = parser.parse_args()

    if not options.veto_file:
        raise ValueError, "missing required argument --veto-file"
    

    # Make sure we have required arguments
    database_location = None
    file_location     = None

    # Make sure we know who to contact for data
    # (This is redundant with ligolw_segment_query, maybe move to
    # query_engine)
    if options.segment:
        if options.segment.startswith('ldbd:'):
            database_location = options.segment[len('ldbd://'):]
        elif options.segment.startswith('file:'):
            file_location = options.segment[len('file://'):]
        else:
            raise ValueError( "Segment URL %s must start with ldbd: or file:" % (options.segment) )
    elif options.database:
        if 'LSC_SEGFIND_SERVER' not in os.environ:
            raise ValueError( "--database specified but LSC_SEGFIND_SERVER not set" )
        database_location = os.environ['LSC_SEGFIND_SERVER'][len('ldbd://'):]
    elif options.dmt_file:
        if 'DMT_SEGMENT_LOCATION' not in os.environ:
            raise ValueError( "--dmt-file specified but DMT_SEGMENT_LOCATION not set" )
        if os.environ['DMT_SEGMENT_LOCATION'][len('file://')]!='/':
           raise ValueError( "Wrong '--dmt-file' format. 'file://' is the prefix, actual path starts with '/'. Correct format should be file:///path_to_dir") 
        file_location = os.environ['DMT_SEGMENT_LOCATION'][len('file://'):]
    else:
        raise ValueError( "One of [ --segment | --database | --dmt-file ] must be provided" )


    if not options.gps_start_time:
        raise ValueError( "missing required argument --gps-start-time" )
    
    if not options.gps_end_time:
        raise ValueError( "missing required argument --gps-end-time" )

        
    return options, database_location, file_location




#
# =============================================================================
#
#                                 Library Code
#
# =============================================================================
#

def register_to_sqlite():
    """Register ourselves as a process and segment_definer"""

    doc = ligolw.Document()
    doc.appendChild(ligolw.LIGO_LW())
    proc_id = process.register_to_xmldoc(doc, PROGRAM_NAME, options.__dict__).process_id
    seg_def_table = lsctables.New(lsctables.SegmentDefTable, columns = ["process_id", "segment_def_id", "ifos", "name", "version", "comment"])
    doc.childNodes[0].appendChild(seg_def_table)

    seg_def_id                     = seg_def_table.get_next_id()
    segment_definer                = lsctables.SegmentDef()
    segment_definer.process_id     = proc_id
    segment_definer.segment_def_id = seg_def_id
    segment_definer.ifos           = ''
    segment_definer.name           = "ligolw_segments_from_cats"
    segment_definer.version        = 0
    segment_definer.comment        = ''

    seg_def_table.append(segment_definer)

    fake_file1 = StringIO.StringIO()
    doc.write(fake_file1)

    fake_file2 = StringIO.StringIO(fake_file1.getvalue())
    utils.load_fileobj(fake_file2, False, doc)

    return proc_id, seg_def_id


def get_all_files(dirname):
    ret = []

    for o in os.walk(dirname):
        ret += map(lambda x: os.path.join(o[0], x), o[2])

    return ret


def file_filter(file_name, start_time, end_time):
    """Given a filename of the form /root_path/H-DQ_Segments-time-16.xml and start and end
    times returns true if the file falls into the time interval."""
    
    # If this isn;t an XML file, skip it
    if not file_name.endswith('xml'):
        return False

    pieces    = file_name.split('-')
    file_time = int(pieces[-2])

    return file_time >= (start_time-16) and file_time <= (end_time+16)
#
# =============================================================================
#
#                                 Database/ldbd routines
#
# =============================================================================
#


def setup_database(host_and_port):
    port = 30020
    
    if host_and_port.find(':') < 0:
        host = host_and_port
    else:
        # server and port specified
        host, portString = host_and_port.split(':')
        port = int(portString)


    identity = "/DC=org/DC=doegrids/OU=Services/CN=ldbd/%s" % host

    # open connection to LDBD Server
    client = None

    try:
        client = LDBDClient.LDBDClient(host, port, identity)
    except Exception, e:
        print >>sys.stderr, \
              "Unable to connect to LDBD Server %s:%d" % (host, port)
        if gsiserverutils.checkCredentials():
            print >>sys.stderr, "Got the following error : " + str(e)
            print >>sys.stderr, "Enter '%s --help' for usage" % PROGRAM_NAME
        sys.exit(-1)

    return client

#
# =============================================================================
#
#                                     Main
#
# =============================================================================
#

if __name__ == '__main__':
    # Settings - disable nanoseconds
    del lsctables.SegmentTable.validcolumns['start_time_ns']
    del lsctables.SegmentTable.validcolumns['end_time_ns']
    del lsctables.ProcessTable.validcolumns['domain']
    del lsctables.ProcessTable.validcolumns['jobid']
    del lsctables.ProcessTable.validcolumns['is_online']

    # And set up for boolean arguments
    from glue.ligolw import types as ligolwtypes
    ligolwtypes.FromPyType[type(True)] = ligolwtypes.FromPyType[type(8)]

    options, db_location, file_location = parse_command_line()    

    # 1. Load the veto file into sqlite
    # TODO: This should have a better name that includes the
    # start and end times
    
    temp_db    = options.output_dir + '/temp.db'
    target     = dbtables.get_connection_filename(temp_db, None, True, False)
    connection = ligolw_sqlite.setup(target)

    # Create an engine to query veto information
    veto_query_engine = query_engine.SqliteQueryEngine(connection)
    xml_files         = [options.veto_file]

    # 2. If we're working with DMT files load them into sqlite as well
    if file_location:
        all_files = get_all_files(file_location)

        xml_files += filter(lambda x: file_filter(x, int(options.gps_start_time), int(options.gps_end_time)), all_files)

    ligolw_sqlite.insert(connection, xml_files)

    process_id, segment_def_id = register_to_sqlite()


    if file_location:
        #
        # Back up the segment table
        #
        cursor            = connection.cursor()
        cursor.execute("select sql from SQLITE_MASTER where name='segment'")
        seg_table_sql     = str(cursor.fetchone()[0])
        seg_bak_table_sql = seg_table_sql.replace('TABLE segment','TABLE segment_bak')
        cursor.execute(seg_bak_table_sql)
        cursor.execute('insert into segment_bak select * from segment')
        connection.commit()
        cursor.close()

        segment_query_engine = veto_query_engine
        table_name           = 'segment_bak'
    else:
        connection           = setup_database(db_location)
        segment_query_engine = query_engine.LdbdQueryEngine(connection)

        # Create empty segment, segment definer, segment summary tables in the sqlite DB
        doc = ligolw.Document()
        doc.appendChild(ligolw.LIGO_LW())
        seg_def_table = lsctables.New(lsctables.SegmentDefTable, columns = ["process_id", "segment_def_id", "ifos", "name", "version", "comment"])
        doc.childNodes[0].appendChild(seg_def_table)

        segtable = lsctables.New(lsctables.SegmentTable, columns = ["process_id", "segment_def_id", "segment_id", "start_time", "end_time"])
        doc.childNodes[0].appendChild(segtable)

        seg_sum_table = lsctables.New(lsctables.SegmentSumTable)
        doc.childNodes[0].appendChild(seg_sum_table)

        fake_file1 = StringIO.StringIO()
        doc.write(fake_file1)
        fake_file2 = StringIO.StringIO(fake_file1.getvalue())
        utils.load_fileobj(fake_file2, False, doc)
    
        table_name           = 'segment'


    # Get start and end times for file names
    min_start_time, max_end_time = segment_query_engine.query("select min(start_time), max(end_time) from segment")[0]

    #
    # Get the set of veto categories and ifos for which we have segments 
    #
    categories = [row[0] for row in veto_query_engine.query("select distinct(category) from veto_definer")]
    ifos       = [row[0] for row in segment_query_engine.query("select distinct(ifo) from veto_definer")]

    for ifo, category_num in [(i,c) for i in ifos for c in categories]:
        # Start a new document
        xmldoc = ligolw.Document()
        xmldoc.appendChild(ligolw.LIGO_LW())

        # Update the IFOs for the segment definer
        cursor = connection.cursor()
        cursor.execute("""UPDATE segment_definer SET ifos=? WHERE name = ?""", (ifo, PROGRAM_NAME))
        connection.commit()
        cursor.close()
        
        #
        # Get the set of vetos
        #
        cursor = connection.cursor()
        cursor.execute("""SELECT * FROM veto_definer WHERE ifo = ? AND category <= ?""", (ifo, category_num))

        #
        # Clear out the segments table
        #
        cursor = connection.cursor()
        cursor.execute("DELETE FROM segment")
        connection.commit()
        cursor.close()

        # If everything were in the same database we could do a join like
        # thus:
        # cursor.execute("""
        #      SELECT segment_bak.start_time, segment_bak.end_time, veto_definer.start_time, veto_definer.end_time, veto_definer.start_pad, veto_definer.end_pad
        #      FROM segment_bak, segment_definer, veto_definer 
        #      WHERE segment_bak.segment_def_id = segment_definer.segment_def_id
        #        AND segment_definer.ifos = veto_definer.ifo
        #        AND veto_definer.ifo  = ?
        #        AND veto_definer.name = segment_definer.name
        #        AND veto_definer.version = segment_definer.version
        #       AND veto_definer.category <= ? """,(ifo, category_num))
        #
        # but since the segments may be coming from LDBD and the vetos from
        # the local database we need to do a bit more work.

        # loop over select of name, version where ifo=current ifo and category <= current category
        cursor = connection.cursor()
        cursor.execute("""SELECT name, version, start_time, end_time, start_pad, end_pad
                          FROM veto_definer
                          WHERE ifo = '%s' AND category <= %s""" % (ifo, category_num))
        
        disjoint_segments = glue.segments.segmentlist([])
        
        for name, version, veto_start_time, veto_end_time, start_pad, end_pad in cursor:
            veto_interval = glue.segments.segment(veto_start_time, veto_end_time)
       
            params = {'table_name':table_name, 'name':name, 'ifo':ifo, 'version':version, 'veto_start_time':veto_start_time, 'veto_end_time':veto_end_time}

            if veto_end_time == 0:
                time_clause = ' AND %(veto_start_time)s BETWEEN %(table_name)s.start_time AND %(table_name)s.end_time ' % params
            else:
                time_clause = ' AND NOT(%(table_name)s.start_time > %(veto_end_time)s OR %(veto_start_time)s > %(table_name)s.end_time) ' % params

            params['time_clause'] = time_clause


            rows2 = segment_query_engine.query("""
            SELECT %(table_name)s.start_time, %(table_name)s.end_time
             FROM %(table_name)s, segment_definer
             WHERE %(table_name)s.segment_def_id = segment_definer.segment_def_id
               AND segment_definer.ifos = '%(ifo)s'
               AND segment_definer.name = '%(name)s'
               %(time_clause)s
               AND segment_definer.version = '%(version)s'""" % params)
        
            for seg_start_time, seg_end_time in rows2:
                if seg_end_time == 0:
                    seg_end_time = glue.segments.infinity()

                if veto_end_time == 0:
                    veto_end_time = glue.segments.infinity()
                    
                seg_interval  = glue.segments.segment(seg_start_time, seg_end_time)

                # Add the padding
                seg_interval = glue.segments.segment(seg_interval[0] - start_pad, seg_interval[1] + end_pad)

                disjoint_segments |= glue.segments.segmentlist([seg_interval])
                
        cursor.close()
        disjoint_segments.coalesce()
            
        segment_id = 0
        
        for seg in disjoint_segments:
            cursor.execute("""insert into segment(segment_id, start_time, end_time, segment_def_id, process_id) values(?, ?, ?, ?, ?)""",
                           ('segment:segment_id:%d' % segment_id, seg[0], seg[1], str(segment_def_id), str(process_id)))
            segment_id += 1
            
        connection.commit()
            

        #
        # Update the summary table
        #
        cursor.execute("DELETE FROM segment_summary")
        cursor.execute("""INSERT INTO segment_summary(segment_sum_id,start_time, end_time, segment_def_id, process_id) VALUES('segment_summary:segment_sum_id:0',?,?,?,?)""",
                       (min_start_time, max_end_time, str(segment_def_id), str(process_id)))
        connection.commit()
            
        #
        # Dump to XML
        #
        output_name = "%s/%s-VETOTIME_CAT%d_%d_%d.xml.gz" % (options.output_dir, ifo, category_num, min_start_time, (max_end_time - min_start_time))
        ligolw_sqlite.extract(connection, output_name, table_names = ['process','process_params', 'segment_definer','veto_definer','segment','segment_summary'] )

        #
        # Dump to text
        #
        # output_name = "%s/%s-VETOTIME_CAT%d_%d_%d.txt" % (options.output_dir, ifo, category_num, min_start_time, (max_end_time - min_start_time))
        # f_out       = open(output_name,'w')
        # cursor      = connection.cursor()
        # cursor.execute("select start_time, end_time from segment")
        # rowcount    = 1
        # for row in cursor:
        #     print >>f_out, '%d\t%d\t%d\t%d' % (rowcount, row[0], row[1], (row[1] - row[0]))
        #     rowcount += 1
        # f_out.close()
        # cursor.close()


    #
    # Clean up
    #
    if not options.keep_db:
        os.remove(temp_db)

