#!/usr/bin/env python

# This script coalesces segment and segment_summary table at LHO and LLO segment database machine
# At LHO, this script only coalesces H1, H2 segments
# At LLO, this script only coalesces L1 segments

import sys
import os
import time
import socket
import ConfigParser
from optparse import OptionParser


try:
  import DB2
except:
  pass

try:
  from glue import gpstime
  from glue import segments
except ImportError, e:
  print >> sys.stderr, """
Error: unable to import modules from glue.

Check that glue is correctly installed and in your PYTHONPATH.

%s
""" % e

#================================================================================
__author__ = "Ping Wei <piwei@physics.syr.edu>"
__date__ = "$Date$"[7:-2]
__version__ ="$Revision$"[11:-2]
__src__ = "$Source$"
#================================================================================
#                Command Line
#================================================================================
def parse_command_line():
  parser = OptionParser()

  parser.add_option("-s", "--gps-start-time", metavar = "gps_start_time", help = "Start of GPS time range")
  parser.add_option("-e", "--gps-end-time", metavar = "gps_end_time", help = "End of GPS time range")
  parser.add_option("-d", "--database-name", metavar = "database_name", help = "name of the database. Currently segdb_coalesce only takes seg6_lho and seg6_llo")

  opts, others = parser.parse_args()

  return opts


options = parse_command_line()

if not options.gps_start_time:
   print "Error: --gps-start-time is required"
   sys.exit(1)
if not options.gps_end_time:
   print "Error: --gps-end-time is required"
   sys.exit(1)
if not options.database_name:
   print "Error: --database-name is required, please specify either seg6_lho or seg6_llo"
   sys.exit(1)


# Set up connection to the database
database = options.database_name
try:
  dbconn = DB2.connect(dsn=database, uid='', pwd='')
  curs = dbconn.cursor()
except Exception, e:
  print e
  sys.exit(1)

# Get coalesce time range
st = int(options.gps_start_time)
et = int(options.gps_end_time)

#================================================================================
#                 Insert a new row in the process table
#================================================================================
# get current_time for later use
current_time = gpstime.GpsSecondsFromPyUTC(time.time())


# prepare values for the new row to be inserted into the process table
program = sys.argv[0].replace('./','')
node = socket.gethostname()
username = os.getlogin()
unix_procid = os.getpid()
start_time = current_time
end_time = None
jobid = 0
domain = 'coalesce_local'

sql = "select hex(GENERATE_UNIQUE()) from sysibm.sysdummy1"
curs.execute(sql)
hex_procid = curs.fetchone()[0]
process_id = 'x' + '\'' + hex_procid + '\''

if database == 'seg6_lho':
  process_creator_db = 1
elif database == 'seg6_llo':
  process_creator_db = 2
else:
  process_creator_db = 1  # this line is for testing purpose, will go away 

# insert new row into process table
sql = "INSERT INTO process "
sql += "(program, is_online, node, username, unix_procid, start_time, jobid, domain, process_id, creator_db) "
sql += "VALUES ('%s', 0, '%s', '%s', %d, %d, %d, '%s',%s, %d)" % (program, node, username, unix_procid, start_time, jobid, domain, process_id, process_creator_db)
curs.execute(sql)
curs.execute("commit")

# get the BLOB process_id for later reference
sql = "SELECT BLOB(process_id) from process where hex(process_id)='%s' " % hex_procid
curs.execute(sql)
blob_procid = curs.fetchone()[0]


#========================================================================
# loop in the tables to fetch, coalesce and delete segments
#========================================================================
# populate the tmp table with primary ids to delete
try:
  curs.execute("CREATE TABLE tmp_co (prim_id CHAR(13) FOR BIT DATA NOT NULL PRIMARY KEY);")
  curs.execute("CREATE INDEX tmp_in on tmp_co.prim_id")
  curs.execute("commit")
except:
  # if a tmp_co table already exists, delete its content
  curs.execute("delete from tmp_co")
  curs.execute("commit")

for table in ['segment_summary', 'segment']: 
  # find unique segment types
  sql = "SELECT distinct hex(segment_def_id) from %s " % table
  sql += "WHERE %s.creator_db = %d " % (table, process_creator_db)
  sql += "AND start_time <= %d " % et
  sql += "AND end_time >= %d " % st

  curs.execute(sql)
  def_ids = curs.fetchall()

  for d in def_ids:
    # get the BLOB segment_def_id for later use 
    sql = "SELECT BLOB(%s.segment_def_id), segment_definer.ifos, segment_definer.name " % table
    sql += "FROM %s, segment_definer " % table
    sql += "WHERE hex(%s.segment_def_id) = '%s' " % (table, d[0])
    sql += "AND %s.segment_def_id = segment_definer.segment_def_id " % table
    sql += "AND %s.segment_def_cdb = segment_definer.creator_db " % table

    curs.execute(sql)
    result = curs.fetchone()
    blob_defid = result[0]
    ifos = result[1].strip() 
    name = result[2]

    # get the start_time, end_time to coalesce, and according primary key to delete
    if table == 'segment':
      sql = "SELECT start_time, end_time, BLOB(segment_id) from segment " 
    if table == 'segment_summary':
      sql = "SELECT start_time, end_time, BLOB(segment_sum_id) from segment_summary "
    sql += "WHERE hex(%s.segment_def_id) = '%s' " % (table,d[0])
    sql += "AND segment_def_cdb = %d " % process_creator_db
    sql += "AND start_time <= %d " % et
    sql += "AND end_time >= %d " % st
    sql += "ORDER BY start_time "
   
    print "Retrieving start_time and end_time to coalesce for %s, %s ..." %(ifos, name)
    curs.execute(sql)
    bf_segs = curs.fetchall()   # get the segments before coalesce


    # coalesce the segments and populate and get the tmp table with the primary ids to delete
    print "Coalescing segments ... "
    ids_to_delete = []
    segs = segments.segmentlist([]) 
    for bf in bf_segs:
      seg = segments.segment(int(bf[0]), int(bf[1]))
      segs.append(seg) 

      ids_to_delete.append(bf[2])
    segs.coalesce()

    # populate the tmp table with primary ids to delete
    sql = "INSERT INTO tmp_co VALUES(?) "
    curs.executemany(sql, ids_to_delete)
    curs.execute("commit")


    # insert coalesced segments back in to the database  
    print "Inserting coalesced segments back in ... "
    insert_list = []
    for s in segs:
      # generate unique id for insertion
      curs.execute("VALUES BLOB(GENERATE_UNIQUE())")
      prim_id = curs.fetchone()[0]

      # generate a list of values to insert using executemany()
      insert_list.append((prim_id, process_creator_db, s[0], s[1], blob_defid, process_creator_db, blob_procid))

    # insert segments back in 
    if  table == 'segment':
      sql = "INSERT INTO segment "
      sql += "(segment_id, creator_db, start_time, end_time, segment_def_id, segment_def_cdb, process_id) "
    if table == 'segment_summary':
      sql = "INSERT INTO segment_summary "
      sql += "(segment_sum_id, creator_db, start_time, end_time, segment_def_id, segment_def_cdb, process_id) "
    sql += "VALUES (?,?,?,?,?,?,?) "
    curs.executemany(sql, insert_list)
    curs.execute("commit")


    # delete un-coalesced segments
    print "deleting un-coalesced segemnts ... "
    print
    sql = "DELETE FROM %s " % table
    if table == 'segment':
      sql += "WHERE segment_id in (SELECT * FROM tmp_co) "
    if table == 'segment_summary':
      sql += "WHERE segment_sum_id in (SELECT * FROM tmp_co) "
    sql += "AND segment_def_cdb = %d " % process_creator_db
    curs.execute(sql)
    curs.execute("commit")

    # empty the tmp table for next segment type
    curs.execute("DELETE FROM tmp_co")
    curs.execute("commit")


# update end_time in the process table
sql = "UPDATE process SET end_time = %d " % current_time 
sql += "WHERE process_id = %s " % process_id
sql += "AND creator_db = %d " % process_creator_db
curs.execute(sql)
curs.execute("commit")


curs.execute("drop table tmp_co")
curs.execute("commit")
curs.close()
sys.exit(0)
