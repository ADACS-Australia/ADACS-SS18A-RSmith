#!/usr/bin/python
"""
segpagegen creates three web pages that can be parsed by segwizard to obtain
information from the segment database.

$Id$
"""

import os
import sys
import getopt
import time
import types
import ConfigParser
import mx.ODBC.DB2
from glue import segments

# parse command line options
shortop = "c:dh"
longop = [
  "config-file=",
  "help"
  ]


usage = "Usage: " + sys.argv[0] + """ [OPTIONS]

  -c, --config-file FILE    read configuration from FILE
  -h, --help                print help message

""" 

configFilePath = None

try:
  opts, args = getopt.getopt(sys.argv[1:], shortop, longop)
except getopt.GetoptError:
  print >>sys.stderr, "Error parsing command line"
  sys.exit(1)

for o, a in opts:
  if o in ("-c", "--config-file"):
    configFilePath = a
  if o in ("-h", "--help"):
    print usage
    sys.exit(0)

if not configFilePath:
  print >> sys.stderr, \
    "Configuration file must be specified with --config-file"
  sys.exit(1)

configuration = {
  'output-path' : '/export/ldcg_server/htdocs/grid/segments',
  'run' : 'S5',
  'dbname' : 'seg_cit'
  }

myConfigParser = ConfigParser.ConfigParser()
try:
  myConfigParser.read(configFilePath)
except:
  print >> sys.stderr, "Error: unable to read configuration file : %s"
  sys.exit(1)

for k in configuration.keys():
  try:
    value = myConfigParser.get('segpagegen',k)
  except ConfigParser.NoOptionError:
    print >> sys.stderr, "Error: missing configuration option : %s" % (k)
    sys.exit(1)
  try:
    configuration[k] = eval(value)
  except:
    configuration[k] = value

# connect to the database
db = mx.ODBC.DB2.Connect(configuration['dbname'])
curs = db.cursor()

# create the base name of the output files
seg_path = os.path.join(configuration['output-path'], configuration['run'])
time_now = ''.join(map(str,time.localtime()))

# base sql used to get science and injection segments
base = "SELECT segment.start_time, segment.end_time FROM "
base += "segment,segment_def_map,segment_definer WHERE "
base += "segment.segment_id = segment_def_map.segment_id AND "
base += "segment.creator_db = segment_def_map.segment_cdb AND "
base += "segment_def_map.segment_def_id = segment_definer.segment_def_id AND "
base += "segment_def_map.segment_def_cdb = segment_definer.creator_db "

seg_file = {}

for ifo in ['H1', 'H2', 'L1']:
  seg_file['Science'] = os.path.join( seg_path, ifo, 'science_segments.txt')
  seg_file['Injection'] = os.path.join( seg_path, ifo, 'injection_segments.txt')
  seg_file['DataQual'] = os.path.join( seg_path, ifo, 'dq_segments.txt')

  # get the segments which derive from the interferometer state vector
  for segtype in ['Science', 'Injection']:
    # open the output files
    seg_fh = open(seg_file[segtype] + time_now, 'w')

    # construct the sql to perform the query
    sql = base + "AND segment_definer.run = '%s'" % configuration['run']
    sql += "AND segment_definer.ifos = '%s' " % ifo
    sql += "AND segment_definer.name = '%s' " % segtype
    sql += "ORDER BY segment.start_time ASC FOR READ ONLY"
    curs.execute(sql)

    # fetch the result and store as segments
    result = curs.fetchall()
    ret_segs = segments.segmentlist()
    try:
      for r in result:
        ret_segs.append(segments.segment(r[0],r[1]))
      ret_segs.coalesce()
    except:
      pass

    # write the segments to the output file
    print >> seg_fh, "# start_time end_time"
    for s in ret_segs:
      print >> seg_fh, "%s %s" % (s[0], s[1])
    seg_fh.close()

  # get all the data quality segments into a single file
  seg_fh = open(seg_file['DataQual'] + time_now, 'w')

  sql =  "SELECT segment_definer.name, segment_definer.version, "
  sql += "segment.start_time, segment.end_time, segment.active FROM "
  sql += "segment_definer, segment_demap, segment WHERE "
  sql += "segment.segment_id = segment_def_map.segment_id AND "
  sql += "segment.creator_db = segment_def_map.segment_cdb AND "
  sql += "segment_def_map.segment_def_id = segment_definer.segment_def_id AND "
  sql += "segment_def_map.segment_def_cdb = segment_definer.creator_db AND "
  sql += "segment_definer.state_vec_major is NULL AND "
  sql += "segment_definer.run = '%s' AND " % configuration['run']
  sql += "segment_definer.ifos = '%s' " % ifo
  sql += "ORDER BY segment_definer.name, segment.start_time asc FOR READ ONLY"

  curs.execute(sql)
  result = curs.fetchall()
  print >> seg_fh, "# name version start_time end_time active"
  for r in result:
    print >> seg_fh, "%s %d %d %d %d" % r
  seg_fh.close()

curs.close()
db.close()
sys.exit(0)
