#!/ldcg/bin/python
"""
segpagegen creates three web pages that can be parsed by segwizard to obtain
information from the segment database.

$Id$
"""

import os
import sys
import getopt
import time
import types
import ConfigParser
import mx.ODBC.DB2
from glue import gpstime
from glue.__segments import *
from glue.segments import segmentlist

#####################################################################
#assumes that on and off are sorted from highest to lowest version
def current_version(on, off):
  n1=len(on)
  n2=len(off)
  print "n1="+repr(n1)+" n2="+repr(n2)
  valid=range(0,n1)
  VALID=range(0,n1)
  ON=segmentlist([])
  for i in range(0,n1):
    on_dq=on[i][0]
    on_version=on[i][1]
    on_list=on[i][2]
    off_dq=off[i][0]
    off_version=off[i][1]
    off_list=off[i][2]    
    print "on_dq="+on_dq+" on_version="+repr(on_version)+" off_dq="+off_dq+" off_version="+repr(off_version)
    valid[i]= on_list | off_list
    if(i==0):
	VALID[i]=valid[i]
	ALL_VALID=VALID[i]
    else:
	VALID[i]=valid[i]-ALL_VALID
	ALL_VALID |= VALID[i]
    ON |= (on_list & VALID[i])
  OFF=ALL_VALID-ON
  return [ON,OFF]
#####################################################################
def correct4injections(inj,on,off):
  print "In correct4injections"
  on=on+[['Injection',0,inj]]
  off=off+[['Injection',0,segmentlist([inj.extent()])-inj]]
  return [on,off]
#####################################################################
# Parse command line options.
shortop = "c:vh"
longop = [
  "config-file=",
  "verbose",
  "help"
  ]

usage = "Usage: " + sys.argv[0] + """ [OPTIONS]

  -c, --config-file FILE    read configuration from FILE
  -v, --verbose             print debugging information to stdout
  -h, --help                print help message

""" 

configFilePath = None
verbose = 0

try:
  opts, args = getopt.getopt(sys.argv[1:], shortop, longop)
except getopt.GetoptError:
  print >>sys.stderr, "Error parsing command line"
  sys.exit(1)

for o, a in opts:
  if o in ("-c", "--config-file"):
    configFilePath = a
  if o in ("-v", "--verbose"):
    verbose = 1
  if o in ("-h", "--help"):
    print usage
    sys.exit(0)

if not configFilePath:
  print >> sys.stderr, \
    "Configuration file must be specified with --config-file"
  sys.exit(1)

configuration = {
  'output-path' : '/export/ldcg_server/htdocs/segments',
  'run' : 'S5',
  'dbname' : 'seg_cit'
  }

myConfigParser = ConfigParser.ConfigParser()
try:
  myConfigParser.read(configFilePath)
except:
  print >> sys.stderr, "Error: unable to read configuration file : %s"
  sys.exit(1)

for k in configuration.keys():
  try:
    value = myConfigParser.get('segpagegen',k)
  except ConfigParser.NoOptionError:
    print >> sys.stderr, "Error: missing configuration option : %s" % (k)
    sys.exit(1)
  try:
    configuration[k] = eval(value)
  except:
    configuration[k] = value

#####################################################################
# Connect to the database.
if verbose: print "connecting to database " + configuration['dbname']
db = mx.ODBC.DB2.Connect(configuration['dbname'])
curs = db.cursor()

#####################################################################
# Create the base name of the output files.
seg_path = os.path.join(configuration['output-path'], configuration['run'])
seg_file = {}

# we query the database up 1600 GMT
midnight = list(time.gmtime())
midnight[3:] = [16,0,0,0,0,0]
midnight = time.mktime(tuple(midnight)) - time.timezone
midnight_gps = gpstime.GpsSecondsFromPyUTC(midnight)
time_str = str(midnight_gps)

#####################################################################
# SQL used to join the segment_definer table to the segment table.
sqlj = "segment,segment_def_map,segment_definer WHERE "
sqlj += "segment.segment_id = segment_def_map.segment_id AND "
sqlj += "segment.creator_db = segment_def_map.segment_cdb AND "
sqlj += "segment_def_map.segment_def_id = segment_definer.segment_def_id AND "
sqlj += "segment_def_map.segment_def_cdb = segment_definer.creator_db "

#####################################################################
# Loop over interferometers to get the various segments.
for ifo in ['H1','H2','L1']:
  # create the names of the segment files
  seg_file['Science'] = os.path.join( seg_path, ifo, 'science_segments')
  seg_file['Injection'] = os.path.join( seg_path, ifo, 'injection_segments')
  seg_file['DataQual'] = os.path.join( seg_path, ifo, 'dq_segments')

  # get the segments which derive from the interferometer state vector
  for segtype in ['Science', 'Injection']:
    # open the output files
    seg_fh = open(seg_file[segtype] + '.' + time_str + '.txt', 'w')

    # construct the sql to perform the query
    if verbose: print "querying database for ifo %s, state %s" % (ifo, segtype)
    if segtype is 'Science':
      sql = "SELECT segment.start_time, segment.end_time, segment.segnum FROM "
    else:
      sql = "SELECT segment.start_time, segment.end_time, 0 FROM "
    sql += sqlj + "AND segment.end_time < %d " % midnight_gps
    sql += "AND segment_definer.run = '%s' " % configuration['run']
    sql += "AND segment_definer.ifos = '%s' " % ifo
    sql += "AND segment_definer.name = '%s' " % segtype
    sql += "AND segment_definer.version = 0 " ####
    sql += "ORDER BY segment.start_time ASC FOR READ ONLY"
    curs.execute(sql)
    result = curs.fetchall()

    # coalesce the result and write to file
    if verbose: 
      print "coalescing %d segments for ifo %s, state %s and writing to file" \
        % (len(result), ifo, segtype)

    # put each segment number into a different segment list
    ret_segs_dict = {}
    for r in result:
      try:
        ret_segs_dict[r[2]].append(segment(r[0],r[1]))
      except KeyError:
        ret_segs_dict[r[2]] = segmentlist()
        ret_segs_dict[r[2]].append(segment(r[0],r[1]))

    # print the header to the file
    print >> seg_fh, "# %s" % configuration['dbname']
    print >> seg_fh, "# %d" % midnight_gps
    print >> seg_fh, "# number gps_start_time gps_end_time duration"

    # coalesce the segments and print them out in order of seg number
    segnums = ret_segs_dict.keys()
    segnums.sort()
    for r in segnums:
      ret_segs_dict[r].coalesce()
      for s in ret_segs_dict[r]:
        print >> seg_fh, str(r) + ' ' + str(s[0]) + ' ' + str(s[1]) + \
          ' ' + str(s[1] - s[0])
    if segtype is 'Injection':
      injections=ret_segs_dict[0]
    # close the file
    seg_fh.flush()
    seg_fh.close()

  # get all the data quality segments into a single file
  seg_fh = open(seg_file['DataQual'] + '.' + time_str + '.txt', 'w')

  print "injections="
  print injections

  # get the a list of non-statevec data quality quality segments
  if verbose: print "fetching list of data quality segments"
  sql = "SELECT name, version FROM segment_definer WHERE "
  sql += "run = '%s' AND ifos = '%s' AND state_vec_major is NULL " \
    % (configuration['run'], ifo)
  sql += "order by name, version desc "
  sql += "FOR READ ONLY"

  print sql

  curs.execute(sql)
  dq_types = curs.fetchall()
  if verbose: print "got %d data quality segments" % len(dq_types)

  print dq_types

  # get each data quality flag, coalesce the list and write to a file
  print >> seg_fh, "# %s" % configuration['dbname']
  print >> seg_fh, "# %d" % midnight_gps
  print >> seg_fh, "# name version gps_start_time gps_end_time active"
  prev_type=dq_types[0][0] 

  ON_SEGS=[]	
  OFF_SEGS=[]
  for dq in dq_types:
    if verbose:
      print "querying database for %s,%s,%d" % (ifo, dq[0], dq[1])
    if(dq[0]!=prev_type):
      print "prev_type="+prev_type
      if(prev_type == 'Injection'):
        print "Here?"
        [ON_SEGS,OFF_SEGS]=correct4injections(injections,ON_SEGS, OFF_SEGS)
        print "corrected injections"
        print ON_SEGS
        print OFF_SEGS
        sys.stdout.flush()
      [ON,OFF]=current_version(ON_SEGS,OFF_SEGS)
      for s in ON:
      	print >> seg_fh, "%s 99 %d %d 1" % (prev_type, s[0], s[1])
      for s in OFF:
      	print >> seg_fh, "%s 99 %d %d 0" % (prev_type, s[0], s[1])         
      ON_SEGS=[]
      OFF_SEGS=[]
    prev_type=dq[0]

    sql =  "SELECT segment.start_time, segment.end_time, segment.active FROM "
    sql += sqlj + "AND segment.end_time < %d " % midnight_gps
    sql += "AND segment_definer.run = '%s' AND " % configuration['run']
    sql += "segment_definer.ifos = '%s' AND " % ifo
    sql += "segment_definer.name = '%s' AND  " % dq[0]
    sql += "segment_definer.version = %d " % dq[1]
    sql += "ORDER BY segment.start_time asc FOR READ ONLY"
    curs.execute(sql)
    result = curs.fetchall()

    on_segs = segmentlist()
    off_segs = segmentlist()

    if verbose: 
      print "coalescing %d segments for %s,%s,%d and writing to file" \
        % (len(result), ifo, dq[0], dq[1])
    for r in result:
      if r[2] == 0:
        off_segs.append(segment(r[0],r[1]))
      elif r[2] == 1:
        on_segs.append(segment(r[0],r[1]))

    on_segs.coalesce()
    off_segs.coalesce()
  
    ON_SEGS.append([dq[0],dq[1],on_segs])
    OFF_SEGS.append([dq[0],dq[1],off_segs])

    for s in on_segs:
      print >> seg_fh, "%s %d %d %d 1" % (dq[0], dq[1], s[0], s[1])

    for s in off_segs:
      print >> seg_fh, "%s %d %d %d 0" % (dq[0], dq[1], s[0], s[1])

    seg_fh.flush()
    sys.stdout.flush()

  if(dq[0] is 'Injection'):
    [ON_SEGS,OFF_SEGS]=correct4injections(injections,ON_SEGS, OFF_SEGS)
    print "corrected injections"
    print ON_SEGS
    print OFF_SEGS
    sys.stdout.flush()
  [ON,OFF]=current_version(ON_SEGS,OFF_SEGS)
  for s in ON:
    print >> seg_fh, "%s 99 %d %d 1" % (dq[0], s[0], s[1]) 
  for s in OFF:
    print >> seg_fh, "%s 99 %d %d 0" % (prev_type, s[0], s[1])         
  ON_SEGS=[]	
  OFF_SEGS=[]

  seg_fh.flush()
  seg_fh.close()

  # update the symbolic links
  if verbose: print "creating symbolic links"
  for k in seg_file.keys():
    symlink_name = seg_file[k] + '.txt'
    try:
      os.unlink(symlink_name)
    except:
      pass
    os.symlink(seg_file[k] + '.' + time_str + '.txt', symlink_name)

#####################################################################
# Close the connection to the database and exit.
if verbose: print "closing connection to the database and exiting"
curs.close()
db.close()
sys.exit(0)
