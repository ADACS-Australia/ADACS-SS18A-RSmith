#!/usr/bin/python
"""
segpagegen creates three web pages that can be parsed by segwizard to obtain
information from the segment database.

This program is part of the Grid LSC User Environment (GLUE)

GLUE is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see <http://www.gnu.org/licenses/>.

$Id$
"""

import os
import sys
import getopt
import time
import types
import ConfigParser
import mx.ODBC.DB2
from glue import gpstime
from glue.__segments import *
from glue.segments import segmentlist
import glob
#####################################################################
#assumes that on and off are sorted from highest to lowest version
def latest_version(active, inactive):
  n1=len(active)
  n2=len(inactive)

  DEFINED_SEGS=segmentlist([])
  # DEFINED_SEGS contains all the defined segments, both active and inactive,
  # up to the current processing version.

  print 'total number of versions of active ',active[0][0], ' segments=', repr(n1)
  print 'total number of versions of inactive ',inactive[0][0],' segments=', repr(n2)
  valid=range(0,n1)
  delta_valid=range(0,n1)

  ACTIVE=segmentlist([])
  # ACTIVE contains the active segments that will be returned. 

  for i in range(0,n1):
    active_dqFlag=active[i][0]  # Dq flag currently being processed
    active_version=active[i][1] # Version currently being processed
    active_segList=active[i][2] # Active dq segment list currently being processed
    inactive_dqFlag=inactive[i][0]
    inactive_version=inactive[i][1]
    inactive_segList=inactive[i][2]    
    print "Active: DqFlag="+active_dqFlag+ " version="+repr(active_version) 
    print " Inactive: DqFlag="+inactive_dqFlag+ " version="+repr(inactive_version)

    valid[i]= active_segList | inactive_segList  
    # valid[i] contains defined segments of the version currently being processed

    if(i==0):
        delta_valid[i]=valid[i]
        # delta_valid[i] contains the defined segments of the current
        # version being processed, but not the one previously processed.
        # Meaning, ie., defined segments defined in version 2 but not version 3, 
        # for active and inactive are sorted from highest to lowest version. 

        DEFINED_SEGS=delta_valid[i]
        # Initialize DEFINED_SEGS, assign defined segments of the first processed version
        # to DEFINED_SEGS

    else:
        delta_valid[i]=valid[i]-DEFINED_SEGS
        DEFINED_SEGS |= delta_valid[i]
        # DEFINED_SEGS combines all the defined segments UP To the version
        # currently being processed


    ACTIVE |= (active_segList & delta_valid[i])
    # ACTIVE combines all the active segments for the version currently being processed.

  INACTIVE=DEFINED_SEGS - ACTIVE # Compute all the inactive segments for the dq flag
                                 # currently being processed.
  return [ACTIVE,INACTIVE]


#####################################################################
# Given the peculiar way they are stored in the database, injection 
# segments requires special handling.
# Version 0 Injections are inserted into the database the
# same way as 'Science' segments. 
# While further versions are inserted as DQ flags. 
# The correct4injections() function adds version 0 to other
# injection versions so that version 99 can be computed correctly.

def correct4injections(inj,active,inactive):
  active = active+[['Injection',0,inj]]
  try:
    inactive = inactive+[['Injection',0,segmentlist([inj.extent()])-inj]]
  except:
    return [segmentlist([]),segmentlist([])]
  return [active,inactive]
#####################################################################
# Parse command line options.
shortop = "c:vh"
longop = [
  "config-file=",
  "verbose",
  "help"
  ]

usage = "Usage: " + sys.argv[0] + """ [OPTIACTIVES]

  -c, --config-file FILE    read configuration from FILE
  -v, --verbose             print debugging information to stdout
  -h, --help                print help message

""" 

configFilePath = None
verbose = 0

try:
  opts, args = getopt.getopt(sys.argv[1:], shortop, longop)
except getopt.GetoptError:
  print >>sys.stderr, "Error parsing command line"
  sys.exit(1)

for o, a in opts:
  if o in ("-c", "--config-file"):
    configFilePath = a
  if o in ("-v", "--verbose"):
    verbose = 1
  if o in ("-h", "--help"):
    print usage
    sys.exit(0)

if not configFilePath:
  print >> sys.stderr, \
    "Configuration file must be specified with --config-file"
  sys.exit(1)

configuration = {
  'output-path' : '/export/ldcg_server/htdocs/segments',
  'run' : 'S5',
  'dbname' : 'seg_cit'
  }

myConfigParser = ConfigParser.ConfigParser()
try:
  myConfigParser.read(configFilePath)
except:
  print >> sys.stderr, "Error: unable to read configuration file : %s"
  sys.exit(1)

for k in configuration.keys():
  try:
    value = myConfigParser.get('segpagegen',k)
  except ConfigParser.NoOptionError:
    print >> sys.stderr, "Error: missing configuration option : %s" % (k)
    sys.exit(1)
  try:
    configuration[k] = eval(value)
  except:
    configuration[k] = value

#####################################################################
# Connect to the database.
if verbose: print "connecting to database " + configuration['dbname']
db = mx.ODBC.DB2.Connect(configuration['dbname'])
curs = db.cursor()

#####################################################################
# Create base name for the output files.
seg_path = os.path.join(configuration['output-path'], configuration['run'])
seg_file = {}

# we query the database up 1600 GMT
midnight = list(time.gmtime())
midnight[3:] = [16,0,0,0,0,0]
midnight = time.mktime(tuple(midnight)) - time.timezone
midnight_gps = gpstime.GpsSecondsFromPyUTC(midnight)
time_str = str(midnight_gps)

#####################################################################
# SQL used to join the segment_definer table to the segment table.
sqlj = "segment,segment_def_map,segment_definer WHERE "
sqlj += "segment.segment_id = segment_def_map.segment_id AND "
sqlj += "segment.creator_db = segment_def_map.segment_cdb AND "
sqlj += "segment_def_map.segment_def_id = segment_definer.segment_def_id AND "
sqlj += "segment_def_map.segment_def_cdb = segment_definer.creator_db "
#####################################################################

# There are 5 interferometers: H1,H2,L1,G1,V1
# All of them have S5 run.
# All of them but V1 have A5 run.
# The purpose of having Variable 'interferometers' is to handle different
# interferometers covered in S5 and A5 runs.
 
if configuration['run']=='A5':
  interferometers = ['H1','H2','G1','L1']
elif configuration['run']=='S5':
  interferometers = ['V1']
#  interferometers = ['H1','H2','G1','L1','V1']

for ifo in interferometers:
  output_dir = os.path.join( seg_path, ifo )
  print output_dir
  
  # Check if directory for the ifo currently being processed exists, 
  # create new directory if not.
  dirname = output_dir
  if not os.path.isdir(output_dir+"/"):
    os.mkdir(output_dir+"/")



#-------------------------------------------------------------------------------#
# Process the Science segments
#-------------------------------------------------------------------------------#
  # Construct name for the science segment dump file.
  seg_file['Science'] = os.path.join( seg_path, ifo, 'science_segments')



#----- Begin: Handle multiple data dump runs that may occur on  the same day-------#  
  # It is a very rare case but does happen that segpagegen can run more 
  # than once a day. Symbolic link would point to a dump file
  # that is currently being writtne into. The purpose of the following 
  # block of code is to prevent users from retrieving data from unfinished
  # dump file.

  # Check if current day's dump file already exists:
  if os.path.isfile(seg_file['Science'] + '.' + time_str  + '.txt'):

     # If yes, unlink the symbolic file
     symlink_name = seg_file['Science'] + '.txt'
     try:
       os.unlink(symlink_name)
     except:
       pass   

     # Check how many bad file(s) for current day already exist(s):
     pattern = os.path.normpath(os.path.join( seg_path, ifo, 'science_segments*bad*'))
     file_num = len(glob.glob(pattern))
     file_num = file_num + 1

     # Rename current day's dump file as a new bad file
     os.rename(seg_file['Science'] + '.' + time_str + '.txt', seg_file['Science'] + \
           '.' + time_str + '.bad.' + str(file_num) +'.txt')
#----- End: Handle multiple data dump runs that may occur on  the same day-------#  



  # Create dump file
  segment_file = open(seg_file['Science'] + '.' + time_str + '.txt', 'w')
  if verbose: print "querying database for ifo %s, Science" % (ifo)
  




  # Construct sql to retrieve version 0 Science segemnts:
  if (ifo == 'V1'):
    sql = "SELECT segment.start_time, segment.end_time, 0 FROM "
    # Virgo Science segments do not have segnum, so take '0' instead.
    sql += sqlj + "AND segment.active = 1 "
    # Version 10 Virgo Science segments are inserted by LSCdqInsert.
    # To retrieve Virgo Science segments, segment.active has to be 1.

  else:
    sql = "SELECT segment.start_time, segment.end_time, segment.segnum FROM "
    sql += sqlj + "AND segment_definer.run = '%s' " % configuration['run']
    sql += "AND segment_definer.version = 0 "

  sql += "AND segment.end_time < %d " % midnight_gps
  sql += "AND segment_definer.ifos = '%s' " % ifo
  sql += "AND segment_definer.name = 'Science' "
  sql += "ORDER BY segment.start_time ASC FOR READ ONLY"
  print sql
  curs.execute(sql)
  sci_result = curs.fetchall()


 
    
  # Coalesce the result and write into its corresponding daily dump file,
  if verbose:
    print "coalescing %d segments for ifo %s, segment type %s and writing into file" % (len(sci_result), ifo, science_name)

  # Group segments into different lists by their segnum:
  sci_segments = {}
  for s in sci_result:
    if(ifo == 'V1'):
      segnum_key=0
    else:
      segnum_key=s[2]
    try:
      sci_segments[segnum_key].append(segment(s[0],s[1]))
    except KeyError:
      sci_segments[segnum_key] = segmentlist()
      sci_segments[segnum_key].append(segment(s[0],s[1]))
  print sci_segments

  # print the header to the corresponding text file
  print >> segment_file, "# %s" % configuration['dbname']
  print >> segment_file, "# %d" % midnight_gps
  print >> segment_file, "# number gps_start_time gps_end_time duration"


  # coalesce the segments in sci_segments and print them out in the order of segnums
  segnums = sci_segments.keys()
  segnums.sort()
  for r in segnums:
    sci_segments[r].coalesce()
    for s in sci_segments[r]:
      print >> segment_file, str(r) + ' ' + str(s[0]) + ' ' + str(s[1]) + \
          ' ' + str(s[1] - s[0])

  # Close segment_file: 
  segment_file.flush()
  segment_file.close()      
          

#---------- update the symbolic links for science segments --------------#
  # science_segments.txt points to current day's data dump file.
  if verbose: print "creating symbolic links"
  symlink_name = seg_file['Science'] + '.txt'
  try:
      os.unlink(symlink_name)
  except:
      pass
  os.symlink(seg_file['Science'] + '.' + time_str + '.txt', symlink_name)
#------------------------------------------------------------------------#





#-------------------------------------------------------------------------------------#
# Process the Injection segments
#-------------------------------------------------------------------------------------#
  # Construct name for injection dump file
  seg_file['Injection'] = os.path.join( seg_path, ifo, 'injection_segments')



#----- Begin: Handle multiple data dump runs that may occur on  the same day-------#  
  # It is a very rare case but does happen that segpagegen can run more 
  # than once a day. Symbolic link would point to a dump file
  # that is currently being writtne into. The purpose of the following 
  # block of code is to prevent users from retrieving data from unfinished
  # dump file.

  # Check if current day's dump file already exists:
  if os.path.isfile(seg_file['Injection'] + '.' + time_str  + '.txt'):

     # If yes, break symbolic link:
     symlink_name = seg_file['Injection'] + '.txt'
     try:
       os.unlink(symlink_name)
     except:
       pass

     # Check how many bad file(s) for current day already exist(s)
     pattern = os.path.normpath(os.path.join( seg_path, ifo, 'injection_segments*bad*'))
     file_num = len(glob.glob(pattern))
     file_num = file_num + 1

     # Rename dump file as a a new bad file
     os.rename(seg_file['Injection'] + '.' + time_str + '.txt', seg_file['Injection'] + \
        '.' + time_str + '.bad.' + str(file_num) +'.txt')
#----- End: Handle multiple data dump runs that may occur on  the same day-------#  


  # Create dump file
  segment_file = open(seg_file['Injection'] + '.' + time_str + '.txt', 'w')


  # Write file head
  print >> segment_file, "# %s" % configuration['dbname']
  print >> segment_file, "# %d" % midnight_gps
  print >> segment_file, "# number gps_start_time gps_end_time duration"

  if verbose: print "querying database for ifo %s, Injection" % (ifo)
  
  # Construct sql to retrieve version 0 injection segments:
  sql = "SELECT segment.start_time, segment.end_time FROM "
  # injection segments do not have segnum, so take 0 instead.

  sql += sqlj + "AND segment.end_time < %d " % midnight_gps
  sql += "AND segment_definer.ifos = '%s' " % ifo
  if (ifo != 'V1'):
    sql += "AND segment_definer.run ='%s' " % configuration['run']
  sql += "AND segment_definer.name = 'Injection' "
  sql += "AND segment_definer.version = 0 "
  sql += "ORDER BY segment.start_time ASC FOR READ ONLY"
  print 'retrieve injection segments for %s %s' % (configuration['run'],ifo)
  print  sql
  curs.execute(sql)
  inj_result = curs.fetchall()

  
  inj_segments = segmentlist()
  for r in inj_result:
    inj_segments.append(segment(r[0],r[1]))
  print inj_segments

  # Coalesce injection segments
  inj_segments.coalesce()
  for i in inj_segments:
  # injection segements do not have segnum, so take 0 instead
    print >> segment_file, '0' + ' ' + str(i[0]) + ' ' + str(i[1]) + \
          ' ' + str(i[1] - i[0])

  # Close the file segment_file: 
  segment_file.flush()
  segment_file.close()


  # update the symbolic links for injection_segments.txt so that
  # injection_segments.txt can point to the latest dq segments
  if verbose: print "creating symbolic links"
  symlink_name = seg_file['Injection'] + '.txt'
  try:
      os.unlink(symlink_name)
  except:
      pass
  os.symlink(seg_file['Injection'] + '.' + time_str + '.txt', symlink_name)





#----------------------------------------------------------------------#
# Process the DQ segments
#----------------------------------------------------------------------#
  ACTIVE_DQ_SEGS=[]
  INACTIVE_DQ_SEGS=[]

  # Construct name for dq segment dump file
  seg_file['DataQual'] = os.path.join( seg_path, ifo, 'dq_segments')



#----- Begin: Handle multiple data dump runs that may occur on  the same day-------#  
  # It is a very rare case but does happen that segpagegen can run more 
  # than once a day. Symbolic link would point to a dump file
  # that is currently being writtne into. The purpose of the following 
  # block of code is to prevent users from retrieving data from unfinished
  # dump file.

  # Check if current day's dump file already exists:
  if os.path.isfile(seg_file['DataQual'] + '.' + time_str  + '.txt'):
     # If yes, break the symbolick link
     symlink_name = seg_file['DataQual'] + '.txt'
     try:
       os.unlink(symlink_name)
     except:
       pass

     # Check how many bad file(s) for current day already exist(s):
     pattern = os.path.normpath(os.path.join( seg_path, ifo, 'dq_segments*bad*'))
     file_num = len(glob.glob(pattern))
     file_num = file_num + 1

     # Rename the first created dump file as a new bad file
     os.rename(seg_file['DataQual'] + '.' + time_str + '.txt', seg_file['DataQual'] + \
           '.' + time_str + '.bad.' + str(file_num) +'.txt')

  # Create current day's dump file
  segment_file = open(seg_file['DataQual'] + '.' + time_str + '.txt', 'w')

  
  # Print file head:
  print >> segment_file, "# %s" % configuration['dbname']
  print >> segment_file, "# %d" % midnight_gps
  print >> segment_file, "# name version gps_start_time gps_end_time active"
 
  # Get the list of names of non-statevec data quality segments:
  if verbose: print "fetching list of data quality segments"
  sql = "SELECT distinct(name) FROM segment_definer WHERE "
  if ifo == 'V1':
     sql += "run = 'VSR1' And ifos = '%s' AND state_vec_major is NULL " % ifo 
  else:
     sql += "run = '%s' AND ifos = '%s' AND state_vec_major is NULL " \
      % (configuration['run'], ifo)
  # Exclude version 10 science segments from dq_segment dump
  sql += "AND name != 'Science' "
  sql += " ORDER BY name asc FOR READ ONLY "

  print sql
  curs.execute(sql)
  names = curs.fetchall()
  
  for name in names:
    n = name[0]
  
    # Get the list of corresponding versions:
    sql = "SELECT distinct(version) FROM segment_definer WHERE  "
    if ifo == 'V1':
       sql += "run = 'VSR1' AND "
    else:
       sql += "run = '%s' AND " % configuration['run']
    sql += "ifos = '%s' AND " % ifo
    sql += "name ='%s' AND " % n
    sql += "state_vec_major is NULL "
    sql += "ORDER BY version desc FOR READ ONLY "

    print sql
    curs.execute(sql)
    versions = curs.fetchall()
    print 'print versions:',versions
    
    # Get the list of corresponding segemnts:
    for version in versions:
      v = version[0]
      sql =  "SELECT segment.start_time, segment.end_time, segment.active FROM "
      sql += sqlj + "AND segment.end_time < %d " % midnight_gps
      sql += "AND segment_definer.ifos = '%s' " % ifo
      if (ifo=='V1'):
          sql += "AND segment_definer.run = 'VSR1'"
      else:
          sql += "AND segment_definer.run = '%s' " % configuration['run']
      sql += "AND segment_definer.name = '%s' " % n
      sql += "AND segment_definer.version = %d " % v
      sql += "AND state_vec_major is NULL "
      sql += "ORDER BY segment.start_time asc FOR READ ONLY "
      
      print sql
      curs.execute(sql)
      dq_result = curs.fetchall()
      print 'print dq_result:',dq_result
      

      #Coalesce DQ segments:
      on_dq_segs=segmentlist()
      off_dq_segs=segmentlist()

      if verbose:
        print "coalescing %d segments for %s,%s,%d and writing to file" \
        % (len(dq_result), ifo, n, v)
      for dq in dq_result:
        if dq[2] == 0:
          off_dq_segs.append(segment(dq[0],dq[1]))
        elif dq[2] == 1:
          on_dq_segs.append(segment(dq[0],dq[1]))

      on_dq_segs.coalesce()
      off_dq_segs.coalesce()

      ACTIVE_DQ_SEGS.append([n,v,on_dq_segs])
      INACTIVE_DQ_SEGS.append([n,v,off_dq_segs])

      for s in on_dq_segs:
        print >> segment_file, "%s %s %d %d 1" % (n, v, s[0], s[1])
      for s in off_dq_segs:
        print >> segment_file, "%s %s %d %d 0" % (n, v, s[0], s[1])

    # correct injections and develop current version for DQ segments
    if ( n is 'Injection'):
      [ACTIVE_DQ_SEGS, INACTIVE_DQ_SEGS] = correct4injections(inj_segments, ACTIVE_DQ_SEGS, INACTIVE_DQ_SEGS)
      sys.stdout.flush()
    [ACTIVE, INACTIVE] = latest_version(ACTIVE_DQ_SEGS, INACTIVE_DQ_SEGS)
    for s in ACTIVE:
      print >> segment_file, "%s 99 %d %d 1" % (n, s[0], s[1])
    for s in INACTIVE:
      print >> segment_file, "%s 99 %d %d 0" % (n, s[0], s[1])
    ACTIVE_DQ_SEGS=[]
    INACTIVE_DQ_SEGS=[]

    # Close file segment_file
    segment_file.flush()
    sys.stdout.flush()
      
  # update the symbolic links for dq_segments.txt so that 
  # dq_segments.txt can point to the latest dq segments
  if verbose: print "creating symbolic links"
  symlink_name = seg_file['DataQual'] + '.txt'
  try:
    os.unlink(symlink_name)
  except:
    pass
  os.symlink(seg_file['DataQual'] + '.' + time_str + '.txt', symlink_name)

###########################################################################
# Close the connection to the database and exit
if verbose: print "closing connection to the database and exiting"
curs.close()
db.close()
sys.exit(0)
