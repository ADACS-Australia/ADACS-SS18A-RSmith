#!/usr/bin/python
"""
segpagegen creates three web pages that can be parsed by segwizard to obtain
information from the segment database.

$Id$
"""

import os
import sys
import getopt
import time
import types
import ConfigParser
import mx.ODBC.DB2
from glue import gpstime

#####################################################################
# Define a couple of classes that we need for the segments based
# on the glue segments module. We can't use glue.segments directly
# as we need the extra field for the segment number.
class sciseg(tuple):
  """
  A science segment is a tuple that contains (start, end, segnum).
  """
  def __new__(cls, *args):
    if len(args) == 1:
      args = args[0]
    if len(args) != 3:
      raise TypeError, "__new__() takes 4 arguments or 2 arguments " \
        + "when the second is a 3-element container type"
    if args[0] <= args[1]:
      return tuple.__new__(cls, args)
    else:
      return tuple.__new__(cls, args[1], args[0], args[2])

  def __str__(self):
    """
    Return the segment in segwizard format.
    """
    return str(self[2]) + ' ' + str(self[0]) + ' ' + str(self[1]) + ' ' + \
      str(self[1] - self[0])

  def __or__(self,other):
    """
    Return the segment that is the union of the given segments, or
    None if the result cannot be represented as a single segment.
    """
    if not self.continuous(other):
      return None
    return sciseg(min(self[0], other[0]), max(self[1], other[1]), self[2])

  def continuous(self, other):
    """
    Return True if self and other are not disjoint and share the same
    science segment number.
    """
    return (self[1] >= other[0]) and (self[0] <= other[1]) \
      and (self[2] == other[2])

class sciseglist(list):
  """
  The sciseglist defines a list of scisegs, and is an extension of the
  built in list class. This class provides an extra method to coalesce
  pre-sorted lists.
  """
  def coalesce(self):
    """
    This will only work if the list has already been sorted by time,
    but we assume that DB2 has taken care of this when returning the
    results of the query.
    """
    try:
      for i in range(len(self) - 1):
        while self[i].continuous(self[i+1]):
          self[i:i+2] = [ self[i] | self[i+1] ]
    except IndexError:
      pass
    return self

#####################################################################
# Parse command line options.
shortop = "c:vh"
longop = [
  "config-file=",
  "verbose",
  "help"
  ]

usage = "Usage: " + sys.argv[0] + """ [OPTIONS]

  -c, --config-file FILE    read configuration from FILE
  -v, --verbose             print debugging information to stdout
  -h, --help                print help message

""" 

configFilePath = None
verbose = 0

try:
  opts, args = getopt.getopt(sys.argv[1:], shortop, longop)
except getopt.GetoptError:
  print >>sys.stderr, "Error parsing command line"
  sys.exit(1)

for o, a in opts:
  if o in ("-c", "--config-file"):
    configFilePath = a
  if o in ("-v", "--verbose"):
    verbose = 1
  if o in ("-h", "--help"):
    print usage
    sys.exit(0)

if not configFilePath:
  print >> sys.stderr, \
    "Configuration file must be specified with --config-file"
  sys.exit(1)

configuration = {
  'output-path' : '/export/ldcg_server/htdocs/segments',
  'run' : 'S5',
  'dbname' : 'seg_cit'
  }

myConfigParser = ConfigParser.ConfigParser()
try:
  myConfigParser.read(configFilePath)
except:
  print >> sys.stderr, "Error: unable to read configuration file : %s"
  sys.exit(1)

for k in configuration.keys():
  try:
    value = myConfigParser.get('segpagegen',k)
  except ConfigParser.NoOptionError:
    print >> sys.stderr, "Error: missing configuration option : %s" % (k)
    sys.exit(1)
  try:
    configuration[k] = eval(value)
  except:
    configuration[k] = value

#####################################################################
# Connect to the database.
if verbose: print "connecting to database " + configuration['dbname']
db = mx.ODBC.DB2.Connect(configuration['dbname'])
curs = db.cursor()

#####################################################################
# Create the base name of the output files.
seg_path = os.path.join(configuration['output-path'], configuration['run'])
seg_file = {}

# we query the database up 1600 GMT
midnight = list(time.gmtime())
midnight[3:] = [16,0,0,0,0,0]
midnight = time.mktime(tuple(midnight)) - time.timezone
midnight_gps = gpstime.GpsSecondsFromPyUTC(midnight)
time_str = str(midnight_gps)

#####################################################################
# SQL used to join the segment_definer table to the segment table.
sqlj = "segment,segment_def_map,segment_definer WHERE "
sqlj += "segment.segment_id = segment_def_map.segment_id AND "
sqlj += "segment.creator_db = segment_def_map.segment_cdb AND "
sqlj += "segment_def_map.segment_def_id = segment_definer.segment_def_id AND "
sqlj += "segment_def_map.segment_def_cdb = segment_definer.creator_db "

#####################################################################
# Loop over interferometers to get the various segments.
for ifo in ['H1', 'H2', 'L1']:
  # create the names of the segment files
  seg_file['Science'] = os.path.join( seg_path, ifo, 'science_segments')
  seg_file['Injection'] = os.path.join( seg_path, ifo, 'injection_segments')
  seg_file['DataQual'] = os.path.join( seg_path, ifo, 'dq_segments')

  # get the segments which derive from the interferometer state vector
  for segtype in ['Science', 'Injection']:
    # open the output files
    seg_fh = open(seg_file[segtype] + '.' + time_str + '.txt', 'w')

    # construct the sql to perform the query
    if verbose: print "querying database for ifo %s, state %s" % (ifo, segtype)
    if segtype is 'Science':
      sql = "SELECT segment.start_time, segment.end_time, segment.segnum FROM "
    else:
      sql = "SELECT segment.start_time, segment.end_time, 0 FROM "
    sql += sqlj + "AND segment.end_time < %d " % midnight_gps
    sql += "AND segment_definer.run = '%s' " % configuration['run']
    sql += "AND segment_definer.ifos = '%s' " % ifo
    sql += "AND segment_definer.name = '%s' " % segtype
    sql += "ORDER BY segment.start_time ASC FOR READ ONLY"
    curs.execute(sql)
    result = curs.fetchall()

    # coalesce the result and write to file
    if verbose: 
      print "coalescing %d segments for ifo %s, state %s and writing to file" \
        % (len(result), ifo, segtype)
    ret_segs = sciseglist()
    for r in result:
      ret_segs.append(sciseg(r[0],r[1],r[2]))
    ret_segs.coalesce()

    # write the segments to the output file
    print >> seg_fh, "# %s" % configuration['dbname']
    print >> seg_fh, "# %d" % midnight_gps
    print >> seg_fh, "# number gps_start_time gps_end_time duration"
    for s in ret_segs:
      print >> seg_fh, str(s)
    seg_fh.close()

  # get all the data quality segments into a single file
  seg_fh = open(seg_file['DataQual'] + '.' + time_str + '.txt', 'w')

  # get the a list of non-statevec data quality quality segments
  if verbose: print "fetching list of data quality segments"
  sql = "SELECT name, version FROM segment_definer WHERE "
  sql += "run = '%s' AND ifos = '%s' AND state_vec_major is NULL " \
    % (configuration['run'], ifo)
  sql += "FOR READ ONLY"
  curs.execute(sql)
  dq_types = curs.fetchall()
  if verbose: print "got %d data quality segments" % len(dq_types)

  # get each data quality flag, coalesce the list and write to a file
  print >> seg_fh, "# %s" % configuration['dbname']
  print >> seg_fh, "# %d" % midnight_gps
  print >> seg_fh, "# name version gps_start_time gps_end_time active"
  for dq in dq_types:
    if verbose:
      print "querying database for %s,%s,%d" % (ifo, dq[0], dq[1])
    sql =  "SELECT segment.start_time, segment.end_time, segment.active FROM "
    sql += sqlj + "AND segment.end_time < %d " % midnight_gps
    sql += "AND segment_definer.run = '%s' AND " % configuration['run']
    sql += "segment_definer.ifos = '%s' AND " % ifo
    sql += "segment_definer.name = '%s' AND  " % dq[0]
    sql += "segment_definer.version = %d " % dq[1]
    sql += "ORDER BY segment.start_time asc FOR READ ONLY"
    curs.execute(sql)
    result = curs.fetchall()
    ret_segs = sciseglist()

    if verbose: 
      print "coalescing %d segments for %s,%s,%d and writing to file" \
        % (len(result), ifo, dq[0], dq[1])
    for r in result:
      ret_segs.append(sciseg(r[0],r[1],r[2]))
    ret_segs.coalesce()
  
    for s in ret_segs:
      print >> seg_fh, "%s %d %d %d %d" % (dq[0], dq[1], s[0], s[1], s[2])

  seg_fh.close()

  # update the symbolic links
  if verbose: print "creating symbolic links"
  for k in seg_file.keys():
    symlink_name = seg_file[k] + '.txt'
    try:
      os.unlink(symlink_name)
    except:
      pass
    os.symlink(seg_file[k] + '.' + time_str + '.txt', symlink_name)

#####################################################################
# Close the connection to the database and exit.
if verbose: print "closing connection to the database and exiting"
curs.close()
db.close()
sys.exit(0)
