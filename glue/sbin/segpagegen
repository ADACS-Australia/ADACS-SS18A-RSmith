#!/usr/bin/python
"""
segpagegen creates three web pages that can be parsed by segwizard to obtain
information from the segment database.

$Id$
"""

import os
import sys
import getopt
import time
import types
import ConfigParser
import mx.ODBC.DB2
from glue import segments

#####################################################################
# parse command line options
shortop = "c:vh"
longop = [
  "config-file=",
  "verbose",
  "help"
  ]

usage = "Usage: " + sys.argv[0] + """ [OPTIONS]

  -c, --config-file FILE    read configuration from FILE
  -v, --verbose             print debugging information to stdout
  -h, --help                print help message

""" 

configFilePath = None
verbose = 0

try:
  opts, args = getopt.getopt(sys.argv[1:], shortop, longop)
except getopt.GetoptError:
  print >>sys.stderr, "Error parsing command line"
  sys.exit(1)

for o, a in opts:
  if o in ("-c", "--config-file"):
    configFilePath = a
  if o in ("-v", "--verbose"):
    verbose = 1
  if o in ("-h", "--help"):
    print usage
    sys.exit(0)

if not configFilePath:
  print >> sys.stderr, \
    "Configuration file must be specified with --config-file"
  sys.exit(1)

configuration = {
  'output-path' : '/export/ldcg_server/htdocs/segments',
  'run' : 'S5',
  'dbname' : 'seg_cit'
  }

myConfigParser = ConfigParser.ConfigParser()
try:
  myConfigParser.read(configFilePath)
except:
  print >> sys.stderr, "Error: unable to read configuration file : %s"
  sys.exit(1)

for k in configuration.keys():
  try:
    value = myConfigParser.get('segpagegen',k)
  except ConfigParser.NoOptionError:
    print >> sys.stderr, "Error: missing configuration option : %s" % (k)
    sys.exit(1)
  try:
    configuration[k] = eval(value)
  except:
    configuration[k] = value

#####################################################################
# connect to the database
if verbose: print "connecting to database " + configuration['dbname']
db = mx.ODBC.DB2.Connect(configuration['dbname'])
curs = db.cursor()

#####################################################################
# create the base name of the output files
seg_path = os.path.join(configuration['output-path'], configuration['run'])
seg_file = {}

# we query the database up to 0000 PST which is 0800 GMT
midnight = list(time.gmtime())
midnight[3:] = [8,0,0,0,0]
time_str = ''.join(map(str,midnight))

#####################################################################
# sql used to join the segment_definer table to the segment table
sqlj = "segment,segment_def_map,segment_definer WHERE "
sqlj += "segment.segment_id = segment_def_map.segment_id AND "
sqlj += "segment.creator_db = segment_def_map.segment_cdb AND "
sqlj += "segment_def_map.segment_def_id = segment_definer.segment_def_id AND "
sqlj += "segment_def_map.segment_def_cdb = segment_definer.creator_db "

#####################################################################
# loop over interferometers to get the various segments
for ifo in ['H1', 'H2', 'L1']:
  # create the names of the segment files
  seg_file['Science'] = os.path.join( seg_path, ifo, 'science_segments.txt')
  seg_file['Injection'] = os.path.join( seg_path, ifo, 'injection_segments.txt')
  seg_file['DataQual'] = os.path.join( seg_path, ifo, 'dq_segments.txt')

  # get the segments which derive from the interferometer state vector
  for segtype in ['Science', 'Injection']:
    # open the output files
    seg_fh = open(seg_file[segtype] + '.' + time_str, 'w')

    # construct the sql to perform the query
    if verbose: print "querying database for ifo %s, state %s" % (ifo, segtype)
    if segtype is 'Science':
      sql = "SELECT segment.start_time, segment.end_time, segment.segnum FROM "
    else:
      sql = "SELECT segment.start_time, segment.end_time, 0 FROM "
    sql += sqlj + "AND segment_definer.run = '%s' " % configuration['run']
    sql += "AND segment_definer.ifos = '%s' " % ifo
    sql += "AND segment_definer.name = '%s' " % segtype
    sql += "ORDER BY segment.start_time ASC FOR READ ONLY"
    curs.execute(sql)
    result = curs.fetchall()

    # coalesce the result and write to file
    if verbose: 
      print "coalescing %d segments for ifo %s, state %s and writing to file" \
        % (len(result), ifo, segtype)
    ret_segs = segments.segmentlist()
    for r in result:
      ret_segs.append(segments.segment(r[0],r[1]))
    ret_segs.coalesce()

    # write the segments to the output file
    print >> seg_fh, "# %s" % configuration['dbname']
    print >> seg_fh, "# %s" % time_str
    print >> seg_fh, "# start_time end_time"
    for s in ret_segs:
      print >> seg_fh, "%d %d %d" % (s[0], s[1], s[1] - s[0])
    seg_fh.close()

  # get all the data quality segments into a single file
  seg_fh = open(seg_file['DataQual'] + '.' + time_str, 'w')

  # get the a list of non-statevec data quality quality segments
  if verbose: print "fetching list of data quality segments"
  sql = "SELECT name, version FROM segment_definer WHERE "
  sql += "run = '%s' AND ifos = '%s' AND state_vec_major is NULL " \
    % (configuration['run'], ifo)
  sql += "FOR READ ONLY"
  curs.execute(sql)
  dq_types = curs.fetchall()
  if verbose: print "got %d data quality segments" % len(dq_types)

  # get each data quality flag, coalesce the list and write to a file
  print >> seg_fh, "# %s" % configuration['dbname']
  print >> seg_fh, "# %s" % time_str
  print >> seg_fh, "# name version start_time end_time active"
  for dq in dq_types:
    if verbose:
      print "querying database for %s,%s,%d" % (ifo, dq[0], dq[1])
    sql =  "SELECT segment.start_time, segment.end_time, segment.active FROM "
    sql += sqlj
    sql += "AND segment_definer.run = '%s' AND " % configuration['run']
    sql += "segment_definer.ifos = '%s' AND " % ifo
    sql += "segment_definer.name = '%s' AND  " % dq[0]
    sql += "segment_definer.version = %d AND " % dq[1]
    sql += "segment.active = 1 "
    sql += "ORDER BY segment.start_time asc FOR READ ONLY"
    curs.execute(sql)
    result = curs.fetchall()
    ret_segs = segments.segmentlist()

    if verbose: 
      print "coalescing %d segments for %s,%s,%d and writing to file" \
        % (len(result), ifo, dq[0], dq[1])
    for r in result:
      ret_segs.append(segments.segment(r[0],r[1]))
    ret_segs.coalesce()
  
    for s in ret_segs:
      print >> seg_fh, "%s %d %d %d" % (dq[0], dq[1], s[0], s[1])

  seg_fh.close()

  # update the symbolic links
  if verbose: print "creating symbolic links"
  for k in seg_file.keys():
    os.symlink(seg_file[k] + '.' + time_str, seg_file[k])

#####################################################################
# close the connection to the database and exit
if verbose: print "closing connection to the database and exiting"
curs.close()
db.close()
sys.exit(0)
