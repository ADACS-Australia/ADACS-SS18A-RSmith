#!/usr/bin/python
"""
segpagegen creates three web pages that can be parsed by segwizard to obtain
information from the segment database.

$Id$
"""

import os
import sys
import getopt
import time
import types
import ConfigParser
import mx.ODBC.DB2
from glue import gpstime
from glue.__segments import *
from glue.segments import segmentlist

#####################################################################
# Parse command line options.
shortop = "c:vh"
longop = [
  "config-file=",
  "verbose",
  "help"
  ]

usage = "Usage: " + sys.argv[0] + """ [OPTIONS]

  -c, --config-file FILE    read configuration from FILE
  -v, --verbose             print debugging information to stdout
  -h, --help                print help message

""" 

configFilePath = None
verbose = 0

try:
  opts, args = getopt.getopt(sys.argv[1:], shortop, longop)
except getopt.GetoptError:
  print >>sys.stderr, "Error parsing command line"
  sys.exit(1)

for o, a in opts:
  if o in ("-c", "--config-file"):
    configFilePath = a
  if o in ("-v", "--verbose"):
    verbose = 1
  if o in ("-h", "--help"):
    print usage
    sys.exit(0)

if not configFilePath:
  print >> sys.stderr, \
    "Configuration file must be specified with --config-file"
  sys.exit(1)

configuration = {
  'output-path' : '/export/ldcg_server/htdocs/segments',
  'run' : 'S5',
  'dbname' : 'seg_cit'
  }

myConfigParser = ConfigParser.ConfigParser()
try:
  myConfigParser.read(configFilePath)
except:
  print >> sys.stderr, "Error: unable to read configuration file : %s"
  sys.exit(1)

for k in configuration.keys():
  try:
    value = myConfigParser.get('segpagegen',k)
  except ConfigParser.NoOptionError:
    print >> sys.stderr, "Error: missing configuration option : %s" % (k)
    sys.exit(1)
  try:
    configuration[k] = eval(value)
  except:
    configuration[k] = value

#####################################################################
# Connect to the database.
if verbose: print "connecting to database " + configuration['dbname']
db = mx.ODBC.DB2.Connect(configuration['dbname'])
curs = db.cursor()

#####################################################################
# Create the base name of the output files.
seg_path = os.path.join(configuration['output-path'], configuration['run'])
seg_file = {}

# we query the database up 1600 GMT
midnight = list(time.gmtime())
midnight[3:] = [16,0,0,0,0,0]
midnight = time.mktime(tuple(midnight)) - time.timezone
midnight_gps = gpstime.GpsSecondsFromPyUTC(midnight)
time_str = str(midnight_gps)

#####################################################################
# SQL used to join the segment_definer table to the segment table.
sqlj = "segment,segment_def_map,segment_definer WHERE "
sqlj += "segment.segment_id = segment_def_map.segment_id AND "
sqlj += "segment.creator_db = segment_def_map.segment_cdb AND "
sqlj += "segment_def_map.segment_def_id = segment_definer.segment_def_id AND "
sqlj += "segment_def_map.segment_def_cdb = segment_definer.creator_db "

#####################################################################
# Loop over interferometers to get the various segments.
for ifo in ['H1', 'H2', 'L1']:
  # create the names of the segment files
  seg_file['Science'] = os.path.join( seg_path, ifo, 'science_segments')
  seg_file['Injection'] = os.path.join( seg_path, ifo, 'injection_segments')
  seg_file['DataQual'] = os.path.join( seg_path, ifo, 'dq_segments')

  # get the segments which derive from the interferometer state vector
  for segtype in ['Science', 'Injection']:
    # open the output files
    seg_fh = open(seg_file[segtype] + '.' + time_str + '.txt', 'w')

    # construct the sql to perform the query
    if verbose: print "querying database for ifo %s, state %s" % (ifo, segtype)
    if segtype is 'Science':
      sql = "SELECT segment.start_time, segment.end_time, segment.segnum FROM "
    else:
      sql = "SELECT segment.start_time, segment.end_time, 0 FROM "
    sql += sqlj + "AND segment.end_time < %d " % midnight_gps
    sql += "AND segment_definer.run = '%s' " % configuration['run']
    sql += "AND segment_definer.ifos = '%s' " % ifo
    sql += "AND segment_definer.name = '%s' " % segtype
    sql += "ORDER BY segment.start_time ASC FOR READ ONLY"
    curs.execute(sql)
    result = curs.fetchall()

    # coalesce the result and write to file
    if verbose: 
      print "coalescing %d segments for ifo %s, state %s and writing to file" \
        % (len(result), ifo, segtype)

    # put each segment number into a different segment list
    ret_segs_dict = {}
    for r in result:
      try:
        ret_segs_dict[r[2]].append(segment(r[0],r[1]))
      except KeyError:
        ret_segs_dict[r[2]] = segmentlist()
        ret_segs_dict[r[2]].append(segment(r[0],r[1]))

    # print the header to the file
    print >> seg_fh, "# %s" % configuration['dbname']
    print >> seg_fh, "# %d" % midnight_gps
    print >> seg_fh, "# number gps_start_time gps_end_time duration"

    # coalesce the segments and print them out in order of seg number
    segnums = ret_segs_dict.keys()
    segnums.sort()
    for r in segnums:
      ret_segs_dict[r].coalesce()
      for s in ret_segs_dict[r]:
        print >> seg_fh, str(r) + ' ' + str(s[0]) + ' ' + str(s[1]) + \
          ' ' + str(s[1] - s[0])

    # close the file
    seg_fh.close()

  # get all the data quality segments into a single file
  seg_fh = open(seg_file['DataQual'] + '.' + time_str + '.txt', 'w')

  # get the a list of non-statevec data quality quality segments
  if verbose: print "fetching list of data quality segments"
  sql = "SELECT name, version FROM segment_definer WHERE "
  sql += "run = '%s' AND ifos = '%s' AND state_vec_major is NULL " \
    % (configuration['run'], ifo)
  sql += "FOR READ ONLY"
  curs.execute(sql)
  dq_types = curs.fetchall()
  if verbose: print "got %d data quality segments" % len(dq_types)

  # get each data quality flag, coalesce the list and write to a file
  print >> seg_fh, "# %s" % configuration['dbname']
  print >> seg_fh, "# %d" % midnight_gps
  print >> seg_fh, "# name version gps_start_time gps_end_time active"
  for dq in dq_types:
    if verbose:
      print "querying database for %s,%s,%d" % (ifo, dq[0], dq[1])
    sql =  "SELECT segment.start_time, segment.end_time, segment.active FROM "
    sql += sqlj + "AND segment.end_time < %d " % midnight_gps
    sql += "AND segment_definer.run = '%s' AND " % configuration['run']
    sql += "segment_definer.ifos = '%s' AND " % ifo
    sql += "segment_definer.name = '%s' AND  " % dq[0]
    sql += "segment_definer.version = %d " % dq[1]
    sql += "ORDER BY segment.start_time asc FOR READ ONLY"
    curs.execute(sql)
    result = curs.fetchall()

    on_segs = segmentlist()
    off_segs = segmentlist()

    if verbose: 
      print "coalescing %d segments for %s,%s,%d and writing to file" \
        % (len(result), ifo, dq[0], dq[1])
    for r in result:
      if r[2] == 0:
        off_segs.append(segment(r[0],r[1]))
      elif r[2] == 1:
        on_segs.append(segment(r[0],r[1]))

    on_segs.coalesce()
    off_segs.coalesce()
  
    for s in on_segs:
      print >> seg_fh, "%s %d %d %d 1" % (dq[0], dq[1], s[0], s[1])

    for s in off_segs:
      print >> seg_fh, "%s %d %d %d 0" % (dq[0], dq[1], s[0], s[1])

  seg_fh.close()

  # update the symbolic links
  if verbose: print "creating symbolic links"
  for k in seg_file.keys():
    symlink_name = seg_file[k] + '.txt'
    try:
      os.unlink(symlink_name)
    except:
      pass
    os.symlink(seg_file[k] + '.' + time_str + '.txt', symlink_name)

#####################################################################
# Close the connection to the database and exit.
if verbose: print "closing connection to the database and exiting"
curs.close()
db.close()
sys.exit(0)
