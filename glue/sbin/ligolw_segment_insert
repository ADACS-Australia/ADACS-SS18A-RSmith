#!/usr/bin/env python

###################################################################
import os
import socket
import pwd
import re
import time
import sys
import getopt
import commands
import exceptions

try:
  import pyRXP
except ImportError, e:
  print >> sys.stderr, """
Error: unable to import the pyRXP module.

You must have pyRXP installed and in your PYTHONPATH to run %s.

%s
""" %(sys.argv[0], e)

try:
  from glue import gpstime
  from glue import ldbd
  from glue import LDBDClient
  from glue import gsiserverutils
  from glue import segments
  from glue import segmentsUtils
except ImportError, e:
  print >> sys.stderr, """
Error: unable to import modules from glue.

Check that glue is correctly installed and in your PYTHONPATH.

%s
""" % e
  sys.exit(1)
##################################################################
__author__ = "Ping Wei <piwei@physics.syr.edu>"
__date__ = "$Date$"[7:-2]
__version__ ="$Revision$"[11:-2]
__src__ = "$Source$"[9:-2]
##################################################################
class ligolw_dqInsertException(exceptions.Exception):
  """
  Class representing exceptions within the ligolw_dqInsert class.
  """
  def __init__(self, args=None):
    """
    Initialize an instance.

    @param args: 

    @return: Instance of class ligolw_dqInsertException
    """
    self.args = args
###################################################################
def usage():
  """
  Print a help message and a description of the command line args.
  """
  
  msg = """
Usage: %s [OPTIONS]

  -s, --server HOST:PORT   connect to ldbd on HOST:PORT (default port 30020)
  -j, --identity SUBJECT   the subject of the servers service certififcate

  -A, --append             add segments to an existing data quality flag

  -i, --ifos IFOS          the interferometers to which this flag applies
  -n, --name NAME          the name of the data quality flag (e.g. DUST)
  -v, --version VERS       the numeric version of this data quality flag

  -e, --explain EXPLN      a string explaining WHAT this DQ flag means
  -c, --comment COMM       a string explaining WHY this DQ flag was inserted

  -g, --gps-start-time T1  start of interval checked for this flag
  -G, --gps-end-time T2    end of interval checked for this flag

  -S, --segment-file FILE  a file containing the gps start and stop times

  -p, --ping               ping the server
  -h, --help               print this message 
""" % sys.argv[0]
  print msg



###################################################################
#           Define command line arguments
###################################################################
shortop = "s:j:Ain:v:e:c:g:G:S:ph"
longop = [
"server=",
"identity=",
"append",
"ifos=",
"name=",
"version=",
"explain=",
"comment=",
"gps-start-time=",
"gps-end-time=",
"segment-file=",
"ping",
"help"
]


# parse the command line arguments
try:
  opts, args = getopt.getopt(sys.argv[1:], shortop, longop)
except getopt.GetoptError:
  usage()
  sys.exit(1)

hostPortString = None
port = 30020
identity = None
ifos = None
name = None
version = None
expln = None
comment = None
segfile = None
starttime = None
endtime = None
append = 0
ping = None

# environment variables override defaults but not 
# command line options
try:
  hostPortString = os.environ['LDBD_SERVER']
except:
  pass


for o, a in opts:
  if o in ("-h", "--help"):
    usage()
    sys.exit(0)
  elif o in ("-p", "--ping"):
    ping = 1
  elif o in ("-s", "--server"):
    hostPortString = a
  elif o in ("-j", "--identity"):
    identity = a
  elif o in ("-A", "--append"):
    append = 1
  elif o in ("-i", "--ifos"):
    ifos = a
  elif o in ("-n", "--name"):
    name = a
  elif o in ("-v", "--version"):
    version = int(a)
  elif o in ("-e", "--explain"):
    expln = a
  elif o in ("-c", "--comment"):
    comment = a
  elif o in ("-g", "--gps-start-time"):
    starttime = int(a)
  elif o in ("-G", "--gps-end-time"):
    endtime = int(a)
  elif o in ("-S", "--segment-file"):
    segfile = a


# determine server and port
if hostPortString:
  if hostPortString.find(':') < 0:
    # no port specified
    host = hostPortString
  else:
    # server and port specified
    host, portString = hostPortString.split(':')
    port = int(portString)

  # used the standard ldbd server service certificate
  if not identity:
    identity = "/DC=org/DC=doegrids/OU=Services/CN=ldbd/%s" % host

#-----------------------------------------------------------------------#
# make sure all neccessary command line arguments are given
fail = 0
errmsg = ""
if not ifos:
  errmsg += "Error: --ifos must be specified\n"
if not name:
  errmsg += "Error: --name must be specified\n"
if not version:
  errmsg += "Error: --version must be specified\n"
if not expln and not append:
  errmsg += "Error: --explain must be specified\n"
if not comment:
  errmsg += "Error: --comment must be specified\n"
if not segfile:
  errmsg += "Error: --segment-file must be specified\n"
if not starttime:
  errmsg += "Error: --gps-start-time must be specified\n"
if not endtime:
  errmsg += "Error: --gps-end-time must be specified\n"

if len(errmsg) and not ping:
  print >> sys.stderr, errmsg
  print >> sys.stderr, "Run\n    %s --help\nfor more information." % sys.argv[0]
  sys.exit(1)

########################################################################
def dtd_uri_callback(uri):
  if uri in ['http://www.ldas-sw.ligo.caltech.edu/doc/ligolwAPI/html/ligolw_dtd.txt',
    'http://ldas-sw.ligo.caltech.edu/doc/ligolwAPI/html/ligolw_dtd.txt']:
    # if the XML file contains a http pointer to the ligolw DTD at CIT then
    # return a local copy to avoid any network problems
    return 'file://localhost' + os.path.join( os.environ["GLUE_LOCATION"],
      'etc/ligolw_dtd.txt' )
  else:
    # otherwise just use the uri in the file
    return uri

#Create an xml parser, a ligo_lw document parser, and the document
xmlparser = pyRXP.Parser()
lwtparser = ldbd.LIGOLwParser()
segment_md = ldbd.LIGOMetadata(xmlparser,lwtparser)

#----------------------------------------------------------------------#
# Handle PING before constructing local tables
if ping:
  # ping the server and print the response
  print myClient.ping()
  
########################################################################
# Construct local tables need to be filled in
########################################################################
# create the elements in the process table that need to be filled in
process_cols = {
  "process_id" : "ilwd:char",
  "program" : "lstring",
  "version" : "lstring",
  "cvs_repository" : "lstring",
  "cvs_entry_time" : "int_4s",
  "is_online" : "int_4s",
  "node" : "lstring",
  "username" : "lstring",
  "unix_procid" : "int_4s",
  "start_time": "int_4s",
  "end_time": "int_4s",
  "ifos" : "lstring",
  "comment" : "lstring",
}

process_ocols = [
  "process_id",
  "program",
  "version",
  "cvs_repository",
  "cvs_entry_time",
  "is_online",
  "node",
  "username",
  "unix_procid",
  "start_time",
  "end_time",
  "ifos",
  "comment"
]

process_stream = [(
  "process:process_id:0",
  os.path.basename(sys.argv[0]), 
  __version__, 
  __src__,
  __date__,
  0,
  socket.gethostname(),
  pwd.getpwuid(os.geteuid())[0],
  os.getpid(),
  gpstime.GpsSecondsFromPyUTC(time.time()),
  gpstime.GpsSecondsFromPyUTC(time.time()),
  ifos,
  comment
)]

process_dict = { 
  'pos' : 0,
  'column' : process_cols,
  'orderedcol' : process_ocols,
  'stream' : process_stream
}


#--------------------------------------------------------------------------#
# create the elements in the segment_definer table that need to be filled in
segment_definer_cols = {
  "process_id" : "ilwd:char", 
  "segment_def_id" : "ilwd:char",
  "ifos" : "lstring",
  "name" : "lstring",
  "version" : "int_4s",
  "comment" : "lstring"
}

segment_definer_ocols  = [
  "process_id",
  "segment_def_id",
  "ifos",
  "name",
  "version",
  "comment"
]

segment_definer_stream = [(
  "process:process_id:0",
  "segment_definer:segment_def_id:0",
  ifos,
  name,
  version,
  expln
)]

segment_definer_dict = { 
  'pos' : 0,
  'column' : segment_definer_cols,
  'orderedcol' : segment_definer_ocols,
  'stream' : segment_definer_stream
}

#--------------------------------------------------------------------------#
# create the elements in the segment table that need to be filled in
segment_cols = {
  "process_id" : "ilwd:char",
  "segment_def_id" : "ilwd:char",
  "segment_id" : "ilwd:char",
  "start_time" : "int_4s",
  "end_time" : "int_4s",
}

segment_ocols = [
  "process_id",
  "segment_def_id",
  "segment_id",
  "start_time",
  "end_time",
]

segment_stream = []
  
segment_dict = { 
  'pos' : 0,
  'column' : segment_cols,
  'orderedcol' : segment_ocols,
  'stream' : segment_stream
}


#--------------------------------------------------------------------------#
# create the elements in the segment_summary table that need to be filled in
segment_summary_cols = {
  "process_id" : "ilwd:char",
  "segment_def_id" : "ilwd:char",
  "segment_sum_id" : "ilwd:char",
  "start_time" : "int_4s",
  "end_time" : "int_4s"
  }

segment_summary_ocols = [
  "process_id",
  "segment_def_id",
  "segment_sum_id",
  "start_time",
  "end_time"
]
 
segment_summary_stream = []
 
segment_summary_dict = { 
  'pos' : 0,
  'column' : segment_summary_cols,
  'orderedcol' : segment_summary_ocols,
  'stream' : segment_summary_stream
}
########################################################################
#                    Open connection to LDBD Server
########################################################################
try:
  myClient = LDBDClient.LDBDClient(host, port, identity)

except Exception, e:
  print >>sys.stderr, \
    "Unable to connect to LDBDServer %s:%d" % (host, port)
  if gsiserverutils.checkCredentials():
    print >>sys.stderr, "Got the following error : " + str(e)
    print >>sys.stderr, "Enter '%s --help' for usage" % sys.argv[0]
  sys.exit(1)

#---------------------Check segment type existence-----------------------#
# query the database to see if the segment type already exists
sql = "SELECT count(segment_def_id) FROM segment_definer WHERE "
sql += "ifos = '%s' AND " % ifos
sql += "name = '%s' AND " % name
sql += "version = %d " % int(version)
typexml = myClient.query(sql)

del myClient
myClient = None


# parse the result returned from the database query
type_md = ldbd.LIGOMetadata(xmlparser,lwtparser)
xmlparser.eoCB = dtd_uri_callback
type_md.parse(typexml)
type = type_md.table['segment_definer']['stream'][0][0]


########################################################################
#                    Process Commands
########################################################################
# create the total time interval and storage for the active segments
interval_s = segments.segment(starttime,endtime)
interval = segments.segmentlist([interval_s])
active_segments = segments.segmentlist()

try:
  #-----------------------Process INSERT NEW SEGMENT TYPE-----------------------#
  if not append and version==1:

    # Check if the segment type already exists
    if type != 0: 
      print >> sys.stderr, """
Error: Segment type %s %s.upper() already exists. Exiting now. """ % (ifos, name)
      sys.exit(1)

    # get the active segments to be inserted:
    # read in the active segments from the file specified on the cmd line
    fh = open(segfile, 'r')
    for line in fh.readlines():
      seg_line = line.strip().split(",")
      this_seg = segments.segment(int(seg_line[0]),int(seg_line[1]))
      if this_seg not in interval_s:
      # reject any segment that does not lie entirely in the interval
      # specified on the command line
        msg = "Error: segments in %s must lie between %d and %d\n" % (
        segfile, starttime, endtime)
        msg += "Bad segment is " + str(this_seg)
        print >> sys.stderr, msg
        sys.exit(1)
      # otherwise append the segment to the list of active segments
      active_segments.append(this_seg)
    # coalesce the active segments to deal with overlaps
    active_segments.coalesce()

    # create the xml streams containing the active segments for the segment and
    # segment_summary table, correctly mapped to the segment_def_id,
    # and process_id for the insert
    seg_id = 0
    for this_seg in active_segments:
      segment_stream.append(
        tuple( [ "process:process_id:0",
        "segment_definer:segment_def_id:0",
        "segment:segment_id:" + str(seg_id),
        int(this_seg[0]),
        int(this_seg[1])
        ] ) )
      seg_id += 1    
    
    segment_summary_stream.append(
    tuple( ["process:process_id:0",
    "segment_definer:segment_def_id:0",
    "segment_summary:segment_sum_id:0",
    starttime,
    endtime
    ] ) )
  #----------------------------Process APPEND----------------------------#
  elif append:
    if type == 0:
      print >> sys.stderr, """
Error: The segment type your want to apend to does not exist. Exiting now."""
      sys.exit(1)

    # get the active segments to be inserted:
    # read in the active segments from the file specified on the cmd line
    fh = open(segfile, 'r')
    for line in fh.readlines():
      seg_line = line.strip().split(",")
      this_seg = segments.segment(int(seg_line[0]),int(seg_line[1]))
      if this_seg not in interval_s:
      # reject any segment that does not lie entirely in the interval
      # specified on the command line
        msg = "Error: segments in %s must lie between %d and %d\n" % (
        segfile, starttime, endtime)
        msg += "Bad segment is " + str(this_seg)
        print >> sys.stderr, msg
        sys.exit(1)
      # otherwise append the segment to the list of active segments
      active_segments.append(this_seg)
    # coalesce the active segments to deal with overlaps
    active_segments.coalesce()
   


    #-----------------------------------------------------------# 
    # query the database to get the segment_def_id and creator_db
    myClient = LDBDClient.LDBDClient(host, port, identity)
    sql = "SELECT creator_db, hex(segment_def_id) AS segment_def_id "
    sql += "From segment_definer WHERE "
    sql += "ifos = '%s' AND " % ifos
    sql += "name = '%s' AND " % name
    sql += "version = %d " % int(version)
    defxml = myClient.query(sql)

    del myClient
    myClient = None

    # parse the result returned from the database query
    seg_def_md = ldbd.LIGOMetadata(xmlparser,lwtparser)
    xmlparser.eoCB = dtd_uri_callback
    seg_def_md.parse(defxml)

    cdb_col = \
       seg_def_md.table['segment_definer']['orderedcol'].index('creator_db')
    sdf_col = \
       seg_def_md.table['segment_definer']['orderedcol'].index('segment_def_id')
    creator_db = seg_def_md.table['segment_definer']['stream'][0][cdb_col]
    seg_def_id = seg_def_md.table['segment_definer']['stream'][0][sdf_col]
    #-----------------------------------------------------------------------------#

    # add segment_def_cdb,segment_def_id to the local segment table that 
    # needs to be filled in
    segment_cols['segment_def_id'] = "ilwd:char_u"
    segment_cols['segment_def_cdb'] = "int_4s"
    segment_ocols.append("segment_def_cdb")
    seg_id = 0
    for this_seg in active_segments:
      segment_stream.append(
      tuple( [ "process:process_id:0",
      seg_def_id,
      "segment:segment_id:" + str(seg_id),
      int(this_seg[0]),
      int(this_seg[1]),
      creator_db
      ] ) )
      seg_id += 1

    # add segment_def_cdb, segment_def_id to the local segment_summary table that 
    # needs to be filled in
    segment_summary_cols['segment_def_id'] = "ilwd:char_u"
    segment_summary_cols['segment_def_cdb'] = "int_4s"
    segment_summary_ocols.append("segment_def_cdb")
    segment_summary_stream.append(
    tuple( [ "process:process_id:0",
    seg_def_id,
    "segment_summary:segment_sum_id:0",
    starttime,
    endtime,
    creator_db
    ] ) ) 

    # query the database to get the last segment inserted
    segment_def_id = "x" + "\'" + seg_def_id + "\'"
 
    myClient = LDBDClient.LDBDClient(host, port, identity)
    sql = "SELECT max(end_time) FROM segment WHERE "
    sql += "segment_def_cdb = %d AND " % creator_db
    sql += "segment_def_id = %s " % str(segment_def_id) 
    endxml = myClient.query(sql)

    del myClient
    myClient = None

    # parse the result returned from the database
    end_md = ldbd.LIGOMetadata(xmlparser,lwtparser)
    xmlparser.eoCB = dtd_uri_callback
    end_md.parse(endxml)

    # check that there is no overlap with the interval that
    # we want to insert
    last_end_time = end_md.table['segment']['stream'][0][0]
    existing_segs = segments.segmentlist()
    existing_segs.append(segments.segment(0, int(last_end_time)))
    print
    print "existing_segs="+str(existing_segs)
    print "interval="+str(interval)
    existing_segs &= interval
    if len(existing_segs) != 0:
      msg = "overlap with existing segment times for this version\n"
      msg += "Overlapping times are %s" % str(existing_segs)
      raise ligolw_dqInsertException, msg
    else:
      print >> sys.stdout, "Append successfully."
  # ...end if append


  else:
    print >> sys.stderr, "Error: Wrong command combination. Exiting now."
    sys.exit(1)



  #append all the tables we have created to the actual document
  segment_md.table['process'] = process_dict
  if not append:
    segment_md.table['segment_definer'] = segment_definer_dict
  segment_md.table['segment_summary'] = segment_summary_dict
  segment_md.table['segment'] = segment_dict


  # send parsed tables to LDBD Server:
  if not myClient:
    myClient = LDBDClient.LDBDClient(host, port, identity)
  myClient.insert(segment_md.xml())

except Exception, e:
  print >>sys.stderr, "Error inserting segments: %s" % str(e)
  print >>sys.stderr, "Enter '%s --help' for usage" % sys.argv[0]
  sys.exit(1)

sys.exit(0)



