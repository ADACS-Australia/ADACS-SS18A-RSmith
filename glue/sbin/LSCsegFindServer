#!/usr/bin/env python
"""
LSCsegFindServer listens on a socket for connections from a client,
processes the requests and then returns the results to the client.
It is used to expose the information in the segfind database to
clients.

The RPC protocol for LDCsegFindServer is detailed at

U{http://www.lsc-group.phys.uwm.edu/daswg/projects/glue/segfindprotocol.html}

The server is built on top of the ThreadingGSITCPSocketServer from
the io module in U{pyGlobus<http://www-itg.lbl.gov/gtg/projects/pyGlobus/>},
which is build on top of the standard module SocketServer.
"""

import sys
import os
import signal
import logging
import logging.handlers
import getopt
from ConfigParser import ConfigParser
import time
import socket
import SocketServer
import types
import exceptions
import pickle
import MySQLdb
from pyGlobus import io
from glue import segments
from glue import gsiserverutils


def SIGHUPhandler(signum, frame):
  """
  Handle SIGHUP signals by asking the server to stop its 
  service, then read the gridmap file again and reconfigure, 
  after which the service will automatically start again.

  @param signum: signal number; see the documentation for the 
    signal module

  @param frame: current stack frame; see the documentation for
    the signal module
        
  @return: None
  """
  global myServer
        
  myServer.stopService()



def SIGTERMhandler(signum, frame):
  """
  Handle SIGTERM signals by asking the server to stop and die.

  @param signum: signal number; see the documentation for the 
    signal module

  @param frame: current stack frame; see the documentation for
    the signal module
        
  @return: None
  """
  global myServer

  myServer.die()



def socketReadyCallback(arg, handle, result):
  """
  Called when a socket is ready for reading (when a connection has been made
  and there is something to read).

  This function simply sets a flag to let the server loop know the socket
  is ready for reading.

  @param arg: User supplied argument. Here it is used to carry the socket ready
    flag.
  @param handle: a pointer to the SWIG'ized globus_io_handle_t
  @param result: a pointer to the SWIG'ized globus_result_t

  @return: None
  """
  arg.mySocketReady = 1



# parse command line options
shortop = "p:g:c:k:d:Dh"
longop = [
  "port=",
  "gridmap=",
  "certificate=",
  "key=",
  "database=",
  "daemon",
  "help"
  ]


usage = """\
Usage: LSCdataFindServer [OPTIONS]

  -p, --port PORT           listen for connections on PORT (default 49999)
  -g, --gridmap FILE        obtain authourized user credentials from FILE
  -c, --certificate FILE    obtain service certificate from FILE
  -k, --key FILE            obtain service private key form FILE
  -d, --database DB         query database DB for segment information
  -D, --daemon              run as a deamon
  -h, --help                print detailed help message

The --gridmap, --certificate,--key and --database options must be specified.
"""

try:
  opts, args = getopt.getopt(sys.argv[1:], shortop, longop)
except getopt.GetoptError:
  print >>sys.stderr, "Error parsing command line"
  sys.exit(1)

#default for command-line options
runAsDaemon = False

# default configuration values may go here, but they will be replaced
# by actual values if and when a ConfigurationManager instance is
# created elsewhere
configuration = {
  'port' : 49999,
  'gridmap' : '/export/grid/online/grid-mapfile',
  'certfile' : '/export/LDR-local/globus/etc/hostcert.pem',
  'keyfile' : '/export/LDR-local/globus/etc/hostkey.pem',
  'dbname' : 'segfind',
  'dbuser' : 'grid',
  'dbpasswd' : '',
  'max_client_byte_string': 2048,
  'pidfile' : '/tmp/segfind.pid',
  'logfile' : '/tmp/segfind.log',
  'logmaxbytes' : 1024 * 1024 * 1,
  'logbackupcount' : 5,
  'loglevel' : 'INFO'
  }



class LSCsegFindServerHandlerException(exceptions.Exception):
  """
  Class representing exceptions within the LSCsegFindServer class.
  """
  def __init__(self, args=None):
    """
    Initialize an instance.

    @param args: 

    @return: Instance of class LSCsegFindServerHandlerException
    """
    self.args = args
        


class LSCsegFindServerHandler(SocketServer.BaseRequestHandler):
  """
  An instance of this class is created to service each request of the server.
  """
  def handle(self):
    """
    This method does all the work of servicing a request to the server. See
    the documentation for the standard module SocketServer.

    The input from the socket is parsed for the method with the remaining
    strings stripped of null bytes passed to the method in a list.

    There are no parameters. When the instance of the class is created to
    process the request all necessary information is made attributes of the
    class instance.

    @return: None
    """
    global logger

    logger.debug("handle method of LSCsegFindServerHandler class called")

    # mapping of LSCsegFindServer RPC protocol names to methods of this class
    methodDict = {
      'PING' : self.ping,
      'DISTINCT' : self.distinctAttribute,
      'METASEGS' : self.segmentFindWithMetadata
    }

    try:
      # from the socket object create a file object
      self.sfile = self.request.makefile("rw")
      f = self.sfile

      # read all of the input up to limited number of bytes
      max = configuration['max_client_byte_string']
      input = f.read(size=max,waitForBytes=2)

      # the format should be a method string, followed by a null byte
      # followed by the arguments to the method encoded as null
      # terminatd strings

      # check if the last byte is a null byte
      if input[-1] != '\0':
        raise LSCsegFindServerHandlerException, \
          "Last byte of input is not null byte"
    except Exception, e:
      logger.error("Error reading input on socket: %s" %  e)
      return

    logger.debug("Input on socket: %s" % input[0:-1])

    try:
      # parse out the method and arguments 
      stringList = input.split('\0')
      methodString = stringList[0]
      argStringList = stringList[1:-1]
                        
    except Exception, e:
      logger.error("Error parsing method and argument string: %s" % e)

      msg = "ERROR LSCsegFindServer Error: " + \
        "Error parsing method and argument string: %s" % e
      self.__reply__(1, msg)
      return
                
    try:
      # look up method in dictionary
      method = methodDict[methodString]
    except Exception, e:
      msg = "Error converting method string %s to method call: %s" % \
        (methodString, e)
      logger.error(msg)
                        
      self.__reply__(1, msg)
      return

    try:
      # call the method requested with the rest of strings as input
      method(argStringList) 
    except Exception, e:
      logger.error("Error while calling method %s: %s" % (methodString, e))

    return
        
  def __reply__(self, code, msg):
    """
    Format and send a reply back down the socket to the client. The file
    representing the socket is closed at the end of this method.

    @param code: integer representing the error code with 0 for success
                
    @param msg: object to be passed back to the client, either a string
    or a list of items that can be represented by strings
                        
    @return: None
    """

    pmsg = pickle.dumps(msg)
    reply = "%d\0%s\0" % (code, pmsg)
    f.write(reply)

    # close the file associated with the socket
    f.close()

  def ping(self, arg):
    """
    Bounce back alive statment. Corresponds to the PING method in the
    LSCsegFindServer RPC protocol.

    @param arg: list (perhaps empty) of strings representing message sent
      by client to server

    @return: None
     """

    logger.debug("Method ping() called")
    try:
      hostname = socket.getfqdn()
      msg = "LSCsegFindServer at %s is alive" % hostname
    except Exception, e:
      msg = "LCSsegFindServer is alive"

    self.__reply__(0, msg)



  def distinctAttribute(self, arg):
    """
    Find distinct values for an attribute. Corresponds to the DISTINCT method
    in the LSCsegFindServer RPC protocol.

    @param arg: list of strings representing messages sent by client; first
      one should be the attribute to be examined

    @return: None
    """

    logger.debug("Method distinctAttribute called")

    # get database access details from configuration
    dbuser = configuration['dbuser']
    dbpasswd = configuration ['dbpasswd']
    dbname = configuration['dbname']

    # assume failure
    code = 1

    try:
      attribute = arg[0]

      sql = "SELECT DISTINCT "
      if attribute == "interferometers":
        sql += "ifo FROM state_segment"
      elif attribute == "state":
        sql += "state FROM state_vec"
      else:
        raise LSCsegFindServerHandlerException, \
          "Unknown select distinct method " + attribute

      db = MySQLdb.connect(user=dbuser,passwd=dbpasswd,db=dbname)
      c = db.cursor()
      c.execute(sql)
      res = c.fetchall()
      result = '\n'.join([ x[0] for x in res ])
      c.close()
      
      logger.debug("Method distinctAttribute: %d results found" % 
        len(result))
      code = 0
    except Exception, e:
      result = "Error querying metadata for distinct values of attribute " + \
        "%s: %s" % (arg[0], e)
      logger.error(result)

    try:
      db.close()
      del db
    except Exception, e:
      logger.error(
        "Error closing connection to MySQL in method distinctAttribute")

    self.__reply__(code, result)


  def segmentFindWithMetadata(self, arg):
    """
    Given a SQL WHERE-type clause find segment(s) that have the matching
    attributes. Corresponds to the METASEGS method in the LSCsegFindServer RPC
    protocol.

    @param arg: list of strings representing messages sent by the client; see
    the RPC protocol 

    @return: None
    """

    logger.debug("Method segmentFindWithMetadata called")

    # get database access details from configuration
    dbuser = configuration['dbuser']
    dbpasswd = configuration ['dbpasswd']
    dbname = configuration['dbname']

    # assume failure
    code = 1

    try:
      sql = "SELECT state_segment.start_time, state_segment.end_time "
      sql += "FROM state_segment, state_vec WHERE "
      sql += arg.pop(0)
      sql += " AND state_segment.state_vec_id = state_vec.state_vec_id;"

      db = MySQLdb.connect(user=dbuser,passwd=dbpasswd,db=dbname)
      c = db.cursor()
      c.execute(sql)
      res = c.fetchall()
      c.close()

      result = ""

      try:
        segs = segments.segmentlist()
        for r in res:
          segs |= segments.segmentlist([segments.segment(r[0],r[1])])
        for s in segs:
          result += "%d %d\n" % (s.start, s.end)
        result = result[0:-1]
      except:
        pass
      
      logger.debug("Method : segmentFindWithMetadata %d results found" % 
        len(result))
      code = 0
    except Exception, e:
      result = "Error querying metadata for segments" + \
        "%s: %s" % (arg[0], e)
      logger.error(result)

    try:
      db.close()
      del db
    except Exception, e:
      logger.error(
        "Error closing connection to MySQL in method distinctAttribute")

    self.__reply__(code, result)


class LSCsegFindServer(object):
  """
  An instance of this class is a multi-threadead server that will listen on a
  socket/port for connections from a client and will process requests.
  """
  def __init__(self):
    """
    Perform any checks that are necessary before becoming a daemon and
    starting a socket service to listen on. If any check fail print
    to stderr and exit.

    @param:

    @return: instance of class LSCsegFindServer
    """
    self.server = None

    # verify that we have access to the certificate, key, grid-mapfile
    certFilePath = configuration["certfile"]
    if not os.access(certFilePath, os.R_OK):
      print >>sys.stderr, "LSCsegFindServer: " + \
      "Cannot access certificate file at %s" % certFilePath
      sys.exit(1)

    keyFilePath = configuration["keyfile"]
    if not os.access(keyFilePath, os.R_OK):
      print >>sys.stderr, \
        "LSCsegFindServer: Cannot access key file at %s" % keyFilePath
      sys.exit(1)

    gridmapFilePath = configuration["gridmap"]
    if not os.access(gridmapFilePath, os.R_OK):
      print >>sys.stderr, \
        "LSCsegFindServer: Cannot access grid-mapfile at %s" % gridmapFilePath
      sys.exit(1)

    # verify that we can write PID file
    failure = 0
    pidFilePath = configuration["pidfile"]
    exists  = os.access(pidFilePath, os.F_OK)
    if exists:
      if not os.access(pidFilePath, os.W_OK):
        failure = 1
    else:
      try:
        f = open(pidFilePath, "w")
        f.close()
      except:
        failure = 1
                        

    if failure:
      print >>sys.stderr, \
        "LSCsegFindServer: Cannot write PID to file %s" % pidFilePath
      sys.exit(1)


  def initialize(self):
    """
    Grab information from configuration and record it for this instance. Set
    up logging.

    @param:
                
    @return: None

    """
    global logger

    try:
      self.certFilePath = configuration["certfile"]
      self.keyFilePath  = configuration["keyfile"]
      self.gridmapFilePath = configuration["gridmap"]
      self.pidFilePath = configuration["pidfile"]
      self.port = configuration["port"]
                        
      myLogger = logging.getLogger('LSCsegFindServer')

      # remove any existing handlers
      for h in myLogger.handlers:
        myLogger.removeHandler(h)


      logFilePath = configuration["logfile"]

      handler = logging.handlers.RotatingFileHandler(
        logFilePath, 'a', configuration['logmaxbytes'], 
        configuration['logbackupcount'])
      formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
      handler.setFormatter(formatter)
      myLogger.addHandler(handler)
      logFileLevel = configuration["loglevel"]
      myLogger.setLevel(eval("logging." + logFileLevel))

      self.logger = myLogger
      logger = myLogger

    except Exception, e:
      print >>sys.__stderr__, "Unable to start logging: %s" % e
        
  def run(self):
    """
    Read configuration information in the initialize() method, write out
    pid, set up our environment, start the GSI TCP service on the socket,
    then start listening forever.

    @param:

    @return: None
    """
    self.initialize()
    self.writePID()
    self.setEnvironment()
    self.startService()
    self.serveForever()

  def stopService(self):
    """
    Set a flag on this instance of LSCsegFindServer so that when the main
    loop in the serveForever() method sees the flag set the service is
    stopped.

    @param:

    @return: None
    """
    self.logger.info("stopNow flag set; server will stop during next loop")
    self.stopNow = 1
        
  def die(self):
    """
    Set a flag on this instance of LSCsegFindServer so that when the main
    loop in the serveForever() method sees the flag set the service is
    stopped and then the executable exits.

    @param:

    @return: None
    """
    self.logger.info("dieNow flag set; executable will exit during next loop")
    self.stopService()
    self.dieNow = 1

  def writePID(self):
    """
    Write pid out to a file.
                
    @param:

    @return: None
    """

    # write PID out to file
    myPIDfd = os.open(self.pidFilePath, os.O_WRONLY | os.O_CREAT, 0644)
    os.write(myPIDfd, "%d\n" % os.getpid())
    os.close(myPIDfd)

  def clearPID(self):
    """
    Delete pid file.
                
    @param:

    @return: None
    """

    try:
      os.unlink(self.pidFilePath)
    except:
      pass


  def setEnvironment(self):
    """
    Set environment variables that this instance of LSCsegFindServer needs,
    in particular for GSI services.
                
    @param:

    @return: None
    """
    os.environ["X509_USER_CERT"] = self.certFilePath
    os.environ["X509_USER_KEY"] = self.keyFilePath
    os.environ["GRIDMAP"] = self.gridmapFilePath


  def startService(self):
    """
    Create instance of io.ThreadingGSITCPSocketServer that this server will
    use to listen for incoming requests from clients. See the
    U{pyGlobus<http://www-itg.lbl.gov/gtg/projects/pyGlobus/>} documentation.

    If the ThreadingGSITCPSocketServer cannot be started sleep and then try
    again, with the time between retries growing exponentially.

    This server requires GSI authentication. 

    @param:

    @return: None
    """
    # create a callback to use for authorization
    gridmap = gsiserverutils.Gridmap(self.gridmapFilePath, self.logger)
    callback = gsiserverutils.AuthCallback(gridmap, self.logger, callback=None)

    # create authorization data object and set callback
    authData = io.AuthData()
    authData.set_callback(callback, self)
    self.authData = authData
        
    # create TCPIO Attribute object and initialize to pass to server        
    #
    # we use secure IO authentication using GSSAPI and authorization back
    # to a callback function, which reads a gridmap file
    tcpIOAttr = io.TCPIOAttr()
    tcpIOAttr.set_authentication_mode(
      io.ioc.GLOBUS_IO_SECURE_AUTHENTICATION_MODE_GSSAPI)
    tcpIOAttr.set_authorization_mode(
      io.ioc.GLOBUS_IO_SECURE_AUTHORIZATION_MODE_CALLBACK, authData)
    tcpIOAttr.set_channel_mode(
      io.ioc.GLOBUS_IO_SECURE_CHANNEL_MODE_CLEAR)
    tcpIOAttr.set_delegation_mode(
      io.ioc.GLOBUS_IO_SECURE_DELEGATION_MODE_FULL_PROXY)
                
    self.tcpIOAttr = tcpIOAttr

    # start the server
    self.running = 0
    self.nap = 1
    while not self.running:
      try:
        self.logger.info("Starting server on port %d" % self.port)
        server = io.ThreadingGSITCPSocketServer(
          addr=("", self.port), 
          RequestHandlerClass=LSCsegFindServerHandler,
          #io.ioc.GLOBUS_IO_SECURE_CHANNEL_MODE_CLEAR,
          channel_mode=io.ioc.GLOBUS_IO_SECURE_CHANNEL_MODE_CLEAR,
          delegation_mode=io.ioc.GLOBUS_IO_SECURE_DELEGATION_MODE_FULL_PROXY,
          tcpAttr=self.tcpIOAttr
          )
        self.server = server
        self.logger.info("Server running on port %d" % self.port)

        self.running = 1
        self.nap = 1
                                
        self.stopNow = 0
        self.dieNow = 0
                        
      except Exception, e:
        self.logger.warning("Error starting server: %s" % e)
        self.logger.warning("Will retry in %d seconds" % self.nap)

        try:
          del server
          del self.server
        except:
          pass

        time.sleep(self.nap)
        self.nap = self.nap * 2
                                
                        
  def serveForever(self):
    """
    Our own version of the server_forever() method for the GSITCPServer and
    SocketServer.BaseServer classes. Normally the call sequence is

    get_request()
    verify_request()
    process_request()

    and this is normally done with error handling by the handle_request() 
    method. In turn server_forever() is usually just

    while 1: handle_request()

    The get_request() for GSITCPServer is normally a blocking listen() on the
    socket followed by the accept() call.

    In order to not block we instead use a register_listen() call and have the
    callback set a flag when a socket is ready to be answered and a call to
    accept() made.

    Since the loop is not blocking on the socket IO, it can be interrupted
    by signals, such as a SIGHUP.

    @param:
        
    @return: None
    """
    # set socket ready flag to false and register a listening callback
    # that is called when the socket is ready
    self.mySocketReady = 0
    handle = self.server.socket.register_listen(socketReadyCallback, self)

    while self.running:
      # is my socket ready? 
      if self.mySocketReady:
        # socket is ready so accept the connection, then process it
        # the process_request() method used here will be that from
        # the SocketServer.ThreadingMixIn class so inside of that a
        # new thread is started.
        try:
          self.logger.debug("calling accept method for socket instance")
          (request, client_address) = self.server.socket.accept(
            self.server.attr)
          process = 1
        except io.GSITCPSocketException, ex:
          self.server.socket.shutdown(2)
          process = 0

        if process:
          try:
            self.logger.debug("processing request on socket now...")
            self.server.process_request(request, client_address)
            self.logger.debug("finished processing request")
          except Exception, e: 
            self.logger.error("Error during server.process_request(): %s" % e)
            self.server.handle_error(request, client_address)
            self.server.close_request(request)

        # free callback handle used for the register_listen
        self.server.socket.free_callback(handle)

        # prepare for next connection by setting ready flag to false and
        # registering a new listener
        self.mySocketReady = 0
        handle = self.server.socket.register_listen(socketReadyCallback, self)
        continue

      # have I been told to shutdown?
      if self.stopNow:
        # close and delete the server
        self.logger.info('closing server')
        self.server.server_close()
        del self.server

        # have I been told to die?
        if self.dieNow:
          self.clearPID()
          raise SystemExit

        # give 5 seconds for the socket to be freed up
        time.sleep(5)
        self.running = 0

        continue
                        

      # no socket is ready and I have not been told to shutdown
      # so sleep for a bit so that we don't burn CPU all the time
      time.sleep(0.1)


# set up logging but don't set handler here since that is
# configurable in the .ini file
logger = logging.getLogger('LSCsegFindServer')

# setup to cach HUP and SIGTERM
signal.signal(signal.SIGHUP, SIGHUPhandler)
signal.signal(signal.SIGTERM, SIGTERMhandler)

# initialize server
myServer = LSCsegFindServer()

# become a daemon
if runAsDaemon:
  gsiserverutils.daemon()

running = 1

try:
  while running:
    # start server
    myServer.run()

except SystemExit:
  logger.info("LSCsegFindServer shutting down")
  sys.exit()

except KeyboardInterrupt:
  logger.info("LSCsegFindServer shutting down")
  sys.exit()

except Exception, e:
  msg = "LSCsegFindServer is stopping due to unhandled error: %s" % e
  print >>sys.stderr, msg
  logger.critical(msg)

del logger
logger = None
sys.exit()
