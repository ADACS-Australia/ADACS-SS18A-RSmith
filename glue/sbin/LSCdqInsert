#!/usr/bin/python

import os
import socket
import getopt
import pwd
import sys
import re
import time
import exceptions
import commands

try:
  import pyRXP
except ImportError, e:
  print >> sys.stderr, """
Error: unable to import the pyRXP module.

You must have pyRXP installed and in your PYTHONPATH to run %s.

%s
""" % (sys.argv[0], e)
  sys.exit( 1 )
try:
  from glue import gpstime
  from glue import ldbd
  from glue import LDBDClient
  from glue import gsiserverutils
  from glue import segments
  from glue import segmentsUtils
except ImportError, e:
  print >> sys.stderr, """
Error: unable to import modules from glue.

Check that glue is correctly installed and in your PYTHONPATH.

%s
""" % e
  sys.exit(1)

cvs_date = '$Date$'
cvs_rev = '$Revision$' 
cvs_src = '$Source$'


class LSCdqInsertException(exceptions.Exception):
  """
  Class representing exceptions within the LSCdqInsert class.
  """
  def __init__(self, args=None):
    """
    Initialize an instance.

    @param args: 

    @return: Instance of class LSCdqInsertException
    """
    self.args = args


def usage():
  """
  Print a help message and a description of the command line args.
  """
  msg = """\
Usage: %s [OPTIONS]

  -s, --server HOST:PORT   connect to ldbd on HOST:PORT (default port 30020)
  -j, --identity SUBJECT   the subject of the servers service certififcate

  -A, --append             add segments to an existing data quality flag

  -r, --run RUN            the name of the run for this flag (S4, S5, etc.)
  -i, --ifos IFOS          the interferometers to which this flag applies
  -n, --name NAME          the name of the data quality flag (e.g. DUST)
  -v, --version VERS       the numeric version of this data quality flag

  -e, --explain EXPLN      a string explaining WHAT this DQ flag means
  -c, --comment COMM       a string explaining WHY this DQ flag was inserted

  -g, --gps-start-time T1  start of interval checked for this flag
  -G, --gps-end-time T2    end of interval checked for this flag

  -I, --interval START,END insert only the GPS interval [START,END)
  -S, --segment-file FILE  a file containing the gps start and stop times

  -p, --ping               ping the server
  -h, --help               print this message

If no server is specified, then the segment data is written to stdout and can
be viewed using guild.

The argument to the --ifos option should be a list of the interferometers to
which this data quality flag applies. If multiple inferferometers are listed,
they should be given in alphanumeric order. For example if the flag applies
only to the Hanford 4km inferferometer, then

  --ifos H1

should be specified. If the flag applies to all the interferometers at LHO and
the PEM channels, then

  --ifos H0H1H2

should be specified.

The --explain flag should give a human parsable string describing what the
flag means, for example

  --explain "Raised dust levels on the optical bench"

and the --comment flag should give a human parsable string describing why or
how these data quality segments were derived, for example

  --comment "Generated by looking at e-log entries"

If extra segments are being added to an exisiting data quality flag, then the
--append option must be given. Then new data quality segments must have times
after end time of the last existing segment in the database, otherwise an
error is generated. If the users wishes to change existing segment
information, the version of the data quality flag must be incremented.

A single interval may be inserted with the --interval command, for example

  --interval 700000000,700000100

or a list of segments may be given with the --segment-file command.

The segment file to be inserted should contain active segments in the format

gps_start gps_end

where each segment is on a new line. Inactive segments will be created for the
inverse of these times starting from the specified start time T1 and ending at
the specified end time T2.
\
""" % sys.argv[0]
  print msg

# define the command line arguments
shortop = "s:j:r:i:n:v:e:c:g:G:I:s:Aph"
longop = [
  "server=",
  "identity=",
  "run=",
  "ifos=",
  "name=",
  "version=",
  "explain=",
  "comment=",
  "segment-file=",
  "interval=",
  "gps-start-time=",
  "gps-end-time=",
  "append",
  "ping",
  "help"
  ]

# parse the command line arguments
try:
  opts, args = getopt.getopt(sys.argv[1:], shortop, longop)
except getopt.GetoptError:
  usage()
  sys.exit(1)

hostPortString = None
port = 30020
identity = None
run = None
ifos = None
name = None
version = None
expln = None
comment = None
segfile = None
seg_interval = None
starttime = None
endtime = None
append = 0
ping = None

# environment variables override defaults but not
# command line options
try:
  hostPortString = os.environ['LDBD_SERVER']
except:
  pass

for o, a in opts:
  if o in ("-h", "--help"):
    usage()
    sys.exit(0)
  elif o in ("-s", "--server"):
    hostPortString = a
  elif o in ("-j", "--identity"):
    identity = a
  elif o in ("-r", "--run"):
    run = a
  elif o in ("-i", "--ifos"):
    ifos = a
  elif o in ("-n", "--name"):
    name = a
  elif o in ("-v", "--version"):
    version = int(a)
  elif o in ("-e", "--explain"):
    expln = a
  elif o in ("-c", "--comment"):
    comment = a
  elif o in ("-S", "--segment-file"):
    segfile = a
  elif o in ("-I", "--interval"):
    seg_interval = a
  elif o in ("-g", "--gps-start-time"):
    starttime = int(a)
  elif o in ("-G", "--gps-end-time"):
    endtime = int(a)
  elif o in ("-A", "--append"):
    append = 1
  elif o in ("-p", "--ping"):
    ping = 1



# determine server and port
if hostPortString:
  if hostPortString.find(':') < 0:
    # no port specified
    host = hostPortString
  else:
    # server and port specified
    host, portString = hostPortString.split(':')
    port = int(portString)

  # used the standard ldbd server service certificate
  if not identity:
    identity = "/DC=org/DC=doegrids/OU=Services/CN=ldbd/%s" % host

# make sure all neccessary command line arguments are given
fail = 0
errmsg = ""
if not run:
  errmsg += "Error: --run must be specified\n"
if not ifos:
  errmsg += "Error: --ifos must be specified\n"
if not name:
  errmsg += "Error: --name must be specified\n"
if not version:
  errmsg += "Error: --version must be specified\n"
if not expln and not append:
  errmsg += "Error: --explain must be specified\n"
if not comment:
  errmsg += "Error: --comment must be specified\n"
if not segfile and not seg_interval:
  errmsg += "Error: either --interval or --segment-file must be specified\n"
if segfile and seg_interval:
  errmsg += "Error: only one of --interval or --segment-file may be specified\n"
if not starttime:
  errmsg += "Error: --gps-start-time must be specified\n"
if not endtime:
  errmsg += "Error: --gps-end-time must be specified\n"

if len(errmsg) and not ping:
  print >> sys.stderr, errmsg
  print >> sys.stderr, "Run\n    %s --help\nfor more information." % sys.argv[0]
  sys.exit(1)

# create the total time interval and storage for the active and inactive
# segments
interval_s = segments.segment(starttime,endtime)
interval = segments.segmentlist([interval_s])
active_segments = segments.segmentlist()

if not ping:
  # get the previous version
  if(run=='S5'):
    if(version>10):
      print >> sys.stdout, "Correcting the previous version %d" % (version-1)
      print >> sys.stdout, "Extracting version %d from the database. Please, wait..." % (version-1)
      com="LSCsegFindDev --run " + run + " -t " + name + ":%d:1" % (version-1) + " -i "+ifos+" -r " + host + ":30016"
      a=commands.getstatusoutput(com)
      if(a[0]!=0):
        print >>sys.stderr, str(a)
        sys.exit(1)
      previous_version=segments.segmentlist(map(lambda x:segments.segment(map(int,x.split())),a[1].split("\n")))
    elif(version==10):
      print >> sys.stdout, "New segment type is inserted"
      previous_version=segments.segmentlist([])
    else:
      print >> sys.stderr, "For S5, segment version < 10 cannot be inserted"
      sys.exit(1)

  
  # create an xml parser, a ligo_lw document parser, and the document
  xmlparser = pyRXP.Parser()
  lwtparser = ldbd.LIGOLwParser()
  segment_md = ldbd.LIGOMetadata(xmlparser,lwtparser)

  # create the elements in the process table that need to be filled in
  process_cols = {
    "process_id" : "ilwd:char",
    "program" : "lstring",
    "version" : "lstring",
    "cvs_repository" : "lstring",
    "cvs_entry_time" : "int_4s",
    "is_online" : "int_4s",
    "node" : "lstring",
    "username" : "lstring",
    "unix_procid" : "int_4s",
    "start_time": "int_4s",
    "end_time": "int_4s",
    "ifos" : "lstring",
    "comment" : "lstring"
  }

  process_ocols = [
    "process_id",
    "program",
    "version",
    "cvs_repository",
    "cvs_entry_time",
    "is_online",
    "node",
    "username",
    "unix_procid",
    "start_time",
    "end_time",
    "ifos",
    "comment"
  ]

  process_stream = [(
    "process:process_id:0",
    os.path.basename(sys.argv[0]), 
    cvs_rev[11:-2], 
    cvs_src[9:-2],
    gpstime.GpsSecondsFromPyUTC( time.mktime( time.strptime( 
      cvs_date[7:-2], "%Y/%m/%d %H:%M:%S" ) ) ),
    0,
    socket.gethostname(),
    pwd.getpwuid(os.geteuid())[0],
    os.getpid(),
    gpstime.GpsSecondsFromPyUTC(time.time()),
    gpstime.GpsSecondsFromPyUTC(time.time()),
    ifos,
    comment
  )]

  process_dict = { 
    'pos' : 0,
    'column' : process_cols,
    'orderedcol' : process_ocols,
    'stream' : process_stream
  }

  # create the elements in the segment_definer table that need to be filled in
  segment_definer_cols = {
      "process_id" : "ilwd:char", 
      "segment_def_id" : "ilwd:char",
      "run" : "lstring",
      "ifos" : "lstring",
      "name" : "lstring",
      "version" : "int_4s",
      "comment" : "lstring"
  }

  segment_definer_ocols  = [
      "process_id",
      "segment_def_id",
      "run",
      "ifos",
      "name",
      "version",
      "comment"
  ]

  segment_definer_stream = [(
    "process:process_id:0",
    "segment_definer:segment_def_id:0",
    run,
    ifos,
    name,
    version,
    expln
  )]

  segment_definer_dict = { 
    'pos' : 0,
    'column' : segment_definer_cols,
    'orderedcol' : segment_definer_ocols,
    'stream' : segment_definer_stream
  }

  # create the elements in the segment_def_map table that need to be filled in
  segment_def_map_cols = {
    "process_id" : "ilwd:char",
    "segment_def_id" : "ilwd:char",
    "segment_id" : "ilwd:char"
  }

  segment_def_map_ocols = [
    "process_id",
    "segment_def_id",
    "segment_id"
  ]

  segment_def_map_stream = []

  # create the elements in the segment table that need to be filled in
  segment_cols = {
    "process_id" : "ilwd:char",
    "segment_id" : "ilwd:char",
    "start_time" : "int_4s",
    "end_time" : "int_4s",
    "active" : "int_4s"
  }

  segment_ocols = [
    "process_id",
    "segment_id",
    "start_time",
    "end_time",
    "active"
  ]

  segment_stream = []

  if seg_interval:
    # parse the segment from the command line
    seg_line = seg_interval.strip().split(",")
    this_seg = segments.segment(int(seg_line[0]),int(seg_line[1]))
    if this_seg not in interval_s:
      # reject any segment that does not lie entirely in the interval
      # specified on the command line
      msg = "Error: interval %s must lie between %d and %d\n" % (
        seg_interval, starttime, endtime)
      msg += "Bad segment is " + str(this_seg)
      print >> sys.stderr, msg
      sys.exit(1)
    # otherwise append the segment to the list of active segments
    active_segments.append(this_seg)
  else:
    # read in the active segments from the file specified on the cmd line
    fh = open(segfile, 'r')
    for line in fh.readlines():
      seg_line = line.strip().split(" ")
      this_seg = segments.segment(int(seg_line[0]),int(seg_line[1]))
      if this_seg not in interval_s:
        # reject any segment that does not lie entirely in the interval
        # specified on the command line
        msg = "Error: segments in %s must lie between %d and %d\n" % (
          segfile, starttime, endtime)
        msg += "Bad segment is " + str(this_seg)
        print >> sys.stderr, msg
        sys.exit(1)
      # otherwise append the segment to the list of active segments
      active_segments.append(this_seg)
    # coalesce the active segments to deal with overlaps
    active_segments.coalesce()

  f=open(".active.out","w")
  segmentsUtils.tosegwizard(f,active_segments)
  f.close()

  try:
    f=open(".previous_version","w")
    segmentsUtils.tosegwizard(f,previous_version);
    f.close()
  except:
    pass

  if(len(previous_version)>0):
    active_segments |= (previous_version - segments.segmentlist([segments.segment(starttime,endtime)]))
  active_segments.coalesce()

  f=open(".new_version","w")
  segmentsUtils.tosegwizard(f,active_segments)
  f.close()

  print "%d %d"%(starttime,endtime)

  # subtract the active segments from the total interval to get
  # the list of inactive segments to be inserted into the database
  # inactive_segments = interval - active_segments

  inactive_segments = segments.segmentlist([active_segments.extent()]) - active_segments

  # create the xml streams containing the active and inactive segments
  # for the segment table, correctly mapped to the segment_def_id and
  # process_id for the insert
  seg_id = 0
  all_segments = [(active_segments, 1), (inactive_segments, 0)]
  for seg_list in all_segments:
    for this_seg in seg_list[0]:
      segment_def_map_stream.append(
        tuple( [ "process:process_id:0",
          "segment_definer:segment_def_id:0",
          "segment:segment_id:" + str(seg_id)
        ] ) )
      segment_stream.append(
        tuple( [ "process:process_id:0",
          "segment:segment_id:" + str(seg_id),
          int(this_seg[0]),
          int(this_seg[1]),
          seg_list[1]
        ] ) )
      seg_id += 1
  
  segment_def_map_dict = { 
    'pos' : 0,
    'column' : segment_def_map_cols,
    'orderedcol' : segment_def_map_ocols,
    'stream' : segment_def_map_stream
  }
  
  segment_dict = { 
    'pos' : 0,
    'column' : segment_cols,
    'orderedcol' : segment_ocols,
    'stream' : segment_stream
  }
  
  # append all the tables we have created to the actual document
  segment_md.table['process'] = process_dict
  segment_md.table['segment_definer'] = segment_definer_dict
  segment_md.table['segment_def_map'] = segment_def_map_dict
  segment_md.table['segment'] = segment_dict
  
  # if no host and port are specifed, print out the xml and exit
  if not hostPortString:
    print segment_md.xml()
    sys.exit(0)

# open connection to LDBD Server
try:
  myClient = LDBDClient.LDBDClient(host, port, identity)

except Exception, e:
  print >>sys.stderr, \
    "Unable to connect to LDBDServer %s:%d" % (host, port)
  if gsiserverutils.checkCredentials():
    print >>sys.stderr, "Got the following error : " + str(e)
    print >>sys.stderr, "Enter '%s --help' for usage" % sys.argv[0]
  sys.exit(1)

try:
  if ping:
    # ping the server and print the response
    print myClient.ping()
  else:
    if append:
      # If we are appending segments to an existing segment type, we need
      # to do obtain the existing (creator_db,segment_def_id) tuple for the
      # type of segment we're appending to. Then we need to check that we are
      # not trying to go back in time and change segments that already exist

      # delete the segment_definer table we created locally
      del segment_md.table['segment_definer']

      # query the database to get the segment_def_id and creator_db
      defxml = myClient.query(
       "SELECT creator_db,segment_def_id FROM segment_definer WHERE " +
       "run = '" + run + "' AND " +
       "ifos = '" + ifos + "' AND " +
       "name = '" + name + "' AND " +
       "version = " + str(version)
      )
      del myClient
      myClient = None
      
      # parse the result returned from the database query
      try:
        seg_def_md = ldbd.LIGOMetadata(xmlparser,lwtparser)
        seg_def_md.parse(defxml)
      except IndexError:
        msg = "trying to append to non exsting segment.\n"
        msg += "Cannot find segment definition in database for type\n"
        msg += run + " " + ifos + " " + name + " " + str(version)
        raise LSCdqInsertException, msg
      cdb_col = \
       seg_def_md.table['segment_definer']['orderedcol'].index('creator_db')
      sdf_col = \
       seg_def_md.table['segment_definer']['orderedcol'].index('segment_def_id')
      creator_db = seg_def_md.table['segment_definer']['stream'][0][cdb_col]
      seg_def_id = seg_def_md.table['segment_definer']['stream'][0][sdf_col]

      # append the creator_db and change the segment_def_id in the rest of the
      # columns created locally
      segment_md.table['segment_def_map']['column']['segment_def_id'] = \
       "ilwd:char_u"
      segment_md.table['segment_def_map']['orderedcol'].append(
        "segment_def_cdb")
      segment_md.table['segment_def_map']['column']['segment_def_cdb'] = \
        "int_4s"
      sdf_col = \
       segment_md.table['segment_def_map']['orderedcol'].index('segment_def_id')
      newstream = []
      for s in segment_md.table['segment_def_map']['stream']:
        s = list(s)
        s[sdf_col] = seg_def_id
        s.append(creator_db)
        newstream.append(tuple(s))
      segment_md.table['segment_def_map']['stream'] = newstream

      # turn the segment_def_id into the db2 format for the next query
      segment_def_id = "x'"
      for ch in str(seg_def_id):
        segment_def_id += "%02x" % ord(ch)
      segment_def_id += "'"
     
      # query the database to get the last segment inserted 
      # for this segment type
      myClient = LDBDClient.LDBDClient(host, port, identity)
      endxml = myClient.query(
       "SELECT segment.end_time FROM segment,segment_def_map WHERE " +
       "segment.segment_id = segment_def_map.segment_id AND " +
       "segment.creator_db = segment_def_map.segment_cdb AND " +
       "segment_def_map.segment_def_cdb = " + str(creator_db) + " AND " +
       "segment_def_id = " + segment_def_id + " " +
       "ORDER BY end_time DESC FETCH FIRST 1 ROWS ONLY" )
      del myClient
      myClient = None

      # parse the result returned from the database
      end_md = ldbd.LIGOMetadata(xmlparser,lwtparser)
      end_md.parse(endxml)

      # check that there is no overlap with the interval that
      # we want to insert
      last_end_time = end_md.table['segment']['stream'][0][0]
      existing_segs = segments.segmentlist()
      existing_segs.append(segments.segment(0, int(last_end_time)))
      print "existing_segs="+str(existing_segs)
      print "interval="+str(interval)
      existing_segs &= interval
      if len(existing_segs) != 0:
        msg = "overlap with existing segment times for this version\n"
        msg += "Overlapping times are %s" % str(existing_segs)
        raise LSCdqInsertException, msg

      # ...end if append
      
    # send the xml we have constructed to the server
    if not myClient:
      myClient = LDBDClient.LDBDClient(host, port, identity)
    myClient.insert(segment_md.xml())

except Exception, e:
  print >>sys.stderr, "Error inserting segments: %s" % str(e)
  print >>sys.stderr, "Enter '%s --help' for usage" % sys.argv[0]
  sys.exit(1)

sys.exit(0)
