#!/usr/bin/python

import os
import socket
import getopt
import pwd
import sys
import re
import time
import exceptions
try:
  import pyRXP
except ImportError, e:
  print >> sys.stderr, """
Error: unable to import the pyRXP module.

You must have pyRXP installed and in your PYTHONPATH to run %s.

%s
""" % (sys.argv[0], e)
  sys.exit( 1 )
try:
  from glue import gpstime
  from glue import ldbd
  from glue import LDBDClient
  from glue import gsiserverutils
  from glue import segments
except ImportError, e:
  print >> sys.stderr, """
Error: unable to import modules from glue.

Check that glue is correctly installed and in your PYTHONPATH.

%s
""" % e
  sys.exit(1)

cvs_date = '$Date$'
cvs_rev = '$Revision$' 
cvs_src = '$Source$'


class LSCdqInsertException(exceptions.Exception):
  """
  Class representing exceptions within the LSCdqInsert class.
  """
  def __init__(self, args=None):
    """
    Initialize an instance.

    @param args: 

    @return: Instance of class LSCdqInsertException
    """
    self.args = args


def usage():
  msg = """\
Usage: %s [OPTIONS]

  -s, --server HOST:PORT   connect to ldbd on HOST:PORT (default port 30020)
  -j, --identity SUBJECT   the subject of the servers service certififcate

  -A, --append             add segments to an existing data quality flag

  -r, --run RUN            the name of the run for this flag (S4, S5, etc.)
  -i, --ifos IFOS          the interferometers to which this flag applies
  -n, --name NAME          the name of the data quality flag (e.g. DUST)
  -v, --version VERS       the numeric version of this data quality flag

  -e, --explain EXPLN      a string explaining WHAT this DQ flag means
  -c, --comment COMM       a string explaining WHY this DQ flag was inserted

  -g, --gps-start-time T1  start of interval checked for this flag
  -G, --gps-end-time T2    end of interval checked for this flag

  -S, --segment-file FILE  a file containing the gps start and stop times

  -p, --ping               ping the server
  -h, --help               print this message

If no server is specified, then the segment data is written to stdout and can
be viewed using guild.

The segment file to be inserted should contain active segments in the format

gps_start gps_end

where each segment is on a new line. Inactive segments will be created for the
inverse of these times starting from the specified start time T1 and ending at
the specified end time T2.

The argument to the --ifos option should be a list of the interferometers to
which this data quality flag applies. If multiple inferferometers are listed,
they should be given in alphanumeric order. For example if the flag applies
only to the Hanford 4km inferferometer, then

  --ifos H1

should be specified. If the flag applies to all the interferometers at LHO and
the PEM channels, then

  --ifos H0H1H2

should be specified.

The --explain flag should give a human parsable string describing what the
flag means, for example

  --explain "Raised dust levels on the optical bench"

and the --comment flag should give a human parsable string describing why or
how these data quality segments were derived, for example

  --comment "Generated by looking at e-log entries"

If extra segments are being added to an exisiting data quality flag, then the
--append option must be given. Then new data quality segments must have times
after end time of the last existing segment in the database, otherwise an
error is generated. If the users wishes to change existing segment
information, the version of the data quality flag must be incremented.
\
""" % sys.argv[0]
  print msg


shortop = "s:j:r:i:n:v:e:c:g:G:s:Aph"
longop = [
  "server=",
  "identity=",
  "run=",
  "ifos=",
  "name=",
  "version=",
  "explain=",
  "comment=",
  "segment-file=",
  "gps-start-time=",
  "gps-end-time=",
  "append",
  "ping",
  "help"
  ]

try:
  opts, args = getopt.getopt(sys.argv[1:], shortop, longop)
except getopt.GetoptError:
  usage()
  sys.exit(1)

hostPortString = None
port = 30020
identity = None
run = None
ifos = None
name = None
version = None
expln = None
comment = None
segfile = None
starttime = None
endtime = None
append = 0
ping = None

# environment variables override defaults but not
# command line options
try:
  hostPortString = os.environ['LDBD_SERVER']
except:
  pass

for o, a in opts:
  if o in ("-h", "--help"):
    usage()
    sys.exit(0)
  elif o in ("-s", "--server"):
    hostPortString = a
  elif o in ("-j", "--identity"):
    identity = a
  elif o in ("-r", "--run"):
    run = a
  elif o in ("-i", "--ifos"):
    ifos = a
  elif o in ("-n", "--name"):
    name = a
  elif o in ("-v", "--version"):
    version = int(a)
  elif o in ("-e", "--explain"):
    expln = a
  elif o in ("-c", "--comment"):
    comment = a
  elif o in ("-S", "--segment-file"):
    segfile = a
  elif o in ("-g", "--gps-start-time"):
    starttime = int(a)
  elif o in ("-G", "--gps-end-time"):
    endtime = int(a)
  elif o in ("-A", "--append"):
    append = 1
  elif o in ("-p", "--ping"):
    ping = 1

# determine server and port
if hostPortString:
  if hostPortString.find(':') < 0:
    # no port specified
    host = hostPortString
  else:
    # server and port specified
    host, portString = hostPortString.split(':')
    port = int(portString)

  if not identity:
    identity = "/DC=org/DC=doegrids/OU=Services/CN=ldbd/%s" % host

fail = 0
errmsg = ""
if not run:
  errmsg += "Error: --run must be specified\n"
if not ifos:
  errmsg += "Error: --ifos must be specified\n"
if not name:
  errmsg += "Error: --name must be specified\n"
if not version:
  errmsg += "Error: --version must be specified\n"
if not expln:
  errmsg += "Error: --explain must be specified\n"
if not comment:
  errmsg += "Error: --comment must be specified\n"
if not segfile:
  errmsg += "Error: --segment-file must be specified\n"
if not starttime:
  errmsg += "Error: --gps-start-time must be specified\n"
if not endtime:
  errmsg += "Error: --gps-end-time must be specified\n"

if len(errmsg) and not ping:
  print >> sys.stderr, errmsg
  print >> sys.stderr, "Run\n    %s --help\nfor more information." % sys.argv[0]
  sys.exit(1)

interval = segments.segmentlist(segments.segment(starttime,endtime))
active_segments = segments.segmentlist()
inactive_segments = segments.segmentlist()

if not ping:
  xmlparser = pyRXP.Parser()
  lwtparser = ldbd.LIGOLwParser()

  segment_md = ldbd.LIGOMetadata(xmlparser,lwtparser)

  process_cols = {
    "process_id" : "ilwd:char",
    "program" : "lstring",
    "version" : "lstring",
    "cvs_repository" : "lstring",
    "cvs_entry_time" : "lstring",
    "is_online" : "int_4s",
    "node" : "lstring",
    "username" : "lstring",
    "unix_procid" : "lstring",
    "start_time": "int_4s",
    "end_time": "int_4s",
    "ifos" : "lstring",
    "comment" : "lstring"
  }

  process_ocols = [
    "process_id",
    "program",
    "version",
    "cvs_repository",
    "cvs_entry_time",
    "is_online",
    "node",
    "username",
    "unix_procid",
    "start_time",
    "end_time",
    "ifos",
    "comment"
  ]

  process_stream = [(
    "process:process_id:0",
    os.path.basename(sys.argv[0]), 
    cvs_rev[11:-2], 
    cvs_src[9:-2],
    gpstime.GpsSecondsFromPyUTC( time.mktime( time.strptime( 
      cvs_date[7:-2], "%Y/%m/%d %H:%M:%S" ) ) ),
    0,
    socket.gethostname(),
    pwd.getpwuid(os.geteuid())[0],
    os.getpid(),
    gpstime.GpsSecondsFromPyUTC(time.time()),
    gpstime.GpsSecondsFromPyUTC(time.time()),
    ifos,
    comment
  )]

  process_dict = { 
    'pos' : 0,
    'column' : process_cols,
    'orderedcol' : process_ocols,
    'stream' : process_stream
  }

  segment_definer_cols = {
      "process_id" : "ilwd:char", 
      "segment_def_id" : "ilwd:char",
      "run" : "lstring",
      "ifos" : "lstring",
      "name" : "lstring",
      "version" : "int_4s",
      "comment" : "lstring"
  }

  segment_definer_ocols  = [
      "process_id",
      "segment_def_id",
      "run",
      "ifos",
      "name",
      "version",
      "comment"
  ]

  segment_definer_stream = [(
    "process:process_id:0",
    "segment_definer:segment_def_id:0",
    run,
    ifos,
    name,
    version,
    expln
  )]

  segment_definer_dict = { 
    'pos' : 0,
    'column' : segment_definer_cols,
    'orderedcol' : segment_definer_ocols,
    'stream' : segment_definer_stream
  }

  segment_def_map_cols = {
    "process_id" : "ilwd:char",
    "segment_def_id" : "ilwd:char",
    "segment_id" : "ilwd:char"
  }

  segment_def_map_ocols = [
    "process_id",
    "segment_def_id",
    "segment_id"
  ]

  segment_cols = {
    "process_id" : "ilwd:char",
    "segment_id" : "ilwd:char",
    "start_time" : "int_4s",
    "end_time" : "int_4s",
    "active" : "int_4s"
  }

  segment_ocols = [
    "process_id",
    "segment_id",
    "start_time",
    "end_time",
    "active"
  ]

  segment_def_map_stream = []
  segment_stream = []

  fh = open(segfile, 'r')
  for line in fh.readlines():
    seg_line = line.strip().split(" ")
    this_seg = segments.segment(int(segment[0]),int(segment[1]))
    if this_seg is not in interval:
      msg = "Error: segments in %s must lie between %d and %d\n" % (
        segfile, starttime, endtime)
      msg += "Bad segment is " + str(this_seg)
      print >> sys.stderr, msg
      sys.exit(1)
    active_segments.append(this_seg)

  inactive_segments = interval - active_segments
    
  seg_id = 0
  for seg_list in [active_segments, inactive_segments]:
    for this_seg in seg_list:
      segment_def_map_stream.append(
        tuple( [ "process:process_id:0",
          "segment_definer:segment_def_id:0",
          "segment:segment_id:" + str(seg_id)
        ] ) )
      segment_stream.append(
        tuple( [ "process:process_id:0",
          "segment:segment_id:" + str(seg_id),
          int(segment[0]),
          int(segment[1]),
          1
        ] ) )
      seg_id += 1
  
  segment_def_map_dict = { 
    'pos' : 0,
    'column' : segment_def_map_cols,
    'orderedcol' : segment_def_map_ocols,
    'stream' : segment_def_map_stream
  }
  
  segment_dict = { 
    'pos' : 0,
    'column' : segment_cols,
    'orderedcol' : segment_ocols,
    'stream' : segment_stream
  }
  
  segment_md.table['process'] = process_dict
  segment_md.table['segment_definer'] = segment_definer_dict
  segment_md.table['segment_def_map'] = segment_def_map_dict
  segment_md.table['segment'] = segment_dict
  
  if not hostPortString:
    print segment_md.xml()
    sys.exit(0)

# open connection to LDBD Server
try:
  myClient = LDBDClient.LDBDClient(host, port, identity)

except Exception, e:
  print >>sys.stderr, \
    "Unable to connect to LDBDServer %s:%d" % (host, port)
  if gsiserverutils.checkCredentials():
    print >>sys.stderr, "Got the following error : " + str(e)
    print >>sys.stderr, "Enter '%s --help' for usage" % sys.argv[0]
  sys.exit(1)

try:
  if ping:
    # ping the server and print the response
    print myClient.ping()
  else:
    if append:
      # delete the segment definer table
      del segment_md.table['segment_definer']
      # get the segment definition id and creator db for this type
      defxml = myClient.query(
       "SELECT creator_db,segment_def_id FROM segment_definer WHERE " +
       "run = '" + run + "' AND " +
       "ifos = '" + ifos + "' AND " +
       "name = '" + name + "' AND " +
       "version = " + str(version)
      )
      del myClient
      seg_def_md = ldbd.LIGOMetadata(xmlparser,lwtparser)
      seg_def_md.parse(defxml)
      cdb_col = \
       seg_def_md.table['segment_definer']['orderedcol'].index('creator_db')
      sdf_col = \
       seg_def_md.table['segment_definer']['orderedcol'].index('segment_def_id')
      creator_db = seg_def_md.table['segment_definer']['stream'][0][cdb_col]
      seg_def_id = seg_def_md.table['segment_definer']['stream'][0][sdf_col]
      # append the creator_db and change the segment_def_id
      segment_md.table['segment_def_map']['column']['segment_def_id'] = \
       "ilwd:char_u"
      segment_md.table['segment_def_map']['orderedcol'].append(
        "segment_def_cdb")
      segment_md.table['segment_def_map']['column']['segment_def_cdb'] = \
        "int_4s"
      sdf_col = \
       segment_md.table['segment_def_map']['orderedcol'].index('segment_def_id')
      newstream = []
      for s in segment_md.table['segment_def_map']['stream']:
        s = list(s)
        s[sdf_col] = seg_def_id
        s.append(creator_db)
        newstream.append(tuple(s))
      segment_md.table['segment_def_map']['stream'] = newstream

      myClient = LDBDClient.LDBDClient(host, port, identity)
      segment_def_id = "x'"
      for ch in str(seg_def_id):
        segment_def_id += "%02x" % ord(ch)
      segment_def_id += "'"
      
      endxml = myClient.query(
       "SELECT segment.end_time FROM segment,segment_def_map WHERE " +
       "segment.segment_id = segment_def_map.segment_id AND " +
       "segment.creator_db = segment_def_map.segment_cdb AND " +
       "segment_def_map.segment_def_cdb = " + str(creator_db) + " AND " +
       "segment_def_id = " + segment_def_id + " " +
       "ORDER BY end_time DESC FETCH FIRST 1 ROWS ONLY" )

      end_md = ldbd.LIGOMetadata(xmlparser,lwtparser)
      end_md.parse(endxml)
      last_end_time = end_md.table['segment']['stream'][0][0]
      existing_segs = segments.segmentlist()
      existing_segs.append(segments.segment(0, int(last_end_time)))
      existing_segs &= interval
      if len(existing_segs) != 0:
        msg = "overlap with existing segment times for this version\n"
        msg += "Overlapping times are %s" % str(existing_segs)
        raise LSCdqInsertException, msg
      del myClient
      myClient = None
      
    # send the xml we have constructed to the server
    if not myClient:
      myClient = LDBDClient.LDBDClient(host, port, identity)
    myClient.insert(segment_md.xml())

except Exception, e:
  print >>sys.stderr, "Error inserting segments: %s" % str(e)
  print >>sys.stderr, "Enter '%s --help' for usage" % sys.argv[0]
  sys.exit(1)

sys.exit(0)
