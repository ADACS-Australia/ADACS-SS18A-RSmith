#!/usr/bin/python

import os
import socket
import getopt
import pwd
import sys
import re
import time
import exceptions
try:
  import pyRXP
except ImportError, e:
  print >> sys.stderr, """
Error: unable to import the pyRXP module.

You must have pyRXP installed and in your PYTHONPATH to run %s.

%s
""" % (sys.argv[0], e)
  sys.exit( 1 )
try:
  from glue import gpstime
  from glue import ldbd
  from glue import LDBDClient
  from glue import gsiserverutils
except ImportError, e:
  print >> sys.stderr, """
Error: unable to import modules from glue.

Check that glue is correctly installed and in your PYTHONPATH.

%s
""" % e
  sys.exit(1)

cvs_date = '$Date$'
cvs_rev = '$Revision$' 
cvs_src = '$Source$'

def usage():
  msg = """\
Usage: %s [OPTIONS]

  -s, --server HOST:PORT   connect to ldbd on HOST:PORT (default port 30020)
  -j, --identity SUBJECT   the subject of the servers service certififcate

  -r, --run RUN            the name of the run for this flag (S4, S5, etc.)
  -i, --ifos IFOS          the interferometers to which this flag applies
  -n, --name NAME          the name of the data quality flag (e.g. DUST)
  -v, --version VERS       the numeric version of this data quality flag

  -e, --explain EXPLN      a string explaining WHAT this DQ flag means
  -c, --comment COMM       a string explaining WHY this DQ flag was inserted

  -a, --active             insert as active segments
  -S, --segment-file FILE  a file containing the gps start and stop times

  -p, --ping               ping the server
  -h, --help               print this message

If no server is specified, then the segment data is written to stdout and can
be viewed using guild.

The segment file to be inserted should be in the format

gps_start gps_end

where each segment is on a new line.

The argument to the --ifos option should be a list of the interferometers to
which this data quality flag applies. If multiple inferferometers are listed,
they should be given in alphanumeric order. For example if the flag applies
only to the Hanford 4km inferferometer, then

  --ifos H1

should be specified. If the flag applies to all the interferometers at LHO and
the PEM channels, then

  --ifos H0H1H2

should be specified.

The --explain flag should give a human parsable string describing what the
flag means, for example

  --explain "Raised dust levels on the optical bench"

and the --comment flag should give a human parsable string describing why or
how these data quality segments were derived, for example

  --comment "Generated by looking at e-log entries"
\
""" % sys.argv[0]
  print msg

shortop = "s:j:r:i:n:v:e:c:as:ih"
longop = [
  "server=",
  "identity=",
  "run=",
  "ifos=",
  "name=",
  "version=",
  "explain=",
  "comment=",
  "active",
  "segment-file=",
  "ping",
  "help"
  ]

try:
  opts, args = getopt.getopt(sys.argv[1:], shortop, longop)
except getopt.GetoptError:
  usage()
  sys.exit(1)

hostPortString = None
port = 30020
identity = None
run = None
ifos = None
name = None
version = None
expln = None
comment = None
active = 0
segfile = None
ping = None

# environment variables override defaults but not
# command line options
try:
  hostPortString = os.environ['LDBD_SERVER']
except:
  pass

for o, a in opts:
  if o in ("-h", "--help"):
    usage()
    sys.exit(0)
  elif o in ("-s", "--server"):
    hostPortString = a
  elif o in ("-j", "--identity"):
    identity = a
  elif o in ("-r", "--run"):
    run = a
  elif o in ("-i", "--ifos"):
    ifos = a
  elif o in ("-n", "--name"):
    name = a
  elif o in ("-v", "--version"):
    version = int(a)
  elif o in ("-e", "--explain"):
    expln = a
  elif o in ("-c", "--comment"):
    comment = a
  elif o in ("-a", "--active"):
    active = 1
  elif o in ("-S", "--segment-file"):
    segfile = a
  elif o in ("-p", "--ping"):
    ping = 1

# determine server and port
if hostPortString:
  if hostPortString.find(':') < 0:
    # no port specified
    host = hostPortString
  else:
    # server and port specified
    host, portString = hostPortString.split(':')
    port = int(portString)

  if not identity:
    identity = "/DC=org/DC=doegrids/OU=Services/CN=ldbd/%s" % host

fail = 0
errmsg = ""
if not run:
  errmsg += "Error: --run must be specified\n"
if not ifos:
  errmsg += "Error: --ifos must be specified\n"
if not name:
  errmsg += "Error: --name must be specified\n"
if not version:
  errmsg += "Error: --version must be specified\n"
if not expln:
  errmsg += "Error: --explain must be specified\n"
if not comment:
  errmsg += "Error: --comment must be specified\n"
if not segfile:
  errmsg += "Error: --segment-file must be specified\n"

if len(errmsg) and not ping:
  print >> sys.stderr, errmsg
  print >> sys.stderr, "Run\n    %s --help\nfor more information." % sys.argv[0]
  sys.exit(1)

if not ping:
  xmlparser = pyRXP.Parser()
  lwtparser = ldbd.LIGOLwParser()

  ligomd = ldbd.LIGOMetadata(xmlparser,lwtparser)

  process_cols = {
    "process_id" : "ilwd:char",
    "program" : "lstring",
    "version" : "lstring",
    "cvs_repository" : "lstring",
    "cvs_entry_time" : "lstring",
    "is_online" : "int_4s",
    "node" : "lstring",
    "username" : "lstring",
    "unix_procid" : "lstring",
    "start_time": "int_4s",
    "end_time": "int_4s",
    "ifos" : "lstring",
    "comment" : "lstring"
  }

  process_ocols = [
    "process_id",
    "program",
    "version",
    "cvs_repository",
    "cvs_entry_time",
    "is_online",
    "node",
    "username",
    "unix_procid",
    "start_time",
    "end_time",
    "ifos",
    "comment"
  ]

  process_stream = [(
    "process:process_id:0",
    os.path.basename(sys.argv[0]), 
    cvs_rev[11:-2], 
    cvs_src[9:-2],
    gpstime.GpsSecondsFromPyUTC( time.mktime( time.strptime( 
      cvs_date[7:-2], "%Y/%m/%d %H:%M:%S" ) ) ),
    0,
    socket.gethostname(),
    pwd.getpwuid(os.geteuid())[0],
    os.getpid(),
    gpstime.GpsSecondsFromPyUTC(time.time()),
    gpstime.GpsSecondsFromPyUTC(time.time()),
    ifos,
    comment
  )]

  process_dict = { 
    'pos' : 0,
    'column' : process_cols,
    'orderedcol' : process_ocols,
    'stream' : process_stream
  }

  segment_definer_cols = {
      "process_id" : "ilwd:char", 
      "segment_def_id" : "ilwd:char",
      "run" : "lstring",
      "ifos" : "lstring",
      "name" : "lstring",
      "version" : "int_4s",
      "comment" : "lstring"
  }

  segment_definer_ocols  = [
      "process_id",
      "segment_def_id",
      "run",
      "ifos",
      "name",
      "version",
      "comment"
  ]

  segment_definer_stream = [(
    "process:process_id:0",
    "segment_definer:segment_def_id:0",
    run,
    ifos,
    name,
    version,
    expln
  )]

  segment_definer_dict = { 
    'pos' : 0,
    'column' : segment_definer_cols,
    'orderedcol' : segment_definer_ocols,
    'stream' : segment_definer_stream
  }

  segment_def_map_cols = {
    "process_id" : "ilwd:char",
    "segment_def_id" : "ilwd:char",
    "segment_id" : "ilwd:char"
  }

  segment_def_map_ocols = [
    "process_id",
    "segment_def_id",
    "segment_id"
  ]

  segment_cols = {
    "process_id" : "ilwd:char",
    "segment_id" : "ilwd:char",
    "start_time" : "int_4s",
    "end_time" : "int_4s",
    "active" : "int_4s"
  }

  segment_ocols = [
    "process_id",
    "segment_id",
    "start_time",
    "end_time",
    "active"
  ]

  segment_def_map_stream = []
  segment_stream = []

  seg_id = 0
  fh = open(segfile, 'r')
  for line in fh.readlines():
    segment = line.strip().split(" ")
    segment_def_map_stream.append(
      tuple( [ "process:process_id:0",
        "segment_definer:segment_def_id:0",
        "segment:segment_id:" + str(seg_id)
      ] ) )
    segment_stream.append(
      tuple( [ "process:process_id:0",
        "segment:segment_id:" + str(seg_id),
        segment[0],
        segment[1],
        active
      ] ) )
    seg_id += 1
  
  segment_def_map_dict = { 
    'pos' : 0,
    'column' : segment_def_map_cols,
    'orderedcol' : segment_def_map_ocols,
    'stream' : segment_def_map_stream
  }
  
  segment_dict = { 
    'pos' : 0,
    'column' : segment_cols,
    'orderedcol' : segment_ocols,
    'stream' : segment_stream
  }
  
  ligomd.table['process'] = process_dict
  ligomd.table['segment_definer'] = segment_definer_dict
  ligomd.table['segment_def_map'] = segment_def_map_dict
  ligomd.table['segment'] = segment_dict
  
  if not hostPortString:
    print ligomd.xml()
    sys.exit(0)

# open connection to LDBD Server
try:
  myClient = LDBDClient.LDBDClient(host, port, identity)

except Exception, e:
  print >>sys.stderr, \
    "Unable to connect to LDBDServer %s:%d" % (host, port)
  if gsiserverutils.checkCredentials():
    print >>sys.stderr, "Got the following error : " + str(e)
    print >>sys.stderr, "Enter '%s --help' for usage" % sys.argv[0]
  sys.exit(1)

try:
  if ping:
    # ping the server and print the response
    print myClient.ping()
  else:
    # send the xml we have constructed to the server
    myClient.insert(ligomd.xml())

except Exception, e:
  print >>sys.stderr, "Error querying LDBD Server: %s" % str(e)
  print >>sys.stderr, "Enter 'ldbdc --help' for usage"
  sys.exit(1)

sys.exit(0)
