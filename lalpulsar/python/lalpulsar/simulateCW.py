# Copyright (C) 2017 Karl Wette
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

## \defgroup lalpulsar_py_simulateCW SimulateCW
## \ingroup lalpulsar_python
"""
Generate strain time series of a continuous-wave signal in the detector frame,
given a function which computes signal phase and amplitudes as functions of time.

The given function should compute quantities \f$\Delta\phi(t)\f$, \f$a_+(t)\f$,
and \f$a_\times(t)\f$ such that the plus and cross gravitational-wave
polarisations \f$h_+(t)\f$ and \f$h_\times(t)\f$ are given by:
\f{eqnarray}{
h_+(t)      & = & a_+(t)     \cos[\phi_0 + \Delta\phi(t)] \; , \\
h_\times(t) & = & a_\times(t)\sin[\phi_0 + \Delta\phi(t)] \; .
\f}

This module provides a class CWSimulator() to generate the strain time series.
CWSimulator() can also directly write frame files and SFT files.
"""
## @{

from __future__ import (division, print_function)

import os
import re
import math
import random

try:
    import lal
except ImportError:
    raise ImportError("SWIG wrappings of LAL cannot be imported")

try:
    import lalpulsar
except ImportError:
    raise ImportError("SWIG wrappings of LALPulsar cannot be imported")

from . import git_version

__author__ = "Karl Wette <karl.wette@ligo.org>"
__version__ = git_version.id
__date__ = git_version.date

class CWSimulator(object):

    __origin_str = "Generated by %s, %s-%s (%s)" % (__file__, git_version.id, git_version.status, git_version.date)

    def __init__(self, gps_t0, T, wf, gps_tref_wf, dt_wf, phi_0, psi, alpha, delta, det_name,
                 earth_ephem_file="earth00-19-DE405.dat.gz", sun_ephem_file="sun00-19-DE405.dat.gz"):
        """
        Initialise a continuous-wave signal simulator.

        @param gps_t0: start time of signal, in GPS seconds
        @param T: total duration of signal, in seconds
        @param wf: function which computes signal phase and amplitudes as functions of time:
            @b dphi, @b aplus, @b across = @b wf(dt), where:
                @b dt = time since reference time @b gps_tref_wf;
                @b dphi = phase of signal at time @b dt relative to reference time @b gps_tref_wf, in radians;
                @b aplus = strain amplitude of plus polarisation at time @b dt;
                @b across = strain amplitude of cross polarisation at time @b dt
        @param gps_tref_wf: reference time for signal phase, in GPS seconds
        @param dt_wf: sampling time of the function @c wf; this need only be small enough to ensure
            that @c dphi, @c aplus, and @c across are smoothly interpolated, and does not need to make
            the desired sampling frequency of the output strain time series
        @param phi_0: initial phase of the gravitational-wave signal at @b gps_t0, in radians
        @param psi: polarisation angle of the gravitational-wave source, in radians
        @param alpha: right ascension of the gravitational-wave source, in radians
        @param delta: declination  of the gravitational-wave source, in radians
        @param det_name: name of the gravitational-wave detector to simulate a response for;
            e.g. @c "H1" for LIGO Hanford, @c "L1" for LIGO Livingston, @c "V1" for Virgo

        @param earth_ephem_file: name of file to load Earth ephemeris from
        @param sun_ephem_file: name of file to load Sun ephemeris from
        """

        # store arguments
        self.__gps_t0 = gps_t0
        self.__T = T

        # parse detector name
        try:
            _, self.__det_index = lalpulsar.GetCWDetectorPrefix(det_name)
            assert(self.__det_index >= 0)
        except:
            raise ValueError("Invalid detector name det_name='%s'" % det_name)

        # load Earth and Sun ephemerides
        self.__ephemerides = lalpulsar.InitBarycenter(earth_ephem_file, sun_ephem_file)

        # start signal time series 'T_pad_wf' before/after output strain time series
        # to add sufficient padding for maximum Doppler modulation time shifts, otherwise
        # lalpulsar.PulsarSimulateCoherentGW() will output zeros without complaint (unless
        # you run with LAL_DEBUG_LEVEL=warning)
        T_pad_wf = 2.0 * lal.AU_SI / lal.C_SI
        gps_t0_wf = gps_t0 - T_pad_wf
        N_wf = int(math.ceil(float(T + 2*T_pad_wf) / float(dt_wf)))

        # create REAL8TimeSeries to store signal phase
        self.__phi = lal.CreateREAL8TimeSeries("phi", gps_t0_wf, 0, dt_wf, lal.DimensionlessUnit, N_wf)

        # create REAL4TimeVectorSeries to store signal amplitudes
        # - LAL provides no creator function for this type, so must be done manually
        self.__a = lal.REAL4TimeVectorSeries()
        self.__a.name = "a+,ax"
        self.__a.epoch = gps_t0_wf
        self.__a.deltaT = dt_wf
        self.__a.f0 = 0
        self.__a.sampleUnits = lal.StrainUnit
        self.__a.data = lal.CreateREAL4VectorSequence(N_wf, 2)

        # call wf() to fill time series of signal phase and amplitudes
        dt = float(gps_t0_wf - gps_tref_wf)
        for i in xrange(0, N_wf):
            dphi, aplus, across = wf(dt)
            self.__phi.data.data[i] = phi_0 + dphi
            self.__a.data.data[i][0] = aplus
            self.__a.data.data[i][1] = across
            dt += dt_wf

        # create and initialise PulsarCoherentGW struct
        self.__waveform = lalpulsar.PulsarCoherentGW()
        self.__waveform.position.system = lal.COORDINATESYSTEM_EQUATORIAL
        self.__waveform.position.longitude = alpha
        self.__waveform.position.latitude = delta
        self.__waveform.psi = psi
        self.__waveform.phi = self.__phi
        self.__waveform.a = self.__a

        # create and initialise PulsarDetectorResponse struct
        self.__detector = lalpulsar.PulsarDetectorResponse()
        self.__detector.site = lal.CachedDetectors[self.__det_index]
        self.__detector.ephemerides = self.__ephemerides

    def _simulate_coherent_gw(self, h, noise_sqrt_Sh):

        # generate strain time series
        lalpulsar.PulsarSimulateCoherentGW(h, self.__waveform, self.__detector)

        # add Gaussian noise, if requested
        if noise_sqrt_Sh > 0:
            noise_sigma = math.sqrt(0.5 / h.deltaT) * noise_sqrt_Sh
            noise_seed = int(math.floor(random.random() * lal.LAL_INT4_MAX))
            lalpulsar.AddGaussianNoise(h, noise_sigma, noise_seed)

    def get_strain(self, fs, noise_sqrt_Sh=0):
        """
        Generate strain time series of a continuous-wave signal in the detector frame.

        @param fs: sampling frequency of strain time series, in Hz
        @param noise_sqrt_Sh: if >0, add Gaussian noise with square-root single-sided power
            spectral density given by this value, in Hz^(-1/2)

        @return (@b t, @b h), where:
            @b t = start of time strain time series, in GPS seconds;
            @b h = strain time series
        """

        # create REAL4TimeSeries to store output time series
        N_h = int(fs*self.__T)
        h = lal.CreateREAL4TimeSeries("h", self.__gps_t0, 0, 1.0 / fs, lal.DimensionlessUnit, N_h)

        # generate strain time series
        self._simulate_coherent_gw(h, noise_sqrt_Sh)
        return (h.epoch, h.data.data)

    def get_strain_blocks(self, fs, T_block, noise_sqrt_Sh=0):
        """
        Generate strain time series of a continuous-wave signal in the detector frame, in contiguous blocks.

        @param fs: sampling frequency of strain time series, in Hz
        @param T_block: length of each block, in seconds; should divide evenly into @b T
        @param noise_sqrt_Sh: if >0, add Gaussian noise with square-root single-sided power
            spectral density given by this value, in Hz^(-1/2)

        @return (@b t, @b h, @b i, @b N), where:
            @b t = start of time strain time series, in GPS seconds;
            @b h = strain time series;
            @b i = block index, starting from zero;
            @b N = number of blocks

        This is a Python generator function and so should be called as follows:
        ~~~
        S = CWSimulator(...)
        for t, h, i, N in S.get_strain_blocks(...):
            ...
        ~~~
        """

        # work out number of blocks
        N_block = int(round(self.__T / T_block))
        if T_block * N_block > self.__T:
            raise ValueError("Length of block T_block=%g does not divide evenly into T=%g" % (T_block, self.__T))

        # create REAL4TimeSeries to store output time series
        N_h = int(fs*T_block)
        h = lal.CreateREAL4TimeSeries("h", self.__gps_t0, 0, 1.0 / fs, lal.DimensionlessUnit, N_h)

        # generate strain time series in blocks of length 'T_block'
        for i_block in xrange(0, N_block):
            self._simulate_coherent_gw(h, noise_sqrt_Sh)
            yield h.epoch, h.data.data, i_block, N_block
            h.epoch += T_block

    def write_frame_files(self, fs, T_frame, comment, out_dir="."):
        """
        Write frame files [1] containing strain time series of a continuous-wave signal.

        The strain time series is written as double-precision post-processed data (ProcData) channel named
        <tt>&lt;detector&gt;:SIMCW-STRAIN</tt>,
        where <tt>&lt;detector&gt;</tt> is the 2-character detector prefix (e.g. <tt>H1</tt> for LIGO Hanford,
        <tt>L1</tt> for LIGO Livingston, <tt>V1</tt> for Virgo).

        @param fs: sampling frequency of strain time series, in Hz
        @param T_frame: length of each frame, in seconds; should divide evenly into @b T
        @param comment: frame file name comment, may only contain A-Z, a-z, 0-9, _, +, # characters

        @param out_dir: output directory to write frame files into

        @return (@b file, @b i, @b N), where:
            @b file = name of frame file just written;
            @b i = frame file index, starting from zero;
            @b N = number of frame files

        This is a Python generator function and so should be called as follows:
        ~~~
        S = CWSimulator(...)
        for t, h, i, N in S.write_frame_files(...):
            ...
        ~~~

        [1] https://dcc.ligo.org/LIGO-T970130/public
        """

        try:
            import lalframe
        except ImportError:
            raise ImportError("SWIG wrappings of LALFrame cannot be imported")

        # check for valid frame filename comment (see LIGO-T010150)
        valid_comment = re.compile(r'^[A-Za-z0-9_+#]+$')
        if not valid_comment.match(comment):
            raise ValueError("Frame file comment='%s' may only contain A-Z, a-z, 0-9, _, +, # characters" % comment)

        # generate strain time series in blocks of length 'T_frame'
        frame_h = None
        for t, h, i, N in self.get_strain_blocks(fs, T_frame):

            # create and initialise REAL8TimeSeries to write to frame files
            if frame_h is None:
                frame_h_channel = '%s:SIMCW-STRAIN' % lal.CachedDetectors[self.__det_index].frDetector.prefix
                frame_h = lal.CreateREAL8TimeSeries(frame_h_channel, t, 0, 1.0 / fs, lal.DimensionlessUnit, len(h))
            frame_h.epoch = t
            frame_h.data.data = h

            # create standard frame file name (see LIGO-T010150)
            frame_src = lal.CachedDetectors[self.__det_index].frDetector.prefix[0]
            frame_desc = 'simCW_%s' % comment
            frame_t0 = int(t.gpsSeconds)
            frame_T = int(math.ceil(float(t + T_frame)) - math.floor(float(t)))
            frame_name = '%s-%s-%u-%u.gwf' % (frame_src, frame_desc, frame_t0, frame_T)
            frame_path = os.path.join(out_dir, frame_name)

            # create frame
            frame_det_bits = 2 * self.__det_index
            frame = lalframe.FrameNew(t, T_frame, "simCW", -1, i, frame_det_bits)

            # add strain time series to frame
            lalframe.FrameAddREAL8TimeSeriesProcData(frame, frame_h)

            # add history
            lalframe.FrameAddFrHistory(frame, "origin", self.__origin_str)

            # write frame
            lalframe.FrameWrite(frame, frame_path)

            # yield current file name for e.g. printing progress
            yield frame_path, i, N

    def write_sft_files(self, fmax, T_sft, comment, out_dir=".", window=None, window_param=0):
        """
        Write SFT files [2] containing strain time series of a continuous-wave signal.

        @param fmax: maximum SFT frequency, in Hz
        @param T_sft: length of each SFT, in seconds; should divide evenly into @b T
        @param comment: SFT file name comment, may only contain A-Z, a-z, 0-9, _, +, # characters

        @param out_dir: output directory to write SFT files into
        @param window: if not None, window the time series before performing the FFT, using
            the named window function; see XLALCreateNamedREAL8Window()
        @param window_param: parameter for the window function given by @b window, if needed

        @return (@b file, @b i, @b N), where:
            @b file = name of SFT file just written;
            @b i = SFT file index, starting from zero;
            @b N = number of SFT files

        This is a Python generator function and so should be called as follows:
        ~~~
        S = CWSimulator(...)
        for t, h, i, N in S.write_sft_files(...):
            ...
        ~~~

        [2] https://dcc.ligo.org/LIGO-T040164/public
        """

        # check for valid SFT filename comment (see LIGO-T040164)
        valid_comment = re.compile(r'^[A-Za-z0-9_+#]+$')
        if not valid_comment.match(comment):
            raise ValueError("SFT file comment='%s' may only contain A-Z, a-z, 0-9, _, +, # characters" % comment)

        # create timestamps for generating one SFT per time series
        sft_ts = lalpulsar.CreateTimestampVector(1)
        sft_ts.deltaT = T_sft

        # generate strain time series in blocks of length 'T_sft'
        sft_h = None
        sft_fs = 2 * fmax
        for t, h, i, N in self.get_strain_blocks(sft_fs, T_sft):

            # create and initialise REAL8TimeSeries to write to SFT files
            if sft_h is None:
                sft_name = lal.CachedDetectors[self.__det_index].frDetector.prefix
                sft_h = lal.CreateREAL8TimeSeries(sft_name, t, 0, 1.0 / sft_fs, lal.DimensionlessUnit, len(h))
            sft_h.epoch = t
            sft_h.data.data = h

            # create SFT, possibly with windowing
            sft_ts.data[0] = t
            sft_vect = lalpulsar.MakeSFTsFromREAL8TimeSeries(sft_h, sft_ts, window, window_param)

            # create standard SFT file name (see LIGO-T040164)
            sft_desc = 'simCW_%s' % comment
            sft_name = lalpulsar.GetOfficialName4MergedSFTs(sft_vect, sft_desc)
            sft_path = os.path.join(out_dir, sft_name)

            # write SFT
            lalpulsar.WriteSFTVector2NamedFile(sft_vect, sft_path, self.__origin_str)

            # yield current file name for e.g. printing progress
            yield sft_path, i, N

## @}
